// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// ../sisventa/node_modules/bcryptjs/dist/bcrypt.js
var require_bcrypt = __commonJS((exports, module) => {
  (function(global2, factory) {
    if (typeof define === "function" && define["amd"])
      define([], factory);
    else if (typeof import.meta.require === "function" && typeof module === "object" && module && exports)
      module["exports"] = factory();
    else
      (global2["dcodeIO"] = global2["dcodeIO"] || {})["bcrypt"] = factory();
  })(exports, function() {
    var bcrypt = {};
    var randomFallback = null;
    function random(len) {
      if (typeof module !== "undefined" && module && module["exports"])
        try {
          return import.meta.require("crypto")["randomBytes"](len);
        } catch (e3) {
        }
      try {
        var a3;
        (self["crypto"] || self["msCrypto"])["getRandomValues"](a3 = new Uint32Array(len));
        return Array.prototype.slice.call(a3);
      } catch (e3) {
      }
      if (!randomFallback)
        throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
      return randomFallback(len);
    }
    var randomAvailable = false;
    try {
      random(1);
      randomAvailable = true;
    } catch (e3) {
    }
    randomFallback = null;
    bcrypt.setRandomFallback = function(random2) {
      randomFallback = random2;
    };
    bcrypt.genSaltSync = function(rounds, seed_length) {
      rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;
      if (typeof rounds !== "number")
        throw Error("Illegal arguments: " + typeof rounds + ", " + typeof seed_length);
      if (rounds < 4)
        rounds = 4;
      else if (rounds > 31)
        rounds = 31;
      var salt = [];
      salt.push("$2a$");
      if (rounds < 10)
        salt.push("0");
      salt.push(rounds.toString());
      salt.push("$");
      salt.push(base64_encode(random(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN));
      return salt.join("");
    };
    bcrypt.genSalt = function(rounds, seed_length, callback) {
      if (typeof seed_length === "function")
        callback = seed_length, seed_length = undefined;
      if (typeof rounds === "function")
        callback = rounds, rounds = undefined;
      if (typeof rounds === "undefined")
        rounds = GENSALT_DEFAULT_LOG2_ROUNDS;
      else if (typeof rounds !== "number")
        throw Error("illegal arguments: " + typeof rounds);
      function _async(callback2) {
        nextTick(function() {
          try {
            callback2(null, bcrypt.genSaltSync(rounds));
          } catch (err) {
            callback2(err);
          }
        });
      }
      if (callback) {
        if (typeof callback !== "function")
          throw Error("Illegal callback: " + typeof callback);
        _async(callback);
      } else
        return new Promise(function(resolve, reject) {
          _async(function(err, res) {
            if (err) {
              reject(err);
              return;
            }
            resolve(res);
          });
        });
    };
    bcrypt.hashSync = function(s3, salt) {
      if (typeof salt === "undefined")
        salt = GENSALT_DEFAULT_LOG2_ROUNDS;
      if (typeof salt === "number")
        salt = bcrypt.genSaltSync(salt);
      if (typeof s3 !== "string" || typeof salt !== "string")
        throw Error("Illegal arguments: " + typeof s3 + ", " + typeof salt);
      return _hash(s3, salt);
    };
    bcrypt.hash = function(s3, salt, callback, progressCallback) {
      function _async(callback2) {
        if (typeof s3 === "string" && typeof salt === "number")
          bcrypt.genSalt(salt, function(err, salt2) {
            _hash(s3, salt2, callback2, progressCallback);
          });
        else if (typeof s3 === "string" && typeof salt === "string")
          _hash(s3, salt, callback2, progressCallback);
        else
          nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof s3 + ", " + typeof salt)));
      }
      if (callback) {
        if (typeof callback !== "function")
          throw Error("Illegal callback: " + typeof callback);
        _async(callback);
      } else
        return new Promise(function(resolve, reject) {
          _async(function(err, res) {
            if (err) {
              reject(err);
              return;
            }
            resolve(res);
          });
        });
    };
    function safeStringCompare(known, unknown11) {
      var right = 0, wrong = 0;
      for (var i = 0, k3 = known.length;i < k3; ++i) {
        if (known.charCodeAt(i) === unknown11.charCodeAt(i))
          ++right;
        else
          ++wrong;
      }
      if (right < 0)
        return false;
      return wrong === 0;
    }
    bcrypt.compareSync = function(s3, hash11) {
      if (typeof s3 !== "string" || typeof hash11 !== "string")
        throw Error("Illegal arguments: " + typeof s3 + ", " + typeof hash11);
      if (hash11.length !== 60)
        return false;
      return safeStringCompare(bcrypt.hashSync(s3, hash11.substr(0, hash11.length - 31)), hash11);
    };
    bcrypt.compare = function(s3, hash11, callback, progressCallback) {
      function _async(callback2) {
        if (typeof s3 !== "string" || typeof hash11 !== "string") {
          nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof s3 + ", " + typeof hash11)));
          return;
        }
        if (hash11.length !== 60) {
          nextTick(callback2.bind(this, null, false));
          return;
        }
        bcrypt.hash(s3, hash11.substr(0, 29), function(err, comp) {
          if (err)
            callback2(err);
          else
            callback2(null, safeStringCompare(comp, hash11));
        }, progressCallback);
      }
      if (callback) {
        if (typeof callback !== "function")
          throw Error("Illegal callback: " + typeof callback);
        _async(callback);
      } else
        return new Promise(function(resolve, reject) {
          _async(function(err, res) {
            if (err) {
              reject(err);
              return;
            }
            resolve(res);
          });
        });
    };
    bcrypt.getRounds = function(hash11) {
      if (typeof hash11 !== "string")
        throw Error("Illegal arguments: " + typeof hash11);
      return parseInt(hash11.split("$")[2], 10);
    };
    bcrypt.getSalt = function(hash11) {
      if (typeof hash11 !== "string")
        throw Error("Illegal arguments: " + typeof hash11);
      if (hash11.length !== 60)
        throw Error("Illegal hash length: " + hash11.length + " != 60");
      return hash11.substring(0, 29);
    };
    var nextTick = typeof process !== "undefined" && process && typeof process.nextTick === "function" ? typeof setImmediate === "function" ? setImmediate : process.nextTick : setTimeout;
    function stringToBytes(str) {
      var out = [], i = 0;
      utfx.encodeUTF16toUTF8(function() {
        if (i >= str.length)
          return null;
        return str.charCodeAt(i++);
      }, function(b3) {
        out.push(b3);
      });
      return out;
    }
    var BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
    var BASE64_INDEX = [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      -1,
      -1,
      -1,
      -1,
      -1
    ];
    var stringFromCharCode = String.fromCharCode;
    function base64_encode(b3, len) {
      var off = 0, rs = [], c1, c22;
      if (len <= 0 || len > b3.length)
        throw Error("Illegal len: " + len);
      while (off < len) {
        c1 = b3[off++] & 255;
        rs.push(BASE64_CODE[c1 >> 2 & 63]);
        c1 = (c1 & 3) << 4;
        if (off >= len) {
          rs.push(BASE64_CODE[c1 & 63]);
          break;
        }
        c22 = b3[off++] & 255;
        c1 |= c22 >> 4 & 15;
        rs.push(BASE64_CODE[c1 & 63]);
        c1 = (c22 & 15) << 2;
        if (off >= len) {
          rs.push(BASE64_CODE[c1 & 63]);
          break;
        }
        c22 = b3[off++] & 255;
        c1 |= c22 >> 6 & 3;
        rs.push(BASE64_CODE[c1 & 63]);
        rs.push(BASE64_CODE[c22 & 63]);
      }
      return rs.join("");
    }
    function base64_decode(s3, len) {
      var off = 0, slen = s3.length, olen = 0, rs = [], c1, c22, c3, c4, o3, code;
      if (len <= 0)
        throw Error("Illegal len: " + len);
      while (off < slen - 1 && olen < len) {
        code = s3.charCodeAt(off++);
        c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
        code = s3.charCodeAt(off++);
        c22 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
        if (c1 == -1 || c22 == -1)
          break;
        o3 = c1 << 2 >>> 0;
        o3 |= (c22 & 48) >> 4;
        rs.push(stringFromCharCode(o3));
        if (++olen >= len || off >= slen)
          break;
        code = s3.charCodeAt(off++);
        c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
        if (c3 == -1)
          break;
        o3 = (c22 & 15) << 4 >>> 0;
        o3 |= (c3 & 60) >> 2;
        rs.push(stringFromCharCode(o3));
        if (++olen >= len || off >= slen)
          break;
        code = s3.charCodeAt(off++);
        c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
        o3 = (c3 & 3) << 6 >>> 0;
        o3 |= c4;
        rs.push(stringFromCharCode(o3));
        ++olen;
      }
      var res = [];
      for (off = 0;off < olen; off++)
        res.push(rs[off].charCodeAt(0));
      return res;
    }
    var utfx = function() {
      var utfx2 = {};
      utfx2.MAX_CODEPOINT = 1114111;
      utfx2.encodeUTF8 = function(src, dst) {
        var cp = null;
        if (typeof src === "number")
          cp = src, src = function() {
            return null;
          };
        while (cp !== null || (cp = src()) !== null) {
          if (cp < 128)
            dst(cp & 127);
          else if (cp < 2048)
            dst(cp >> 6 & 31 | 192), dst(cp & 63 | 128);
          else if (cp < 65536)
            dst(cp >> 12 & 15 | 224), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
          else
            dst(cp >> 18 & 7 | 240), dst(cp >> 12 & 63 | 128), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
          cp = null;
        }
      };
      utfx2.decodeUTF8 = function(src, dst) {
        var a3, b3, c3, d3, fail = function(b4) {
          b4 = b4.slice(0, b4.indexOf(null));
          var err = Error(b4.toString());
          err.name = "TruncatedError";
          err["bytes"] = b4;
          throw err;
        };
        while ((a3 = src()) !== null) {
          if ((a3 & 128) === 0)
            dst(a3);
          else if ((a3 & 224) === 192)
            (b3 = src()) === null && fail([a3, b3]), dst((a3 & 31) << 6 | b3 & 63);
          else if ((a3 & 240) === 224)
            ((b3 = src()) === null || (c3 = src()) === null) && fail([a3, b3, c3]), dst((a3 & 15) << 12 | (b3 & 63) << 6 | c3 & 63);
          else if ((a3 & 248) === 240)
            ((b3 = src()) === null || (c3 = src()) === null || (d3 = src()) === null) && fail([a3, b3, c3, d3]), dst((a3 & 7) << 18 | (b3 & 63) << 12 | (c3 & 63) << 6 | d3 & 63);
          else
            throw RangeError("Illegal starting byte: " + a3);
        }
      };
      utfx2.UTF16toUTF8 = function(src, dst) {
        var c1, c22 = null;
        while (true) {
          if ((c1 = c22 !== null ? c22 : src()) === null)
            break;
          if (c1 >= 55296 && c1 <= 57343) {
            if ((c22 = src()) !== null) {
              if (c22 >= 56320 && c22 <= 57343) {
                dst((c1 - 55296) * 1024 + c22 - 56320 + 65536);
                c22 = null;
                continue;
              }
            }
          }
          dst(c1);
        }
        if (c22 !== null)
          dst(c22);
      };
      utfx2.UTF8toUTF16 = function(src, dst) {
        var cp = null;
        if (typeof src === "number")
          cp = src, src = function() {
            return null;
          };
        while (cp !== null || (cp = src()) !== null) {
          if (cp <= 65535)
            dst(cp);
          else
            cp -= 65536, dst((cp >> 10) + 55296), dst(cp % 1024 + 56320);
          cp = null;
        }
      };
      utfx2.encodeUTF16toUTF8 = function(src, dst) {
        utfx2.UTF16toUTF8(src, function(cp) {
          utfx2.encodeUTF8(cp, dst);
        });
      };
      utfx2.decodeUTF8toUTF16 = function(src, dst) {
        utfx2.decodeUTF8(src, function(cp) {
          utfx2.UTF8toUTF16(cp, dst);
        });
      };
      utfx2.calculateCodePoint = function(cp) {
        return cp < 128 ? 1 : cp < 2048 ? 2 : cp < 65536 ? 3 : 4;
      };
      utfx2.calculateUTF8 = function(src) {
        var cp, l3 = 0;
        while ((cp = src()) !== null)
          l3 += utfx2.calculateCodePoint(cp);
        return l3;
      };
      utfx2.calculateUTF16asUTF8 = function(src) {
        var n3 = 0, l3 = 0;
        utfx2.UTF16toUTF8(src, function(cp) {
          ++n3;
          l3 += utfx2.calculateCodePoint(cp);
        });
        return [n3, l3];
      };
      return utfx2;
    }();
    Date.now = Date.now || function() {
      return +new Date;
    };
    var BCRYPT_SALT_LEN = 16;
    var GENSALT_DEFAULT_LOG2_ROUNDS = 10;
    var BLOWFISH_NUM_ROUNDS = 16;
    var MAX_EXECUTION_TIME = 100;
    var P_ORIG = [
      608135816,
      2242054355,
      320440878,
      57701188,
      2752067618,
      698298832,
      137296536,
      3964562569,
      1160258022,
      953160567,
      3193202383,
      887688300,
      3232508343,
      3380367581,
      1065670069,
      3041331479,
      2450970073,
      2306472731
    ];
    var S_ORIG = [
      3509652390,
      2564797868,
      805139163,
      3491422135,
      3101798381,
      1780907670,
      3128725573,
      4046225305,
      614570311,
      3012652279,
      134345442,
      2240740374,
      1667834072,
      1901547113,
      2757295779,
      4103290238,
      227898511,
      1921955416,
      1904987480,
      2182433518,
      2069144605,
      3260701109,
      2620446009,
      720527379,
      3318853667,
      677414384,
      3393288472,
      3101374703,
      2390351024,
      1614419982,
      1822297739,
      2954791486,
      3608508353,
      3174124327,
      2024746970,
      1432378464,
      3864339955,
      2857741204,
      1464375394,
      1676153920,
      1439316330,
      715854006,
      3033291828,
      289532110,
      2706671279,
      2087905683,
      3018724369,
      1668267050,
      732546397,
      1947742710,
      3462151702,
      2609353502,
      2950085171,
      1814351708,
      2050118529,
      680887927,
      999245976,
      1800124847,
      3300911131,
      1713906067,
      1641548236,
      4213287313,
      1216130144,
      1575780402,
      4018429277,
      3917837745,
      3693486850,
      3949271944,
      596196993,
      3549867205,
      258830323,
      2213823033,
      772490370,
      2760122372,
      1774776394,
      2652871518,
      566650946,
      4142492826,
      1728879713,
      2882767088,
      1783734482,
      3629395816,
      2517608232,
      2874225571,
      1861159788,
      326777828,
      3124490320,
      2130389656,
      2716951837,
      967770486,
      1724537150,
      2185432712,
      2364442137,
      1164943284,
      2105845187,
      998989502,
      3765401048,
      2244026483,
      1075463327,
      1455516326,
      1322494562,
      910128902,
      469688178,
      1117454909,
      936433444,
      3490320968,
      3675253459,
      1240580251,
      122909385,
      2157517691,
      634681816,
      4142456567,
      3825094682,
      3061402683,
      2540495037,
      79693498,
      3249098678,
      1084186820,
      1583128258,
      426386531,
      1761308591,
      1047286709,
      322548459,
      995290223,
      1845252383,
      2603652396,
      3431023940,
      2942221577,
      3202600964,
      3727903485,
      1712269319,
      422464435,
      3234572375,
      1170764815,
      3523960633,
      3117677531,
      1434042557,
      442511882,
      3600875718,
      1076654713,
      1738483198,
      4213154764,
      2393238008,
      3677496056,
      1014306527,
      4251020053,
      793779912,
      2902807211,
      842905082,
      4246964064,
      1395751752,
      1040244610,
      2656851899,
      3396308128,
      445077038,
      3742853595,
      3577915638,
      679411651,
      2892444358,
      2354009459,
      1767581616,
      3150600392,
      3791627101,
      3102740896,
      284835224,
      4246832056,
      1258075500,
      768725851,
      2589189241,
      3069724005,
      3532540348,
      1274779536,
      3789419226,
      2764799539,
      1660621633,
      3471099624,
      4011903706,
      913787905,
      3497959166,
      737222580,
      2514213453,
      2928710040,
      3937242737,
      1804850592,
      3499020752,
      2949064160,
      2386320175,
      2390070455,
      2415321851,
      4061277028,
      2290661394,
      2416832540,
      1336762016,
      1754252060,
      3520065937,
      3014181293,
      791618072,
      3188594551,
      3933548030,
      2332172193,
      3852520463,
      3043980520,
      413987798,
      3465142937,
      3030929376,
      4245938359,
      2093235073,
      3534596313,
      375366246,
      2157278981,
      2479649556,
      555357303,
      3870105701,
      2008414854,
      3344188149,
      4221384143,
      3956125452,
      2067696032,
      3594591187,
      2921233993,
      2428461,
      544322398,
      577241275,
      1471733935,
      610547355,
      4027169054,
      1432588573,
      1507829418,
      2025931657,
      3646575487,
      545086370,
      48609733,
      2200306550,
      1653985193,
      298326376,
      1316178497,
      3007786442,
      2064951626,
      458293330,
      2589141269,
      3591329599,
      3164325604,
      727753846,
      2179363840,
      146436021,
      1461446943,
      4069977195,
      705550613,
      3059967265,
      3887724982,
      4281599278,
      3313849956,
      1404054877,
      2845806497,
      146425753,
      1854211946,
      1266315497,
      3048417604,
      3681880366,
      3289982499,
      2909710000,
      1235738493,
      2632868024,
      2414719590,
      3970600049,
      1771706367,
      1449415276,
      3266420449,
      422970021,
      1963543593,
      2690192192,
      3826793022,
      1062508698,
      1531092325,
      1804592342,
      2583117782,
      2714934279,
      4024971509,
      1294809318,
      4028980673,
      1289560198,
      2221992742,
      1669523910,
      35572830,
      157838143,
      1052438473,
      1016535060,
      1802137761,
      1753167236,
      1386275462,
      3080475397,
      2857371447,
      1040679964,
      2145300060,
      2390574316,
      1461121720,
      2956646967,
      4031777805,
      4028374788,
      33600511,
      2920084762,
      1018524850,
      629373528,
      3691585981,
      3515945977,
      2091462646,
      2486323059,
      586499841,
      988145025,
      935516892,
      3367335476,
      2599673255,
      2839830854,
      265290510,
      3972581182,
      2759138881,
      3795373465,
      1005194799,
      847297441,
      406762289,
      1314163512,
      1332590856,
      1866599683,
      4127851711,
      750260880,
      613907577,
      1450815602,
      3165620655,
      3734664991,
      3650291728,
      3012275730,
      3704569646,
      1427272223,
      778793252,
      1343938022,
      2676280711,
      2052605720,
      1946737175,
      3164576444,
      3914038668,
      3967478842,
      3682934266,
      1661551462,
      3294938066,
      4011595847,
      840292616,
      3712170807,
      616741398,
      312560963,
      711312465,
      1351876610,
      322626781,
      1910503582,
      271666773,
      2175563734,
      1594956187,
      70604529,
      3617834859,
      1007753275,
      1495573769,
      4069517037,
      2549218298,
      2663038764,
      504708206,
      2263041392,
      3941167025,
      2249088522,
      1514023603,
      1998579484,
      1312622330,
      694541497,
      2582060303,
      2151582166,
      1382467621,
      776784248,
      2618340202,
      3323268794,
      2497899128,
      2784771155,
      503983604,
      4076293799,
      907881277,
      423175695,
      432175456,
      1378068232,
      4145222326,
      3954048622,
      3938656102,
      3820766613,
      2793130115,
      2977904593,
      26017576,
      3274890735,
      3194772133,
      1700274565,
      1756076034,
      4006520079,
      3677328699,
      720338349,
      1533947780,
      354530856,
      688349552,
      3973924725,
      1637815568,
      332179504,
      3949051286,
      53804574,
      2852348879,
      3044236432,
      1282449977,
      3583942155,
      3416972820,
      4006381244,
      1617046695,
      2628476075,
      3002303598,
      1686838959,
      431878346,
      2686675385,
      1700445008,
      1080580658,
      1009431731,
      832498133,
      3223435511,
      2605976345,
      2271191193,
      2516031870,
      1648197032,
      4164389018,
      2548247927,
      300782431,
      375919233,
      238389289,
      3353747414,
      2531188641,
      2019080857,
      1475708069,
      455242339,
      2609103871,
      448939670,
      3451063019,
      1395535956,
      2413381860,
      1841049896,
      1491858159,
      885456874,
      4264095073,
      4001119347,
      1565136089,
      3898914787,
      1108368660,
      540939232,
      1173283510,
      2745871338,
      3681308437,
      4207628240,
      3343053890,
      4016749493,
      1699691293,
      1103962373,
      3625875870,
      2256883143,
      3830138730,
      1031889488,
      3479347698,
      1535977030,
      4236805024,
      3251091107,
      2132092099,
      1774941330,
      1199868427,
      1452454533,
      157007616,
      2904115357,
      342012276,
      595725824,
      1480756522,
      206960106,
      497939518,
      591360097,
      863170706,
      2375253569,
      3596610801,
      1814182875,
      2094937945,
      3421402208,
      1082520231,
      3463918190,
      2785509508,
      435703966,
      3908032597,
      1641649973,
      2842273706,
      3305899714,
      1510255612,
      2148256476,
      2655287854,
      3276092548,
      4258621189,
      236887753,
      3681803219,
      274041037,
      1734335097,
      3815195456,
      3317970021,
      1899903192,
      1026095262,
      4050517792,
      356393447,
      2410691914,
      3873677099,
      3682840055,
      3913112168,
      2491498743,
      4132185628,
      2489919796,
      1091903735,
      1979897079,
      3170134830,
      3567386728,
      3557303409,
      857797738,
      1136121015,
      1342202287,
      507115054,
      2535736646,
      337727348,
      3213592640,
      1301675037,
      2528481711,
      1895095763,
      1721773893,
      3216771564,
      62756741,
      2142006736,
      835421444,
      2531993523,
      1442658625,
      3659876326,
      2882144922,
      676362277,
      1392781812,
      170690266,
      3921047035,
      1759253602,
      3611846912,
      1745797284,
      664899054,
      1329594018,
      3901205900,
      3045908486,
      2062866102,
      2865634940,
      3543621612,
      3464012697,
      1080764994,
      553557557,
      3656615353,
      3996768171,
      991055499,
      499776247,
      1265440854,
      648242737,
      3940784050,
      980351604,
      3713745714,
      1749149687,
      3396870395,
      4211799374,
      3640570775,
      1161844396,
      3125318951,
      1431517754,
      545492359,
      4268468663,
      3499529547,
      1437099964,
      2702547544,
      3433638243,
      2581715763,
      2787789398,
      1060185593,
      1593081372,
      2418618748,
      4260947970,
      69676912,
      2159744348,
      86519011,
      2512459080,
      3838209314,
      1220612927,
      3339683548,
      133810670,
      1090789135,
      1078426020,
      1569222167,
      845107691,
      3583754449,
      4072456591,
      1091646820,
      628848692,
      1613405280,
      3757631651,
      526609435,
      236106946,
      48312990,
      2942717905,
      3402727701,
      1797494240,
      859738849,
      992217954,
      4005476642,
      2243076622,
      3870952857,
      3732016268,
      765654824,
      3490871365,
      2511836413,
      1685915746,
      3888969200,
      1414112111,
      2273134842,
      3281911079,
      4080962846,
      172450625,
      2569994100,
      980381355,
      4109958455,
      2819808352,
      2716589560,
      2568741196,
      3681446669,
      3329971472,
      1835478071,
      660984891,
      3704678404,
      4045999559,
      3422617507,
      3040415634,
      1762651403,
      1719377915,
      3470491036,
      2693910283,
      3642056355,
      3138596744,
      1364962596,
      2073328063,
      1983633131,
      926494387,
      3423689081,
      2150032023,
      4096667949,
      1749200295,
      3328846651,
      309677260,
      2016342300,
      1779581495,
      3079819751,
      111262694,
      1274766160,
      443224088,
      298511866,
      1025883608,
      3806446537,
      1145181785,
      168956806,
      3641502830,
      3584813610,
      1689216846,
      3666258015,
      3200248200,
      1692713982,
      2646376535,
      4042768518,
      1618508792,
      1610833997,
      3523052358,
      4130873264,
      2001055236,
      3610705100,
      2202168115,
      4028541809,
      2961195399,
      1006657119,
      2006996926,
      3186142756,
      1430667929,
      3210227297,
      1314452623,
      4074634658,
      4101304120,
      2273951170,
      1399257539,
      3367210612,
      3027628629,
      1190975929,
      2062231137,
      2333990788,
      2221543033,
      2438960610,
      1181637006,
      548689776,
      2362791313,
      3372408396,
      3104550113,
      3145860560,
      296247880,
      1970579870,
      3078560182,
      3769228297,
      1714227617,
      3291629107,
      3898220290,
      166772364,
      1251581989,
      493813264,
      448347421,
      195405023,
      2709975567,
      677966185,
      3703036547,
      1463355134,
      2715995803,
      1338867538,
      1343315457,
      2802222074,
      2684532164,
      233230375,
      2599980071,
      2000651841,
      3277868038,
      1638401717,
      4028070440,
      3237316320,
      6314154,
      819756386,
      300326615,
      590932579,
      1405279636,
      3267499572,
      3150704214,
      2428286686,
      3959192993,
      3461946742,
      1862657033,
      1266418056,
      963775037,
      2089974820,
      2263052895,
      1917689273,
      448879540,
      3550394620,
      3981727096,
      150775221,
      3627908307,
      1303187396,
      508620638,
      2975983352,
      2726630617,
      1817252668,
      1876281319,
      1457606340,
      908771278,
      3720792119,
      3617206836,
      2455994898,
      1729034894,
      1080033504,
      976866871,
      3556439503,
      2881648439,
      1522871579,
      1555064734,
      1336096578,
      3548522304,
      2579274686,
      3574697629,
      3205460757,
      3593280638,
      3338716283,
      3079412587,
      564236357,
      2993598910,
      1781952180,
      1464380207,
      3163844217,
      3332601554,
      1699332808,
      1393555694,
      1183702653,
      3581086237,
      1288719814,
      691649499,
      2847557200,
      2895455976,
      3193889540,
      2717570544,
      1781354906,
      1676643554,
      2592534050,
      3230253752,
      1126444790,
      2770207658,
      2633158820,
      2210423226,
      2615765581,
      2414155088,
      3127139286,
      673620729,
      2805611233,
      1269405062,
      4015350505,
      3341807571,
      4149409754,
      1057255273,
      2012875353,
      2162469141,
      2276492801,
      2601117357,
      993977747,
      3918593370,
      2654263191,
      753973209,
      36408145,
      2530585658,
      25011837,
      3520020182,
      2088578344,
      530523599,
      2918365339,
      1524020338,
      1518925132,
      3760827505,
      3759777254,
      1202760957,
      3985898139,
      3906192525,
      674977740,
      4174734889,
      2031300136,
      2019492241,
      3983892565,
      4153806404,
      3822280332,
      352677332,
      2297720250,
      60907813,
      90501309,
      3286998549,
      1016092578,
      2535922412,
      2839152426,
      457141659,
      509813237,
      4120667899,
      652014361,
      1966332200,
      2975202805,
      55981186,
      2327461051,
      676427537,
      3255491064,
      2882294119,
      3433927263,
      1307055953,
      942726286,
      933058658,
      2468411793,
      3933900994,
      4215176142,
      1361170020,
      2001714738,
      2830558078,
      3274259782,
      1222529897,
      1679025792,
      2729314320,
      3714953764,
      1770335741,
      151462246,
      3013232138,
      1682292957,
      1483529935,
      471910574,
      1539241949,
      458788160,
      3436315007,
      1807016891,
      3718408830,
      978976581,
      1043663428,
      3165965781,
      1927990952,
      4200891579,
      2372276910,
      3208408903,
      3533431907,
      1412390302,
      2931980059,
      4132332400,
      1947078029,
      3881505623,
      4168226417,
      2941484381,
      1077988104,
      1320477388,
      886195818,
      18198404,
      3786409000,
      2509781533,
      112762804,
      3463356488,
      1866414978,
      891333506,
      18488651,
      661792760,
      1628790961,
      3885187036,
      3141171499,
      876946877,
      2693282273,
      1372485963,
      791857591,
      2686433993,
      3759982718,
      3167212022,
      3472953795,
      2716379847,
      445679433,
      3561995674,
      3504004811,
      3574258232,
      54117162,
      3331405415,
      2381918588,
      3769707343,
      4154350007,
      1140177722,
      4074052095,
      668550556,
      3214352940,
      367459370,
      261225585,
      2610173221,
      4209349473,
      3468074219,
      3265815641,
      314222801,
      3066103646,
      3808782860,
      282218597,
      3406013506,
      3773591054,
      379116347,
      1285071038,
      846784868,
      2669647154,
      3771962079,
      3550491691,
      2305946142,
      453669953,
      1268987020,
      3317592352,
      3279303384,
      3744833421,
      2610507566,
      3859509063,
      266596637,
      3847019092,
      517658769,
      3462560207,
      3443424879,
      370717030,
      4247526661,
      2224018117,
      4143653529,
      4112773975,
      2788324899,
      2477274417,
      1456262402,
      2901442914,
      1517677493,
      1846949527,
      2295493580,
      3734397586,
      2176403920,
      1280348187,
      1908823572,
      3871786941,
      846861322,
      1172426758,
      3287448474,
      3383383037,
      1655181056,
      3139813346,
      901632758,
      1897031941,
      2986607138,
      3066810236,
      3447102507,
      1393639104,
      373351379,
      950779232,
      625454576,
      3124240540,
      4148612726,
      2007998917,
      544563296,
      2244738638,
      2330496472,
      2058025392,
      1291430526,
      424198748,
      50039436,
      29584100,
      3605783033,
      2429876329,
      2791104160,
      1057563949,
      3255363231,
      3075367218,
      3463963227,
      1469046755,
      985887462
    ];
    var C_ORIG = [
      1332899944,
      1700884034,
      1701343084,
      1684370003,
      1668446532,
      1869963892
    ];
    function _encipher(lr, off, P, S) {
      var n3, l3 = lr[off], r = lr[off + 1];
      l3 ^= P[0];
      n3 = S[l3 >>> 24];
      n3 += S[256 | l3 >> 16 & 255];
      n3 ^= S[512 | l3 >> 8 & 255];
      n3 += S[768 | l3 & 255];
      r ^= n3 ^ P[1];
      n3 = S[r >>> 24];
      n3 += S[256 | r >> 16 & 255];
      n3 ^= S[512 | r >> 8 & 255];
      n3 += S[768 | r & 255];
      l3 ^= n3 ^ P[2];
      n3 = S[l3 >>> 24];
      n3 += S[256 | l3 >> 16 & 255];
      n3 ^= S[512 | l3 >> 8 & 255];
      n3 += S[768 | l3 & 255];
      r ^= n3 ^ P[3];
      n3 = S[r >>> 24];
      n3 += S[256 | r >> 16 & 255];
      n3 ^= S[512 | r >> 8 & 255];
      n3 += S[768 | r & 255];
      l3 ^= n3 ^ P[4];
      n3 = S[l3 >>> 24];
      n3 += S[256 | l3 >> 16 & 255];
      n3 ^= S[512 | l3 >> 8 & 255];
      n3 += S[768 | l3 & 255];
      r ^= n3 ^ P[5];
      n3 = S[r >>> 24];
      n3 += S[256 | r >> 16 & 255];
      n3 ^= S[512 | r >> 8 & 255];
      n3 += S[768 | r & 255];
      l3 ^= n3 ^ P[6];
      n3 = S[l3 >>> 24];
      n3 += S[256 | l3 >> 16 & 255];
      n3 ^= S[512 | l3 >> 8 & 255];
      n3 += S[768 | l3 & 255];
      r ^= n3 ^ P[7];
      n3 = S[r >>> 24];
      n3 += S[256 | r >> 16 & 255];
      n3 ^= S[512 | r >> 8 & 255];
      n3 += S[768 | r & 255];
      l3 ^= n3 ^ P[8];
      n3 = S[l3 >>> 24];
      n3 += S[256 | l3 >> 16 & 255];
      n3 ^= S[512 | l3 >> 8 & 255];
      n3 += S[768 | l3 & 255];
      r ^= n3 ^ P[9];
      n3 = S[r >>> 24];
      n3 += S[256 | r >> 16 & 255];
      n3 ^= S[512 | r >> 8 & 255];
      n3 += S[768 | r & 255];
      l3 ^= n3 ^ P[10];
      n3 = S[l3 >>> 24];
      n3 += S[256 | l3 >> 16 & 255];
      n3 ^= S[512 | l3 >> 8 & 255];
      n3 += S[768 | l3 & 255];
      r ^= n3 ^ P[11];
      n3 = S[r >>> 24];
      n3 += S[256 | r >> 16 & 255];
      n3 ^= S[512 | r >> 8 & 255];
      n3 += S[768 | r & 255];
      l3 ^= n3 ^ P[12];
      n3 = S[l3 >>> 24];
      n3 += S[256 | l3 >> 16 & 255];
      n3 ^= S[512 | l3 >> 8 & 255];
      n3 += S[768 | l3 & 255];
      r ^= n3 ^ P[13];
      n3 = S[r >>> 24];
      n3 += S[256 | r >> 16 & 255];
      n3 ^= S[512 | r >> 8 & 255];
      n3 += S[768 | r & 255];
      l3 ^= n3 ^ P[14];
      n3 = S[l3 >>> 24];
      n3 += S[256 | l3 >> 16 & 255];
      n3 ^= S[512 | l3 >> 8 & 255];
      n3 += S[768 | l3 & 255];
      r ^= n3 ^ P[15];
      n3 = S[r >>> 24];
      n3 += S[256 | r >> 16 & 255];
      n3 ^= S[512 | r >> 8 & 255];
      n3 += S[768 | r & 255];
      l3 ^= n3 ^ P[16];
      lr[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];
      lr[off + 1] = l3;
      return lr;
    }
    function _streamtoword(data, offp) {
      for (var i = 0, word = 0;i < 4; ++i)
        word = word << 8 | data[offp] & 255, offp = (offp + 1) % data.length;
      return { key: word, offp };
    }
    function _key(key, P, S) {
      var offset = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
      for (var i = 0;i < plen; i++)
        sw = _streamtoword(key, offset), offset = sw.offp, P[i] = P[i] ^ sw.key;
      for (i = 0;i < plen; i += 2)
        lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
      for (i = 0;i < slen; i += 2)
        lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
    }
    function _ekskey(data, key, P, S) {
      var offp = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
      for (var i = 0;i < plen; i++)
        sw = _streamtoword(key, offp), offp = sw.offp, P[i] = P[i] ^ sw.key;
      offp = 0;
      for (i = 0;i < plen; i += 2)
        sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
      for (i = 0;i < slen; i += 2)
        sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
    }
    function _crypt(b3, salt, rounds, callback, progressCallback) {
      var cdata = C_ORIG.slice(), clen = cdata.length, err;
      if (rounds < 4 || rounds > 31) {
        err = Error("Illegal number of rounds (4-31): " + rounds);
        if (callback) {
          nextTick(callback.bind(this, err));
          return;
        } else
          throw err;
      }
      if (salt.length !== BCRYPT_SALT_LEN) {
        err = Error("Illegal salt length: " + salt.length + " != " + BCRYPT_SALT_LEN);
        if (callback) {
          nextTick(callback.bind(this, err));
          return;
        } else
          throw err;
      }
      rounds = 1 << rounds >>> 0;
      var P, S, i = 0, j;
      if (Int32Array) {
        P = new Int32Array(P_ORIG);
        S = new Int32Array(S_ORIG);
      } else {
        P = P_ORIG.slice();
        S = S_ORIG.slice();
      }
      _ekskey(salt, b3, P, S);
      function next() {
        if (progressCallback)
          progressCallback(i / rounds);
        if (i < rounds) {
          var start = Date.now();
          for (;i < rounds; ) {
            i = i + 1;
            _key(b3, P, S);
            _key(salt, P, S);
            if (Date.now() - start > MAX_EXECUTION_TIME)
              break;
          }
        } else {
          for (i = 0;i < 64; i++)
            for (j = 0;j < clen >> 1; j++)
              _encipher(cdata, j << 1, P, S);
          var ret = [];
          for (i = 0;i < clen; i++)
            ret.push((cdata[i] >> 24 & 255) >>> 0), ret.push((cdata[i] >> 16 & 255) >>> 0), ret.push((cdata[i] >> 8 & 255) >>> 0), ret.push((cdata[i] & 255) >>> 0);
          if (callback) {
            callback(null, ret);
            return;
          } else
            return ret;
        }
        if (callback)
          nextTick(next);
      }
      if (typeof callback !== "undefined") {
        next();
      } else {
        var res;
        while (true)
          if (typeof (res = next()) !== "undefined")
            return res || [];
      }
    }
    function _hash(s3, salt, callback, progressCallback) {
      var err;
      if (typeof s3 !== "string" || typeof salt !== "string") {
        err = Error("Invalid string / salt: Not a string");
        if (callback) {
          nextTick(callback.bind(this, err));
          return;
        } else
          throw err;
      }
      var minor, offset;
      if (salt.charAt(0) !== "$" || salt.charAt(1) !== "2") {
        err = Error("Invalid salt version: " + salt.substring(0, 2));
        if (callback) {
          nextTick(callback.bind(this, err));
          return;
        } else
          throw err;
      }
      if (salt.charAt(2) === "$")
        minor = String.fromCharCode(0), offset = 3;
      else {
        minor = salt.charAt(2);
        if (minor !== "a" && minor !== "b" && minor !== "y" || salt.charAt(3) !== "$") {
          err = Error("Invalid salt revision: " + salt.substring(2, 4));
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        offset = 4;
      }
      if (salt.charAt(offset + 2) > "$") {
        err = Error("Missing salt rounds");
        if (callback) {
          nextTick(callback.bind(this, err));
          return;
        } else
          throw err;
      }
      var r13 = parseInt(salt.substring(offset, offset + 1), 10) * 10, r2 = parseInt(salt.substring(offset + 1, offset + 2), 10), rounds = r13 + r2, real_salt = salt.substring(offset + 3, offset + 25);
      s3 += minor >= "a" ? "\0" : "";
      var passwordb = stringToBytes(s3), saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);
      function finish(bytes) {
        var res = [];
        res.push("$2");
        if (minor >= "a")
          res.push(minor);
        res.push("$");
        if (rounds < 10)
          res.push("0");
        res.push(rounds.toString());
        res.push("$");
        res.push(base64_encode(saltb, saltb.length));
        res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));
        return res.join("");
      }
      if (typeof callback == "undefined")
        return finish(_crypt(passwordb, saltb, rounds));
      else {
        _crypt(passwordb, saltb, rounds, function(err2, bytes) {
          if (err2)
            callback(err2, null);
          else
            callback(null, finish(bytes));
        }, progressCallback);
      }
    }
    bcrypt.encodeBase64 = base64_encode;
    bcrypt.decodeBase64 = base64_decode;
    return bcrypt;
  });
});

// ../sisventa/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  var copyProps = function(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  };
  var SafeBuffer = function(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  };
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = import.meta.require("buffer");
  var Buffer2 = buffer.Buffer;
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// ../sisventa/node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS((exports, module) => {
  var DataStream = function(data) {
    this.buffer = null;
    this.writable = true;
    this.readable = true;
    if (!data) {
      this.buffer = Buffer2.alloc(0);
      return this;
    }
    if (typeof data.pipe === "function") {
      this.buffer = Buffer2.alloc(0);
      data.pipe(this);
      return this;
    }
    if (data.length || typeof data === "object") {
      this.buffer = data;
      this.writable = false;
      process.nextTick(function() {
        this.emit("end", data);
        this.readable = false;
        this.emit("close");
      }.bind(this));
      return this;
    }
    throw new TypeError("Unexpected data type (" + typeof data + ")");
  };
  var Buffer2 = require_safe_buffer().Buffer;
  var Stream = import.meta.require("stream");
  var util = import.meta.require("util");
  util.inherits(DataStream, Stream);
  DataStream.prototype.write = function write(data) {
    this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
    this.emit("data", data);
  };
  DataStream.prototype.end = function end(data) {
    if (data)
      this.write(data);
    this.emit("end", data);
    this.emit("close");
    this.writable = false;
    this.readable = false;
  };
  module.exports = DataStream;
});

// ../sisventa/node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS((exports, module) => {
  var bufferEq = function(a3, b3) {
    if (!Buffer2.isBuffer(a3) || !Buffer2.isBuffer(b3)) {
      return false;
    }
    if (a3.length !== b3.length) {
      return false;
    }
    var c3 = 0;
    for (var i = 0;i < a3.length; i++) {
      c3 |= a3[i] ^ b3[i];
    }
    return c3 === 0;
  };
  var Buffer2 = import.meta.require("buffer").Buffer;
  var SlowBuffer = import.meta.require("buffer").SlowBuffer;
  module.exports = bufferEq;
  bufferEq.install = function() {
    Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
      return bufferEq(this, that);
    };
  };
  var origBufEqual = Buffer2.prototype.equal;
  var origSlowBufEqual = SlowBuffer.prototype.equal;
  bufferEq.restore = function() {
    Buffer2.prototype.equal = origBufEqual;
    SlowBuffer.prototype.equal = origSlowBufEqual;
  };
});

// ../sisventa/node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS((exports, module) => {
  var getParamSize = function(keySize) {
    var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
    return result;
  };
  var getParamBytesForAlg = function(alg) {
    var paramBytes = paramBytesForAlg[alg];
    if (paramBytes) {
      return paramBytes;
    }
    throw new Error('Unknown algorithm "' + alg + '"');
  };
  var paramBytesForAlg = {
    ES256: getParamSize(256),
    ES384: getParamSize(384),
    ES512: getParamSize(521)
  };
  module.exports = getParamBytesForAlg;
});

// ../sisventa/node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS((exports, module) => {
  var base64Url = function(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  };
  var signatureAsBuffer = function(signature) {
    if (Buffer2.isBuffer(signature)) {
      return signature;
    } else if (typeof signature === "string") {
      return Buffer2.from(signature, "base64");
    }
    throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
  };
  var derToJose = function(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var maxEncodedParamLength = paramBytes + 1;
    var inputLength = signature.length;
    var offset = 0;
    if (signature[offset++] !== ENCODED_TAG_SEQ) {
      throw new Error('Could not find expected "seq"');
    }
    var seqLength = signature[offset++];
    if (seqLength === (MAX_OCTET | 1)) {
      seqLength = signature[offset++];
    }
    if (inputLength - offset < seqLength) {
      throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
    }
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "r"');
    }
    var rLength = signature[offset++];
    if (inputLength - offset - 2 < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
    }
    if (maxEncodedParamLength < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var rOffset = offset;
    offset += rLength;
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "s"');
    }
    var sLength = signature[offset++];
    if (inputLength - offset !== sLength) {
      throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
    }
    if (maxEncodedParamLength < sLength) {
      throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var sOffset = offset;
    offset += sLength;
    if (offset !== inputLength) {
      throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
    }
    var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
    var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
    for (offset = 0;offset < rPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
    offset = paramBytes;
    for (var o3 = offset;offset < o3 + sPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
    dst = dst.toString("base64");
    dst = base64Url(dst);
    return dst;
  };
  var countPadding = function(buf, start, stop) {
    var padding = 0;
    while (start + padding < stop && buf[start + padding] === 0) {
      ++padding;
    }
    var needsSign = buf[start + padding] >= MAX_OCTET;
    if (needsSign) {
      --padding;
    }
    return padding;
  };
  var joseToDer = function(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var signatureBytes = signature.length;
    if (signatureBytes !== paramBytes * 2) {
      throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
    }
    var rPadding = countPadding(signature, 0, paramBytes);
    var sPadding = countPadding(signature, paramBytes, signature.length);
    var rLength = paramBytes - rPadding;
    var sLength = paramBytes - sPadding;
    var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
    var shortLength = rsBytes < MAX_OCTET;
    var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
    var offset = 0;
    dst[offset++] = ENCODED_TAG_SEQ;
    if (shortLength) {
      dst[offset++] = rsBytes;
    } else {
      dst[offset++] = MAX_OCTET | 1;
      dst[offset++] = rsBytes & 255;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = rLength;
    if (rPadding < 0) {
      dst[offset++] = 0;
      offset += signature.copy(dst, offset, 0, paramBytes);
    } else {
      offset += signature.copy(dst, offset, rPadding, paramBytes);
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = sLength;
    if (sPadding < 0) {
      dst[offset++] = 0;
      signature.copy(dst, offset, paramBytes);
    } else {
      signature.copy(dst, offset, paramBytes + sPadding);
    }
    return dst;
  };
  var Buffer2 = require_safe_buffer().Buffer;
  var getParamBytesForAlg = require_param_bytes_for_alg();
  var MAX_OCTET = 128;
  var CLASS_UNIVERSAL = 0;
  var PRIMITIVE_BIT = 32;
  var TAG_SEQ = 16;
  var TAG_INT = 2;
  var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
  var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
  module.exports = {
    derToJose,
    joseToDer
  };
});

// ../sisventa/node_modules/jwa/index.js
var require_jwa = __commonJS((exports, module) => {
  var checkIsPublicKey = function(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key !== "object") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.type !== "string") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.asymmetricKeyType !== "string") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.export !== "function") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
  };
  var checkIsPrivateKey = function(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return;
    }
    if (typeof key === "object") {
      return;
    }
    throw typeError(MSG_INVALID_SIGNER_KEY);
  };
  var checkIsSecretKey = function(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return key;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key !== "object") {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (key.type !== "secret") {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key.export !== "function") {
      throw typeError(MSG_INVALID_SECRET);
    }
  };
  var fromBase64 = function(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  };
  var toBase64 = function(base64url) {
    base64url = base64url.toString();
    var padding = 4 - base64url.length % 4;
    if (padding !== 4) {
      for (var i = 0;i < padding; ++i) {
        base64url += "=";
      }
    }
    return base64url.replace(/\-/g, "+").replace(/_/g, "/");
  };
  var typeError = function(template) {
    var args = [].slice.call(arguments, 1);
    var errMsg = util.format.bind(util, template).apply(null, args);
    return new TypeError(errMsg);
  };
  var bufferOrString = function(obj) {
    return Buffer2.isBuffer(obj) || typeof obj === "string";
  };
  var normalizeInput = function(thing) {
    if (!bufferOrString(thing))
      thing = JSON.stringify(thing);
    return thing;
  };
  var createHmacSigner = function(bits) {
    return function sign(thing, secret) {
      checkIsSecretKey(secret);
      thing = normalizeInput(thing);
      var hmac = crypto2.createHmac("sha" + bits, secret);
      var sig = (hmac.update(thing), hmac.digest("base64"));
      return fromBase64(sig);
    };
  };
  var createHmacVerifier = function(bits) {
    return function verify(thing, signature, secret) {
      var computedSig = createHmacSigner(bits)(thing, secret);
      return bufferEqual(Buffer2.from(signature), Buffer2.from(computedSig));
    };
  };
  var createKeySigner = function(bits) {
    return function sign(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto2.createSign("RSA-SHA" + bits);
      var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
      return fromBase64(sig);
    };
  };
  var createKeyVerifier = function(bits) {
    return function verify(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto2.createVerify("RSA-SHA" + bits);
      verifier.update(thing);
      return verifier.verify(publicKey, signature, "base64");
    };
  };
  var createPSSKeySigner = function(bits) {
    return function sign(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto2.createSign("RSA-SHA" + bits);
      var sig = (signer.update(thing), signer.sign({
        key: privateKey,
        padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
      }, "base64"));
      return fromBase64(sig);
    };
  };
  var createPSSKeyVerifier = function(bits) {
    return function verify(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto2.createVerify("RSA-SHA" + bits);
      verifier.update(thing);
      return verifier.verify({
        key: publicKey,
        padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
      }, signature, "base64");
    };
  };
  var createECDSASigner = function(bits) {
    var inner = createKeySigner(bits);
    return function sign() {
      var signature = inner.apply(null, arguments);
      signature = formatEcdsa.derToJose(signature, "ES" + bits);
      return signature;
    };
  };
  var createECDSAVerifer = function(bits) {
    var inner = createKeyVerifier(bits);
    return function verify(thing, signature, publicKey) {
      signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
      var result = inner(thing, signature, publicKey);
      return result;
    };
  };
  var createNoneSigner = function() {
    return function sign() {
      return "";
    };
  };
  var createNoneVerifier = function() {
    return function verify(thing, signature) {
      return signature === "";
    };
  };
  var bufferEqual = require_buffer_equal_constant_time();
  var Buffer2 = require_safe_buffer().Buffer;
  var crypto2 = import.meta.require("crypto");
  var formatEcdsa = require_ecdsa_sig_formatter();
  var util = import.meta.require("util");
  var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
  var MSG_INVALID_SECRET = "secret must be a string or buffer";
  var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
  var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
  var supportsKeyObjects = typeof crypto2.createPublicKey === "function";
  if (supportsKeyObjects) {
    MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
    MSG_INVALID_SECRET += "or a KeyObject";
  }
  module.exports = function jwa(algorithm) {
    var signerFactories = {
      hs: createHmacSigner,
      rs: createKeySigner,
      ps: createPSSKeySigner,
      es: createECDSASigner,
      none: createNoneSigner
    };
    var verifierFactories = {
      hs: createHmacVerifier,
      rs: createKeyVerifier,
      ps: createPSSKeyVerifier,
      es: createECDSAVerifer,
      none: createNoneVerifier
    };
    var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
    if (!match)
      throw typeError(MSG_INVALID_ALGORITHM, algorithm);
    var algo = (match[1] || match[3]).toLowerCase();
    var bits = match[2];
    return {
      sign: signerFactories[algo](bits),
      verify: verifierFactories[algo](bits)
    };
  };
});

// ../sisventa/node_modules/jws/lib/tostring.js
var require_tostring = __commonJS((exports, module) => {
  var Buffer2 = import.meta.require("buffer").Buffer;
  module.exports = function toString(obj) {
    if (typeof obj === "string")
      return obj;
    if (typeof obj === "number" || Buffer2.isBuffer(obj))
      return obj.toString();
    return JSON.stringify(obj);
  };
});

// ../sisventa/node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS((exports, module) => {
  var base64url = function(string11, encoding) {
    return Buffer2.from(string11, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  };
  var jwsSecuredInput = function(header, payload, encoding) {
    encoding = encoding || "utf8";
    var encodedHeader = base64url(toString2(header), "binary");
    var encodedPayload = base64url(toString2(payload), encoding);
    return util.format("%s.%s", encodedHeader, encodedPayload);
  };
  var jwsSign = function(opts) {
    var header = opts.header;
    var payload = opts.payload;
    var secretOrKey = opts.secret || opts.privateKey;
    var encoding = opts.encoding;
    var algo = jwa(header.alg);
    var securedInput = jwsSecuredInput(header, payload, encoding);
    var signature = algo.sign(securedInput, secretOrKey);
    return util.format("%s.%s", securedInput, signature);
  };
  var SignStream = function(opts) {
    var secret = opts.secret || opts.privateKey || opts.key;
    var secretStream = new DataStream(secret);
    this.readable = true;
    this.header = opts.header;
    this.encoding = opts.encoding;
    this.secret = this.privateKey = this.key = secretStream;
    this.payload = new DataStream(opts.payload);
    this.secret.once("close", function() {
      if (!this.payload.writable && this.readable)
        this.sign();
    }.bind(this));
    this.payload.once("close", function() {
      if (!this.secret.writable && this.readable)
        this.sign();
    }.bind(this));
  };
  var Buffer2 = require_safe_buffer().Buffer;
  var DataStream = require_data_stream();
  var jwa = require_jwa();
  var Stream = import.meta.require("stream");
  var toString2 = require_tostring();
  var util = import.meta.require("util");
  util.inherits(SignStream, Stream);
  SignStream.prototype.sign = function sign() {
    try {
      var signature = jwsSign({
        header: this.header,
        payload: this.payload.buffer,
        secret: this.secret.buffer,
        encoding: this.encoding
      });
      this.emit("done", signature);
      this.emit("data", signature);
      this.emit("end");
      this.readable = false;
      return signature;
    } catch (e3) {
      this.readable = false;
      this.emit("error", e3);
      this.emit("close");
    }
  };
  SignStream.sign = jwsSign;
  module.exports = SignStream;
});

// ../sisventa/node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS((exports, module) => {
  var isObject = function(thing) {
    return Object.prototype.toString.call(thing) === "[object Object]";
  };
  var safeJsonParse = function(thing) {
    if (isObject(thing))
      return thing;
    try {
      return JSON.parse(thing);
    } catch (e3) {
      return;
    }
  };
  var headerFromJWS = function(jwsSig) {
    var encodedHeader = jwsSig.split(".", 1)[0];
    return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
  };
  var securedInputFromJWS = function(jwsSig) {
    return jwsSig.split(".", 2).join(".");
  };
  var signatureFromJWS = function(jwsSig) {
    return jwsSig.split(".")[2];
  };
  var payloadFromJWS = function(jwsSig, encoding) {
    encoding = encoding || "utf8";
    var payload = jwsSig.split(".")[1];
    return Buffer2.from(payload, "base64").toString(encoding);
  };
  var isValidJws = function(string11) {
    return JWS_REGEX.test(string11) && !!headerFromJWS(string11);
  };
  var jwsVerify = function(jwsSig, algorithm, secretOrKey) {
    if (!algorithm) {
      var err = new Error("Missing algorithm parameter for jws.verify");
      err.code = "MISSING_ALGORITHM";
      throw err;
    }
    jwsSig = toString2(jwsSig);
    var signature = signatureFromJWS(jwsSig);
    var securedInput = securedInputFromJWS(jwsSig);
    var algo = jwa(algorithm);
    return algo.verify(securedInput, signature, secretOrKey);
  };
  var jwsDecode = function(jwsSig, opts) {
    opts = opts || {};
    jwsSig = toString2(jwsSig);
    if (!isValidJws(jwsSig))
      return null;
    var header = headerFromJWS(jwsSig);
    if (!header)
      return null;
    var payload = payloadFromJWS(jwsSig);
    if (header.typ === "JWT" || opts.json)
      payload = JSON.parse(payload, opts.encoding);
    return {
      header,
      payload,
      signature: signatureFromJWS(jwsSig)
    };
  };
  var VerifyStream = function(opts) {
    opts = opts || {};
    var secretOrKey = opts.secret || opts.publicKey || opts.key;
    var secretStream = new DataStream(secretOrKey);
    this.readable = true;
    this.algorithm = opts.algorithm;
    this.encoding = opts.encoding;
    this.secret = this.publicKey = this.key = secretStream;
    this.signature = new DataStream(opts.signature);
    this.secret.once("close", function() {
      if (!this.signature.writable && this.readable)
        this.verify();
    }.bind(this));
    this.signature.once("close", function() {
      if (!this.secret.writable && this.readable)
        this.verify();
    }.bind(this));
  };
  var Buffer2 = require_safe_buffer().Buffer;
  var DataStream = require_data_stream();
  var jwa = require_jwa();
  var Stream = import.meta.require("stream");
  var toString2 = require_tostring();
  var util = import.meta.require("util");
  var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
  util.inherits(VerifyStream, Stream);
  VerifyStream.prototype.verify = function verify() {
    try {
      var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
      var obj = jwsDecode(this.signature.buffer, this.encoding);
      this.emit("done", valid, obj);
      this.emit("data", valid);
      this.emit("end");
      this.readable = false;
      return valid;
    } catch (e3) {
      this.readable = false;
      this.emit("error", e3);
      this.emit("close");
    }
  };
  VerifyStream.decode = jwsDecode;
  VerifyStream.isValid = isValidJws;
  VerifyStream.verify = jwsVerify;
  module.exports = VerifyStream;
});

// ../sisventa/node_modules/jws/index.js
var require_jws = __commonJS((exports) => {
  var SignStream = require_sign_stream();
  var VerifyStream = require_verify_stream();
  var ALGORITHMS = [
    "HS256",
    "HS384",
    "HS512",
    "RS256",
    "RS384",
    "RS512",
    "PS256",
    "PS384",
    "PS512",
    "ES256",
    "ES384",
    "ES512"
  ];
  exports.ALGORITHMS = ALGORITHMS;
  exports.sign = SignStream.sign;
  exports.verify = VerifyStream.verify;
  exports.decode = VerifyStream.decode;
  exports.isValid = VerifyStream.isValid;
  exports.createSign = function createSign(opts) {
    return new SignStream(opts);
  };
  exports.createVerify = function createVerify(opts) {
    return new VerifyStream(opts);
  };
});

// ../sisventa/node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS((exports, module) => {
  var jws = require_jws();
  module.exports = function(jwt, options) {
    options = options || {};
    var decoded = jws.decode(jwt, options);
    if (!decoded) {
      return null;
    }
    var payload = decoded.payload;
    if (typeof payload === "string") {
      try {
        var obj = JSON.parse(payload);
        if (obj !== null && typeof obj === "object") {
          payload = obj;
        }
      } catch (e3) {
      }
    }
    if (options.complete === true) {
      return {
        header: decoded.header,
        payload,
        signature: decoded.signature
      };
    }
    return payload;
  };
});

// ../sisventa/node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS((exports, module) => {
  var JsonWebTokenError = function(message, error41) {
    Error.call(this, message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "JsonWebTokenError";
    this.message = message;
    if (error41)
      this.inner = error41;
  };
  JsonWebTokenError.prototype = Object.create(Error.prototype);
  JsonWebTokenError.prototype.constructor = JsonWebTokenError;
  module.exports = JsonWebTokenError;
});

// ../sisventa/node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS((exports, module) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var NotBeforeError = function(message, date7) {
    JsonWebTokenError.call(this, message);
    this.name = "NotBeforeError";
    this.date = date7;
  };
  NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
  NotBeforeError.prototype.constructor = NotBeforeError;
  module.exports = NotBeforeError;
});

// ../sisventa/node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS((exports, module) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var TokenExpiredError = function(message, expiredAt) {
    JsonWebTokenError.call(this, message);
    this.name = "TokenExpiredError";
    this.expiredAt = expiredAt;
  };
  TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
  TokenExpiredError.prototype.constructor = TokenExpiredError;
  module.exports = TokenExpiredError;
});

// ../sisventa/node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var parse7 = function(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n3 = parseFloat(match[1]);
    var type145 = (match[2] || "ms").toLowerCase();
    switch (type145) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n3 * y3;
      case "weeks":
      case "week":
      case "w":
        return n3 * w;
      case "days":
      case "day":
      case "d":
        return n3 * d3;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n3 * h3;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n3 * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n3 * s3;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n3;
      default:
        return;
    }
  };
  var fmtShort = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d3) {
      return Math.round(ms / d3) + "d";
    }
    if (msAbs >= h3) {
      return Math.round(ms / h3) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s3) {
      return Math.round(ms / s3) + "s";
    }
    return ms + "ms";
  };
  var fmtLong = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d3) {
      return plural(ms, msAbs, d3, "day");
    }
    if (msAbs >= h3) {
      return plural(ms, msAbs, h3, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s3) {
      return plural(ms, msAbs, s3, "second");
    }
    return ms + " ms";
  };
  var plural = function(ms, msAbs, n3, name) {
    var isPlural = msAbs >= n3 * 1.5;
    return Math.round(ms / n3) + " " + name + (isPlural ? "s" : "");
  };
  var s3 = 1000;
  var m = s3 * 60;
  var h3 = m * 60;
  var d3 = h3 * 24;
  var w = d3 * 7;
  var y3 = d3 * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type145 = typeof val;
    if (type145 === "string" && val.length > 0) {
      return parse7(val);
    } else if (type145 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
});

// ../sisventa/node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS((exports, module) => {
  var ms = require_ms();
  module.exports = function(time, iat) {
    var timestamp = iat || Math.floor(Date.now() / 1000);
    if (typeof time === "string") {
      var milliseconds = ms(time);
      if (typeof milliseconds === "undefined") {
        return;
      }
      return Math.floor(timestamp + milliseconds / 1000);
    } else if (typeof time === "number") {
      return timestamp + time;
    } else {
      return;
    }
  };
});

// ../sisventa/node_modules/semver/internal/constants.js
var require_constants = __commonJS((exports, module) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});

// ../sisventa/node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports, module) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  module.exports = debug;
});

// ../sisventa/node_modules/semver/internal/re.js
var require_re = __commonJS((exports, module) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_LENGTH
  } = require_constants();
  var debug = require_debug();
  exports = module.exports = {};
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var t3 = exports.t = {};
  var R3 = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  var makeSafeRegex = (value27) => {
    for (const [token, max] of safeRegexReplacements) {
      value27 = value27.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value27;
  };
  var createToken = (name, value27, isGlobal) => {
    const safe = makeSafeRegex(value27);
    const index = R3++;
    debug(name, index, value27);
    t3[name] = index;
    src[index] = value27;
    re[index] = new RegExp(value27, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t3.NUMERICIDENTIFIER]})\\.` + `(${src[t3.NUMERICIDENTIFIER]})\\.` + `(${src[t3.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t3.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t3.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t3.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t3.NUMERICIDENTIFIER]}|${src[t3.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t3.NUMERICIDENTIFIERLOOSE]}|${src[t3.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t3.PRERELEASEIDENTIFIER]}(?:\\.${src[t3.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t3.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t3.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t3.BUILDIDENTIFIER]}(?:\\.${src[t3.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t3.MAINVERSION]}${src[t3.PRERELEASE]}?${src[t3.BUILD]}?`);
  createToken("FULL", `^${src[t3.FULLPLAIN]}\$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t3.MAINVERSIONLOOSE]}${src[t3.PRERELEASELOOSE]}?${src[t3.BUILD]}?`);
  createToken("LOOSE", `^${src[t3.LOOSEPLAIN]}\$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t3.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t3.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t3.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t3.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t3.XRANGEIDENTIFIER]})` + `(?:${src[t3.PRERELEASE]})?${src[t3.BUILD]}?` + `)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t3.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t3.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t3.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t3.PRERELEASELOOSE]})?${src[t3.BUILD]}?` + `)?)?`);
  createToken("XRANGE", `^${src[t3.GTLT]}\\s*${src[t3.XRANGEPLAIN]}\$`);
  createToken("XRANGELOOSE", `^${src[t3.GTLT]}\\s*${src[t3.XRANGEPLAINLOOSE]}\$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
  createToken("COERCE", `${src[t3.COERCEPLAIN]}(?:\$|[^\\d])`);
  createToken("COERCEFULL", src[t3.COERCEPLAIN] + `(?:${src[t3.PRERELEASE]})?` + `(?:${src[t3.BUILD]})?` + `(?:\$|[^\\d])`);
  createToken("COERCERTL", src[t3.COERCE], true);
  createToken("COERCERTLFULL", src[t3.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t3.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t3.LONETILDE]}${src[t3.XRANGEPLAIN]}\$`);
  createToken("TILDELOOSE", `^${src[t3.LONETILDE]}${src[t3.XRANGEPLAINLOOSE]}\$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t3.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t3.LONECARET]}${src[t3.XRANGEPLAIN]}\$`);
  createToken("CARETLOOSE", `^${src[t3.LONECARET]}${src[t3.XRANGEPLAINLOOSE]}\$`);
  createToken("COMPARATORLOOSE", `^${src[t3.GTLT]}\\s*(${src[t3.LOOSEPLAIN]})\$|^\$`);
  createToken("COMPARATOR", `^${src[t3.GTLT]}\\s*(${src[t3.FULLPLAIN]})\$|^\$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t3.GTLT]}\\s*(${src[t3.LOOSEPLAIN]}|${src[t3.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t3.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t3.XRANGEPLAIN]})` + `\\s*\$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t3.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t3.XRANGEPLAINLOOSE]})` + `\\s*\$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// ../sisventa/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports, module) => {
  var looseOption = Object.freeze({ loose: true });
  var emptyOpts = Object.freeze({});
  var parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  module.exports = parseOptions;
});

// ../sisventa/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports, module) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a3, b3) => {
    const anum = numeric.test(a3);
    const bnum = numeric.test(b3);
    if (anum && bnum) {
      a3 = +a3;
      b3 = +b3;
    }
    return a3 === b3 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a3 < b3 ? -1 : 1;
  };
  var rcompareIdentifiers = (a3, b3) => compareIdentifiers(b3, a3);
  module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// ../sisventa/node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports, module) => {
  var debug = require_debug();
  var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
  var { safeRe: re, t: t3 } = require_re();
  var parseOptions = require_parse_options();
  var { compareIdentifiers } = require_identifiers();

  class SemVer {
    constructor(version, options) {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version.trim().match(options.loose ? re[t3.LOOSE] : re[t3.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version}`);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a3 = this.prerelease[i];
        const b3 = other.prerelease[i];
        debug("prerelease compare", i, a3, b3);
        if (a3 === undefined && b3 === undefined) {
          return 0;
        } else if (b3 === undefined) {
          return 1;
        } else if (a3 === undefined) {
          return -1;
        } else if (a3 === b3) {
          continue;
        } else {
          return compareIdentifiers(a3, b3);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a3 = this.build[i];
        const b3 = other.build[i];
        debug("prerelease compare", i, a3, b3);
        if (a3 === undefined && b3 === undefined) {
          return 0;
        } else if (b3 === undefined) {
          return 1;
        } else if (a3 === undefined) {
          return -1;
        } else if (a3 === b3) {
          continue;
        } else {
          return compareIdentifiers(a3, b3);
        }
      } while (++i);
    }
    inc(release, identifier, identifierBase) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  module.exports = SemVer;
});

// ../sisventa/node_modules/semver/functions/parse.js
var require_parse = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse7 = (version, options, throwErrors = false) => {
    if (version instanceof SemVer) {
      return version;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  module.exports = parse7;
});

// ../sisventa/node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports, module) => {
  var parse7 = require_parse();
  var valid = (version, options) => {
    const v3 = parse7(version, options);
    return v3 ? v3.version : null;
  };
  module.exports = valid;
});

// ../sisventa/node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports, module) => {
  var parse7 = require_parse();
  var clean5 = (version, options) => {
    const s3 = parse7(version.trim().replace(/^[=v]+/, ""), options);
    return s3 ? s3.version : null;
  };
  module.exports = clean5;
});

// ../sisventa/node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var inc = (version, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = undefined;
    }
    try {
      return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  module.exports = inc;
});

// ../sisventa/node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports, module) => {
  var parse7 = require_parse();
  var diff = (version1, version2) => {
    const v13 = parse7(version1, null, true);
    const v22 = parse7(version2, null, true);
    const comparison = v13.compare(v22);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v13 : v22;
    const lowVersion = v1Higher ? v22 : v13;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (highVersion.patch) {
        return "patch";
      }
      if (highVersion.minor) {
        return "minor";
      }
      return "major";
    }
    const prefix = highHasPre ? "pre" : "";
    if (v13.major !== v22.major) {
      return prefix + "major";
    }
    if (v13.minor !== v22.minor) {
      return prefix + "minor";
    }
    if (v13.patch !== v22.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  module.exports = diff;
});

// ../sisventa/node_modules/semver/functions/major.js
var require_major = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var major = (a3, loose) => new SemVer(a3, loose).major;
  module.exports = major;
});

// ../sisventa/node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var minor = (a3, loose) => new SemVer(a3, loose).minor;
  module.exports = minor;
});

// ../sisventa/node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var patch = (a3, loose) => new SemVer(a3, loose).patch;
  module.exports = patch;
});

// ../sisventa/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports, module) => {
  var parse7 = require_parse();
  var prerelease = (version, options) => {
    const parsed = parse7(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module.exports = prerelease;
});

// ../sisventa/node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compare = (a3, b3, loose) => new SemVer(a3, loose).compare(new SemVer(b3, loose));
  module.exports = compare;
});

// ../sisventa/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports, module) => {
  var compare = require_compare();
  var rcompare = (a3, b3, loose) => compare(b3, a3, loose);
  module.exports = rcompare;
});

// ../sisventa/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports, module) => {
  var compare = require_compare();
  var compareLoose = (a3, b3) => compare(a3, b3, true);
  module.exports = compareLoose;
});

// ../sisventa/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compareBuild = (a3, b3, loose) => {
    const versionA = new SemVer(a3, loose);
    const versionB = new SemVer(b3, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module.exports = compareBuild;
});

// ../sisventa/node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var sort = (list, loose) => list.sort((a3, b3) => compareBuild(a3, b3, loose));
  module.exports = sort;
});

// ../sisventa/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a3, b3) => compareBuild(b3, a3, loose));
  module.exports = rsort;
});

// ../sisventa/node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports, module) => {
  var compare = require_compare();
  var gt = (a3, b3, loose) => compare(a3, b3, loose) > 0;
  module.exports = gt;
});

// ../sisventa/node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports, module) => {
  var compare = require_compare();
  var lt = (a3, b3, loose) => compare(a3, b3, loose) < 0;
  module.exports = lt;
});

// ../sisventa/node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports, module) => {
  var compare = require_compare();
  var eq = (a3, b3, loose) => compare(a3, b3, loose) === 0;
  module.exports = eq;
});

// ../sisventa/node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports, module) => {
  var compare = require_compare();
  var neq = (a3, b3, loose) => compare(a3, b3, loose) !== 0;
  module.exports = neq;
});

// ../sisventa/node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports, module) => {
  var compare = require_compare();
  var gte = (a3, b3, loose) => compare(a3, b3, loose) >= 0;
  module.exports = gte;
});

// ../sisventa/node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports, module) => {
  var compare = require_compare();
  var lte = (a3, b3, loose) => compare(a3, b3, loose) <= 0;
  module.exports = lte;
});

// ../sisventa/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports, module) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a3, op, b3, loose) => {
    switch (op) {
      case "===":
        if (typeof a3 === "object") {
          a3 = a3.version;
        }
        if (typeof b3 === "object") {
          b3 = b3.version;
        }
        return a3 === b3;
      case "!==":
        if (typeof a3 === "object") {
          a3 = a3.version;
        }
        if (typeof b3 === "object") {
          b3 = b3.version;
        }
        return a3 !== b3;
      case "":
      case "=":
      case "==":
        return eq(a3, b3, loose);
      case "!=":
        return neq(a3, b3, loose);
      case ">":
        return gt(a3, b3, loose);
      case ">=":
        return gte(a3, b3, loose);
      case "<":
        return lt(a3, b3, loose);
      case "<=":
        return lte(a3, b3, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module.exports = cmp;
});

// ../sisventa/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse7 = require_parse();
  var { safeRe: re, t: t3 } = require_re();
  var coerce = (version, options) => {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version.match(options.includePrerelease ? re[t3.COERCEFULL] : re[t3.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re[t3.COERCERTLFULL] : re[t3.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse7(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  };
  module.exports = coerce;
});

// ../sisventa/node_modules/yallist/iterator.js
var require_iterator = __commonJS((exports, module) => {
  module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head;walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// ../sisventa/node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports, module) => {
  var Yallist = function(list) {
    var self2 = this;
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist;
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l3 = arguments.length;i < l3; i++) {
        self2.push(arguments[i]);
      }
    }
    return self2;
  };
  var insert = function(self2, node, value27) {
    var inserted = node === self2.head ? new Node(value27, null, node, self2) : new Node(value27, node, node.next, self2);
    if (inserted.next === null) {
      self2.tail = inserted;
    }
    if (inserted.prev === null) {
      self2.head = inserted;
    }
    self2.length++;
    return inserted;
  };
  var push = function(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  };
  var unshift = function(self2, item) {
    self2.head = new Node(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  };
  var Node = function(value27, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value27, prev, next, list);
    }
    this.list = list;
    this.value = value27;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  };
  module.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l3 = arguments.length;i < l3; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l3 = arguments.length;i < l3; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0;walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1;walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n3) {
    for (var i = 0, walker = this.head;walker !== null && i < n3; i++) {
      walker = walker.next;
    }
    if (i === n3 && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n3) {
    for (var i = 0, walker = this.tail;walker !== null && i < n3; i++) {
      walker = walker.prev;
    }
    if (i === n3 && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.head;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.tail;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0;walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1;walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head;walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (;walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail;walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (;walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head;walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i = 0;walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0;i < nodes.length; i++) {
      walker = insert(this, walker, nodes[i]);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head;walker !== null; walker = walker.prev) {
      var p3 = walker.prev;
      walker.prev = walker.next;
      walker.next = p3;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  try {
    require_iterator()(Yallist);
  } catch (er) {
  }
});

// ../sisventa/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS((exports, module) => {
  var Yallist = require_yallist();
  var MAX = Symbol("max");
  var LENGTH = Symbol("length");
  var LENGTH_CALCULATOR = Symbol("lengthCalculator");
  var ALLOW_STALE = Symbol("allowStale");
  var MAX_AGE = Symbol("maxAge");
  var DISPOSE = Symbol("dispose");
  var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
  var LRU_LIST = Symbol("lruList");
  var CACHE = Symbol("cache");
  var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
  var naiveLength = () => 1;

  class LRUCache {
    constructor(options) {
      if (typeof options === "number")
        options = { max: options };
      if (!options)
        options = {};
      if (options.max && (typeof options.max !== "number" || options.max < 0))
        throw new TypeError("max must be a non-negative number");
      const max = this[MAX] = options.max || Infinity;
      const lc = options.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
      this[ALLOW_STALE] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
      this.reset();
    }
    set max(mL) {
      if (typeof mL !== "number" || mL < 0)
        throw new TypeError("max must be a non-negative number");
      this[MAX] = mL || Infinity;
      trim(this);
    }
    get max() {
      return this[MAX];
    }
    set allowStale(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
      return this[ALLOW_STALE];
    }
    set maxAge(mA) {
      if (typeof mA !== "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[MAX_AGE] = mA;
      trim(this);
    }
    get maxAge() {
      return this[MAX_AGE];
    }
    set lengthCalculator(lC) {
      if (typeof lC !== "function")
        lC = naiveLength;
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach((hit) => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
          this[LENGTH] += hit.length;
        });
      }
      trim(this);
    }
    get lengthCalculator() {
      return this[LENGTH_CALCULATOR];
    }
    get length() {
      return this[LENGTH];
    }
    get itemCount() {
      return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].tail;walker !== null; ) {
        const prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
    forEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].head;walker !== null; ) {
        const next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
    keys() {
      return this[LRU_LIST].toArray().map((k3) => k3.key);
    }
    values() {
      return this[LRU_LIST].toArray().map((k3) => k3.value);
    }
    reset() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
      }
      this[CACHE] = new Map;
      this[LRU_LIST] = new Yallist;
      this[LENGTH] = 0;
    }
    dump() {
      return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter((h3) => h3);
    }
    dumpLru() {
      return this[LRU_LIST];
    }
    set(key, value27, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      const now = maxAge ? Date.now() : 0;
      const len = this[LENGTH_CALCULATOR](value27, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        const node = this[CACHE].get(key);
        const item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET])
            this[DISPOSE](key, item.value);
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value27;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      const hit = new Entry(key, value27, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE])
          this[DISPOSE](key, value27);
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
    has(key) {
      if (!this[CACHE].has(key))
        return false;
      const hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
    get(key) {
      return get(this, key, true);
    }
    peek(key) {
      return get(this, key, false);
    }
    pop() {
      const node = this[LRU_LIST].tail;
      if (!node)
        return null;
      del(this, node);
      return node.value;
    }
    del(key) {
      del(this, this[CACHE].get(key));
    }
    load(arr) {
      this.reset();
      const now = Date.now();
      for (let l3 = arr.length - 1;l3 >= 0; l3--) {
        const hit = arr[l3];
        const expiresAt = hit.e || 0;
        if (expiresAt === 0)
          this.set(hit.k, hit.v);
        else {
          const maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
    prune() {
      this[CACHE].forEach((value27, key) => get(this, key, false));
    }
  }
  var get = (self2, key, doUse) => {
    const node = self2[CACHE].get(key);
    if (node) {
      const hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          return;
      } else {
        if (doUse) {
          if (self2[UPDATE_AGE_ON_GET])
            node.value.now = Date.now();
          self2[LRU_LIST].unshiftNode(node);
        }
      }
      return hit.value;
    }
  };
  var isStale = (self2, hit) => {
    if (!hit || !hit.maxAge && !self2[MAX_AGE])
      return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
  };
  var trim = (self2) => {
    if (self2[LENGTH] > self2[MAX]) {
      for (let walker = self2[LRU_LIST].tail;self2[LENGTH] > self2[MAX] && walker !== null; ) {
        const prev = walker.prev;
        del(self2, walker);
        walker = prev;
      }
    }
  };
  var del = (self2, node) => {
    if (node) {
      const hit = node.value;
      if (self2[DISPOSE])
        self2[DISPOSE](hit.key, hit.value);
      self2[LENGTH] -= hit.length;
      self2[CACHE].delete(hit.key);
      self2[LRU_LIST].removeNode(node);
    }
  };

  class Entry {
    constructor(key, value27, length, now, maxAge) {
      this.key = key;
      this.value = value27;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  }
  var forEachStep = (self2, fn, node, thisp) => {
    let hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        hit = undefined;
    }
    if (hit)
      fn.call(thisp, hit.value, hit.key, self2);
  };
  module.exports = LRUCache;
});

// ../sisventa/node_modules/semver/classes/range.js
var require_range = __commonJS((exports, module) => {
  class Range {
    constructor(range, options) {
      options = parseOptions(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c3) => c3.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c3) => !isNullSet(c3[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c3 of this.set) {
            if (c3.length === 1 && isAny(c3[0])) {
              this.set = [c3];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re[t3.HYPHENRANGELOOSE] : re[t3.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range);
      range = range.replace(re[t3.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range);
      range = range.replace(re[t3.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range);
      range = range.replace(re[t3.CARETTRIM], caretTrimReplace);
      debug("caret trim", range);
      let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re[t3.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = new Map;
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0;i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  module.exports = Range;
  var LRU = require_lru_cache();
  var cache = new LRU({ max: 1000 });
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug = require_debug();
  var SemVer = require_semver();
  var {
    safeRe: re,
    t: t3,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
  var isNullSet = (c3) => c3.value === "<0.0.0-0";
  var isAny = (c3) => c3.value === "";
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c3) => replaceTilde(c3, options)).join(" ");
  };
  var replaceTilde = (comp, options) => {
    const r = options.loose ? re[t3.TILDELOOSE] : re[t3.TILDE];
    return comp.replace(r, (_, M, m, p3, pr) => {
      debug("tilde", comp, _, M, m, p3, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p3)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p3}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p3} <${M}.${+m + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c3) => replaceCaret(c3, options)).join(" ");
  };
  var replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re[t3.CARETLOOSE] : re[t3.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p3, pr) => {
      debug("caret", comp, _, M, m, p3, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p3)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p3}-${pr} <${M}.${m}.${+p3 + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p3}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p3}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p3}${z} <${M}.${m}.${+p3 + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p3}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p3} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c3) => replaceXRange(c3, options)).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re[t3.XRANGELOOSE] : re[t3.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p3, pr) => {
      debug("xRange", comp, ret, gtlt, M, m, p3, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p3);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p3 = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p3 = 0;
          } else {
            m = +m + 1;
            p3 = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p3}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t3.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t3.GTE0PRE : t3.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($03, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set3, version, options) => {
    for (let i = 0;i < set3.length; i++) {
      if (!set3[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i = 0;i < set3.length; i++) {
        debug(set3[i].semver);
        if (set3[i].semver === Comparator.ANY) {
          continue;
        }
        if (set3[i].semver.prerelease.length > 0) {
          const allowed = set3[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// ../sisventa/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports, module) => {
  var ANY = Symbol("SemVer ANY");

  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re[t3.COMPARATORLOOSE] : re[t3.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== undefined ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  module.exports = Comparator;
  var parseOptions = require_parse_options();
  var { safeRe: re, t: t3 } = require_re();
  var cmp = require_cmp();
  var debug = require_debug();
  var SemVer = require_semver();
  var Range = require_range();
});

// ../sisventa/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports, module) => {
  var Range = require_range();
  var satisfies = (version, range, options) => {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  };
  module.exports = satisfies;
});

// ../sisventa/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports, module) => {
  var Range = require_range();
  var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c3) => c3.value).join(" ").trim().split(" "));
  module.exports = toComparators;
});

// ../sisventa/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var maxSatisfying = (versions, range, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v3) => {
      if (rangeObj.test(v3)) {
        if (!max || maxSV.compare(v3) === -1) {
          max = v3;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  module.exports = maxSatisfying;
});

// ../sisventa/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var minSatisfying = (versions, range, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v3) => {
      if (rangeObj.test(v3)) {
        if (!min || minSV.compare(v3) === 1) {
          min = v3;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module.exports = minSatisfying;
});

// ../sisventa/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var gt = require_gt();
  var minVersion = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let setMin = null;
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module.exports = minVersion;
});

// ../sisventa/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports, module) => {
  var Range = require_range();
  var validRange = (range, options) => {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  module.exports = validRange;
});

// ../sisventa/node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var Range = require_range();
  var satisfies = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte = require_gte();
  var outside = (version, range, hilo, options) => {
    version = new SemVer(version, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module.exports = outside;
});

// ../sisventa/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports, module) => {
  var outside = require_outside();
  var gtr = (version, range, options) => outside(version, range, ">", options);
  module.exports = gtr;
});

// ../sisventa/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports, module) => {
  var outside = require_outside();
  var ltr = (version, range, options) => outside(version, range, "<", options);
  module.exports = ltr;
});

// ../sisventa/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports, module) => {
  var Range = require_range();
  var intersects = (r13, r2, options) => {
    r13 = new Range(r13, options);
    r2 = new Range(r2, options);
    return r13.intersects(r2, options);
  };
  module.exports = intersects;
});

// ../sisventa/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports, module) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module.exports = (versions, range, options) => {
    const set3 = [];
    let first = null;
    let prev = null;
    const v3 = versions.sort((a3, b3) => compare(a3, b3, options));
    for (const version of v3) {
      const included = satisfies(version, range, options);
      if (included) {
        prev = version;
        if (!first) {
          first = version;
        }
      } else {
        if (prev) {
          set3.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set3.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set3) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v3[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v3[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// ../sisventa/node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports, module) => {
  var Range = require_range();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
    return true;
  };
  var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  var minimumVersion = [new Comparator(">=0.0.0")];
  var simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = new Set;
    let gt, lt;
    for (const c3 of sub) {
      if (c3.operator === ">" || c3.operator === ">=") {
        gt = higherGT(gt, c3, options);
      } else if (c3.operator === "<" || c3.operator === "<=") {
        lt = lowerLT(lt, c3, options);
      } else {
        eqSet.add(c3.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }
      for (const c3 of dom) {
        if (!satisfies(eq, String(c3), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c3 of dom) {
      hasDomGT = hasDomGT || c3.operator === ">" || c3.operator === ">=";
      hasDomLT = hasDomLT || c3.operator === "<" || c3.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c3.semver.prerelease && c3.semver.prerelease.length && c3.semver.major === needDomGTPre.major && c3.semver.minor === needDomGTPre.minor && c3.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c3.operator === ">" || c3.operator === ">=") {
          higher = higherGT(gt, c3, options);
          if (higher === c3 && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c3), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c3.semver.prerelease && c3.semver.prerelease.length && c3.semver.major === needDomLTPre.major && c3.semver.minor === needDomLTPre.minor && c3.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c3.operator === "<" || c3.operator === "<=") {
          lower = lowerLT(lt, c3, options);
          if (lower === c3 && lower !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c3), options)) {
          return false;
        }
      }
      if (!c3.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  var higherGT = (a3, b3, options) => {
    if (!a3) {
      return b3;
    }
    const comp = compare(a3.semver, b3.semver, options);
    return comp > 0 ? a3 : comp < 0 ? b3 : b3.operator === ">" && a3.operator === ">=" ? b3 : a3;
  };
  var lowerLT = (a3, b3, options) => {
    if (!a3) {
      return b3;
    }
    const comp = compare(a3.semver, b3.semver, options);
    return comp < 0 ? a3 : comp > 0 ? b3 : b3.operator === "<" && a3.operator === "<=" ? b3 : a3;
  };
  module.exports = subset;
});

// ../sisventa/node_modules/semver/index.js
var require_semver2 = __commonJS((exports, module) => {
  var internalRe = require_re();
  var constants = require_constants();
  var SemVer = require_semver();
  var identifiers = require_identifiers();
  var parse7 = require_parse();
  var valid = require_valid();
  var clean5 = require_clean();
  var inc = require_inc();
  var diff = require_diff();
  var major = require_major();
  var minor = require_minor();
  var patch = require_patch();
  var prerelease = require_prerelease();
  var compare = require_compare();
  var rcompare = require_rcompare();
  var compareLoose = require_compare_loose();
  var compareBuild = require_compare_build();
  var sort = require_sort();
  var rsort = require_rsort();
  var gt = require_gt();
  var lt = require_lt();
  var eq = require_eq();
  var neq = require_neq();
  var gte = require_gte();
  var lte = require_lte();
  var cmp = require_cmp();
  var coerce = require_coerce();
  var Comparator = require_comparator();
  var Range = require_range();
  var satisfies = require_satisfies();
  var toComparators = require_to_comparators();
  var maxSatisfying = require_max_satisfying();
  var minSatisfying = require_min_satisfying();
  var minVersion = require_min_version();
  var validRange = require_valid2();
  var outside = require_outside();
  var gtr = require_gtr();
  var ltr = require_ltr();
  var intersects = require_intersects();
  var simplifyRange = require_simplify();
  var subset = require_subset();
  module.exports = {
    parse: parse7,
    valid,
    clean: clean5,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  };
});

// ../sisventa/node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS((exports, module) => {
  var semver = require_semver2();
  module.exports = semver.satisfies(process.version, ">=15.7.0");
});

// ../sisventa/node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS((exports, module) => {
  var semver = require_semver2();
  module.exports = semver.satisfies(process.version, ">=16.9.0");
});

// ../sisventa/node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS((exports, module) => {
  var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
  var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
  var allowedAlgorithmsForKeys = {
    ec: ["ES256", "ES384", "ES512"],
    rsa: ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
    "rsa-pss": ["PS256", "PS384", "PS512"]
  };
  var allowedCurves = {
    ES256: "prime256v1",
    ES384: "secp384r1",
    ES512: "secp521r1"
  };
  module.exports = function(algorithm, key) {
    if (!algorithm || !key)
      return;
    const keyType = key.asymmetricKeyType;
    if (!keyType)
      return;
    const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
    if (!allowedAlgorithms) {
      throw new Error(`Unknown key type "${keyType}".`);
    }
    if (!allowedAlgorithms.includes(algorithm)) {
      throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
    }
    if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
      switch (keyType) {
        case "ec":
          const keyCurve = key.asymmetricKeyDetails.namedCurve;
          const allowedCurve = allowedCurves[algorithm];
          if (keyCurve !== allowedCurve) {
            throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
          }
          break;
        case "rsa-pss":
          if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
            const length = parseInt(algorithm.slice(-3), 10);
            const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
            if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
              throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
            }
            if (saltLength !== undefined && saltLength > length >> 3) {
              throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
            }
          }
          break;
      }
    }
  };
});

// ../sisventa/node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS((exports, module) => {
  var semver = require_semver2();
  module.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
});

// ../sisventa/node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS((exports, module) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var NotBeforeError = require_NotBeforeError();
  var TokenExpiredError = require_TokenExpiredError();
  var decode3 = require_decode();
  var timespan = require_timespan();
  var validateAsymmetricKey = require_validateAsymmetricKey();
  var PS_SUPPORTED = require_psSupported();
  var jws = require_jws();
  var { KeyObject, createSecretKey, createPublicKey } = import.meta.require("crypto");
  var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
  var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
  var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
  var HS_ALGS = ["HS256", "HS384", "HS512"];
  if (PS_SUPPORTED) {
    PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
  }
  module.exports = function(jwtString, secretOrPublicKey, options, callback) {
    if (typeof options === "function" && !callback) {
      callback = options;
      options = {};
    }
    if (!options) {
      options = {};
    }
    options = Object.assign({}, options);
    let done;
    if (callback) {
      done = callback;
    } else {
      done = function(err, data) {
        if (err)
          throw err;
        return data;
      };
    }
    if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
      return done(new JsonWebTokenError("clockTimestamp must be a number"));
    }
    if (options.nonce !== undefined && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
      return done(new JsonWebTokenError("nonce must be a non-empty string"));
    }
    if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
      return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
    }
    const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);
    if (!jwtString) {
      return done(new JsonWebTokenError("jwt must be provided"));
    }
    if (typeof jwtString !== "string") {
      return done(new JsonWebTokenError("jwt must be a string"));
    }
    const parts = jwtString.split(".");
    if (parts.length !== 3) {
      return done(new JsonWebTokenError("jwt malformed"));
    }
    let decodedToken;
    try {
      decodedToken = decode3(jwtString, { complete: true });
    } catch (err) {
      return done(err);
    }
    if (!decodedToken) {
      return done(new JsonWebTokenError("invalid token"));
    }
    const header = decodedToken.header;
    let getSecret;
    if (typeof secretOrPublicKey === "function") {
      if (!callback) {
        return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
      }
      getSecret = secretOrPublicKey;
    } else {
      getSecret = function(header2, secretCallback) {
        return secretCallback(null, secretOrPublicKey);
      };
    }
    return getSecret(header, function(err, secretOrPublicKey2) {
      if (err) {
        return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
      }
      const hasSignature = parts[2].trim() !== "";
      if (!hasSignature && secretOrPublicKey2) {
        return done(new JsonWebTokenError("jwt signature is required"));
      }
      if (hasSignature && !secretOrPublicKey2) {
        return done(new JsonWebTokenError("secret or public key must be provided"));
      }
      if (!hasSignature && !options.algorithms) {
        return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
      }
      if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
        try {
          secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
        } catch (_) {
          try {
            secretOrPublicKey2 = createSecretKey(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
          } catch (_2) {
            return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
          }
        }
      }
      if (!options.algorithms) {
        if (secretOrPublicKey2.type === "secret") {
          options.algorithms = HS_ALGS;
        } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
          options.algorithms = RSA_KEY_ALGS;
        } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
          options.algorithms = EC_KEY_ALGS;
        } else {
          options.algorithms = PUB_KEY_ALGS;
        }
      }
      if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
        return done(new JsonWebTokenError("invalid algorithm"));
      }
      if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
        return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
        return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPublicKey2);
        } catch (e3) {
          return done(e3);
        }
      }
      let valid;
      try {
        valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
      } catch (e3) {
        return done(e3);
      }
      if (!valid) {
        return done(new JsonWebTokenError("invalid signature"));
      }
      const payload = decodedToken.payload;
      if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
        if (typeof payload.nbf !== "number") {
          return done(new JsonWebTokenError("invalid nbf value"));
        }
        if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
          return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1000)));
        }
      }
      if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
        if (typeof payload.exp !== "number") {
          return done(new JsonWebTokenError("invalid exp value"));
        }
        if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
          return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1000)));
        }
      }
      if (options.audience) {
        const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
        const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
        const match = target.some(function(targetAudience) {
          return audiences.some(function(audience) {
            return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
          });
        });
        if (!match) {
          return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
        }
      }
      if (options.issuer) {
        const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
        if (invalid_issuer) {
          return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
        }
      }
      if (options.subject) {
        if (payload.sub !== options.subject) {
          return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
        }
      }
      if (options.jwtid) {
        if (payload.jti !== options.jwtid) {
          return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
        }
      }
      if (options.nonce) {
        if (payload.nonce !== options.nonce) {
          return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
        }
      }
      if (options.maxAge) {
        if (typeof payload.iat !== "number") {
          return done(new JsonWebTokenError("iat required when maxAge is specified"));
        }
        const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
        if (typeof maxAgeTimestamp === "undefined") {
          return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
        if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
          return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1000)));
        }
      }
      if (options.complete === true) {
        const signature = decodedToken.signature;
        return done(null, {
          header,
          payload,
          signature
        });
      }
      return done(null, payload);
    });
  };
});

// ../sisventa/node_modules/lodash.includes/index.js
var require_lodash = __commonJS((exports, module) => {
  var arrayMap = function(array7, iteratee) {
    var index = -1, length = array7 ? array7.length : 0, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array7[index], index, array7);
    }
    return result;
  };
  var baseFindIndex = function(array7, predicate, fromIndex, fromRight) {
    var length = array7.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array7[index], index, array7)) {
        return index;
      }
    }
    return -1;
  };
  var baseIndexOf = function(array7, value27, fromIndex) {
    if (value27 !== value27) {
      return baseFindIndex(array7, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array7.length;
    while (++index < length) {
      if (array7[index] === value27) {
        return index;
      }
    }
    return -1;
  };
  var baseIsNaN = function(value27) {
    return value27 !== value27;
  };
  var baseTimes = function(n3, iteratee) {
    var index = -1, result = Array(n3);
    while (++index < n3) {
      result[index] = iteratee(index);
    }
    return result;
  };
  var baseValues = function(object23, props) {
    return arrayMap(props, function(key) {
      return object23[key];
    });
  };
  var overArg = function(func, transform9) {
    return function(arg) {
      return func(transform9(arg));
    };
  };
  var arrayLikeKeys = function(value27, inherited) {
    var result = isArray(value27) || isArguments(value27) ? baseTimes(value27.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value27) {
      if ((inherited || hasOwnProperty.call(value27, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  };
  var baseKeys = function(object23) {
    if (!isPrototype(object23)) {
      return nativeKeys(object23);
    }
    var result = [];
    for (var key in Object(object23)) {
      if (hasOwnProperty.call(object23, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  };
  var isIndex = function(value27, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value27 == "number" || reIsUint.test(value27)) && (value27 > -1 && value27 % 1 == 0 && value27 < length);
  };
  var isPrototype = function(value27) {
    var Ctor = value27 && value27.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value27 === proto;
  };
  var includes = function(collection, value27, fromIndex, guard39) {
    collection = isArrayLike(collection) ? collection : values(collection);
    fromIndex = fromIndex && !guard39 ? toInteger(fromIndex) : 0;
    var length = collection.length;
    if (fromIndex < 0) {
      fromIndex = nativeMax(length + fromIndex, 0);
    }
    return isString(collection) ? fromIndex <= length && collection.indexOf(value27, fromIndex) > -1 : !!length && baseIndexOf(collection, value27, fromIndex) > -1;
  };
  var isArguments = function(value27) {
    return isArrayLikeObject(value27) && hasOwnProperty.call(value27, "callee") && (!propertyIsEnumerable.call(value27, "callee") || objectToString.call(value27) == argsTag);
  };
  var isArrayLike = function(value27) {
    return value27 != null && isLength(value27.length) && !isFunction(value27);
  };
  var isArrayLikeObject = function(value27) {
    return isObjectLike(value27) && isArrayLike(value27);
  };
  var isFunction = function(value27) {
    var tag = isObject(value27) ? objectToString.call(value27) : "";
    return tag == funcTag || tag == genTag;
  };
  var isLength = function(value27) {
    return typeof value27 == "number" && value27 > -1 && value27 % 1 == 0 && value27 <= MAX_SAFE_INTEGER;
  };
  var isObject = function(value27) {
    var type145 = typeof value27;
    return !!value27 && (type145 == "object" || type145 == "function");
  };
  var isObjectLike = function(value27) {
    return !!value27 && typeof value27 == "object";
  };
  var isString = function(value27) {
    return typeof value27 == "string" || !isArray(value27) && isObjectLike(value27) && objectToString.call(value27) == stringTag;
  };
  var isSymbol = function(value27) {
    return typeof value27 == "symbol" || isObjectLike(value27) && objectToString.call(value27) == symbolTag;
  };
  var toFinite = function(value27) {
    if (!value27) {
      return value27 === 0 ? value27 : 0;
    }
    value27 = toNumber(value27);
    if (value27 === INFINITY || value27 === -INFINITY) {
      var sign = value27 < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value27 === value27 ? value27 : 0;
  };
  var toInteger = function(value27) {
    var result = toFinite(value27), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  };
  var toNumber = function(value27) {
    if (typeof value27 == "number") {
      return value27;
    }
    if (isSymbol(value27)) {
      return NAN;
    }
    if (isObject(value27)) {
      var other = typeof value27.valueOf == "function" ? value27.valueOf() : value27;
      value27 = isObject(other) ? other + "" : other;
    }
    if (typeof value27 != "string") {
      return value27 === 0 ? value27 : +value27;
    }
    value27 = value27.replace(reTrim, "");
    var isBinary = reIsBinary.test(value27);
    return isBinary || reIsOctal.test(value27) ? freeParseInt(value27.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value27) ? NAN : +value27;
  };
  var keys = function(object23) {
    return isArrayLike(object23) ? arrayLikeKeys(object23) : baseKeys(object23);
  };
  var values = function(object23) {
    return object23 ? baseValues(object23, keys(object23)) : [];
  };
  var INFINITY = 1 / 0;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  var NAN = 0 / 0;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var freeParseInt = parseInt;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeKeys = overArg(Object.keys, Object);
  var nativeMax = Math.max;
  var isArray = Array.isArray;
  module.exports = includes;
});

// ../sisventa/node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS((exports, module) => {
  var isBoolean = function(value27) {
    return value27 === true || value27 === false || isObjectLike(value27) && objectToString.call(value27) == boolTag;
  };
  var isObjectLike = function(value27) {
    return !!value27 && typeof value27 == "object";
  };
  var boolTag = "[object Boolean]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  module.exports = isBoolean;
});

// ../sisventa/node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS((exports, module) => {
  var isInteger = function(value27) {
    return typeof value27 == "number" && value27 == toInteger(value27);
  };
  var isObject = function(value27) {
    var type145 = typeof value27;
    return !!value27 && (type145 == "object" || type145 == "function");
  };
  var isObjectLike = function(value27) {
    return !!value27 && typeof value27 == "object";
  };
  var isSymbol = function(value27) {
    return typeof value27 == "symbol" || isObjectLike(value27) && objectToString.call(value27) == symbolTag;
  };
  var toFinite = function(value27) {
    if (!value27) {
      return value27 === 0 ? value27 : 0;
    }
    value27 = toNumber(value27);
    if (value27 === INFINITY || value27 === -INFINITY) {
      var sign = value27 < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value27 === value27 ? value27 : 0;
  };
  var toInteger = function(value27) {
    var result = toFinite(value27), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  };
  var toNumber = function(value27) {
    if (typeof value27 == "number") {
      return value27;
    }
    if (isSymbol(value27)) {
      return NAN;
    }
    if (isObject(value27)) {
      var other = typeof value27.valueOf == "function" ? value27.valueOf() : value27;
      value27 = isObject(other) ? other + "" : other;
    }
    if (typeof value27 != "string") {
      return value27 === 0 ? value27 : +value27;
    }
    value27 = value27.replace(reTrim, "");
    var isBinary = reIsBinary.test(value27);
    return isBinary || reIsOctal.test(value27) ? freeParseInt(value27.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value27) ? NAN : +value27;
  };
  var INFINITY = 1 / 0;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  module.exports = isInteger;
});

// ../sisventa/node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS((exports, module) => {
  var isObjectLike = function(value27) {
    return !!value27 && typeof value27 == "object";
  };
  var isNumber = function(value27) {
    return typeof value27 == "number" || isObjectLike(value27) && objectToString.call(value27) == numberTag;
  };
  var numberTag = "[object Number]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  module.exports = isNumber;
});

// ../sisventa/node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS((exports, module) => {
  var isHostObject = function(value27) {
    var result = false;
    if (value27 != null && typeof value27.toString != "function") {
      try {
        result = !!(value27 + "");
      } catch (e3) {
      }
    }
    return result;
  };
  var overArg = function(func, transform9) {
    return function(arg) {
      return func(transform9(arg));
    };
  };
  var isObjectLike = function(value27) {
    return !!value27 && typeof value27 == "object";
  };
  var isPlainObject = function(value27) {
    if (!isObjectLike(value27) || objectToString.call(value27) != objectTag || isHostObject(value27)) {
      return false;
    }
    var proto = getPrototype(value27);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  };
  var objectTag = "[object Object]";
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  var objectToString = objectProto.toString;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  module.exports = isPlainObject;
});

// ../sisventa/node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS((exports, module) => {
  var isObjectLike = function(value27) {
    return !!value27 && typeof value27 == "object";
  };
  var isString = function(value27) {
    return typeof value27 == "string" || !isArray(value27) && isObjectLike(value27) && objectToString.call(value27) == stringTag;
  };
  var stringTag = "[object String]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var isArray = Array.isArray;
  module.exports = isString;
});

// ../sisventa/node_modules/lodash.once/index.js
var require_lodash7 = __commonJS((exports, module) => {
  var before = function(n3, func) {
    var result;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    n3 = toInteger(n3);
    return function() {
      if (--n3 > 0) {
        result = func.apply(this, arguments);
      }
      if (n3 <= 1) {
        func = undefined;
      }
      return result;
    };
  };
  var once = function(func) {
    return before(2, func);
  };
  var isObject = function(value27) {
    var type145 = typeof value27;
    return !!value27 && (type145 == "object" || type145 == "function");
  };
  var isObjectLike = function(value27) {
    return !!value27 && typeof value27 == "object";
  };
  var isSymbol = function(value27) {
    return typeof value27 == "symbol" || isObjectLike(value27) && objectToString.call(value27) == symbolTag;
  };
  var toFinite = function(value27) {
    if (!value27) {
      return value27 === 0 ? value27 : 0;
    }
    value27 = toNumber(value27);
    if (value27 === INFINITY || value27 === -INFINITY) {
      var sign = value27 < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value27 === value27 ? value27 : 0;
  };
  var toInteger = function(value27) {
    var result = toFinite(value27), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  };
  var toNumber = function(value27) {
    if (typeof value27 == "number") {
      return value27;
    }
    if (isSymbol(value27)) {
      return NAN;
    }
    if (isObject(value27)) {
      var other = typeof value27.valueOf == "function" ? value27.valueOf() : value27;
      value27 = isObject(other) ? other + "" : other;
    }
    if (typeof value27 != "string") {
      return value27 === 0 ? value27 : +value27;
    }
    value27 = value27.replace(reTrim, "");
    var isBinary = reIsBinary.test(value27);
    return isBinary || reIsOctal.test(value27) ? freeParseInt(value27.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value27) ? NAN : +value27;
  };
  var FUNC_ERROR_TEXT = "Expected a function";
  var INFINITY = 1 / 0;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  module.exports = once;
});

// ../sisventa/node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS((exports, module) => {
  var validate = function(schema, allowUnknown, object23, parameterName) {
    if (!isPlainObject(object23)) {
      throw new Error('Expected "' + parameterName + '" to be a plain object.');
    }
    Object.keys(object23).forEach(function(key) {
      const validator = schema[key];
      if (!validator) {
        if (!allowUnknown) {
          throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
        }
        return;
      }
      if (!validator.isValid(object23[key])) {
        throw new Error(validator.message);
      }
    });
  };
  var validateOptions = function(options) {
    return validate(sign_options_schema, false, options, "options");
  };
  var validatePayload = function(payload) {
    return validate(registered_claims_schema, true, payload, "payload");
  };
  var timespan = require_timespan();
  var PS_SUPPORTED = require_psSupported();
  var validateAsymmetricKey = require_validateAsymmetricKey();
  var jws = require_jws();
  var includes = require_lodash();
  var isBoolean = require_lodash2();
  var isInteger = require_lodash3();
  var isNumber = require_lodash4();
  var isPlainObject = require_lodash5();
  var isString = require_lodash6();
  var once = require_lodash7();
  var { KeyObject, createSecretKey, createPrivateKey } = import.meta.require("crypto");
  var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
  if (PS_SUPPORTED) {
    SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
  }
  var sign_options_schema = {
    expiresIn: { isValid: function(value27) {
      return isInteger(value27) || isString(value27) && value27;
    }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
    notBefore: { isValid: function(value27) {
      return isInteger(value27) || isString(value27) && value27;
    }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
    audience: { isValid: function(value27) {
      return isString(value27) || Array.isArray(value27);
    }, message: '"audience" must be a string or array' },
    algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
    header: { isValid: isPlainObject, message: '"header" must be an object' },
    encoding: { isValid: isString, message: '"encoding" must be a string' },
    issuer: { isValid: isString, message: '"issuer" must be a string' },
    subject: { isValid: isString, message: '"subject" must be a string' },
    jwtid: { isValid: isString, message: '"jwtid" must be a string' },
    noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
    keyid: { isValid: isString, message: '"keyid" must be a string' },
    mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
    allowInsecureKeySizes: { isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean' },
    allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
  };
  var registered_claims_schema = {
    iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
    exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
    nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
  };
  var options_to_payload = {
    audience: "aud",
    issuer: "iss",
    subject: "sub",
    jwtid: "jti"
  };
  var options_for_objects = [
    "expiresIn",
    "notBefore",
    "noTimestamp",
    "audience",
    "issuer",
    "subject",
    "jwtid"
  ];
  module.exports = function(payload, secretOrPrivateKey, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else {
      options = options || {};
    }
    const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
    const header = Object.assign({
      alg: options.algorithm || "HS256",
      typ: isObjectPayload ? "JWT" : undefined,
      kid: options.keyid
    }, options.header);
    function failure(err) {
      if (callback) {
        return callback(err);
      }
      throw err;
    }
    if (!secretOrPrivateKey && options.algorithm !== "none") {
      return failure(new Error("secretOrPrivateKey must have a value"));
    }
    if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
      try {
        secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
      } catch (_) {
        try {
          secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
        } catch (_2) {
          return failure(new Error("secretOrPrivateKey is not valid key material"));
        }
      }
    }
    if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
      return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
    } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
      if (secretOrPrivateKey.type !== "private") {
        return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
      }
      if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== undefined && secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
        return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
      }
    }
    if (typeof payload === "undefined") {
      return failure(new Error("payload is required"));
    } else if (isObjectPayload) {
      try {
        validatePayload(payload);
      } catch (error41) {
        return failure(error41);
      }
      if (!options.mutatePayload) {
        payload = Object.assign({}, payload);
      }
    } else {
      const invalid_options = options_for_objects.filter(function(opt) {
        return typeof options[opt] !== "undefined";
      });
      if (invalid_options.length > 0) {
        return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
      }
    }
    if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
      return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
    }
    if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
      return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
    }
    try {
      validateOptions(options);
    } catch (error41) {
      return failure(error41);
    }
    if (!options.allowInvalidAsymmetricKeyTypes) {
      try {
        validateAsymmetricKey(header.alg, secretOrPrivateKey);
      } catch (error41) {
        return failure(error41);
      }
    }
    const timestamp = payload.iat || Math.floor(Date.now() / 1000);
    if (options.noTimestamp) {
      delete payload.iat;
    } else if (isObjectPayload) {
      payload.iat = timestamp;
    }
    if (typeof options.notBefore !== "undefined") {
      try {
        payload.nbf = timespan(options.notBefore, timestamp);
      } catch (err) {
        return failure(err);
      }
      if (typeof payload.nbf === "undefined") {
        return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
    }
    if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
      try {
        payload.exp = timespan(options.expiresIn, timestamp);
      } catch (err) {
        return failure(err);
      }
      if (typeof payload.exp === "undefined") {
        return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
    }
    Object.keys(options_to_payload).forEach(function(key) {
      const claim = options_to_payload[key];
      if (typeof options[key] !== "undefined") {
        if (typeof payload[claim] !== "undefined") {
          return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
        }
        payload[claim] = options[key];
      }
    });
    const encoding = options.encoding || "utf8";
    if (typeof callback === "function") {
      callback = callback && once(callback);
      jws.createSign({
        header,
        privateKey: secretOrPrivateKey,
        payload,
        encoding
      }).once("error", callback).once("done", function(signature) {
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
        callback(null, signature);
      });
    } else {
      let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
      if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
        throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
      }
      return signature;
    }
  };
});

// ../sisventa/node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS((exports, module) => {
  module.exports = {
    decode: require_decode(),
    verify: require_verify(),
    sign: require_sign(),
    JsonWebTokenError: require_JsonWebTokenError(),
    NotBeforeError: require_NotBeforeError(),
    TokenExpiredError: require_TokenExpiredError()
  };
});

// ../sisventa/node_modules/react/cjs/react.development.js
var require_react_development = __commonJS((exports, module) => {
  if (true) {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);
      }
      var ReactVersion = "18.2.0";
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactCurrentDispatcher = {
        current: null
      };
      var ReactCurrentBatchConfig = {
        transition: null
      };
      var ReactCurrentActQueue = {
        current: null,
        isBatchingLegacy: false,
        didScheduleLegacyUpdate: false
      };
      var ReactCurrentOwner = {
        current: null
      };
      var ReactDebugCurrentFrame = {};
      var currentExtraStackFrame = null;
      function setExtraStackFrame(stack) {
        {
          currentExtraStackFrame = stack;
        }
      }
      {
        ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
          {
            currentExtraStackFrame = stack;
          }
        };
        ReactDebugCurrentFrame.getCurrentStack = null;
        ReactDebugCurrentFrame.getStackAddendum = function() {
          var stack = "";
          if (currentExtraStackFrame) {
            stack += currentExtraStackFrame;
          }
          var impl = ReactDebugCurrentFrame.getCurrentStack;
          if (impl) {
            stack += impl() || "";
          }
          return stack;
        };
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var ReactSharedInternals = {
        ReactCurrentDispatcher,
        ReactCurrentBatchConfig,
        ReactCurrentOwner
      };
      {
        ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
        ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
      }
      function warn(format) {
        {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
      }
      function error41(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var didWarnStateUpdateForUnmountedComponent = {};
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor;
          var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
          var warningKey = componentName + "." + callerName;
          if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
            return;
          }
          error41("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
          didWarnStateUpdateForUnmountedComponent[warningKey] = true;
        }
      }
      var ReactNoopUpdateQueue = {
        isMounted: function(publicInstance) {
          return false;
        },
        enqueueForceUpdate: function(publicInstance, callback, callerName) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function(publicInstance, partialState, callback, callerName) {
          warnNoop(publicInstance, "setState");
        }
      };
      var assign = Object.assign;
      var emptyObject = {};
      {
        Object.freeze(emptyObject);
      }
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        }
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      {
        var deprecatedAPIs = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        };
        var defineDeprecationWarning = function(methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function() {
              warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
              return;
            }
          });
        };
        for (var fnName in deprecatedAPIs) {
          if (deprecatedAPIs.hasOwnProperty(fnName)) {
            defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
          }
        }
      }
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component.prototype;
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy;
      pureComponentPrototype.constructor = PureComponent;
      assign(pureComponentPrototype, Component.prototype);
      pureComponentPrototype.isPureReactComponent = true;
      function createRef() {
        var refObject = {
          current: null
        };
        {
          Object.seal(refObject);
        }
        return refObject;
      }
      var isArrayImpl = Array.isArray;
      function isArray(a3) {
        return isArrayImpl(a3);
      }
      function typeName(value27) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type145 = hasToStringTag && value27[Symbol.toStringTag] || value27.constructor.name || "Object";
          return type145;
        }
      }
      function willCoercionThrow(value27) {
        {
          try {
            testStringCoercion(value27);
            return false;
          } catch (e3) {
            return true;
          }
        }
      }
      function testStringCoercion(value27) {
        return "" + value27;
      }
      function checkKeyStringCoercion(value27) {
        {
          if (willCoercionThrow(value27)) {
            error41("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value27));
            return testStringCoercion(value27);
          }
        }
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type145) {
        return type145.displayName || "Context";
      }
      function getComponentNameFromType(type145) {
        if (type145 == null) {
          return null;
        }
        {
          if (typeof type145.tag === "number") {
            error41("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type145 === "function") {
          return type145.displayName || type145.name || null;
        }
        if (typeof type145 === "string") {
          return type145;
        }
        switch (type145) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type145 === "object") {
          switch (type145.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type145;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type145;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type145, type145.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type145.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type145.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type145;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
      {
        didWarnAboutStringRefs = {};
      }
      function hasValidRef(config2) {
        {
          if (hasOwnProperty.call(config2, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config2.ref !== undefined;
      }
      function hasValidKey(config2) {
        {
          if (hasOwnProperty.call(config2, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config2.key !== undefined;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function() {
          {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error41("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          }
        };
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function() {
          {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error41("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          }
        };
        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, "ref", {
          get: warnAboutAccessingRef,
          configurable: true
        });
      }
      function warnIfStringRefCannotBeAutoConverted(config2) {
        {
          if (typeof config2.ref === "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
              error41('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref);
              didWarnAboutStringRefs[componentName] = true;
            }
          }
        }
      }
      var ReactElement = function(type145, key, ref5, self2, source, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type: type145,
          key,
          ref: ref5,
          props,
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self2
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function createElement(type145, config2, children) {
        var propName;
        var props = {};
        var key = null;
        var ref5 = null;
        var self2 = null;
        var source = null;
        if (config2 != null) {
          if (hasValidRef(config2)) {
            ref5 = config2.ref;
            {
              warnIfStringRefCannotBeAutoConverted(config2);
            }
          }
          if (hasValidKey(config2)) {
            {
              checkKeyStringCoercion(config2.key);
            }
            key = "" + config2.key;
          }
          self2 = config2.__self === undefined ? null : config2.__self;
          source = config2.__source === undefined ? null : config2.__source;
          for (propName in config2) {
            if (hasOwnProperty.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config2[propName];
            }
          }
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);
          for (var i = 0;i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }
          {
            if (Object.freeze) {
              Object.freeze(childArray);
            }
          }
          props.children = childArray;
        }
        if (type145 && type145.defaultProps) {
          var defaultProps = type145.defaultProps;
          for (propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
        }
        {
          if (key || ref5) {
            var displayName = typeof type145 === "function" ? type145.displayName || type145.name || "Unknown" : type145;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref5) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
        return ReactElement(type145, key, ref5, self2, source, ReactCurrentOwner.current, props);
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
        return newElement;
      }
      function cloneElement(element, config2, children) {
        if (element === null || element === undefined) {
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
        }
        var propName;
        var props = assign({}, element.props);
        var key = element.key;
        var ref5 = element.ref;
        var self2 = element._self;
        var source = element._source;
        var owner = element._owner;
        if (config2 != null) {
          if (hasValidRef(config2)) {
            ref5 = config2.ref;
            owner = ReactCurrentOwner.current;
          }
          if (hasValidKey(config2)) {
            {
              checkKeyStringCoercion(config2.key);
            }
            key = "" + config2.key;
          }
          var defaultProps;
          if (element.type && element.type.defaultProps) {
            defaultProps = element.type.defaultProps;
          }
          for (propName in config2) {
            if (hasOwnProperty.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              if (config2[propName] === undefined && defaultProps !== undefined) {
                props[propName] = defaultProps[propName];
              } else {
                props[propName] = config2[propName];
              }
            }
          }
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);
          for (var i = 0;i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }
          props.children = childArray;
        }
        return ReactElement(element.type, key, ref5, self2, source, owner, props);
      }
      function isValidElement(object23) {
        return typeof object23 === "object" && object23 !== null && object23.$$typeof === REACT_ELEMENT_TYPE;
      }
      var SEPARATOR = ".";
      var SUBSEPARATOR = ":";
      function escape(key) {
        var escapeRegex = /[=:]/g;
        var escaperLookup = {
          "=": "=0",
          ":": "=2"
        };
        var escapedString = key.replace(escapeRegex, function(match) {
          return escaperLookup[match];
        });
        return "$" + escapedString;
      }
      var didWarnAboutMaps = false;
      var userProvidedKeyEscapeRegex = /\/+/g;
      function escapeUserProvidedKey(text) {
        return text.replace(userProvidedKeyEscapeRegex, "$&/");
      }
      function getElementKey(element, index) {
        if (typeof element === "object" && element !== null && element.key != null) {
          {
            checkKeyStringCoercion(element.key);
          }
          return escape("" + element.key);
        }
        return index.toString(36);
      }
      function mapIntoArray(children, array7, escapedPrefix, nameSoFar, callback) {
        var type145 = typeof children;
        if (type145 === "undefined" || type145 === "boolean") {
          children = null;
        }
        var invokeCallback = false;
        if (children === null) {
          invokeCallback = true;
        } else {
          switch (type145) {
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
              }
          }
        }
        if (invokeCallback) {
          var _child = children;
          var mappedChild = callback(_child);
          var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
          if (isArray(mappedChild)) {
            var escapedChildKey = "";
            if (childKey != null) {
              escapedChildKey = escapeUserProvidedKey(childKey) + "/";
            }
            mapIntoArray(mappedChild, array7, escapedChildKey, "", function(c3) {
              return c3;
            });
          } else if (mappedChild != null) {
            if (isValidElement(mappedChild)) {
              {
                if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                  checkKeyStringCoercion(mappedChild.key);
                }
              }
              mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
            }
            array7.push(mappedChild);
          }
          return 1;
        }
        var child;
        var nextName;
        var subtreeCount = 0;
        var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
        if (isArray(children)) {
          for (var i = 0;i < children.length; i++) {
            child = children[i];
            nextName = nextNamePrefix + getElementKey(child, i);
            subtreeCount += mapIntoArray(child, array7, escapedPrefix, nextName, callback);
          }
        } else {
          var iteratorFn = getIteratorFn(children);
          if (typeof iteratorFn === "function") {
            var iterableChildren = children;
            {
              if (iteratorFn === iterableChildren.entries) {
                if (!didWarnAboutMaps) {
                  warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                }
                didWarnAboutMaps = true;
              }
            }
            var iterator7 = iteratorFn.call(iterableChildren);
            var step;
            var ii = 0;
            while (!(step = iterator7.next()).done) {
              child = step.value;
              nextName = nextNamePrefix + getElementKey(child, ii++);
              subtreeCount += mapIntoArray(child, array7, escapedPrefix, nextName, callback);
            }
          } else if (type145 === "object") {
            var childrenString = String(children);
            throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return subtreeCount;
      }
      function mapChildren(children, func, context) {
        if (children == null) {
          return children;
        }
        var result = [];
        var count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function countChildren(children) {
        var n3 = 0;
        mapChildren(children, function() {
          n3++;
        });
        return n3;
      }
      function forEachChildren(children, forEachFunc, forEachContext) {
        mapChildren(children, function() {
          forEachFunc.apply(this, arguments);
        }, forEachContext);
      }
      function toArray(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      }
      function onlyChild(children) {
        if (!isValidElement(children)) {
          throw new Error("React.Children.only expected to receive a single React element child.");
        }
        return children;
      }
      function createContext(defaultValue) {
        var context = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
          _defaultValue: null,
          _globalName: null
        };
        context.Provider = {
          $$typeof: REACT_PROVIDER_TYPE,
          _context: context
        };
        var hasWarnedAboutUsingNestedContextConsumers = false;
        var hasWarnedAboutUsingConsumerProvider = false;
        var hasWarnedAboutDisplayNameOnConsumer = false;
        {
          var Consumer = {
            $$typeof: REACT_CONTEXT_TYPE,
            _context: context
          };
          Object.defineProperties(Consumer, {
            Provider: {
              get: function() {
                if (!hasWarnedAboutUsingConsumerProvider) {
                  hasWarnedAboutUsingConsumerProvider = true;
                  error41("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                }
                return context.Provider;
              },
              set: function(_Provider) {
                context.Provider = _Provider;
              }
            },
            _currentValue: {
              get: function() {
                return context._currentValue;
              },
              set: function(_currentValue) {
                context._currentValue = _currentValue;
              }
            },
            _currentValue2: {
              get: function() {
                return context._currentValue2;
              },
              set: function(_currentValue2) {
                context._currentValue2 = _currentValue2;
              }
            },
            _threadCount: {
              get: function() {
                return context._threadCount;
              },
              set: function(_threadCount) {
                context._threadCount = _threadCount;
              }
            },
            Consumer: {
              get: function() {
                if (!hasWarnedAboutUsingNestedContextConsumers) {
                  hasWarnedAboutUsingNestedContextConsumers = true;
                  error41("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
                return context.Consumer;
              }
            },
            displayName: {
              get: function() {
                return context.displayName;
              },
              set: function(displayName) {
                if (!hasWarnedAboutDisplayNameOnConsumer) {
                  warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                  hasWarnedAboutDisplayNameOnConsumer = true;
                }
              }
            }
          });
          context.Consumer = Consumer;
        }
        {
          context._currentRenderer = null;
          context._currentRenderer2 = null;
        }
        return context;
      }
      var Uninitialized = -1;
      var Pending = 0;
      var Resolved = 1;
      var Rejected = 2;
      function lazyInitializer(payload) {
        if (payload._status === Uninitialized) {
          var ctor = payload._result;
          var thenable = ctor();
          thenable.then(function(moduleObject2) {
            if (payload._status === Pending || payload._status === Uninitialized) {
              var resolved = payload;
              resolved._status = Resolved;
              resolved._result = moduleObject2;
            }
          }, function(error42) {
            if (payload._status === Pending || payload._status === Uninitialized) {
              var rejected = payload;
              rejected._status = Rejected;
              rejected._result = error42;
            }
          });
          if (payload._status === Uninitialized) {
            var pending = payload;
            pending._status = Pending;
            pending._result = thenable;
          }
        }
        if (payload._status === Resolved) {
          var moduleObject = payload._result;
          {
            if (moduleObject === undefined) {
              error41("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
            }
          }
          {
            if (!("default" in moduleObject)) {
              error41("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
            }
          }
          return moduleObject.default;
        } else {
          throw payload._result;
        }
      }
      function lazy(ctor) {
        var payload = {
          _status: Uninitialized,
          _result: ctor
        };
        var lazyType = {
          $$typeof: REACT_LAZY_TYPE,
          _payload: payload,
          _init: lazyInitializer
        };
        {
          var defaultProps;
          var propTypes;
          Object.defineProperties(lazyType, {
            defaultProps: {
              configurable: true,
              get: function() {
                return defaultProps;
              },
              set: function(newDefaultProps) {
                error41("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                defaultProps = newDefaultProps;
                Object.defineProperty(lazyType, "defaultProps", {
                  enumerable: true
                });
              }
            },
            propTypes: {
              configurable: true,
              get: function() {
                return propTypes;
              },
              set: function(newPropTypes) {
                error41("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                propTypes = newPropTypes;
                Object.defineProperty(lazyType, "propTypes", {
                  enumerable: true
                });
              }
            }
          });
        }
        return lazyType;
      }
      function forwardRef(render) {
        {
          if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
            error41("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
          } else if (typeof render !== "function") {
            error41("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
          } else {
            if (render.length !== 0 && render.length !== 2) {
              error41("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
            }
          }
          if (render != null) {
            if (render.defaultProps != null || render.propTypes != null) {
              error41("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
            }
          }
        }
        var elementType = {
          $$typeof: REACT_FORWARD_REF_TYPE,
          render
        };
        {
          var ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              if (!render.name && !render.displayName) {
                render.displayName = name;
              }
            }
          });
        }
        return elementType;
      }
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type145) {
        if (typeof type145 === "string" || typeof type145 === "function") {
          return true;
        }
        if (type145 === REACT_FRAGMENT_TYPE || type145 === REACT_PROFILER_TYPE || enableDebugTracing || type145 === REACT_STRICT_MODE_TYPE || type145 === REACT_SUSPENSE_TYPE || type145 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type145 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type145 === "object" && type145 !== null) {
          if (type145.$$typeof === REACT_LAZY_TYPE || type145.$$typeof === REACT_MEMO_TYPE || type145.$$typeof === REACT_PROVIDER_TYPE || type145.$$typeof === REACT_CONTEXT_TYPE || type145.$$typeof === REACT_FORWARD_REF_TYPE || type145.$$typeof === REACT_MODULE_REFERENCE || type145.getModuleId !== undefined) {
            return true;
          }
        }
        return false;
      }
      function memo(type145, compare) {
        {
          if (!isValidElementType(type145)) {
            error41("memo: The first argument must be a component. Instead received: %s", type145 === null ? "null" : typeof type145);
          }
        }
        var elementType = {
          $$typeof: REACT_MEMO_TYPE,
          type: type145,
          compare: compare === undefined ? null : compare
        };
        {
          var ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              if (!type145.name && !type145.displayName) {
                type145.displayName = name;
              }
            }
          });
        }
        return elementType;
      }
      function resolveDispatcher() {
        var dispatcher = ReactCurrentDispatcher.current;
        {
          if (dispatcher === null) {
            error41("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
        }
        return dispatcher;
      }
      function useContext(Context) {
        var dispatcher = resolveDispatcher();
        {
          if (Context._context !== undefined) {
            var realContext = Context._context;
            if (realContext.Consumer === Context) {
              error41("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
            } else if (realContext.Provider === Context) {
              error41("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
            }
          }
        }
        return dispatcher.useContext(Context);
      }
      function useState(initialState) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useState(initialState);
      }
      function useReducer(reducer, initialArg, init) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useReducer(reducer, initialArg, init);
      }
      function useRef(initialValue) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useRef(initialValue);
      }
      function useEffect(create7, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useEffect(create7, deps);
      }
      function useInsertionEffect(create7, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useInsertionEffect(create7, deps);
      }
      function useLayoutEffect(create7, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useLayoutEffect(create7, deps);
      }
      function useCallback(callback, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useCallback(callback, deps);
      }
      function useMemo(create7, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useMemo(create7, deps);
      }
      function useImperativeHandle(ref5, create7, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useImperativeHandle(ref5, create7, deps);
      }
      function useDebugValue(value27, formatterFn) {
        {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDebugValue(value27, formatterFn);
        }
      }
      function useTransition() {
        var dispatcher = resolveDispatcher();
        return dispatcher.useTransition();
      }
      function useDeferredValue(value27) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useDeferredValue(value27);
      }
      function useId() {
        var dispatcher = resolveDispatcher();
        return dispatcher.useId();
      }
      function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      }
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error41("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap;
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== undefined) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s3 = sampleLines.length - 1;
            var c3 = controlLines.length - 1;
            while (s3 >= 1 && c3 >= 0 && sampleLines[s3] !== controlLines[c3]) {
              c3--;
            }
            for (;s3 >= 1 && c3 >= 0; s3--, c3--) {
              if (sampleLines[s3] !== controlLines[c3]) {
                if (s3 !== 1 || c3 !== 1) {
                  do {
                    s3--;
                    c3--;
                    if (c3 < 0 || sampleLines[s3] !== controlLines[c3]) {
                      var _frame = "\n" + sampleLines[s3].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s3 >= 1 && c3 >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher$1.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component2) {
        var prototype = Component2.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type145, source, ownerFn) {
        if (type145 == null) {
          return "";
        }
        if (typeof type145 === "function") {
          {
            return describeNativeComponentFrame(type145, shouldConstruct(type145));
          }
        }
        if (typeof type145 === "string") {
          return describeBuiltInComponentFrame(type145);
        }
        switch (type145) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type145 === "object") {
          switch (type145.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type145.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type145.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type145;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has3 = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has3(typeSpecs, typeSpecName)) {
              var error$1 = undefined;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error41("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error41("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            setExtraStackFrame(stack);
          } else {
            setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner.current) {
          var name = getComponentNameFromType(ReactCurrentOwner.current.type);
          if (name) {
            return "\n\nCheck the render method of `" + name + "`.";
          }
        }
        return "";
      }
      function getSourceInfoErrorAddendum(source) {
        if (source !== undefined) {
          var fileName = source.fileName.replace(/^.*[\\\/]/, "");
          var lineNumber = source.lineNumber;
          return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
        }
        return "";
      }
      function getSourceInfoErrorAddendumForProps(elementProps) {
        if (elementProps !== null && elementProps !== undefined) {
          return getSourceInfoErrorAddendum(elementProps.__source);
        }
        return "";
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();
        if (!info) {
          var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
          if (parentName) {
            info = "\n\nCheck the top-level render call using <" + parentName + ">.";
          }
        }
        return info;
      }
      function validateExplicitKey(element, parentType) {
        if (!element._store || element._store.validated || element.key != null) {
          return;
        }
        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
          return;
        }
        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
        var childOwner = "";
        if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
          childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
        }
        {
          setCurrentlyValidatingElement$1(element);
          error41('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        if (typeof node !== "object") {
          return;
        }
        if (isArray(node)) {
          for (var i = 0;i < node.length; i++) {
            var child = node[i];
            if (isValidElement(child)) {
              validateExplicitKey(child, parentType);
            }
          }
        } else if (isValidElement(node)) {
          if (node._store) {
            node._store.validated = true;
          }
        } else if (node) {
          var iteratorFn = getIteratorFn(node);
          if (typeof iteratorFn === "function") {
            if (iteratorFn !== node.entries) {
              var iterator7 = iteratorFn.call(node);
              var step;
              while (!(step = iterator7.next()).done) {
                if (isValidElement(step.value)) {
                  validateExplicitKey(step.value, parentType);
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type145 = element.type;
          if (type145 === null || type145 === undefined || typeof type145 === "string") {
            return;
          }
          var propTypes;
          if (typeof type145 === "function") {
            propTypes = type145.propTypes;
          } else if (typeof type145 === "object" && (type145.$$typeof === REACT_FORWARD_REF_TYPE || type145.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type145.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name = getComponentNameFromType(type145);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type145.PropTypes !== undefined && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type145);
            error41("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type145.getDefaultProps === "function" && !type145.getDefaultProps.isReactClassApproved) {
            error41("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment) {
        {
          var keys = Object.keys(fragment.props);
          for (var i = 0;i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment);
              error41("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error41("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      function createElementWithValidation(type145, props, children) {
        var validType = isValidElementType(type145);
        if (!validType) {
          var info = "";
          if (type145 === undefined || typeof type145 === "object" && type145 !== null && Object.keys(type145).length === 0) {
            info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          }
          var sourceInfo = getSourceInfoErrorAddendumForProps(props);
          if (sourceInfo) {
            info += sourceInfo;
          } else {
            info += getDeclarationErrorAddendum();
          }
          var typeString;
          if (type145 === null) {
            typeString = "null";
          } else if (isArray(type145)) {
            typeString = "array";
          } else if (type145 !== undefined && type145.$$typeof === REACT_ELEMENT_TYPE) {
            typeString = "<" + (getComponentNameFromType(type145.type) || "Unknown") + " />";
            info = " Did you accidentally export a JSX literal instead of a component?";
          } else {
            typeString = typeof type145;
          }
          {
            error41("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
        }
        var element = createElement.apply(this, arguments);
        if (element == null) {
          return element;
        }
        if (validType) {
          for (var i = 2;i < arguments.length; i++) {
            validateChildKeys(arguments[i], type145);
          }
        }
        if (type145 === REACT_FRAGMENT_TYPE) {
          validateFragmentProps(element);
        } else {
          validatePropTypes(element);
        }
        return element;
      }
      var didWarnAboutDeprecatedCreateFactory = false;
      function createFactoryWithValidation(type145) {
        var validatedFactory = createElementWithValidation.bind(null, type145);
        validatedFactory.type = type145;
        {
          if (!didWarnAboutDeprecatedCreateFactory) {
            didWarnAboutDeprecatedCreateFactory = true;
            warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
          }
          Object.defineProperty(validatedFactory, "type", {
            enumerable: false,
            get: function() {
              warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
              Object.defineProperty(this, "type", {
                value: type145
              });
              return type145;
            }
          });
        }
        return validatedFactory;
      }
      function cloneElementWithValidation(element, props, children) {
        var newElement = cloneElement.apply(this, arguments);
        for (var i = 2;i < arguments.length; i++) {
          validateChildKeys(arguments[i], newElement.type);
        }
        validatePropTypes(newElement);
        return newElement;
      }
      function startTransition(scope, options) {
        var prevTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition = {};
        var currentTransition = ReactCurrentBatchConfig.transition;
        {
          ReactCurrentBatchConfig.transition._updatedFibers = new Set;
        }
        try {
          scope();
        } finally {
          ReactCurrentBatchConfig.transition = prevTransition;
          {
            if (prevTransition === null && currentTransition._updatedFibers) {
              var updatedFibersCount = currentTransition._updatedFibers.size;
              if (updatedFibersCount > 10) {
                warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
              }
              currentTransition._updatedFibers.clear();
            }
          }
        }
      }
      var didWarnAboutMessageChannel = false;
      var enqueueTaskImpl = null;
      function enqueueTask(task) {
        if (enqueueTaskImpl === null) {
          try {
            var requireString = ("require" + Math.random()).slice(0, 7);
            var nodeRequire = module && module[requireString];
            enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
          } catch (_err) {
            enqueueTaskImpl = function(callback) {
              {
                if (didWarnAboutMessageChannel === false) {
                  didWarnAboutMessageChannel = true;
                  if (typeof MessageChannel === "undefined") {
                    error41("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                  }
                }
              }
              var channel = new MessageChannel;
              channel.port1.onmessage = callback;
              channel.port2.postMessage(undefined);
            };
          }
        }
        return enqueueTaskImpl(task);
      }
      var actScopeDepth = 0;
      var didWarnNoAwaitAct = false;
      function act(callback) {
        {
          var prevActScopeDepth = actScopeDepth;
          actScopeDepth++;
          if (ReactCurrentActQueue.current === null) {
            ReactCurrentActQueue.current = [];
          }
          var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
          var result;
          try {
            ReactCurrentActQueue.isBatchingLegacy = true;
            result = callback();
            if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
              var queue = ReactCurrentActQueue.current;
              if (queue !== null) {
                ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                flushActQueue(queue);
              }
            }
          } catch (error42) {
            popActScope(prevActScopeDepth);
            throw error42;
          } finally {
            ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
          }
          if (result !== null && typeof result === "object" && typeof result.then === "function") {
            var thenableResult = result;
            var wasAwaited = false;
            var thenable = {
              then: function(resolve, reject) {
                wasAwaited = true;
                thenableResult.then(function(returnValue2) {
                  popActScope(prevActScopeDepth);
                  if (actScopeDepth === 0) {
                    recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                  } else {
                    resolve(returnValue2);
                  }
                }, function(error42) {
                  popActScope(prevActScopeDepth);
                  reject(error42);
                });
              }
            };
            {
              if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                Promise.resolve().then(function() {
                }).then(function() {
                  if (!wasAwaited) {
                    didWarnNoAwaitAct = true;
                    error41("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                  }
                });
              }
            }
            return thenable;
          } else {
            var returnValue = result;
            popActScope(prevActScopeDepth);
            if (actScopeDepth === 0) {
              var _queue = ReactCurrentActQueue.current;
              if (_queue !== null) {
                flushActQueue(_queue);
                ReactCurrentActQueue.current = null;
              }
              var _thenable = {
                then: function(resolve, reject) {
                  if (ReactCurrentActQueue.current === null) {
                    ReactCurrentActQueue.current = [];
                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  } else {
                    resolve(returnValue);
                  }
                }
              };
              return _thenable;
            } else {
              var _thenable2 = {
                then: function(resolve, reject) {
                  resolve(returnValue);
                }
              };
              return _thenable2;
            }
          }
        }
      }
      function popActScope(prevActScopeDepth) {
        {
          if (prevActScopeDepth !== actScopeDepth - 1) {
            error41("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
          }
          actScopeDepth = prevActScopeDepth;
        }
      }
      function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        {
          var queue = ReactCurrentActQueue.current;
          if (queue !== null) {
            try {
              flushActQueue(queue);
              enqueueTask(function() {
                if (queue.length === 0) {
                  ReactCurrentActQueue.current = null;
                  resolve(returnValue);
                } else {
                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                }
              });
            } catch (error42) {
              reject(error42);
            }
          } else {
            resolve(returnValue);
          }
        }
      }
      var isFlushing = false;
      function flushActQueue(queue) {
        {
          if (!isFlushing) {
            isFlushing = true;
            var i = 0;
            try {
              for (;i < queue.length; i++) {
                var callback = queue[i];
                do {
                  callback = callback(true);
                } while (callback !== null);
              }
              queue.length = 0;
            } catch (error42) {
              queue = queue.slice(i + 1);
              throw error42;
            } finally {
              isFlushing = false;
            }
          }
        }
      }
      var createElement$1 = createElementWithValidation;
      var cloneElement$1 = cloneElementWithValidation;
      var createFactory = createFactoryWithValidation;
      var Children = {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray,
        only: onlyChild
      };
      exports.Children = Children;
      exports.Component = Component;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
      exports.cloneElement = cloneElement$1;
      exports.createContext = createContext;
      exports.createElement = createElement$1;
      exports.createFactory = createFactory;
      exports.createRef = createRef;
      exports.forwardRef = forwardRef;
      exports.isValidElement = isValidElement;
      exports.lazy = lazy;
      exports.memo = memo;
      exports.startTransition = startTransition;
      exports.unstable_act = act;
      exports.useCallback = useCallback;
      exports.useContext = useContext;
      exports.useDebugValue = useDebugValue;
      exports.useDeferredValue = useDeferredValue;
      exports.useEffect = useEffect;
      exports.useId = useId;
      exports.useImperativeHandle = useImperativeHandle;
      exports.useInsertionEffect = useInsertionEffect;
      exports.useLayoutEffect = useLayoutEffect;
      exports.useMemo = useMemo;
      exports.useReducer = useReducer;
      exports.useRef = useRef;
      exports.useState = useState;
      exports.useSyncExternalStore = useSyncExternalStore;
      exports.useTransition = useTransition;
      exports.version = ReactVersion;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error);
      }
    })();
  }
});

// ../sisventa/node_modules/react/index.js
var require_react = __commonJS((exports, module) => {
  var react_development = __toESM(require_react_development(), 1);
  if (false) {
  } else {
    module.exports = react_development;
  }
});

// ../sisventa/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js
import * as stream from "stream";
var require_react_dom_server_legacy_node_development = __commonJS((exports) => {
  var React = __toESM(require_react(), 1);
  if (true) {
    (function() {
      var ReactVersion = "18.2.0";
      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function warn(format) {
        {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
      }
      function error41(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function scheduleWork(callback) {
        callback();
      }
      function beginWriting(destination) {
      }
      function writeChunk(destination, chunk) {
        writeChunkAndReturn(destination, chunk);
      }
      function writeChunkAndReturn(destination, chunk) {
        return destination.push(chunk);
      }
      function completeWriting(destination) {
      }
      function close(destination) {
        destination.push(null);
      }
      function stringToChunk(content) {
        return content;
      }
      function stringToPrecomputedChunk(content) {
        return content;
      }
      function closeWithError(destination, error42) {
        destination.destroy(error42);
      }
      function typeName(value27) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type145 = hasToStringTag && value27[Symbol.toStringTag] || value27.constructor.name || "Object";
          return type145;
        }
      }
      function willCoercionThrow(value27) {
        {
          try {
            testStringCoercion(value27);
            return false;
          } catch (e3) {
            return true;
          }
        }
      }
      function testStringCoercion(value27) {
        return "" + value27;
      }
      function checkAttributeStringCoercion(value27, attributeName) {
        {
          if (willCoercionThrow(value27)) {
            error41("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value27));
            return testStringCoercion(value27);
          }
        }
      }
      function checkCSSPropertyStringCoercion(value27, propName) {
        {
          if (willCoercionThrow(value27)) {
            error41("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value27));
            return testStringCoercion(value27);
          }
        }
      }
      function checkHtmlStringCoercion(value27) {
        {
          if (willCoercionThrow(value27)) {
            error41("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value27));
            return testStringCoercion(value27);
          }
        }
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var RESERVED = 0;
      var STRING = 1;
      var BOOLEANISH_STRING = 2;
      var BOOLEAN = 3;
      var OVERLOADED_BOOLEAN = 4;
      var NUMERIC = 5;
      var POSITIVE_NUMERIC = 6;
      var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
      var illegalAttributeNameCache = {};
      var validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
          return true;
        }
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
          return false;
        }
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
          validatedAttributeNameCache[attributeName] = true;
          return true;
        }
        illegalAttributeNameCache[attributeName] = true;
        {
          error41("Invalid attribute name: `%s`", attributeName);
        }
        return false;
      }
      function shouldRemoveAttributeWithWarning(name, value27, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED) {
          return false;
        }
        switch (typeof value27) {
          case "function":
          case "symbol":
            return true;
          case "boolean": {
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              return !propertyInfo.acceptsBooleans;
            } else {
              var prefix2 = name.toLowerCase().slice(0, 5);
              return prefix2 !== "data-" && prefix2 !== "aria-";
            }
          }
          default:
            return false;
        }
      }
      function getPropertyInfo(name) {
        return properties.hasOwnProperty(name) ? properties[name] : null;
      }
      function PropertyInfoRecord(name, type145, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
        this.acceptsBooleans = type145 === BOOLEANISH_STRING || type145 === BOOLEAN || type145 === OVERLOADED_BOOLEAN;
        this.attributeName = attributeName;
        this.attributeNamespace = attributeNamespace;
        this.mustUseProperty = mustUseProperty;
        this.propertyName = name;
        this.type = type145;
        this.sanitizeURL = sanitizeURL2;
        this.removeEmptyString = removeEmptyString;
      }
      var properties = {};
      var reservedProps = [
        "children",
        "dangerouslySetInnerHTML",
        "defaultValue",
        "defaultChecked",
        "innerHTML",
        "suppressContentEditableWarning",
        "suppressHydrationWarning",
        "style"
      ];
      reservedProps.forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
        var name = _ref[0], attributeName = _ref[1];
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
      });
      [
        "allowFullScreen",
        "async",
        "autoFocus",
        "autoPlay",
        "controls",
        "default",
        "defer",
        "disabled",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "formNoValidate",
        "hidden",
        "loop",
        "noModule",
        "noValidate",
        "open",
        "playsInline",
        "readOnly",
        "required",
        "reversed",
        "scoped",
        "seamless",
        "itemScope"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
      });
      [
        "checked",
        "multiple",
        "muted",
        "selected"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
      });
      [
        "capture",
        "download"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
      });
      [
        "cols",
        "rows",
        "size",
        "span"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
      });
      var CAMELIZE = /[\-\:]([a-z])/g;
      var capitalize3 = function(token) {
        return token[1].toUpperCase();
      };
      [
        "accent-height",
        "alignment-baseline",
        "arabic-form",
        "baseline-shift",
        "cap-height",
        "clip-path",
        "clip-rule",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-name",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "horiz-adv-x",
        "horiz-origin-x",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "overline-position",
        "overline-thickness",
        "paint-order",
        "panose-1",
        "pointer-events",
        "rendering-intent",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "strikethrough-position",
        "strikethrough-thickness",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "underline-position",
        "underline-thickness",
        "unicode-bidi",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "vector-effect",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "word-spacing",
        "writing-mode",
        "xmlns:xlink",
        "x-height"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize3);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
      });
      [
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize3);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
      });
      [
        "xml:base",
        "xml:lang",
        "xml:space"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize3);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
      });
      var xlinkHref = "xlinkHref";
      properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
      });
      var isUnitlessNumber = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      function prefixKey(prefix2, key) {
        return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
      }
      var prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
        });
      });
      var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      };
      function checkControlledValueProps(tagName, props) {
        {
          if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
            error41("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
          }
          if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
            error41("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
          }
        }
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf("-") === -1) {
          return typeof props.is === "string";
        }
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      };
      var warnedProperties = {};
      var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
      var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
      function validateProperty(tagName, name) {
        {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
            return true;
          }
          if (rARIACamel.test(name)) {
            var ariaName = "aria-" + name.slice(4).toLowerCase();
            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (correctName == null) {
              error41("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
              warnedProperties[name] = true;
              return true;
            }
            if (name !== correctName) {
              error41("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
              warnedProperties[name] = true;
              return true;
            }
          }
          if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase();
            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (standardName == null) {
              warnedProperties[name] = true;
              return false;
            }
            if (name !== standardName) {
              error41("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
              warnedProperties[name] = true;
              return true;
            }
          }
        }
        return true;
      }
      function warnInvalidARIAProps(type145, props) {
        {
          var invalidProps = [];
          for (var key in props) {
            var isValid = validateProperty(type145, key);
            if (!isValid) {
              invalidProps.push(key);
            }
          }
          var unknownPropString = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (invalidProps.length === 1) {
            error41("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type145);
          } else if (invalidProps.length > 1) {
            error41("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type145);
          }
        }
      }
      function validateProperties(type145, props) {
        if (isCustomComponent(type145, props)) {
          return;
        }
        warnInvalidARIAProps(type145, props);
      }
      var didWarnValueNull = false;
      function validateProperties$1(type145, props) {
        {
          if (type145 !== "input" && type145 !== "textarea" && type145 !== "select") {
            return;
          }
          if (props != null && props.value === null && !didWarnValueNull) {
            didWarnValueNull = true;
            if (type145 === "select" && props.multiple) {
              error41("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type145);
            } else {
              error41("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type145);
            }
          }
        }
      }
      var possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      };
      var validateProperty$1 = function() {
      };
      {
        var warnedProperties$1 = {};
        var EVENT_NAME_REGEX = /^on./;
        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
        var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        validateProperty$1 = function(tagName, name, value27, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
            return true;
          }
          var lowerCasedName = name.toLowerCase();
          if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
            error41("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (eventRegistry != null) {
            var { registrationNameDependencies, possibleRegistrationNames } = eventRegistry;
            if (registrationNameDependencies.hasOwnProperty(name)) {
              return true;
            }
            var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
            if (registrationName != null) {
              error41("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (EVENT_NAME_REGEX.test(name)) {
              error41("Unknown event handler property `%s`. It will be ignored.", name);
              warnedProperties$1[name] = true;
              return true;
            }
          } else if (EVENT_NAME_REGEX.test(name)) {
            if (INVALID_EVENT_NAME_REGEX.test(name)) {
              error41("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
            }
            warnedProperties$1[name] = true;
            return true;
          }
          if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
            return true;
          }
          if (lowerCasedName === "innerhtml") {
            error41("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (lowerCasedName === "aria") {
            error41("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (lowerCasedName === "is" && value27 !== null && value27 !== undefined && typeof value27 !== "string") {
            error41("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value27);
            warnedProperties$1[name] = true;
            return true;
          }
          if (typeof value27 === "number" && isNaN(value27)) {
            error41("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
            warnedProperties$1[name] = true;
            return true;
          }
          var propertyInfo = getPropertyInfo(name);
          var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name) {
              error41("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
              warnedProperties$1[name] = true;
              return true;
            }
          } else if (!isReserved && name !== lowerCasedName) {
            error41("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
            warnedProperties$1[name] = true;
            return true;
          }
          if (typeof value27 === "boolean" && shouldRemoveAttributeWithWarning(name, value27, propertyInfo, false)) {
            if (value27) {
              error41('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value27, name, name, value27, name);
            } else {
              error41('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value27, name, name, value27, name, name, name);
            }
            warnedProperties$1[name] = true;
            return true;
          }
          if (isReserved) {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name, value27, propertyInfo, false)) {
            warnedProperties$1[name] = true;
            return false;
          }
          if ((value27 === "false" || value27 === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
            error41("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value27, name, value27 === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value27);
            warnedProperties$1[name] = true;
            return true;
          }
          return true;
        };
      }
      var warnUnknownProperties = function(type145, props, eventRegistry) {
        {
          var unknownProps = [];
          for (var key in props) {
            var isValid = validateProperty$1(type145, key, props[key], eventRegistry);
            if (!isValid) {
              unknownProps.push(key);
            }
          }
          var unknownPropString = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (unknownProps.length === 1) {
            error41("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type145);
          } else if (unknownProps.length > 1) {
            error41("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type145);
          }
        }
      };
      function validateProperties$2(type145, props, eventRegistry) {
        if (isCustomComponent(type145, props)) {
          return;
        }
        warnUnknownProperties(type145, props, eventRegistry);
      }
      var warnValidStyle = function() {
      };
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
        var msPattern = /^-ms-/;
        var hyphenPattern = /-(.)/g;
        var badStyleValueWithSemicolonPattern = /;\s*$/;
        var warnedStyleNames = {};
        var warnedStyleValues = {};
        var warnedForNaNValue = false;
        var warnedForInfinityValue = false;
        var camelize = function(string11) {
          return string11.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        };
        var warnHyphenatedStyleName = function(name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return;
          }
          warnedStyleNames[name] = true;
          error41("Unsupported style property %s. Did you mean %s?", name, camelize(name.replace(msPattern, "ms-")));
        };
        var warnBadVendoredStyleName = function(name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return;
          }
          warnedStyleNames[name] = true;
          error41("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
        };
        var warnStyleValueWithSemicolon = function(name, value27) {
          if (warnedStyleValues.hasOwnProperty(value27) && warnedStyleValues[value27]) {
            return;
          }
          warnedStyleValues[value27] = true;
          error41(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value27.replace(badStyleValueWithSemicolonPattern, ""));
        };
        var warnStyleValueIsNaN = function(name, value27) {
          if (warnedForNaNValue) {
            return;
          }
          warnedForNaNValue = true;
          error41("`NaN` is an invalid value for the `%s` css style property.", name);
        };
        var warnStyleValueIsInfinity = function(name, value27) {
          if (warnedForInfinityValue) {
            return;
          }
          warnedForInfinityValue = true;
          error41("`Infinity` is an invalid value for the `%s` css style property.", name);
        };
        warnValidStyle = function(name, value27) {
          if (name.indexOf("-") > -1) {
            warnHyphenatedStyleName(name);
          } else if (badVendoredStyleNamePattern.test(name)) {
            warnBadVendoredStyleName(name);
          } else if (badStyleValueWithSemicolonPattern.test(value27)) {
            warnStyleValueWithSemicolon(name, value27);
          }
          if (typeof value27 === "number") {
            if (isNaN(value27)) {
              warnStyleValueIsNaN(name, value27);
            } else if (!isFinite(value27)) {
              warnStyleValueIsInfinity(name, value27);
            }
          }
        };
      }
      var warnValidStyle$1 = warnValidStyle;
      var matchHtmlRegExp = /["'&<>]/;
      function escapeHtml(string11) {
        {
          checkHtmlStringCoercion(string11);
        }
        var str = "" + string11;
        var match = matchHtmlRegExp.exec(str);
        if (!match) {
          return str;
        }
        var escape;
        var html = "";
        var index;
        var lastIndex = 0;
        for (index = match.index;index < str.length; index++) {
          switch (str.charCodeAt(index)) {
            case 34:
              escape = "&quot;";
              break;
            case 38:
              escape = "&amp;";
              break;
            case 39:
              escape = "&#x27;";
              break;
            case 60:
              escape = "&lt;";
              break;
            case 62:
              escape = "&gt;";
              break;
            default:
              continue;
          }
          if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
          }
          lastIndex = index + 1;
          html += escape;
        }
        return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
      }
      function escapeTextForBrowser(text) {
        if (typeof text === "boolean" || typeof text === "number") {
          return "" + text;
        }
        return escapeHtml(text);
      }
      var uppercasePattern = /([A-Z])/g;
      var msPattern$1 = /^ms-/;
      function hyphenateStyleName(name) {
        return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
      }
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
      var didWarn = false;
      function sanitizeURL(url) {
        {
          if (!didWarn && isJavaScriptProtocol.test(url)) {
            didWarn = true;
            error41("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a3) {
        return isArrayImpl(a3);
      }
      var startInlineScript = stringToPrecomputedChunk("<script>");
      var endInlineScript = stringToPrecomputedChunk("</script>");
      var startScriptSrc = stringToPrecomputedChunk('<script src="');
      var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
      var endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
      function escapeBootstrapScriptContent(scriptText) {
        {
          checkHtmlStringCoercion(scriptText);
        }
        return ("" + scriptText).replace(scriptRegex, scriptReplacer);
      }
      var scriptRegex = /(<\/|<)(s)(cript)/gi;
      var scriptReplacer = function(match, prefix2, s3, suffix) {
        return "" + prefix2 + (s3 === "s" ? "\\u0073" : "\\u0053") + suffix;
      };
      function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        var idPrefix = identifierPrefix === undefined ? "" : identifierPrefix;
        var inlineScriptWithNonce = nonce === undefined ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
        var bootstrapChunks = [];
        if (bootstrapScriptContent !== undefined) {
          bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
        }
        if (bootstrapScripts !== undefined) {
          for (var i = 0;i < bootstrapScripts.length; i++) {
            bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);
          }
        }
        if (bootstrapModules !== undefined) {
          for (var _i = 0;_i < bootstrapModules.length; _i++) {
            bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
          }
        }
        return {
          bootstrapChunks,
          startInlineScript: inlineScriptWithNonce,
          placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
          segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
          boundaryPrefix: idPrefix + "B:",
          idPrefix,
          nextSuspenseID: 0,
          sentCompleteSegmentFunction: false,
          sentCompleteBoundaryFunction: false,
          sentClientRenderFunction: false
        };
      }
      var ROOT_HTML_MODE = 0;
      var HTML_MODE = 1;
      var SVG_MODE = 2;
      var MATHML_MODE = 3;
      var HTML_TABLE_MODE = 4;
      var HTML_TABLE_BODY_MODE = 5;
      var HTML_TABLE_ROW_MODE = 6;
      var HTML_COLGROUP_MODE = 7;
      function createFormatContext(insertionMode, selectedValue) {
        return {
          insertionMode,
          selectedValue
        };
      }
      function getChildFormatContext(parentContext, type145, props) {
        switch (type145) {
          case "select":
            return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
          case "svg":
            return createFormatContext(SVG_MODE, null);
          case "math":
            return createFormatContext(MATHML_MODE, null);
          case "foreignObject":
            return createFormatContext(HTML_MODE, null);
          case "table":
            return createFormatContext(HTML_TABLE_MODE, null);
          case "thead":
          case "tbody":
          case "tfoot":
            return createFormatContext(HTML_TABLE_BODY_MODE, null);
          case "colgroup":
            return createFormatContext(HTML_COLGROUP_MODE, null);
          case "tr":
            return createFormatContext(HTML_TABLE_ROW_MODE, null);
        }
        if (parentContext.insertionMode >= HTML_TABLE_MODE) {
          return createFormatContext(HTML_MODE, null);
        }
        if (parentContext.insertionMode === ROOT_HTML_MODE) {
          return createFormatContext(HTML_MODE, null);
        }
        return parentContext;
      }
      var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
      function assignSuspenseBoundaryID(responseState) {
        var generatedID = responseState.nextSuspenseID++;
        return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
      }
      function makeId(responseState, treeId, localId) {
        var idPrefix = responseState.idPrefix;
        var id = ":" + idPrefix + "R" + treeId;
        if (localId > 0) {
          id += "H" + localId.toString(32);
        }
        return id + ":";
      }
      function encodeHTMLTextNode(text) {
        return escapeTextForBrowser(text);
      }
      var textSeparator = stringToPrecomputedChunk("<!-- -->");
      function pushTextInstance(target, text, responseState, textEmbedded) {
        if (text === "") {
          return textEmbedded;
        }
        if (textEmbedded) {
          target.push(textSeparator);
        }
        target.push(stringToChunk(encodeHTMLTextNode(text)));
        return true;
      }
      function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
        if (lastPushedText && textEmbedded) {
          target.push(textSeparator);
        }
      }
      var styleNameCache = new Map;
      function processStyleName(styleName) {
        var chunk = styleNameCache.get(styleName);
        if (chunk !== undefined) {
          return chunk;
        }
        var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
        styleNameCache.set(styleName, result);
        return result;
      }
      var styleAttributeStart = stringToPrecomputedChunk(' style="');
      var styleAssign = stringToPrecomputedChunk(":");
      var styleSeparator = stringToPrecomputedChunk(";");
      function pushStyle(target, responseState, style) {
        if (typeof style !== "object") {
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        }
        var isFirst = true;
        for (var styleName in style) {
          if (!hasOwnProperty.call(style, styleName)) {
            continue;
          }
          var styleValue = style[styleName];
          if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
            continue;
          }
          var nameChunk = undefined;
          var valueChunk = undefined;
          var isCustomProperty = styleName.indexOf("--") === 0;
          if (isCustomProperty) {
            nameChunk = stringToChunk(escapeTextForBrowser(styleName));
            {
              checkCSSPropertyStringCoercion(styleValue, styleName);
            }
            valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
          } else {
            {
              warnValidStyle$1(styleName, styleValue);
            }
            nameChunk = processStyleName(styleName);
            if (typeof styleValue === "number") {
              if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {
                valueChunk = stringToChunk(styleValue + "px");
              } else {
                valueChunk = stringToChunk("" + styleValue);
              }
            } else {
              {
                checkCSSPropertyStringCoercion(styleValue, styleName);
              }
              valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
            }
          }
          if (isFirst) {
            isFirst = false;
            target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
          } else {
            target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
          }
        }
        if (!isFirst) {
          target.push(attributeEnd);
        }
      }
      var attributeSeparator = stringToPrecomputedChunk(" ");
      var attributeAssign = stringToPrecomputedChunk('="');
      var attributeEnd = stringToPrecomputedChunk('"');
      var attributeEmptyString = stringToPrecomputedChunk('=""');
      function pushAttribute(target, responseState, name, value27) {
        switch (name) {
          case "style": {
            pushStyle(target, responseState, value27);
            return;
          }
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            return;
        }
        if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
          return;
        }
        var propertyInfo = getPropertyInfo(name);
        if (propertyInfo !== null) {
          switch (typeof value27) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              if (!propertyInfo.acceptsBooleans) {
                return;
              }
            }
          }
          var attributeName = propertyInfo.attributeName;
          var attributeNameChunk = stringToChunk(attributeName);
          switch (propertyInfo.type) {
            case BOOLEAN:
              if (value27) {
                target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
              }
              return;
            case OVERLOADED_BOOLEAN:
              if (value27 === true) {
                target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
              } else if (value27 === false)
                ;
              else {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value27)), attributeEnd);
              }
              return;
            case NUMERIC:
              if (!isNaN(value27)) {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value27)), attributeEnd);
              }
              break;
            case POSITIVE_NUMERIC:
              if (!isNaN(value27) && value27 >= 1) {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value27)), attributeEnd);
              }
              break;
            default:
              if (propertyInfo.sanitizeURL) {
                {
                  checkAttributeStringCoercion(value27, attributeName);
                }
                value27 = "" + value27;
                sanitizeURL(value27);
              }
              target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value27)), attributeEnd);
          }
        } else if (isAttributeNameSafe(name)) {
          switch (typeof value27) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var prefix2 = name.toLowerCase().slice(0, 5);
              if (prefix2 !== "data-" && prefix2 !== "aria-") {
                return;
              }
            }
          }
          target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value27)), attributeEnd);
        }
      }
      var endOfStartTag = stringToPrecomputedChunk(">");
      var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
      function pushInnerHTML(target, innerHTML, children) {
        if (innerHTML != null) {
          if (children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          }
          var html = innerHTML.__html;
          if (html !== null && html !== undefined) {
            {
              checkHtmlStringCoercion(html);
            }
            target.push(stringToChunk("" + html));
          }
        }
      }
      var didWarnDefaultInputValue = false;
      var didWarnDefaultChecked = false;
      var didWarnDefaultSelectValue = false;
      var didWarnDefaultTextareaValue = false;
      var didWarnInvalidOptionChildren = false;
      var didWarnInvalidOptionInnerHTML = false;
      var didWarnSelectedSetOnOption = false;
      function checkSelectProp(props, propName) {
        {
          var value27 = props[propName];
          if (value27 != null) {
            var array7 = isArray(value27);
            if (props.multiple && !array7) {
              error41("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
            } else if (!props.multiple && array7) {
              error41("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
            }
          }
        }
      }
      function pushStartSelect(target, props, responseState) {
        {
          checkControlledValueProps("select", props);
          checkSelectProp(props, "value");
          checkSelectProp(props, "defaultValue");
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {
            error41("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnDefaultSelectValue = true;
          }
        }
        target.push(startChunkForTag("select"));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "defaultValue":
              case "value":
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      function flattenOptionChildren(children) {
        var content = "";
        React.Children.forEach(children, function(child) {
          if (child == null) {
            return;
          }
          content += child;
          {
            if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
              didWarnInvalidOptionChildren = true;
              error41("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
            }
          }
        });
        return content;
      }
      var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
      function pushStartOption(target, props, responseState, formatContext) {
        var selectedValue = formatContext.selectedValue;
        target.push(startChunkForTag("option"));
        var children = null;
        var value27 = null;
        var selected = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "selected":
                selected = propValue;
                {
                  if (!didWarnSelectedSetOnOption) {
                    error41("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                    didWarnSelectedSetOnOption = true;
                  }
                }
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "value":
                value27 = propValue;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (selectedValue != null) {
          var stringValue;
          if (value27 !== null) {
            {
              checkAttributeStringCoercion(value27, "value");
            }
            stringValue = "" + value27;
          } else {
            {
              if (innerHTML !== null) {
                if (!didWarnInvalidOptionInnerHTML) {
                  didWarnInvalidOptionInnerHTML = true;
                  error41("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                }
              }
            }
            stringValue = flattenOptionChildren(children);
          }
          if (isArray(selectedValue)) {
            for (var i = 0;i < selectedValue.length; i++) {
              {
                checkAttributeStringCoercion(selectedValue[i], "value");
              }
              var v3 = "" + selectedValue[i];
              if (v3 === stringValue) {
                target.push(selectedMarkerAttribute);
                break;
              }
            }
          } else {
            {
              checkAttributeStringCoercion(selectedValue, "select.value");
            }
            if ("" + selectedValue === stringValue) {
              target.push(selectedMarkerAttribute);
            }
          }
        } else if (selected) {
          target.push(selectedMarkerAttribute);
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      function pushInput(target, props, responseState) {
        {
          checkControlledValueProps("input", props);
          if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnDefaultChecked) {
            error41("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
            didWarnDefaultChecked = true;
          }
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultInputValue) {
            error41("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
            didWarnDefaultInputValue = true;
          }
        }
        target.push(startChunkForTag("input"));
        var value27 = null;
        var defaultValue = null;
        var checked = null;
        var defaultChecked = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              case "defaultChecked":
                defaultChecked = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "checked":
                checked = propValue;
                break;
              case "value":
                value27 = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (checked !== null) {
          pushAttribute(target, responseState, "checked", checked);
        } else if (defaultChecked !== null) {
          pushAttribute(target, responseState, "checked", defaultChecked);
        }
        if (value27 !== null) {
          pushAttribute(target, responseState, "value", value27);
        } else if (defaultValue !== null) {
          pushAttribute(target, responseState, "value", defaultValue);
        }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function pushStartTextArea(target, props, responseState) {
        {
          checkControlledValueProps("textarea", props);
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {
            error41("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnDefaultTextareaValue = true;
          }
        }
        target.push(startChunkForTag("textarea"));
        var value27 = null;
        var defaultValue = null;
        var children = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "value":
                value27 = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (value27 === null && defaultValue !== null) {
          value27 = defaultValue;
        }
        target.push(endOfStartTag);
        if (children != null) {
          {
            error41("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          }
          if (value27 != null) {
            throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          }
          if (isArray(children)) {
            if (children.length > 1) {
              throw new Error("<textarea> can only have at most one child.");
            }
            {
              checkHtmlStringCoercion(children[0]);
            }
            value27 = "" + children[0];
          }
          {
            checkHtmlStringCoercion(children);
          }
          value27 = "" + children;
        }
        if (typeof value27 === "string" && value27[0] === "\n") {
          target.push(leadingNewline);
        }
        if (value27 !== null) {
          {
            checkAttributeStringCoercion(value27, "value");
          }
          target.push(stringToChunk(encodeHTMLTextNode("" + value27)));
        }
        return null;
      }
      function pushSelfClosing(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function pushStartMenuItem(target, props, responseState) {
        target.push(startChunkForTag("menuitem"));
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        return null;
      }
      function pushStartTitle(target, props, responseState) {
        target.push(startChunkForTag("title"));
        var children = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        {
          var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
          if (Array.isArray(children) && children.length > 1) {
            error41("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
          } else if (child != null && child.$$typeof != null) {
            error41("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
          } else if (child != null && typeof child !== "string" && typeof child !== "number") {
            error41("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
          }
        }
        return children;
      }
      function pushStartGenericElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        if (typeof children === "string") {
          target.push(stringToChunk(encodeHTMLTextNode(children)));
          return null;
        }
        return children;
      }
      function pushStartCustomElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "style":
                pushStyle(target, responseState, propValue);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                  target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                }
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      var leadingNewline = stringToPrecomputedChunk("\n");
      function pushStartPreformattedElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        if (innerHTML != null) {
          if (children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          }
          var html = innerHTML.__html;
          if (html !== null && html !== undefined) {
            if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
              target.push(leadingNewline, stringToChunk(html));
            } else {
              {
                checkHtmlStringCoercion(html);
              }
              target.push(stringToChunk("" + html));
            }
          }
        }
        if (typeof children === "string" && children[0] === "\n") {
          target.push(leadingNewline);
        }
        return children;
      }
      var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
      var validatedTagCache = new Map;
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (tagStartChunk === undefined) {
          if (!VALID_TAG_REGEX.test(tag)) {
            throw new Error("Invalid tag: " + tag);
          }
          tagStartChunk = stringToPrecomputedChunk("<" + tag);
          validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
      }
      var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
      function pushStartInstance(target, type145, props, responseState, formatContext) {
        {
          validateProperties(type145, props);
          validateProperties$1(type145, props);
          validateProperties$2(type145, props, null);
          if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
            error41("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
          }
          if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
            if (type145.indexOf("-") === -1 && typeof props.is !== "string" && type145.toLowerCase() !== type145) {
              error41("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type145);
            }
          }
        }
        switch (type145) {
          case "select":
            return pushStartSelect(target, props, responseState);
          case "option":
            return pushStartOption(target, props, responseState, formatContext);
          case "textarea":
            return pushStartTextArea(target, props, responseState);
          case "input":
            return pushInput(target, props, responseState);
          case "menuitem":
            return pushStartMenuItem(target, props, responseState);
          case "title":
            return pushStartTitle(target, props, responseState);
          case "listing":
          case "pre": {
            return pushStartPreformattedElement(target, props, type145, responseState);
          }
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr": {
            return pushSelfClosing(target, props, type145, responseState);
          }
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph": {
            return pushStartGenericElement(target, props, type145, responseState);
          }
          case "html": {
            if (formatContext.insertionMode === ROOT_HTML_MODE) {
              target.push(DOCTYPE);
            }
            return pushStartGenericElement(target, props, type145, responseState);
          }
          default: {
            if (type145.indexOf("-") === -1 && typeof props.is !== "string") {
              return pushStartGenericElement(target, props, type145, responseState);
            } else {
              return pushStartCustomElement(target, props, type145, responseState);
            }
          }
        }
      }
      var endTag1 = stringToPrecomputedChunk("</");
      var endTag2 = stringToPrecomputedChunk(">");
      function pushEndInstance(target, type145, props) {
        switch (type145) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr": {
            break;
          }
          default: {
            target.push(endTag1, stringToChunk(type145), endTag2);
          }
        }
      }
      function writeCompletedRoot(destination, responseState) {
        var bootstrapChunks = responseState.bootstrapChunks;
        var i = 0;
        for (;i < bootstrapChunks.length - 1; i++) {
          writeChunk(destination, bootstrapChunks[i]);
        }
        if (i < bootstrapChunks.length) {
          return writeChunkAndReturn(destination, bootstrapChunks[i]);
        }
        return true;
      }
      var placeholder1 = stringToPrecomputedChunk('<template id="');
      var placeholder2 = stringToPrecomputedChunk('"></template>');
      function writePlaceholder(destination, responseState, id) {
        writeChunk(destination, placeholder1);
        writeChunk(destination, responseState.placeholderPrefix);
        var formattedID = stringToChunk(id.toString(16));
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, placeholder2);
      }
      var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
      var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
      var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
      var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
      var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
      var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
      var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
      var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
      var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
      var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
      var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
      function writeStartCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
      }
      function writeStartPendingSuspenseBoundary(destination, responseState, id) {
        writeChunk(destination, startPendingSuspenseBoundary1);
        if (id === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        writeChunk(destination, id);
        return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
      }
      function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
        var result;
        result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
        writeChunk(destination, clientRenderedSuspenseBoundaryError1);
        if (errorDigest) {
          writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
          writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
          writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
        }
        {
          if (errorMesssage) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
        }
        result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
        return result;
      }
      function writeEndCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndPendingSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
      var startSegmentHTML2 = stringToPrecomputedChunk('">');
      var endSegmentHTML = stringToPrecomputedChunk("</div>");
      var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
      var startSegmentSVG2 = stringToPrecomputedChunk('">');
      var endSegmentSVG = stringToPrecomputedChunk("</svg>");
      var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
      var startSegmentMathML2 = stringToPrecomputedChunk('">');
      var endSegmentMathML = stringToPrecomputedChunk("</math>");
      var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
      var startSegmentTable2 = stringToPrecomputedChunk('">');
      var endSegmentTable = stringToPrecomputedChunk("</table>");
      var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
      var startSegmentTableBody2 = stringToPrecomputedChunk('">');
      var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
      var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
      var startSegmentTableRow2 = stringToPrecomputedChunk('">');
      var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
      var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
      var startSegmentColGroup2 = stringToPrecomputedChunk('">');
      var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
      function writeStartSegment(destination, responseState, formatContext, id) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            writeChunk(destination, startSegmentHTML);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentHTML2);
          }
          case SVG_MODE: {
            writeChunk(destination, startSegmentSVG);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentSVG2);
          }
          case MATHML_MODE: {
            writeChunk(destination, startSegmentMathML);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentMathML2);
          }
          case HTML_TABLE_MODE: {
            writeChunk(destination, startSegmentTable);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTable2);
          }
          case HTML_TABLE_BODY_MODE: {
            writeChunk(destination, startSegmentTableBody);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTableBody2);
          }
          case HTML_TABLE_ROW_MODE: {
            writeChunk(destination, startSegmentTableRow);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTableRow2);
          }
          case HTML_COLGROUP_MODE: {
            writeChunk(destination, startSegmentColGroup);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentColGroup2);
          }
          default: {
            throw new Error("Unknown insertion mode. This is a bug in React.");
          }
        }
      }
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            return writeChunkAndReturn(destination, endSegmentHTML);
          }
          case SVG_MODE: {
            return writeChunkAndReturn(destination, endSegmentSVG);
          }
          case MATHML_MODE: {
            return writeChunkAndReturn(destination, endSegmentMathML);
          }
          case HTML_TABLE_MODE: {
            return writeChunkAndReturn(destination, endSegmentTable);
          }
          case HTML_TABLE_BODY_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableBody);
          }
          case HTML_TABLE_ROW_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableRow);
          }
          case HTML_COLGROUP_MODE: {
            return writeChunkAndReturn(destination, endSegmentColGroup);
          }
          default: {
            throw new Error("Unknown insertion mode. This is a bug in React.");
          }
        }
      }
      var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
      var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
      var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
      var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
      var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
      var completeSegmentScript2 = stringToPrecomputedChunk('","');
      var completeSegmentScript3 = stringToPrecomputedChunk('")</script>');
      function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteSegmentFunction) {
          responseState.sentCompleteSegmentFunction = true;
          writeChunk(destination, completeSegmentScript1Full);
        } else {
          writeChunk(destination, completeSegmentScript1Partial);
        }
        writeChunk(destination, responseState.segmentPrefix);
        var formattedID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, formattedID);
        writeChunk(destination, completeSegmentScript2);
        writeChunk(destination, responseState.placeholderPrefix);
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, completeSegmentScript3);
      }
      var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
      var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
      var completeBoundaryScript2 = stringToPrecomputedChunk('","');
      var completeBoundaryScript3 = stringToPrecomputedChunk('")</script>');
      function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteBoundaryFunction) {
          responseState.sentCompleteBoundaryFunction = true;
          writeChunk(destination, completeBoundaryScript1Full);
        } else {
          writeChunk(destination, completeBoundaryScript1Partial);
        }
        if (boundaryID === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        var formattedContentID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, boundaryID);
        writeChunk(destination, completeBoundaryScript2);
        writeChunk(destination, responseState.segmentPrefix);
        writeChunk(destination, formattedContentID);
        return writeChunkAndReturn(destination, completeBoundaryScript3);
      }
      var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
      var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
      var clientRenderScript1A = stringToPrecomputedChunk('"');
      var clientRenderScript2 = stringToPrecomputedChunk(")</script>");
      var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
      function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentClientRenderFunction) {
          responseState.sentClientRenderFunction = true;
          writeChunk(destination, clientRenderScript1Full);
        } else {
          writeChunk(destination, clientRenderScript1Partial);
        }
        if (boundaryID === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        writeChunk(destination, boundaryID);
        writeChunk(destination, clientRenderScript1A);
        if (errorDigest || errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
        }
        if (errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
        }
        if (errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
        }
        return writeChunkAndReturn(destination, clientRenderScript2);
      }
      var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
      function escapeJSStringsForInstructionScripts(input) {
        var escaped = JSON.stringify(input);
        return escaped.replace(regexForJSStringsInScripts, function(match) {
          switch (match) {
            case "<":
              return "\\u003c";
            case "\u2028":
              return "\\u2028";
            case "\u2029":
              return "\\u2029";
            default: {
              throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
            }
          }
        });
      }
      function createResponseState$1(generateStaticMarkup, identifierPrefix) {
        var responseState = createResponseState(identifierPrefix, undefined);
        return {
          bootstrapChunks: responseState.bootstrapChunks,
          startInlineScript: responseState.startInlineScript,
          placeholderPrefix: responseState.placeholderPrefix,
          segmentPrefix: responseState.segmentPrefix,
          boundaryPrefix: responseState.boundaryPrefix,
          idPrefix: responseState.idPrefix,
          nextSuspenseID: responseState.nextSuspenseID,
          sentCompleteSegmentFunction: responseState.sentCompleteSegmentFunction,
          sentCompleteBoundaryFunction: responseState.sentCompleteBoundaryFunction,
          sentClientRenderFunction: responseState.sentClientRenderFunction,
          generateStaticMarkup
        };
      }
      function createRootFormatContext() {
        return {
          insertionMode: HTML_MODE,
          selectedValue: null
        };
      }
      function pushTextInstance$1(target, text, responseState, textEmbedded) {
        if (responseState.generateStaticMarkup) {
          target.push(stringToChunk(escapeTextForBrowser(text)));
          return false;
        } else {
          return pushTextInstance(target, text, responseState, textEmbedded);
        }
      }
      function pushSegmentFinale$1(target, responseState, lastPushedText, textEmbedded) {
        if (responseState.generateStaticMarkup) {
          return;
        } else {
          return pushSegmentFinale(target, responseState, lastPushedText, textEmbedded);
        }
      }
      function writeStartCompletedSuspenseBoundary$1(destination, responseState) {
        if (responseState.generateStaticMarkup) {
          return true;
        }
        return writeStartCompletedSuspenseBoundary(destination);
      }
      function writeStartClientRenderedSuspenseBoundary$1(destination, responseState, errorDigest, errorMessage, errorComponentStack) {
        if (responseState.generateStaticMarkup) {
          return true;
        }
        return writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMessage, errorComponentStack);
      }
      function writeEndCompletedSuspenseBoundary$1(destination, responseState) {
        if (responseState.generateStaticMarkup) {
          return true;
        }
        return writeEndCompletedSuspenseBoundary(destination);
      }
      function writeEndClientRenderedSuspenseBoundary$1(destination, responseState) {
        if (responseState.generateStaticMarkup) {
          return true;
        }
        return writeEndClientRenderedSuspenseBoundary(destination);
      }
      var assign = Object.assign;
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_SCOPE_TYPE = Symbol.for("react.scope");
      var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
      var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
      var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type145) {
        return type145.displayName || "Context";
      }
      function getComponentNameFromType(type145) {
        if (type145 == null) {
          return null;
        }
        {
          if (typeof type145.tag === "number") {
            error41("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type145 === "function") {
          return type145.displayName || type145.name || null;
        }
        if (typeof type145 === "string") {
          return type145;
        }
        switch (type145) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type145 === "object") {
          switch (type145.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type145;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type145;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type145, type145.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type145.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type145.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type145;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error41("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap;
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== undefined) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s3 = sampleLines.length - 1;
            var c3 = controlLines.length - 1;
            while (s3 >= 1 && c3 >= 0 && sampleLines[s3] !== controlLines[c3]) {
              c3--;
            }
            for (;s3 >= 1 && c3 >= 0; s3--, c3--) {
              if (sampleLines[s3] !== controlLines[c3]) {
                if (s3 !== 1 || c3 !== 1) {
                  do {
                    s3--;
                    c3--;
                    if (c3 < 0 || sampleLines[s3] !== controlLines[c3]) {
                      var _frame = "\n" + sampleLines[s3].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s3 >= 1 && c3 >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeClassComponentFrame(ctor, source, ownerFn) {
        {
          return describeNativeComponentFrame(ctor, true);
        }
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type145, source, ownerFn) {
        if (type145 == null) {
          return "";
        }
        if (typeof type145 === "function") {
          {
            return describeNativeComponentFrame(type145, shouldConstruct(type145));
          }
        }
        if (typeof type145 === "string") {
          return describeBuiltInComponentFrame(type145);
        }
        switch (type145) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type145 === "object") {
          switch (type145.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type145.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type145.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type145;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has3 = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has3(typeSpecs, typeSpecName)) {
              var error$1 = undefined;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error41("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error41("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var warnedAboutMissingGetChildContext;
      {
        warnedAboutMissingGetChildContext = {};
      }
      var emptyContextObject = {};
      {
        Object.freeze(emptyContextObject);
      }
      function getMaskedContext(type145, unmaskedContext) {
        {
          var contextTypes = type145.contextTypes;
          if (!contextTypes) {
            return emptyContextObject;
          }
          var context = {};
          for (var key in contextTypes) {
            context[key] = unmaskedContext[key];
          }
          {
            var name = getComponentNameFromType(type145) || "Unknown";
            checkPropTypes(contextTypes, context, "context", name);
          }
          return context;
        }
      }
      function processChildContext(instance, type145, parentContext, childContextTypes) {
        {
          if (typeof instance.getChildContext !== "function") {
            {
              var componentName = getComponentNameFromType(type145) || "Unknown";
              if (!warnedAboutMissingGetChildContext[componentName]) {
                warnedAboutMissingGetChildContext[componentName] = true;
                error41("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
              }
            }
            return parentContext;
          }
          var childContext = instance.getChildContext();
          for (var contextKey in childContext) {
            if (!(contextKey in childContextTypes)) {
              throw new Error((getComponentNameFromType(type145) || "Unknown") + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes.");
            }
          }
          {
            var name = getComponentNameFromType(type145) || "Unknown";
            checkPropTypes(childContextTypes, childContext, "child context", name);
          }
          return assign({}, parentContext, childContext);
        }
      }
      var rendererSigil;
      {
        rendererSigil = {};
      }
      var rootContextSnapshot = null;
      var currentActiveSnapshot = null;
      function popNode(prev) {
        {
          prev.context._currentValue2 = prev.parentValue;
        }
      }
      function pushNode(next) {
        {
          next.context._currentValue2 = next.value;
        }
      }
      function popToNearestCommonAncestor(prev, next) {
        if (prev === next)
          ;
        else {
          popNode(prev);
          var parentPrev = prev.parent;
          var parentNext = next.parent;
          if (parentPrev === null) {
            if (parentNext !== null) {
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            }
          } else {
            if (parentNext === null) {
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            }
            popToNearestCommonAncestor(parentPrev, parentNext);
          }
          pushNode(next);
        }
      }
      function popAllPrevious(prev) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev !== null) {
          popAllPrevious(parentPrev);
        }
      }
      function pushAllNext(next) {
        var parentNext = next.parent;
        if (parentNext !== null) {
          pushAllNext(parentNext);
        }
        pushNode(next);
      }
      function popPreviousToCommonLevel(prev, next) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev === null) {
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        }
        if (parentPrev.depth === next.depth) {
          popToNearestCommonAncestor(parentPrev, next);
        } else {
          popPreviousToCommonLevel(parentPrev, next);
        }
      }
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (parentNext === null) {
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        }
        if (prev.depth === parentNext.depth) {
          popToNearestCommonAncestor(prev, parentNext);
        } else {
          popNextToCommonLevel(prev, parentNext);
        }
        pushNode(next);
      }
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot;
        var next = newSnapshot;
        if (prev !== next) {
          if (prev === null) {
            pushAllNext(next);
          } else if (next === null) {
            popAllPrevious(prev);
          } else if (prev.depth === next.depth) {
            popToNearestCommonAncestor(prev, next);
          } else if (prev.depth > next.depth) {
            popPreviousToCommonLevel(prev, next);
          } else {
            popNextToCommonLevel(prev, next);
          }
          currentActiveSnapshot = next;
        }
      }
      function pushProvider(context, nextValue) {
        var prevValue;
        {
          prevValue = context._currentValue2;
          context._currentValue2 = nextValue;
          {
            if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
              error41("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
            }
            context._currentRenderer2 = rendererSigil;
          }
        }
        var prevNode = currentActiveSnapshot;
        var newNode = {
          parent: prevNode,
          depth: prevNode === null ? 0 : prevNode.depth + 1,
          context,
          parentValue: prevValue,
          value: nextValue
        };
        currentActiveSnapshot = newNode;
        return newNode;
      }
      function popProvider(context) {
        var prevSnapshot = currentActiveSnapshot;
        if (prevSnapshot === null) {
          throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
        }
        {
          if (prevSnapshot.context !== context) {
            error41("The parent context is not the expected context. This is probably a bug in React.");
          }
        }
        {
          var _value = prevSnapshot.parentValue;
          if (_value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
            prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue;
          } else {
            prevSnapshot.context._currentValue2 = _value;
          }
          {
            if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
              error41("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
            }
            context._currentRenderer2 = rendererSigil;
          }
        }
        return currentActiveSnapshot = prevSnapshot.parent;
      }
      function getActiveContext() {
        return currentActiveSnapshot;
      }
      function readContext(context) {
        var value27 = context._currentValue2;
        return value27;
      }
      function get(key) {
        return key._reactInternals;
      }
      function set3(key, value27) {
        key._reactInternals = value27;
      }
      var didWarnAboutNoopUpdateForComponent = {};
      var didWarnAboutDeprecatedWillMount = {};
      var didWarnAboutUninitializedState;
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
      var didWarnAboutLegacyLifecyclesAndDerivedState;
      var didWarnAboutUndefinedDerivedState;
      var warnOnUndefinedDerivedState;
      var warnOnInvalidCallback;
      var didWarnAboutDirectlyAssigningPropsToState;
      var didWarnAboutContextTypeAndContextTypes;
      var didWarnAboutInvalidateContextType;
      {
        didWarnAboutUninitializedState = new Set;
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set;
        didWarnAboutLegacyLifecyclesAndDerivedState = new Set;
        didWarnAboutDirectlyAssigningPropsToState = new Set;
        didWarnAboutUndefinedDerivedState = new Set;
        didWarnAboutContextTypeAndContextTypes = new Set;
        didWarnAboutInvalidateContextType = new Set;
        var didWarnOnInvalidCallback = new Set;
        warnOnInvalidCallback = function(callback, callerName) {
          if (callback === null || typeof callback === "function") {
            return;
          }
          var key = callerName + "_" + callback;
          if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            error41("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
          }
        };
        warnOnUndefinedDerivedState = function(type145, partialState) {
          if (partialState === undefined) {
            var componentName = getComponentNameFromType(type145) || "Component";
            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
              didWarnAboutUndefinedDerivedState.add(componentName);
              error41("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
            }
          }
        };
      }
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor;
          var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
          var warningKey = componentName + "." + callerName;
          if (didWarnAboutNoopUpdateForComponent[warningKey]) {
            return;
          }
          error41("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
          didWarnAboutNoopUpdateForComponent[warningKey] = true;
        }
      }
      var classComponentUpdater = {
        isMounted: function(inst) {
          return false;
        },
        enqueueSetState: function(inst, payload, callback) {
          var internals = get(inst);
          if (internals.queue === null) {
            warnNoop(inst, "setState");
          } else {
            internals.queue.push(payload);
            {
              if (callback !== undefined && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          }
        },
        enqueueReplaceState: function(inst, payload, callback) {
          var internals = get(inst);
          internals.replace = true;
          internals.queue = [payload];
          {
            if (callback !== undefined && callback !== null) {
              warnOnInvalidCallback(callback, "setState");
            }
          }
        },
        enqueueForceUpdate: function(inst, callback) {
          var internals = get(inst);
          if (internals.queue === null) {
            warnNoop(inst, "forceUpdate");
          } else {
            {
              if (callback !== undefined && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          }
        }
      };
      function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        {
          warnOnUndefinedDerivedState(ctor, partialState);
        }
        var newState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);
        return newState;
      }
      function constructClassInstance(ctor, props, maskedLegacyContext) {
        var context = emptyContextObject;
        var contextType = ctor.contextType;
        {
          if ("contextType" in ctor) {
            var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined;
            if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
              didWarnAboutInvalidateContextType.add(ctor);
              var addendum = "";
              if (contextType === undefined) {
                addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
              } else if (typeof contextType !== "object") {
                addendum = " However, it is set to a " + typeof contextType + ".";
              } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                addendum = " Did you accidentally pass the Context.Provider instead?";
              } else if (contextType._context !== undefined) {
                addendum = " Did you accidentally pass the Context.Consumer instead?";
              } else {
                addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
              }
              error41("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
            }
          }
        }
        if (typeof contextType === "object" && contextType !== null) {
          context = readContext(contextType);
        } else {
          context = maskedLegacyContext;
        }
        var instance = new ctor(props, context);
        {
          if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === undefined)) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutUninitializedState.has(componentName)) {
              didWarnAboutUninitializedState.add(componentName);
              error41("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
            }
          }
          if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;
            if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
              foundWillMountName = "componentWillMount";
            } else if (typeof instance.UNSAFE_componentWillMount === "function") {
              foundWillMountName = "UNSAFE_componentWillMount";
            }
            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              foundWillReceivePropsName = "componentWillReceiveProps";
            } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
            }
            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              foundWillUpdateName = "componentWillUpdate";
            } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              foundWillUpdateName = "UNSAFE_componentWillUpdate";
            }
            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType(ctor) || "Component";
              var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                error41("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
              }
            }
          }
        }
        return instance;
      }
      function checkClassInstance(instance, ctor, newProps) {
        {
          var name = getComponentNameFromType(ctor) || "Component";
          var renderPresent = instance.render;
          if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === "function") {
              error41("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
            } else {
              error41("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
            }
          }
          if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
            error41("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
          }
          if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
            error41("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
          }
          if (instance.propTypes) {
            error41("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
          }
          if (instance.contextType) {
            error41("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
          }
          {
            if (instance.contextTypes) {
              error41("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
            }
            if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
              didWarnAboutContextTypeAndContextTypes.add(ctor);
              error41("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
            }
          }
          if (typeof instance.componentShouldUpdate === "function") {
            error41("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
            error41("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
          }
          if (typeof instance.componentDidUnmount === "function") {
            error41("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
          }
          if (typeof instance.componentDidReceiveProps === "function") {
            error41("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
          }
          if (typeof instance.componentWillRecieveProps === "function") {
            error41("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
          }
          if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
            error41("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
          }
          var hasMutatedProps = instance.props !== newProps;
          if (instance.props !== undefined && hasMutatedProps) {
            error41("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
          }
          if (instance.defaultProps) {
            error41("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            error41("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
          }
          if (typeof instance.getDerivedStateFromProps === "function") {
            error41("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
          }
          if (typeof instance.getDerivedStateFromError === "function") {
            error41("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
          }
          if (typeof ctor.getSnapshotBeforeUpdate === "function") {
            error41("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
          }
          var _state = instance.state;
          if (_state && (typeof _state !== "object" || isArray(_state))) {
            error41("%s.state: must be set to an object or null", name);
          }
          if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
            error41("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
          }
        }
      }
      function callComponentWillMount(type145, instance) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount === "function") {
          {
            if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
              var componentName = getComponentNameFromType(type145) || "Unknown";
              if (!didWarnAboutDeprecatedWillMount[componentName]) {
                warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s", componentName);
                didWarnAboutDeprecatedWillMount[componentName] = true;
              }
            }
          }
          instance.componentWillMount();
        }
        if (typeof instance.UNSAFE_componentWillMount === "function") {
          instance.UNSAFE_componentWillMount();
        }
        if (oldState !== instance.state) {
          {
            error41("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type145) || "Component");
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }
      function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
        if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
          var oldQueue = internalInstance.queue;
          var oldReplace = internalInstance.replace;
          internalInstance.queue = null;
          internalInstance.replace = false;
          if (oldReplace && oldQueue.length === 1) {
            inst.state = oldQueue[0];
          } else {
            var nextState = oldReplace ? oldQueue[0] : inst.state;
            var dontMutate = true;
            for (var i = oldReplace ? 1 : 0;i < oldQueue.length; i++) {
              var partial7 = oldQueue[i];
              var partialState = typeof partial7 === "function" ? partial7.call(inst, nextState, props, maskedLegacyContext) : partial7;
              if (partialState != null) {
                if (dontMutate) {
                  dontMutate = false;
                  nextState = assign({}, nextState, partialState);
                } else {
                  assign(nextState, partialState);
                }
              }
            }
            inst.state = nextState;
          }
        } else {
          internalInstance.queue = null;
        }
      }
      function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
        {
          checkClassInstance(instance, ctor, newProps);
        }
        var initialState = instance.state !== undefined ? instance.state : null;
        instance.updater = classComponentUpdater;
        instance.props = newProps;
        instance.state = initialState;
        var internalInstance = {
          queue: [],
          replace: false
        };
        set3(instance, internalInstance);
        var contextType = ctor.contextType;
        if (typeof contextType === "object" && contextType !== null) {
          instance.context = readContext(contextType);
        } else {
          instance.context = maskedLegacyContext;
        }
        {
          if (instance.state === newProps) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
              didWarnAboutDirectlyAssigningPropsToState.add(componentName);
              error41("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
            }
          }
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps === "function") {
          instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
        }
        if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
          callComponentWillMount(ctor, instance);
          processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
        }
      }
      var emptyTreeContext = {
        id: 1,
        overflow: ""
      };
      function getTreeId(context) {
        var overflow = context.overflow;
        var idWithLeadingBit = context.id;
        var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id.toString(32) + overflow;
      }
      function pushTreeContext(baseContext, totalChildren, index) {
        var baseIdWithLeadingBit = baseContext.id;
        var baseOverflow = baseContext.overflow;
        var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
        var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
        var slot = index + 1;
        var length = getBitLength(totalChildren) + baseLength;
        if (length > 30) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          var newOverflowBits = (1 << numberOfOverflowBits) - 1;
          var newOverflow = (baseId & newOverflowBits).toString(32);
          var restOfBaseId = baseId >> numberOfOverflowBits;
          var restOfBaseLength = baseLength - numberOfOverflowBits;
          var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
          var restOfNewBits = slot << restOfBaseLength;
          var id = restOfNewBits | restOfBaseId;
          var overflow = newOverflow + baseOverflow;
          return {
            id: 1 << restOfLength | id,
            overflow
          };
        } else {
          var newBits = slot << baseLength;
          var _id = newBits | baseId;
          var _overflow = baseOverflow;
          return {
            id: 1 << length | _id,
            overflow: _overflow
          };
        }
      }
      function getBitLength(number11) {
        return 32 - clz32(number11);
      }
      function getLeadingBit(id) {
        return 1 << getBitLength(id) - 1;
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
      var log = Math.log;
      var LN2 = Math.LN2;
      function clz32Fallback(x) {
        var asUint = x >>> 0;
        if (asUint === 0) {
          return 32;
        }
        return 31 - (log(asUint) / LN2 | 0) | 0;
      }
      function is(x, y3) {
        return x === y3 && (x !== 0 || 1 / x === 1 / y3) || x !== x && y3 !== y3;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is;
      var currentlyRenderingComponent = null;
      var currentlyRenderingTask = null;
      var firstWorkInProgressHook = null;
      var workInProgressHook = null;
      var isReRender = false;
      var didScheduleRenderPhaseUpdate = false;
      var localIdCounter = 0;
      var renderPhaseUpdates = null;
      var numberOfReRenders = 0;
      var RE_RENDER_LIMIT = 25;
      var isInHookUserCodeInDev = false;
      var currentHookNameInDev;
      function resolveCurrentlyRenderingComponent() {
        if (currentlyRenderingComponent === null) {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        }
        {
          if (isInHookUserCodeInDev) {
            error41("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
          }
        }
        return currentlyRenderingComponent;
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null) {
          {
            error41("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
          }
          return false;
        }
        {
          if (nextDeps.length !== prevDeps.length) {
            error41("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
          }
        }
        for (var i = 0;i < prevDeps.length && i < nextDeps.length; i++) {
          if (objectIs(nextDeps[i], prevDeps[i])) {
            continue;
          }
          return false;
        }
        return true;
      }
      function createHook() {
        if (numberOfReRenders > 0) {
          throw new Error("Rendered more hooks than during the previous render");
        }
        return {
          memoizedState: null,
          queue: null,
          next: null
        };
      }
      function createWorkInProgressHook() {
        if (workInProgressHook === null) {
          if (firstWorkInProgressHook === null) {
            isReRender = false;
            firstWorkInProgressHook = workInProgressHook = createHook();
          } else {
            isReRender = true;
            workInProgressHook = firstWorkInProgressHook;
          }
        } else {
          if (workInProgressHook.next === null) {
            isReRender = false;
            workInProgressHook = workInProgressHook.next = createHook();
          } else {
            isReRender = true;
            workInProgressHook = workInProgressHook.next;
          }
        }
        return workInProgressHook;
      }
      function prepareToUseHooks(task, componentIdentity) {
        currentlyRenderingComponent = componentIdentity;
        currentlyRenderingTask = task;
        {
          isInHookUserCodeInDev = false;
        }
        localIdCounter = 0;
      }
      function finishHooks(Component, props, children, refOrContext) {
        while (didScheduleRenderPhaseUpdate) {
          didScheduleRenderPhaseUpdate = false;
          localIdCounter = 0;
          numberOfReRenders += 1;
          workInProgressHook = null;
          children = Component(props, refOrContext);
        }
        resetHooksState();
        return children;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0;
        return didRenderIdHook;
      }
      function resetHooksState() {
        {
          isInHookUserCodeInDev = false;
        }
        currentlyRenderingComponent = null;
        currentlyRenderingTask = null;
        didScheduleRenderPhaseUpdate = false;
        firstWorkInProgressHook = null;
        numberOfReRenders = 0;
        renderPhaseUpdates = null;
        workInProgressHook = null;
      }
      function readContext$1(context) {
        {
          if (isInHookUserCodeInDev) {
            error41("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          }
        }
        return readContext(context);
      }
      function useContext(context) {
        {
          currentHookNameInDev = "useContext";
        }
        resolveCurrentlyRenderingComponent();
        return readContext(context);
      }
      function basicStateReducer(state, action) {
        return typeof action === "function" ? action(state) : action;
      }
      function useState(initialState) {
        {
          currentHookNameInDev = "useState";
        }
        return useReducer(basicStateReducer, initialState);
      }
      function useReducer(reducer, initialArg, init) {
        {
          if (reducer !== basicStateReducer) {
            currentHookNameInDev = "useReducer";
          }
        }
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        if (isReRender) {
          var queue = workInProgressHook.queue;
          var dispatch = queue.dispatch;
          if (renderPhaseUpdates !== null) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
            if (firstRenderPhaseUpdate !== undefined) {
              renderPhaseUpdates.delete(queue);
              var newState = workInProgressHook.memoizedState;
              var update = firstRenderPhaseUpdate;
              do {
                var action = update.action;
                {
                  isInHookUserCodeInDev = true;
                }
                newState = reducer(newState, action);
                {
                  isInHookUserCodeInDev = false;
                }
                update = update.next;
              } while (update !== null);
              workInProgressHook.memoizedState = newState;
              return [newState, dispatch];
            }
          }
          return [workInProgressHook.memoizedState, dispatch];
        } else {
          {
            isInHookUserCodeInDev = true;
          }
          var initialState;
          if (reducer === basicStateReducer) {
            initialState = typeof initialArg === "function" ? initialArg() : initialArg;
          } else {
            initialState = init !== undefined ? init(initialArg) : initialArg;
          }
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = initialState;
          var _queue = workInProgressHook.queue = {
            last: null,
            dispatch: null
          };
          var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
          return [workInProgressHook.memoizedState, _dispatch];
        }
      }
      function useMemo(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        if (workInProgressHook !== null) {
          var prevState = workInProgressHook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
        }
        {
          isInHookUserCodeInDev = true;
        }
        var nextValue = nextCreate();
        {
          isInHookUserCodeInDev = false;
        }
        workInProgressHook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }
      function useRef(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var previousRef = workInProgressHook.memoizedState;
        if (previousRef === null) {
          var ref5 = {
            current: initialValue
          };
          {
            Object.seal(ref5);
          }
          workInProgressHook.memoizedState = ref5;
          return ref5;
        } else {
          return previousRef;
        }
      }
      function useLayoutEffect(create7, inputs) {
        {
          currentHookNameInDev = "useLayoutEffect";
          error41("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
        }
      }
      function dispatchAction(componentIdentity, queue, action) {
        if (numberOfReRenders >= RE_RENDER_LIMIT) {
          throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        }
        if (componentIdentity === currentlyRenderingComponent) {
          didScheduleRenderPhaseUpdate = true;
          var update = {
            action,
            next: null
          };
          if (renderPhaseUpdates === null) {
            renderPhaseUpdates = new Map;
          }
          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
          if (firstRenderPhaseUpdate === undefined) {
            renderPhaseUpdates.set(queue, update);
          } else {
            var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
            while (lastRenderPhaseUpdate.next !== null) {
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            }
            lastRenderPhaseUpdate.next = update;
          }
        }
      }
      function useCallback(callback, deps) {
        return useMemo(function() {
          return callback;
        }, deps);
      }
      function useMutableSource(source, getSnapshot, subscribe) {
        resolveCurrentlyRenderingComponent();
        return getSnapshot(source._source);
      }
      function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        if (getServerSnapshot === undefined) {
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        }
        return getServerSnapshot();
      }
      function useDeferredValue(value27) {
        resolveCurrentlyRenderingComponent();
        return value27;
      }
      function unsupportedStartTransition() {
        throw new Error("startTransition cannot be called during server rendering.");
      }
      function useTransition() {
        resolveCurrentlyRenderingComponent();
        return [false, unsupportedStartTransition];
      }
      function useId() {
        var task = currentlyRenderingTask;
        var treeId = getTreeId(task.treeContext);
        var responseState = currentResponseState;
        if (responseState === null) {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
        }
        var localId = localIdCounter++;
        return makeId(responseState, treeId, localId);
      }
      function noop() {
      }
      var Dispatcher = {
        readContext: readContext$1,
        useContext,
        useMemo,
        useReducer,
        useRef,
        useState,
        useInsertionEffect: noop,
        useLayoutEffect,
        useCallback,
        useImperativeHandle: noop,
        useEffect: noop,
        useDebugValue: noop,
        useDeferredValue,
        useTransition,
        useId,
        useMutableSource,
        useSyncExternalStore
      };
      var currentResponseState = null;
      function setCurrentResponseState(responseState) {
        currentResponseState = responseState;
      }
      function getStackByComponentStackNode(componentStack) {
        try {
          var info = "";
          var node = componentStack;
          do {
            switch (node.tag) {
              case 0:
                info += describeBuiltInComponentFrame(node.type, null, null);
                break;
              case 1:
                info += describeFunctionComponentFrame(node.type, null, null);
                break;
              case 2:
                info += describeClassComponentFrame(node.type, null, null);
                break;
            }
            node = node.parent;
          } while (node);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      var PENDING = 0;
      var COMPLETED = 1;
      var FLUSHED = 2;
      var ABORTED = 3;
      var ERRORED = 4;
      var OPEN = 0;
      var CLOSING = 1;
      var CLOSED = 2;
      var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
      function defaultErrorHandler(error42) {
        console["error"](error42);
        return null;
      }
      function noop$1() {
      }
      function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError) {
        var pingedTasks = [];
        var abortSet = new Set;
        var request = {
          destination: null,
          responseState,
          progressiveChunkSize: progressiveChunkSize === undefined ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
          status: OPEN,
          fatalError: null,
          nextSegmentId: 0,
          allPendingTasks: 0,
          pendingRootTasks: 0,
          completedRootSegment: null,
          abortableTasks: abortSet,
          pingedTasks,
          clientRenderedBoundaries: [],
          completedBoundaries: [],
          partialBoundaries: [],
          onError: onError2 === undefined ? defaultErrorHandler : onError2,
          onAllReady: onAllReady === undefined ? noop$1 : onAllReady,
          onShellReady: onShellReady === undefined ? noop$1 : onShellReady,
          onShellError: onShellError === undefined ? noop$1 : onShellError,
          onFatalError: onFatalError === undefined ? noop$1 : onFatalError
        };
        var rootSegment = createPendingSegment(request, 0, null, rootFormatContext, false, false);
        rootSegment.parentFlushed = true;
        var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
        pingedTasks.push(rootTask);
        return request;
      }
      function pingTask(request, task) {
        var pingedTasks = request.pingedTasks;
        pingedTasks.push(task);
        if (pingedTasks.length === 1) {
          scheduleWork(function() {
            return performWork(request);
          });
        }
      }
      function createSuspenseBoundary(request, fallbackAbortableTasks) {
        return {
          id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
          rootSegmentID: -1,
          parentFlushed: false,
          pendingTasks: 0,
          forceClientRender: false,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null
        };
      }
      function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
        request.allPendingTasks++;
        if (blockedBoundary === null) {
          request.pendingRootTasks++;
        } else {
          blockedBoundary.pendingTasks++;
        }
        var task = {
          node,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment,
          abortSet,
          legacyContext,
          context,
          treeContext
        };
        {
          task.componentStack = null;
        }
        abortSet.add(task);
        return task;
      }
      function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {
        return {
          status: PENDING,
          id: -1,
          index,
          parentFlushed: false,
          chunks: [],
          children: [],
          formatContext,
          boundary,
          lastPushedText,
          textEmbedded
        };
      }
      var currentTaskInDEV = null;
      function getCurrentStackInDEV() {
        {
          if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
            return "";
          }
          return getStackByComponentStackNode(currentTaskInDEV.componentStack);
        }
      }
      function pushBuiltInComponentStackInDEV(task, type145) {
        {
          task.componentStack = {
            tag: 0,
            parent: task.componentStack,
            type: type145
          };
        }
      }
      function pushFunctionComponentStackInDEV(task, type145) {
        {
          task.componentStack = {
            tag: 1,
            parent: task.componentStack,
            type: type145
          };
        }
      }
      function pushClassComponentStackInDEV(task, type145) {
        {
          task.componentStack = {
            tag: 2,
            parent: task.componentStack,
            type: type145
          };
        }
      }
      function popComponentStackInDEV(task) {
        {
          if (task.componentStack === null) {
            error41("Unexpectedly popped too many stack frames. This is a bug in React.");
          } else {
            task.componentStack = task.componentStack.parent;
          }
        }
      }
      var lastBoundaryErrorComponentStackDev = null;
      function captureBoundaryErrorDetailsDev(boundary, error42) {
        {
          var errorMessage;
          if (typeof error42 === "string") {
            errorMessage = error42;
          } else if (error42 && typeof error42.message === "string") {
            errorMessage = error42.message;
          } else {
            errorMessage = String(error42);
          }
          var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
          lastBoundaryErrorComponentStackDev = null;
          boundary.errorMessage = errorMessage;
          boundary.errorComponentStack = errorComponentStack;
        }
      }
      function logRecoverableError(request, error42) {
        var errorDigest = request.onError(error42);
        if (errorDigest != null && typeof errorDigest !== "string") {
          throw new Error("onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"" + typeof errorDigest + "\" instead");
        }
        return errorDigest;
      }
      function fatalError(request, error42) {
        var onShellError = request.onShellError;
        onShellError(error42);
        var onFatalError = request.onFatalError;
        onFatalError(error42);
        if (request.destination !== null) {
          request.status = CLOSED;
          closeWithError(request.destination, error42);
        } else {
          request.status = CLOSING;
          request.fatalError = error42;
        }
      }
      function renderSuspenseBoundary(request, task, props) {
        pushBuiltInComponentStackInDEV(task, "Suspense");
        var parentBoundary = task.blockedBoundary;
        var parentSegment = task.blockedSegment;
        var fallback = props.fallback;
        var content = props.children;
        var fallbackAbortSet = new Set;
        var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
        var insertionIndex = parentSegment.chunks.length;
        var boundarySegment = createPendingSegment(request, insertionIndex, newBoundary, parentSegment.formatContext, false, false);
        parentSegment.children.push(boundarySegment);
        parentSegment.lastPushedText = false;
        var contentRootSegment = createPendingSegment(request, 0, null, parentSegment.formatContext, false, false);
        contentRootSegment.parentFlushed = true;
        task.blockedBoundary = newBoundary;
        task.blockedSegment = contentRootSegment;
        try {
          renderNode(request, task, content);
          pushSegmentFinale$1(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
          contentRootSegment.status = COMPLETED;
          queueCompletedSegment(newBoundary, contentRootSegment);
          if (newBoundary.pendingTasks === 0) {
            popComponentStackInDEV(task);
            return;
          }
        } catch (error42) {
          contentRootSegment.status = ERRORED;
          newBoundary.forceClientRender = true;
          newBoundary.errorDigest = logRecoverableError(request, error42);
          {
            captureBoundaryErrorDetailsDev(newBoundary, error42);
          }
        } finally {
          task.blockedBoundary = parentBoundary;
          task.blockedSegment = parentSegment;
        }
        var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
        {
          suspendedFallbackTask.componentStack = task.componentStack;
        }
        request.pingedTasks.push(suspendedFallbackTask);
        popComponentStackInDEV(task);
      }
      function renderHostElement(request, task, type145, props) {
        pushBuiltInComponentStackInDEV(task, type145);
        var segment = task.blockedSegment;
        var children = pushStartInstance(segment.chunks, type145, props, request.responseState, segment.formatContext);
        segment.lastPushedText = false;
        var prevContext = segment.formatContext;
        segment.formatContext = getChildFormatContext(prevContext, type145, props);
        renderNode(request, task, children);
        segment.formatContext = prevContext;
        pushEndInstance(segment.chunks, type145);
        segment.lastPushedText = false;
        popComponentStackInDEV(task);
      }
      function shouldConstruct$1(Component) {
        return Component.prototype && Component.prototype.isReactComponent;
      }
      function renderWithHooks(request, task, Component, props, secondArg) {
        var componentIdentity = {};
        prepareToUseHooks(task, componentIdentity);
        var result = Component(props, secondArg);
        return finishHooks(Component, props, result, secondArg);
      }
      function finishClassComponent(request, task, instance, Component, props) {
        var nextChildren = instance.render();
        {
          if (instance.props !== props) {
            if (!didWarnAboutReassigningProps) {
              error41("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component");
            }
            didWarnAboutReassigningProps = true;
          }
        }
        {
          var childContextTypes = Component.childContextTypes;
          if (childContextTypes !== null && childContextTypes !== undefined) {
            var previousContext = task.legacyContext;
            var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
            task.legacyContext = mergedContext;
            renderNodeDestructive(request, task, nextChildren);
            task.legacyContext = previousContext;
            return;
          }
        }
        renderNodeDestructive(request, task, nextChildren);
      }
      function renderClassComponent(request, task, Component, props) {
        pushClassComponentStackInDEV(task, Component);
        var maskedContext = getMaskedContext(Component, task.legacyContext);
        var instance = constructClassInstance(Component, props, maskedContext);
        mountClassInstance(instance, Component, props, maskedContext);
        finishClassComponent(request, task, instance, Component, props);
        popComponentStackInDEV(task);
      }
      var didWarnAboutBadClass = {};
      var didWarnAboutModulePatternComponent = {};
      var didWarnAboutContextTypeOnFunctionComponent = {};
      var didWarnAboutGetDerivedStateOnFunctionComponent = {};
      var didWarnAboutReassigningProps = false;
      var didWarnAboutGenerators = false;
      var didWarnAboutMaps = false;
      var hasWarnedAboutUsingContextAsConsumer = false;
      function renderIndeterminateComponent(request, task, Component, props) {
        var legacyContext;
        {
          legacyContext = getMaskedContext(Component, task.legacyContext);
        }
        pushFunctionComponentStackInDEV(task, Component);
        {
          if (Component.prototype && typeof Component.prototype.render === "function") {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutBadClass[componentName]) {
              error41("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
              didWarnAboutBadClass[componentName] = true;
            }
          }
        }
        var value27 = renderWithHooks(request, task, Component, props, legacyContext);
        var hasId = checkDidRenderIdHook();
        {
          if (typeof value27 === "object" && value27 !== null && typeof value27.render === "function" && value27.$$typeof === undefined) {
            var _componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName]) {
              error41("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
              didWarnAboutModulePatternComponent[_componentName] = true;
            }
          }
        }
        if (typeof value27 === "object" && value27 !== null && typeof value27.render === "function" && value27.$$typeof === undefined) {
          {
            var _componentName2 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName2]) {
              error41("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
              didWarnAboutModulePatternComponent[_componentName2] = true;
            }
          }
          mountClassInstance(value27, Component, props, legacyContext);
          finishClassComponent(request, task, value27, Component, props);
        } else {
          {
            validateFunctionComponentInDev(Component);
          }
          if (hasId) {
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
            try {
              renderNodeDestructive(request, task, value27);
            } finally {
              task.treeContext = prevTreeContext;
            }
          } else {
            renderNodeDestructive(request, task, value27);
          }
        }
        popComponentStackInDEV(task);
      }
      function validateFunctionComponentInDev(Component) {
        {
          if (Component) {
            if (Component.childContextTypes) {
              error41("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
            }
          }
          if (typeof Component.getDerivedStateFromProps === "function") {
            var _componentName3 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
              error41("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
            }
          }
          if (typeof Component.contextType === "object" && Component.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
              error41("%s: Function components do not support contextType.", _componentName4);
              didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
            }
          }
        }
      }
      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = assign({}, baseProps);
          var defaultProps = Component.defaultProps;
          for (var propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
          return props;
        }
        return baseProps;
      }
      function renderForwardRef(request, task, type145, props, ref5) {
        pushFunctionComponentStackInDEV(task, type145.render);
        var children = renderWithHooks(request, task, type145.render, props, ref5);
        var hasId = checkDidRenderIdHook();
        if (hasId) {
          var prevTreeContext = task.treeContext;
          var totalChildren = 1;
          var index = 0;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
          try {
            renderNodeDestructive(request, task, children);
          } finally {
            task.treeContext = prevTreeContext;
          }
        } else {
          renderNodeDestructive(request, task, children);
        }
        popComponentStackInDEV(task);
      }
      function renderMemo(request, task, type145, props, ref5) {
        var innerType = type145.type;
        var resolvedProps = resolveDefaultProps(innerType, props);
        renderElement(request, task, innerType, resolvedProps, ref5);
      }
      function renderContextConsumer(request, task, context, props) {
        {
          if (context._context === undefined) {
            if (context !== context.Consumer) {
              if (!hasWarnedAboutUsingContextAsConsumer) {
                hasWarnedAboutUsingContextAsConsumer = true;
                error41("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
              }
            }
          } else {
            context = context._context;
          }
        }
        var render = props.children;
        {
          if (typeof render !== "function") {
            error41("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
          }
        }
        var newValue = readContext(context);
        var newChildren = render(newValue);
        renderNodeDestructive(request, task, newChildren);
      }
      function renderContextProvider(request, task, type145, props) {
        var context = type145._context;
        var value27 = props.value;
        var children = props.children;
        var prevSnapshot;
        {
          prevSnapshot = task.context;
        }
        task.context = pushProvider(context, value27);
        renderNodeDestructive(request, task, children);
        task.context = popProvider(context);
        {
          if (prevSnapshot !== task.context) {
            error41("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
          }
        }
      }
      function renderLazyComponent(request, task, lazyComponent, props, ref5) {
        pushBuiltInComponentStackInDEV(task, "Lazy");
        var payload = lazyComponent._payload;
        var init = lazyComponent._init;
        var Component = init(payload);
        var resolvedProps = resolveDefaultProps(Component, props);
        renderElement(request, task, Component, resolvedProps, ref5);
        popComponentStackInDEV(task);
      }
      function renderElement(request, task, type145, props, ref5) {
        if (typeof type145 === "function") {
          if (shouldConstruct$1(type145)) {
            renderClassComponent(request, task, type145, props);
            return;
          } else {
            renderIndeterminateComponent(request, task, type145, props);
            return;
          }
        }
        if (typeof type145 === "string") {
          renderHostElement(request, task, type145, props);
          return;
        }
        switch (type145) {
          case REACT_LEGACY_HIDDEN_TYPE:
          case REACT_DEBUG_TRACING_MODE_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_FRAGMENT_TYPE: {
            renderNodeDestructive(request, task, props.children);
            return;
          }
          case REACT_SUSPENSE_LIST_TYPE: {
            pushBuiltInComponentStackInDEV(task, "SuspenseList");
            renderNodeDestructive(request, task, props.children);
            popComponentStackInDEV(task);
            return;
          }
          case REACT_SCOPE_TYPE: {
            throw new Error("ReactDOMServer does not yet support scope components.");
          }
          case REACT_SUSPENSE_TYPE: {
            {
              renderSuspenseBoundary(request, task, props);
            }
            return;
          }
        }
        if (typeof type145 === "object" && type145 !== null) {
          switch (type145.$$typeof) {
            case REACT_FORWARD_REF_TYPE: {
              renderForwardRef(request, task, type145, props, ref5);
              return;
            }
            case REACT_MEMO_TYPE: {
              renderMemo(request, task, type145, props, ref5);
              return;
            }
            case REACT_PROVIDER_TYPE: {
              renderContextProvider(request, task, type145, props);
              return;
            }
            case REACT_CONTEXT_TYPE: {
              renderContextConsumer(request, task, type145, props);
              return;
            }
            case REACT_LAZY_TYPE: {
              renderLazyComponent(request, task, type145, props);
              return;
            }
          }
        }
        var info = "";
        {
          if (type145 === undefined || typeof type145 === "object" && type145 !== null && Object.keys(type145).length === 0) {
            info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          }
        }
        throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type145 == null ? type145 : typeof type145) + "." + info));
      }
      function validateIterable(iterable, iteratorFn) {
        {
          if (typeof Symbol === "function" && iterable[Symbol.toStringTag] === "Generator") {
            if (!didWarnAboutGenerators) {
              error41("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
            }
            didWarnAboutGenerators = true;
          }
          if (iterable.entries === iteratorFn) {
            if (!didWarnAboutMaps) {
              error41("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
            }
            didWarnAboutMaps = true;
          }
        }
      }
      function renderNodeDestructive(request, task, node) {
        {
          try {
            return renderNodeDestructiveImpl(request, task, node);
          } catch (x) {
            if (typeof x === "object" && x !== null && typeof x.then === "function")
              ;
            else {
              lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
            }
            throw x;
          }
        }
      }
      function renderNodeDestructiveImpl(request, task, node) {
        task.node = node;
        if (typeof node === "object" && node !== null) {
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              var element = node;
              var type145 = element.type;
              var props = element.props;
              var ref5 = element.ref;
              renderElement(request, task, type145, props, ref5);
              return;
            }
            case REACT_PORTAL_TYPE:
              throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
            case REACT_LAZY_TYPE: {
              var lazyNode = node;
              var payload = lazyNode._payload;
              var init = lazyNode._init;
              var resolvedNode;
              {
                try {
                  resolvedNode = init(payload);
                } catch (x) {
                  if (typeof x === "object" && x !== null && typeof x.then === "function") {
                    pushBuiltInComponentStackInDEV(task, "Lazy");
                  }
                  throw x;
                }
              }
              renderNodeDestructive(request, task, resolvedNode);
              return;
            }
          }
          if (isArray(node)) {
            renderChildrenArray(request, task, node);
            return;
          }
          var iteratorFn = getIteratorFn(node);
          if (iteratorFn) {
            {
              validateIterable(node, iteratorFn);
            }
            var iterator7 = iteratorFn.call(node);
            if (iterator7) {
              var step = iterator7.next();
              if (!step.done) {
                var children = [];
                do {
                  children.push(step.value);
                  step = iterator7.next();
                } while (!step.done);
                renderChildrenArray(request, task, children);
                return;
              }
              return;
            }
          }
          var childString = Object.prototype.toString.call(node);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
        }
        if (typeof node === "string") {
          var segment = task.blockedSegment;
          segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);
          return;
        }
        if (typeof node === "number") {
          var _segment = task.blockedSegment;
          _segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, "" + node, request.responseState, _segment.lastPushedText);
          return;
        }
        {
          if (typeof node === "function") {
            error41("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
          }
        }
      }
      function renderChildrenArray(request, task, children) {
        var totalChildren = children.length;
        for (var i = 0;i < totalChildren; i++) {
          var prevTreeContext = task.treeContext;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);
          try {
            renderNode(request, task, children[i]);
          } finally {
            task.treeContext = prevTreeContext;
          }
        }
      }
      function spawnNewSuspendedTask(request, task, x) {
        var segment = task.blockedSegment;
        var insertionIndex = segment.chunks.length;
        var newSegment = createPendingSegment(request, insertionIndex, null, segment.formatContext, segment.lastPushedText, true);
        segment.children.push(newSegment);
        segment.lastPushedText = false;
        var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
        {
          if (task.componentStack !== null) {
            newTask.componentStack = task.componentStack.parent;
          }
        }
        var ping = newTask.ping;
        x.then(ping, ping);
      }
      function renderNode(request, task, node) {
        var previousFormatContext = task.blockedSegment.formatContext;
        var previousLegacyContext = task.legacyContext;
        var previousContext = task.context;
        var previousComponentStack = null;
        {
          previousComponentStack = task.componentStack;
        }
        try {
          return renderNodeDestructive(request, task, node);
        } catch (x) {
          resetHooksState();
          if (typeof x === "object" && x !== null && typeof x.then === "function") {
            spawnNewSuspendedTask(request, task, x);
            task.blockedSegment.formatContext = previousFormatContext;
            task.legacyContext = previousLegacyContext;
            task.context = previousContext;
            switchContext(previousContext);
            {
              task.componentStack = previousComponentStack;
            }
            return;
          } else {
            task.blockedSegment.formatContext = previousFormatContext;
            task.legacyContext = previousLegacyContext;
            task.context = previousContext;
            switchContext(previousContext);
            {
              task.componentStack = previousComponentStack;
            }
            throw x;
          }
        }
      }
      function erroredTask(request, boundary, segment, error42) {
        var errorDigest = logRecoverableError(request, error42);
        if (boundary === null) {
          fatalError(request, error42);
        } else {
          boundary.pendingTasks--;
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true;
            boundary.errorDigest = errorDigest;
            {
              captureBoundaryErrorDetailsDev(boundary, error42);
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary);
            }
          }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function abortTaskSoft(task) {
        var request = this;
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        finishedTask(request, boundary, segment);
      }
      function abortTask(task, request, reason) {
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        if (boundary === null) {
          request.allPendingTasks--;
          if (request.status !== CLOSED) {
            request.status = CLOSED;
            if (request.destination !== null) {
              close(request.destination);
            }
          }
        } else {
          boundary.pendingTasks--;
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true;
            var _error = reason === undefined ? new Error("The render was aborted by the server without a reason.") : reason;
            boundary.errorDigest = request.onError(_error);
            {
              var errorPrefix = "The server did not finish this Suspense boundary: ";
              if (_error && typeof _error.message === "string") {
                _error = errorPrefix + _error.message;
              } else {
                _error = errorPrefix + String(_error);
              }
              var previousTaskInDev = currentTaskInDEV;
              currentTaskInDEV = task;
              try {
                captureBoundaryErrorDetailsDev(boundary, _error);
              } finally {
                currentTaskInDEV = previousTaskInDev;
              }
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary);
            }
          }
          boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, reason);
          });
          boundary.fallbackAbortableTasks.clear();
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
      }
      function queueCompletedSegment(boundary, segment) {
        if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
          var childSegment = segment.children[0];
          childSegment.id = segment.id;
          childSegment.parentFlushed = true;
          if (childSegment.status === COMPLETED) {
            queueCompletedSegment(boundary, childSegment);
          }
        } else {
          var completedSegments = boundary.completedSegments;
          completedSegments.push(segment);
        }
      }
      function finishedTask(request, boundary, segment) {
        if (boundary === null) {
          if (segment.parentFlushed) {
            if (request.completedRootSegment !== null) {
              throw new Error("There can only be one root segment. This is a bug in React.");
            }
            request.completedRootSegment = segment;
          }
          request.pendingRootTasks--;
          if (request.pendingRootTasks === 0) {
            request.onShellError = noop$1;
            var onShellReady = request.onShellReady;
            onShellReady();
          }
        } else {
          boundary.pendingTasks--;
          if (boundary.forceClientRender)
            ;
          else if (boundary.pendingTasks === 0) {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment);
              }
            }
            if (boundary.parentFlushed) {
              request.completedBoundaries.push(boundary);
            }
            boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
            boundary.fallbackAbortableTasks.clear();
          } else {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment);
                var completedSegments = boundary.completedSegments;
                if (completedSegments.length === 1) {
                  if (boundary.parentFlushed) {
                    request.partialBoundaries.push(boundary);
                  }
                }
              }
            }
          }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function retryTask(request, task) {
        var segment = task.blockedSegment;
        if (segment.status !== PENDING) {
          return;
        }
        switchContext(task.context);
        var prevTaskInDEV = null;
        {
          prevTaskInDEV = currentTaskInDEV;
          currentTaskInDEV = task;
        }
        try {
          renderNodeDestructive(request, task, task.node);
          pushSegmentFinale$1(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
          task.abortSet.delete(task);
          segment.status = COMPLETED;
          finishedTask(request, task.blockedBoundary, segment);
        } catch (x) {
          resetHooksState();
          if (typeof x === "object" && x !== null && typeof x.then === "function") {
            var ping = task.ping;
            x.then(ping, ping);
          } else {
            task.abortSet.delete(task);
            segment.status = ERRORED;
            erroredTask(request, task.blockedBoundary, segment, x);
          }
        } finally {
          {
            currentTaskInDEV = prevTaskInDEV;
          }
        }
      }
      function performWork(request) {
        if (request.status === CLOSED) {
          return;
        }
        var prevContext = getActiveContext();
        var prevDispatcher = ReactCurrentDispatcher$1.current;
        ReactCurrentDispatcher$1.current = Dispatcher;
        var prevGetCurrentStackImpl;
        {
          prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
          ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
        }
        var prevResponseState = currentResponseState;
        setCurrentResponseState(request.responseState);
        try {
          var pingedTasks = request.pingedTasks;
          var i;
          for (i = 0;i < pingedTasks.length; i++) {
            var task = pingedTasks[i];
            retryTask(request, task);
          }
          pingedTasks.splice(0, i);
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination);
          }
        } catch (error42) {
          logRecoverableError(request, error42);
          fatalError(request, error42);
        } finally {
          setCurrentResponseState(prevResponseState);
          ReactCurrentDispatcher$1.current = prevDispatcher;
          {
            ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
          }
          if (prevDispatcher === Dispatcher) {
            switchContext(prevContext);
          }
        }
      }
      function flushSubtree(request, destination, segment) {
        segment.parentFlushed = true;
        switch (segment.status) {
          case PENDING: {
            var segmentID = segment.id = request.nextSegmentId++;
            segment.lastPushedText = false;
            segment.textEmbedded = false;
            return writePlaceholder(destination, request.responseState, segmentID);
          }
          case COMPLETED: {
            segment.status = FLUSHED;
            var r = true;
            var chunks = segment.chunks;
            var chunkIdx = 0;
            var children = segment.children;
            for (var childIdx = 0;childIdx < children.length; childIdx++) {
              var nextChild = children[childIdx];
              for (;chunkIdx < nextChild.index; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx]);
              }
              r = flushSegment(request, destination, nextChild);
            }
            for (;chunkIdx < chunks.length - 1; chunkIdx++) {
              writeChunk(destination, chunks[chunkIdx]);
            }
            if (chunkIdx < chunks.length) {
              r = writeChunkAndReturn(destination, chunks[chunkIdx]);
            }
            return r;
          }
          default: {
            throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
          }
        }
      }
      function flushSegment(request, destination, segment) {
        var boundary = segment.boundary;
        if (boundary === null) {
          return flushSubtree(request, destination, segment);
        }
        boundary.parentFlushed = true;
        if (boundary.forceClientRender) {
          writeStartClientRenderedSuspenseBoundary$1(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
          flushSubtree(request, destination, segment);
          return writeEndClientRenderedSuspenseBoundary$1(destination, request.responseState);
        } else if (boundary.pendingTasks > 0) {
          boundary.rootSegmentID = request.nextSegmentId++;
          if (boundary.completedSegments.length > 0) {
            request.partialBoundaries.push(boundary);
          }
          var id = boundary.id = assignSuspenseBoundaryID(request.responseState);
          writeStartPendingSuspenseBoundary(destination, request.responseState, id);
          flushSubtree(request, destination, segment);
          return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else if (boundary.byteSize > request.progressiveChunkSize) {
          boundary.rootSegmentID = request.nextSegmentId++;
          request.completedBoundaries.push(boundary);
          writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id);
          flushSubtree(request, destination, segment);
          return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else {
          writeStartCompletedSuspenseBoundary$1(destination, request.responseState);
          var completedSegments = boundary.completedSegments;
          if (completedSegments.length !== 1) {
            throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
          }
          var contentSegment = completedSegments[0];
          flushSegment(request, destination, contentSegment);
          return writeEndCompletedSuspenseBoundary$1(destination, request.responseState);
        }
      }
      function flushClientRenderedBoundary(request, destination, boundary) {
        return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
      }
      function flushSegmentContainer(request, destination, segment) {
        writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
        flushSegment(request, destination, segment);
        return writeEndSegment(destination, segment.formatContext);
      }
      function flushCompletedBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for (;i < completedSegments.length; i++) {
          var segment = completedSegments[i];
          flushPartiallyCompletedSegment(request, destination, boundary, segment);
        }
        completedSegments.length = 0;
        return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
      }
      function flushPartialBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for (;i < completedSegments.length; i++) {
          var segment = completedSegments[i];
          if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
            i++;
            completedSegments.splice(0, i);
            return false;
          }
        }
        completedSegments.splice(0, i);
        return true;
      }
      function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED) {
          return true;
        }
        var segmentID = segment.id;
        if (segmentID === -1) {
          var rootSegmentID = segment.id = boundary.rootSegmentID;
          if (rootSegmentID === -1) {
            throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
          }
          return flushSegmentContainer(request, destination, segment);
        } else {
          flushSegmentContainer(request, destination, segment);
          return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
        }
      }
      function flushCompletedQueues(request, destination) {
        try {
          var completedRootSegment = request.completedRootSegment;
          if (completedRootSegment !== null && request.pendingRootTasks === 0) {
            flushSegment(request, destination, completedRootSegment);
            request.completedRootSegment = null;
            writeCompletedRoot(destination, request.responseState);
          }
          var clientRenderedBoundaries = request.clientRenderedBoundaries;
          var i;
          for (i = 0;i < clientRenderedBoundaries.length; i++) {
            var boundary = clientRenderedBoundaries[i];
            if (!flushClientRenderedBoundary(request, destination, boundary)) {
              request.destination = null;
              i++;
              clientRenderedBoundaries.splice(0, i);
              return;
            }
          }
          clientRenderedBoundaries.splice(0, i);
          var completedBoundaries = request.completedBoundaries;
          for (i = 0;i < completedBoundaries.length; i++) {
            var _boundary = completedBoundaries[i];
            if (!flushCompletedBoundary(request, destination, _boundary)) {
              request.destination = null;
              i++;
              completedBoundaries.splice(0, i);
              return;
            }
          }
          completedBoundaries.splice(0, i);
          completeWriting(destination);
          beginWriting(destination);
          var partialBoundaries = request.partialBoundaries;
          for (i = 0;i < partialBoundaries.length; i++) {
            var _boundary2 = partialBoundaries[i];
            if (!flushPartialBoundary(request, destination, _boundary2)) {
              request.destination = null;
              i++;
              partialBoundaries.splice(0, i);
              return;
            }
          }
          partialBoundaries.splice(0, i);
          var largeBoundaries = request.completedBoundaries;
          for (i = 0;i < largeBoundaries.length; i++) {
            var _boundary3 = largeBoundaries[i];
            if (!flushCompletedBoundary(request, destination, _boundary3)) {
              request.destination = null;
              i++;
              largeBoundaries.splice(0, i);
              return;
            }
          }
          largeBoundaries.splice(0, i);
        } finally {
          if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0) {
            {
              if (request.abortableTasks.size !== 0) {
                error41("There was still abortable task at the root when we closed. This is a bug in React.");
              }
            }
            close(destination);
          }
        }
      }
      function startWork(request) {
        scheduleWork(function() {
          return performWork(request);
        });
      }
      function startFlowing(request, destination) {
        if (request.status === CLOSING) {
          request.status = CLOSED;
          closeWithError(destination, request.fatalError);
          return;
        }
        if (request.status === CLOSED) {
          return;
        }
        if (request.destination !== null) {
          return;
        }
        request.destination = destination;
        try {
          flushCompletedQueues(request, destination);
        } catch (error42) {
          logRecoverableError(request, error42);
          fatalError(request, error42);
        }
      }
      function abort(request, reason) {
        try {
          var abortableTasks = request.abortableTasks;
          abortableTasks.forEach(function(task) {
            return abortTask(task, request, reason);
          });
          abortableTasks.clear();
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination);
          }
        } catch (error42) {
          logRecoverableError(request, error42);
          fatalError(request, error42);
        }
      }
      function onError() {
      }
      function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
        var didFatal = false;
        var fatalError2 = null;
        var result = "";
        var destination = {
          push: function(chunk) {
            if (chunk !== null) {
              result += chunk;
            }
            return true;
          },
          destroy: function(error42) {
            didFatal = true;
            fatalError2 = error42;
          }
        };
        var readyToStream = false;
        function onShellReady() {
          readyToStream = true;
        }
        var request = createRequest(children, createResponseState$1(generateStaticMarkup, options ? options.identifierPrefix : undefined), createRootFormatContext(), Infinity, onError, undefined, onShellReady, undefined, undefined);
        startWork(request);
        abort(request, abortReason);
        startFlowing(request, destination);
        if (didFatal) {
          throw fatalError2;
        }
        if (!readyToStream) {
          throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
        }
        return result;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var ReactMarkupReadableStream = function(_Readable) {
        _inheritsLoose(ReactMarkupReadableStream2, _Readable);
        function ReactMarkupReadableStream2() {
          var _this;
          _this = _Readable.call(this, {}) || this;
          _this.request = null;
          _this.startedFlowing = false;
          return _this;
        }
        var _proto = ReactMarkupReadableStream2.prototype;
        _proto._destroy = function _destroy(err, callback) {
          abort(this.request);
          callback(err);
        };
        _proto._read = function _read(size) {
          if (this.startedFlowing) {
            startFlowing(this.request, this);
          }
        };
        return ReactMarkupReadableStream2;
      }(stream.Readable);
      function onError$1() {
      }
      function renderToNodeStreamImpl(children, options, generateStaticMarkup) {
        function onAllReady() {
          destination.startedFlowing = true;
          startFlowing(request, destination);
        }
        var destination = new ReactMarkupReadableStream;
        var request = createRequest(children, createResponseState$1(false, options ? options.identifierPrefix : undefined), createRootFormatContext(), Infinity, onError$1, onAllReady, undefined, undefined);
        destination.request = request;
        startWork(request);
        return destination;
      }
      function renderToNodeStream(children, options) {
        {
          error41("renderToNodeStream is deprecated. Use renderToPipeableStream instead.");
        }
        return renderToNodeStreamImpl(children, options);
      }
      function renderToStaticNodeStream(children, options) {
        return renderToNodeStreamImpl(children, options);
      }
      function renderToString(children, options) {
        return renderToStringImpl(children, options, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
      }
      function renderToStaticMarkup(children, options) {
        return renderToStringImpl(children, options, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
      }
      exports.renderToNodeStream = renderToNodeStream;
      exports.renderToStaticMarkup = renderToStaticMarkup;
      exports.renderToStaticNodeStream = renderToStaticNodeStream;
      exports.renderToString = renderToString;
      exports.version = ReactVersion;
    })();
  }
});

// ../sisventa/node_modules/react-dom/cjs/react-dom-server.node.development.js
import * as util from "util";
var require_react_dom_server_node_development = __commonJS((exports) => {
  var React = __toESM(require_react(), 1);
  if (true) {
    (function() {
      var ReactVersion = "18.2.0";
      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function warn(format) {
        {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
      }
      function error41(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function scheduleWork(callback) {
        setImmediate(callback);
      }
      function flushBuffered(destination) {
        if (typeof destination.flush === "function") {
          destination.flush();
        }
      }
      var VIEW_SIZE = 2048;
      var currentView = null;
      var writtenBytes = 0;
      var destinationHasCapacity = true;
      function beginWriting(destination) {
        currentView = new Uint8Array(VIEW_SIZE);
        writtenBytes = 0;
        destinationHasCapacity = true;
      }
      function writeStringChunk(destination, stringChunk) {
        if (stringChunk.length === 0) {
          return;
        }
        if (stringChunk.length * 3 > VIEW_SIZE) {
          if (writtenBytes > 0) {
            writeToDestination(destination, currentView.subarray(0, writtenBytes));
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
          }
          writeToDestination(destination, textEncoder.encode(stringChunk));
          return;
        }
        var target = currentView;
        if (writtenBytes > 0) {
          target = currentView.subarray(writtenBytes);
        }
        var _textEncoder$encodeIn = textEncoder.encodeInto(stringChunk, target), read = _textEncoder$encodeIn.read, written = _textEncoder$encodeIn.written;
        writtenBytes += written;
        if (read < stringChunk.length) {
          writeToDestination(destination, currentView);
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = textEncoder.encodeInto(stringChunk.slice(read), currentView).written;
        }
        if (writtenBytes === VIEW_SIZE) {
          writeToDestination(destination, currentView);
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = 0;
        }
      }
      function writeViewChunk(destination, chunk) {
        if (chunk.byteLength === 0) {
          return;
        }
        if (chunk.byteLength > VIEW_SIZE) {
          if (writtenBytes > 0) {
            writeToDestination(destination, currentView.subarray(0, writtenBytes));
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
          }
          writeToDestination(destination, chunk);
          return;
        }
        var bytesToWrite = chunk;
        var allowableBytes = currentView.length - writtenBytes;
        if (allowableBytes < bytesToWrite.byteLength) {
          if (allowableBytes === 0) {
            writeToDestination(destination, currentView);
          } else {
            currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);
            writtenBytes += allowableBytes;
            writeToDestination(destination, currentView);
            bytesToWrite = bytesToWrite.subarray(allowableBytes);
          }
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = 0;
        }
        currentView.set(bytesToWrite, writtenBytes);
        writtenBytes += bytesToWrite.byteLength;
        if (writtenBytes === VIEW_SIZE) {
          writeToDestination(destination, currentView);
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = 0;
        }
      }
      function writeChunk(destination, chunk) {
        if (typeof chunk === "string") {
          writeStringChunk(destination, chunk);
        } else {
          writeViewChunk(destination, chunk);
        }
      }
      function writeToDestination(destination, view) {
        var currentHasCapacity = destination.write(view);
        destinationHasCapacity = destinationHasCapacity && currentHasCapacity;
      }
      function writeChunkAndReturn(destination, chunk) {
        writeChunk(destination, chunk);
        return destinationHasCapacity;
      }
      function completeWriting(destination) {
        if (currentView && writtenBytes > 0) {
          destination.write(currentView.subarray(0, writtenBytes));
        }
        currentView = null;
        writtenBytes = 0;
        destinationHasCapacity = true;
      }
      function close(destination) {
        destination.end();
      }
      var textEncoder = new util.TextEncoder;
      function stringToChunk(content) {
        return content;
      }
      function stringToPrecomputedChunk(content) {
        return textEncoder.encode(content);
      }
      function closeWithError(destination, error42) {
        destination.destroy(error42);
      }
      function typeName(value27) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type145 = hasToStringTag && value27[Symbol.toStringTag] || value27.constructor.name || "Object";
          return type145;
        }
      }
      function willCoercionThrow(value27) {
        {
          try {
            testStringCoercion(value27);
            return false;
          } catch (e3) {
            return true;
          }
        }
      }
      function testStringCoercion(value27) {
        return "" + value27;
      }
      function checkAttributeStringCoercion(value27, attributeName) {
        {
          if (willCoercionThrow(value27)) {
            error41("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value27));
            return testStringCoercion(value27);
          }
        }
      }
      function checkCSSPropertyStringCoercion(value27, propName) {
        {
          if (willCoercionThrow(value27)) {
            error41("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value27));
            return testStringCoercion(value27);
          }
        }
      }
      function checkHtmlStringCoercion(value27) {
        {
          if (willCoercionThrow(value27)) {
            error41("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value27));
            return testStringCoercion(value27);
          }
        }
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var RESERVED = 0;
      var STRING = 1;
      var BOOLEANISH_STRING = 2;
      var BOOLEAN = 3;
      var OVERLOADED_BOOLEAN = 4;
      var NUMERIC = 5;
      var POSITIVE_NUMERIC = 6;
      var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
      var illegalAttributeNameCache = {};
      var validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
          return true;
        }
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
          return false;
        }
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
          validatedAttributeNameCache[attributeName] = true;
          return true;
        }
        illegalAttributeNameCache[attributeName] = true;
        {
          error41("Invalid attribute name: `%s`", attributeName);
        }
        return false;
      }
      function shouldRemoveAttributeWithWarning(name, value27, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED) {
          return false;
        }
        switch (typeof value27) {
          case "function":
          case "symbol":
            return true;
          case "boolean": {
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              return !propertyInfo.acceptsBooleans;
            } else {
              var prefix2 = name.toLowerCase().slice(0, 5);
              return prefix2 !== "data-" && prefix2 !== "aria-";
            }
          }
          default:
            return false;
        }
      }
      function getPropertyInfo(name) {
        return properties.hasOwnProperty(name) ? properties[name] : null;
      }
      function PropertyInfoRecord(name, type145, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
        this.acceptsBooleans = type145 === BOOLEANISH_STRING || type145 === BOOLEAN || type145 === OVERLOADED_BOOLEAN;
        this.attributeName = attributeName;
        this.attributeNamespace = attributeNamespace;
        this.mustUseProperty = mustUseProperty;
        this.propertyName = name;
        this.type = type145;
        this.sanitizeURL = sanitizeURL2;
        this.removeEmptyString = removeEmptyString;
      }
      var properties = {};
      var reservedProps = [
        "children",
        "dangerouslySetInnerHTML",
        "defaultValue",
        "defaultChecked",
        "innerHTML",
        "suppressContentEditableWarning",
        "suppressHydrationWarning",
        "style"
      ];
      reservedProps.forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
        var name = _ref[0], attributeName = _ref[1];
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
      });
      [
        "allowFullScreen",
        "async",
        "autoFocus",
        "autoPlay",
        "controls",
        "default",
        "defer",
        "disabled",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "formNoValidate",
        "hidden",
        "loop",
        "noModule",
        "noValidate",
        "open",
        "playsInline",
        "readOnly",
        "required",
        "reversed",
        "scoped",
        "seamless",
        "itemScope"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
      });
      [
        "checked",
        "multiple",
        "muted",
        "selected"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
      });
      [
        "capture",
        "download"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
      });
      [
        "cols",
        "rows",
        "size",
        "span"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
      });
      var CAMELIZE = /[\-\:]([a-z])/g;
      var capitalize3 = function(token) {
        return token[1].toUpperCase();
      };
      [
        "accent-height",
        "alignment-baseline",
        "arabic-form",
        "baseline-shift",
        "cap-height",
        "clip-path",
        "clip-rule",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-name",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "horiz-adv-x",
        "horiz-origin-x",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "overline-position",
        "overline-thickness",
        "paint-order",
        "panose-1",
        "pointer-events",
        "rendering-intent",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "strikethrough-position",
        "strikethrough-thickness",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "underline-position",
        "underline-thickness",
        "unicode-bidi",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "vector-effect",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "word-spacing",
        "writing-mode",
        "xmlns:xlink",
        "x-height"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize3);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
      });
      [
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize3);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
      });
      [
        "xml:base",
        "xml:lang",
        "xml:space"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize3);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
      });
      var xlinkHref = "xlinkHref";
      properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
      });
      var isUnitlessNumber = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      function prefixKey(prefix2, key) {
        return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
      }
      var prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
        });
      });
      var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      };
      function checkControlledValueProps(tagName, props) {
        {
          if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
            error41("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
          }
          if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
            error41("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
          }
        }
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf("-") === -1) {
          return typeof props.is === "string";
        }
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      };
      var warnedProperties = {};
      var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
      var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
      function validateProperty(tagName, name) {
        {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
            return true;
          }
          if (rARIACamel.test(name)) {
            var ariaName = "aria-" + name.slice(4).toLowerCase();
            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (correctName == null) {
              error41("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
              warnedProperties[name] = true;
              return true;
            }
            if (name !== correctName) {
              error41("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
              warnedProperties[name] = true;
              return true;
            }
          }
          if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase();
            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (standardName == null) {
              warnedProperties[name] = true;
              return false;
            }
            if (name !== standardName) {
              error41("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
              warnedProperties[name] = true;
              return true;
            }
          }
        }
        return true;
      }
      function warnInvalidARIAProps(type145, props) {
        {
          var invalidProps = [];
          for (var key in props) {
            var isValid = validateProperty(type145, key);
            if (!isValid) {
              invalidProps.push(key);
            }
          }
          var unknownPropString = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (invalidProps.length === 1) {
            error41("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type145);
          } else if (invalidProps.length > 1) {
            error41("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type145);
          }
        }
      }
      function validateProperties(type145, props) {
        if (isCustomComponent(type145, props)) {
          return;
        }
        warnInvalidARIAProps(type145, props);
      }
      var didWarnValueNull = false;
      function validateProperties$1(type145, props) {
        {
          if (type145 !== "input" && type145 !== "textarea" && type145 !== "select") {
            return;
          }
          if (props != null && props.value === null && !didWarnValueNull) {
            didWarnValueNull = true;
            if (type145 === "select" && props.multiple) {
              error41("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type145);
            } else {
              error41("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type145);
            }
          }
        }
      }
      var possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      };
      var validateProperty$1 = function() {
      };
      {
        var warnedProperties$1 = {};
        var EVENT_NAME_REGEX = /^on./;
        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
        var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        validateProperty$1 = function(tagName, name, value27, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
            return true;
          }
          var lowerCasedName = name.toLowerCase();
          if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
            error41("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (eventRegistry != null) {
            var { registrationNameDependencies, possibleRegistrationNames } = eventRegistry;
            if (registrationNameDependencies.hasOwnProperty(name)) {
              return true;
            }
            var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
            if (registrationName != null) {
              error41("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (EVENT_NAME_REGEX.test(name)) {
              error41("Unknown event handler property `%s`. It will be ignored.", name);
              warnedProperties$1[name] = true;
              return true;
            }
          } else if (EVENT_NAME_REGEX.test(name)) {
            if (INVALID_EVENT_NAME_REGEX.test(name)) {
              error41("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
            }
            warnedProperties$1[name] = true;
            return true;
          }
          if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
            return true;
          }
          if (lowerCasedName === "innerhtml") {
            error41("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (lowerCasedName === "aria") {
            error41("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (lowerCasedName === "is" && value27 !== null && value27 !== undefined && typeof value27 !== "string") {
            error41("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value27);
            warnedProperties$1[name] = true;
            return true;
          }
          if (typeof value27 === "number" && isNaN(value27)) {
            error41("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
            warnedProperties$1[name] = true;
            return true;
          }
          var propertyInfo = getPropertyInfo(name);
          var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name) {
              error41("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
              warnedProperties$1[name] = true;
              return true;
            }
          } else if (!isReserved && name !== lowerCasedName) {
            error41("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
            warnedProperties$1[name] = true;
            return true;
          }
          if (typeof value27 === "boolean" && shouldRemoveAttributeWithWarning(name, value27, propertyInfo, false)) {
            if (value27) {
              error41('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value27, name, name, value27, name);
            } else {
              error41('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value27, name, name, value27, name, name, name);
            }
            warnedProperties$1[name] = true;
            return true;
          }
          if (isReserved) {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name, value27, propertyInfo, false)) {
            warnedProperties$1[name] = true;
            return false;
          }
          if ((value27 === "false" || value27 === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
            error41("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value27, name, value27 === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value27);
            warnedProperties$1[name] = true;
            return true;
          }
          return true;
        };
      }
      var warnUnknownProperties = function(type145, props, eventRegistry) {
        {
          var unknownProps = [];
          for (var key in props) {
            var isValid = validateProperty$1(type145, key, props[key], eventRegistry);
            if (!isValid) {
              unknownProps.push(key);
            }
          }
          var unknownPropString = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (unknownProps.length === 1) {
            error41("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type145);
          } else if (unknownProps.length > 1) {
            error41("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type145);
          }
        }
      };
      function validateProperties$2(type145, props, eventRegistry) {
        if (isCustomComponent(type145, props)) {
          return;
        }
        warnUnknownProperties(type145, props, eventRegistry);
      }
      var warnValidStyle = function() {
      };
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
        var msPattern = /^-ms-/;
        var hyphenPattern = /-(.)/g;
        var badStyleValueWithSemicolonPattern = /;\s*$/;
        var warnedStyleNames = {};
        var warnedStyleValues = {};
        var warnedForNaNValue = false;
        var warnedForInfinityValue = false;
        var camelize = function(string11) {
          return string11.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        };
        var warnHyphenatedStyleName = function(name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return;
          }
          warnedStyleNames[name] = true;
          error41("Unsupported style property %s. Did you mean %s?", name, camelize(name.replace(msPattern, "ms-")));
        };
        var warnBadVendoredStyleName = function(name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return;
          }
          warnedStyleNames[name] = true;
          error41("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
        };
        var warnStyleValueWithSemicolon = function(name, value27) {
          if (warnedStyleValues.hasOwnProperty(value27) && warnedStyleValues[value27]) {
            return;
          }
          warnedStyleValues[value27] = true;
          error41(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value27.replace(badStyleValueWithSemicolonPattern, ""));
        };
        var warnStyleValueIsNaN = function(name, value27) {
          if (warnedForNaNValue) {
            return;
          }
          warnedForNaNValue = true;
          error41("`NaN` is an invalid value for the `%s` css style property.", name);
        };
        var warnStyleValueIsInfinity = function(name, value27) {
          if (warnedForInfinityValue) {
            return;
          }
          warnedForInfinityValue = true;
          error41("`Infinity` is an invalid value for the `%s` css style property.", name);
        };
        warnValidStyle = function(name, value27) {
          if (name.indexOf("-") > -1) {
            warnHyphenatedStyleName(name);
          } else if (badVendoredStyleNamePattern.test(name)) {
            warnBadVendoredStyleName(name);
          } else if (badStyleValueWithSemicolonPattern.test(value27)) {
            warnStyleValueWithSemicolon(name, value27);
          }
          if (typeof value27 === "number") {
            if (isNaN(value27)) {
              warnStyleValueIsNaN(name, value27);
            } else if (!isFinite(value27)) {
              warnStyleValueIsInfinity(name, value27);
            }
          }
        };
      }
      var warnValidStyle$1 = warnValidStyle;
      var matchHtmlRegExp = /["'&<>]/;
      function escapeHtml(string11) {
        {
          checkHtmlStringCoercion(string11);
        }
        var str = "" + string11;
        var match = matchHtmlRegExp.exec(str);
        if (!match) {
          return str;
        }
        var escape;
        var html = "";
        var index;
        var lastIndex = 0;
        for (index = match.index;index < str.length; index++) {
          switch (str.charCodeAt(index)) {
            case 34:
              escape = "&quot;";
              break;
            case 38:
              escape = "&amp;";
              break;
            case 39:
              escape = "&#x27;";
              break;
            case 60:
              escape = "&lt;";
              break;
            case 62:
              escape = "&gt;";
              break;
            default:
              continue;
          }
          if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
          }
          lastIndex = index + 1;
          html += escape;
        }
        return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
      }
      function escapeTextForBrowser(text) {
        if (typeof text === "boolean" || typeof text === "number") {
          return "" + text;
        }
        return escapeHtml(text);
      }
      var uppercasePattern = /([A-Z])/g;
      var msPattern$1 = /^ms-/;
      function hyphenateStyleName(name) {
        return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
      }
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
      var didWarn = false;
      function sanitizeURL(url) {
        {
          if (!didWarn && isJavaScriptProtocol.test(url)) {
            didWarn = true;
            error41("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a3) {
        return isArrayImpl(a3);
      }
      var startInlineScript = stringToPrecomputedChunk("<script>");
      var endInlineScript = stringToPrecomputedChunk("</script>");
      var startScriptSrc = stringToPrecomputedChunk('<script src="');
      var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
      var endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
      function escapeBootstrapScriptContent(scriptText) {
        {
          checkHtmlStringCoercion(scriptText);
        }
        return ("" + scriptText).replace(scriptRegex, scriptReplacer);
      }
      var scriptRegex = /(<\/|<)(s)(cript)/gi;
      var scriptReplacer = function(match, prefix2, s3, suffix) {
        return "" + prefix2 + (s3 === "s" ? "\\u0073" : "\\u0053") + suffix;
      };
      function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        var idPrefix = identifierPrefix === undefined ? "" : identifierPrefix;
        var inlineScriptWithNonce = nonce === undefined ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
        var bootstrapChunks = [];
        if (bootstrapScriptContent !== undefined) {
          bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
        }
        if (bootstrapScripts !== undefined) {
          for (var i = 0;i < bootstrapScripts.length; i++) {
            bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);
          }
        }
        if (bootstrapModules !== undefined) {
          for (var _i = 0;_i < bootstrapModules.length; _i++) {
            bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
          }
        }
        return {
          bootstrapChunks,
          startInlineScript: inlineScriptWithNonce,
          placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
          segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
          boundaryPrefix: idPrefix + "B:",
          idPrefix,
          nextSuspenseID: 0,
          sentCompleteSegmentFunction: false,
          sentCompleteBoundaryFunction: false,
          sentClientRenderFunction: false
        };
      }
      var ROOT_HTML_MODE = 0;
      var HTML_MODE = 1;
      var SVG_MODE = 2;
      var MATHML_MODE = 3;
      var HTML_TABLE_MODE = 4;
      var HTML_TABLE_BODY_MODE = 5;
      var HTML_TABLE_ROW_MODE = 6;
      var HTML_COLGROUP_MODE = 7;
      function createFormatContext(insertionMode, selectedValue) {
        return {
          insertionMode,
          selectedValue
        };
      }
      function createRootFormatContext(namespaceURI) {
        var insertionMode = namespaceURI === "http://www.w3.org/2000/svg" ? SVG_MODE : namespaceURI === "http://www.w3.org/1998/Math/MathML" ? MATHML_MODE : ROOT_HTML_MODE;
        return createFormatContext(insertionMode, null);
      }
      function getChildFormatContext(parentContext, type145, props) {
        switch (type145) {
          case "select":
            return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
          case "svg":
            return createFormatContext(SVG_MODE, null);
          case "math":
            return createFormatContext(MATHML_MODE, null);
          case "foreignObject":
            return createFormatContext(HTML_MODE, null);
          case "table":
            return createFormatContext(HTML_TABLE_MODE, null);
          case "thead":
          case "tbody":
          case "tfoot":
            return createFormatContext(HTML_TABLE_BODY_MODE, null);
          case "colgroup":
            return createFormatContext(HTML_COLGROUP_MODE, null);
          case "tr":
            return createFormatContext(HTML_TABLE_ROW_MODE, null);
        }
        if (parentContext.insertionMode >= HTML_TABLE_MODE) {
          return createFormatContext(HTML_MODE, null);
        }
        if (parentContext.insertionMode === ROOT_HTML_MODE) {
          return createFormatContext(HTML_MODE, null);
        }
        return parentContext;
      }
      var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
      function assignSuspenseBoundaryID(responseState) {
        var generatedID = responseState.nextSuspenseID++;
        return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
      }
      function makeId(responseState, treeId, localId) {
        var idPrefix = responseState.idPrefix;
        var id = ":" + idPrefix + "R" + treeId;
        if (localId > 0) {
          id += "H" + localId.toString(32);
        }
        return id + ":";
      }
      function encodeHTMLTextNode(text) {
        return escapeTextForBrowser(text);
      }
      var textSeparator = stringToPrecomputedChunk("<!-- -->");
      function pushTextInstance(target, text, responseState, textEmbedded) {
        if (text === "") {
          return textEmbedded;
        }
        if (textEmbedded) {
          target.push(textSeparator);
        }
        target.push(stringToChunk(encodeHTMLTextNode(text)));
        return true;
      }
      function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
        if (lastPushedText && textEmbedded) {
          target.push(textSeparator);
        }
      }
      var styleNameCache = new Map;
      function processStyleName(styleName) {
        var chunk = styleNameCache.get(styleName);
        if (chunk !== undefined) {
          return chunk;
        }
        var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
        styleNameCache.set(styleName, result);
        return result;
      }
      var styleAttributeStart = stringToPrecomputedChunk(' style="');
      var styleAssign = stringToPrecomputedChunk(":");
      var styleSeparator = stringToPrecomputedChunk(";");
      function pushStyle(target, responseState, style) {
        if (typeof style !== "object") {
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        }
        var isFirst = true;
        for (var styleName in style) {
          if (!hasOwnProperty.call(style, styleName)) {
            continue;
          }
          var styleValue = style[styleName];
          if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
            continue;
          }
          var nameChunk = undefined;
          var valueChunk = undefined;
          var isCustomProperty = styleName.indexOf("--") === 0;
          if (isCustomProperty) {
            nameChunk = stringToChunk(escapeTextForBrowser(styleName));
            {
              checkCSSPropertyStringCoercion(styleValue, styleName);
            }
            valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
          } else {
            {
              warnValidStyle$1(styleName, styleValue);
            }
            nameChunk = processStyleName(styleName);
            if (typeof styleValue === "number") {
              if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {
                valueChunk = stringToChunk(styleValue + "px");
              } else {
                valueChunk = stringToChunk("" + styleValue);
              }
            } else {
              {
                checkCSSPropertyStringCoercion(styleValue, styleName);
              }
              valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
            }
          }
          if (isFirst) {
            isFirst = false;
            target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
          } else {
            target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
          }
        }
        if (!isFirst) {
          target.push(attributeEnd);
        }
      }
      var attributeSeparator = stringToPrecomputedChunk(" ");
      var attributeAssign = stringToPrecomputedChunk('="');
      var attributeEnd = stringToPrecomputedChunk('"');
      var attributeEmptyString = stringToPrecomputedChunk('=""');
      function pushAttribute(target, responseState, name, value27) {
        switch (name) {
          case "style": {
            pushStyle(target, responseState, value27);
            return;
          }
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            return;
        }
        if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
          return;
        }
        var propertyInfo = getPropertyInfo(name);
        if (propertyInfo !== null) {
          switch (typeof value27) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              if (!propertyInfo.acceptsBooleans) {
                return;
              }
            }
          }
          var attributeName = propertyInfo.attributeName;
          var attributeNameChunk = stringToChunk(attributeName);
          switch (propertyInfo.type) {
            case BOOLEAN:
              if (value27) {
                target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
              }
              return;
            case OVERLOADED_BOOLEAN:
              if (value27 === true) {
                target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
              } else if (value27 === false)
                ;
              else {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value27)), attributeEnd);
              }
              return;
            case NUMERIC:
              if (!isNaN(value27)) {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value27)), attributeEnd);
              }
              break;
            case POSITIVE_NUMERIC:
              if (!isNaN(value27) && value27 >= 1) {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value27)), attributeEnd);
              }
              break;
            default:
              if (propertyInfo.sanitizeURL) {
                {
                  checkAttributeStringCoercion(value27, attributeName);
                }
                value27 = "" + value27;
                sanitizeURL(value27);
              }
              target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value27)), attributeEnd);
          }
        } else if (isAttributeNameSafe(name)) {
          switch (typeof value27) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var prefix2 = name.toLowerCase().slice(0, 5);
              if (prefix2 !== "data-" && prefix2 !== "aria-") {
                return;
              }
            }
          }
          target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value27)), attributeEnd);
        }
      }
      var endOfStartTag = stringToPrecomputedChunk(">");
      var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
      function pushInnerHTML(target, innerHTML, children) {
        if (innerHTML != null) {
          if (children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          }
          var html = innerHTML.__html;
          if (html !== null && html !== undefined) {
            {
              checkHtmlStringCoercion(html);
            }
            target.push(stringToChunk("" + html));
          }
        }
      }
      var didWarnDefaultInputValue = false;
      var didWarnDefaultChecked = false;
      var didWarnDefaultSelectValue = false;
      var didWarnDefaultTextareaValue = false;
      var didWarnInvalidOptionChildren = false;
      var didWarnInvalidOptionInnerHTML = false;
      var didWarnSelectedSetOnOption = false;
      function checkSelectProp(props, propName) {
        {
          var value27 = props[propName];
          if (value27 != null) {
            var array7 = isArray(value27);
            if (props.multiple && !array7) {
              error41("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
            } else if (!props.multiple && array7) {
              error41("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
            }
          }
        }
      }
      function pushStartSelect(target, props, responseState) {
        {
          checkControlledValueProps("select", props);
          checkSelectProp(props, "value");
          checkSelectProp(props, "defaultValue");
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {
            error41("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnDefaultSelectValue = true;
          }
        }
        target.push(startChunkForTag("select"));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "defaultValue":
              case "value":
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      function flattenOptionChildren(children) {
        var content = "";
        React.Children.forEach(children, function(child) {
          if (child == null) {
            return;
          }
          content += child;
          {
            if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
              didWarnInvalidOptionChildren = true;
              error41("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
            }
          }
        });
        return content;
      }
      var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
      function pushStartOption(target, props, responseState, formatContext) {
        var selectedValue = formatContext.selectedValue;
        target.push(startChunkForTag("option"));
        var children = null;
        var value27 = null;
        var selected = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "selected":
                selected = propValue;
                {
                  if (!didWarnSelectedSetOnOption) {
                    error41("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                    didWarnSelectedSetOnOption = true;
                  }
                }
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "value":
                value27 = propValue;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (selectedValue != null) {
          var stringValue;
          if (value27 !== null) {
            {
              checkAttributeStringCoercion(value27, "value");
            }
            stringValue = "" + value27;
          } else {
            {
              if (innerHTML !== null) {
                if (!didWarnInvalidOptionInnerHTML) {
                  didWarnInvalidOptionInnerHTML = true;
                  error41("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                }
              }
            }
            stringValue = flattenOptionChildren(children);
          }
          if (isArray(selectedValue)) {
            for (var i = 0;i < selectedValue.length; i++) {
              {
                checkAttributeStringCoercion(selectedValue[i], "value");
              }
              var v3 = "" + selectedValue[i];
              if (v3 === stringValue) {
                target.push(selectedMarkerAttribute);
                break;
              }
            }
          } else {
            {
              checkAttributeStringCoercion(selectedValue, "select.value");
            }
            if ("" + selectedValue === stringValue) {
              target.push(selectedMarkerAttribute);
            }
          }
        } else if (selected) {
          target.push(selectedMarkerAttribute);
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      function pushInput(target, props, responseState) {
        {
          checkControlledValueProps("input", props);
          if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnDefaultChecked) {
            error41("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
            didWarnDefaultChecked = true;
          }
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultInputValue) {
            error41("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
            didWarnDefaultInputValue = true;
          }
        }
        target.push(startChunkForTag("input"));
        var value27 = null;
        var defaultValue = null;
        var checked = null;
        var defaultChecked = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              case "defaultChecked":
                defaultChecked = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "checked":
                checked = propValue;
                break;
              case "value":
                value27 = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (checked !== null) {
          pushAttribute(target, responseState, "checked", checked);
        } else if (defaultChecked !== null) {
          pushAttribute(target, responseState, "checked", defaultChecked);
        }
        if (value27 !== null) {
          pushAttribute(target, responseState, "value", value27);
        } else if (defaultValue !== null) {
          pushAttribute(target, responseState, "value", defaultValue);
        }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function pushStartTextArea(target, props, responseState) {
        {
          checkControlledValueProps("textarea", props);
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {
            error41("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnDefaultTextareaValue = true;
          }
        }
        target.push(startChunkForTag("textarea"));
        var value27 = null;
        var defaultValue = null;
        var children = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "value":
                value27 = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (value27 === null && defaultValue !== null) {
          value27 = defaultValue;
        }
        target.push(endOfStartTag);
        if (children != null) {
          {
            error41("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          }
          if (value27 != null) {
            throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          }
          if (isArray(children)) {
            if (children.length > 1) {
              throw new Error("<textarea> can only have at most one child.");
            }
            {
              checkHtmlStringCoercion(children[0]);
            }
            value27 = "" + children[0];
          }
          {
            checkHtmlStringCoercion(children);
          }
          value27 = "" + children;
        }
        if (typeof value27 === "string" && value27[0] === "\n") {
          target.push(leadingNewline);
        }
        if (value27 !== null) {
          {
            checkAttributeStringCoercion(value27, "value");
          }
          target.push(stringToChunk(encodeHTMLTextNode("" + value27)));
        }
        return null;
      }
      function pushSelfClosing(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function pushStartMenuItem(target, props, responseState) {
        target.push(startChunkForTag("menuitem"));
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        return null;
      }
      function pushStartTitle(target, props, responseState) {
        target.push(startChunkForTag("title"));
        var children = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        {
          var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
          if (Array.isArray(children) && children.length > 1) {
            error41("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
          } else if (child != null && child.$$typeof != null) {
            error41("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
          } else if (child != null && typeof child !== "string" && typeof child !== "number") {
            error41("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
          }
        }
        return children;
      }
      function pushStartGenericElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        if (typeof children === "string") {
          target.push(stringToChunk(encodeHTMLTextNode(children)));
          return null;
        }
        return children;
      }
      function pushStartCustomElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "style":
                pushStyle(target, responseState, propValue);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                  target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                }
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      var leadingNewline = stringToPrecomputedChunk("\n");
      function pushStartPreformattedElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        if (innerHTML != null) {
          if (children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          }
          var html = innerHTML.__html;
          if (html !== null && html !== undefined) {
            if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
              target.push(leadingNewline, stringToChunk(html));
            } else {
              {
                checkHtmlStringCoercion(html);
              }
              target.push(stringToChunk("" + html));
            }
          }
        }
        if (typeof children === "string" && children[0] === "\n") {
          target.push(leadingNewline);
        }
        return children;
      }
      var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
      var validatedTagCache = new Map;
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (tagStartChunk === undefined) {
          if (!VALID_TAG_REGEX.test(tag)) {
            throw new Error("Invalid tag: " + tag);
          }
          tagStartChunk = stringToPrecomputedChunk("<" + tag);
          validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
      }
      var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
      function pushStartInstance(target, type145, props, responseState, formatContext) {
        {
          validateProperties(type145, props);
          validateProperties$1(type145, props);
          validateProperties$2(type145, props, null);
          if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
            error41("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
          }
          if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
            if (type145.indexOf("-") === -1 && typeof props.is !== "string" && type145.toLowerCase() !== type145) {
              error41("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type145);
            }
          }
        }
        switch (type145) {
          case "select":
            return pushStartSelect(target, props, responseState);
          case "option":
            return pushStartOption(target, props, responseState, formatContext);
          case "textarea":
            return pushStartTextArea(target, props, responseState);
          case "input":
            return pushInput(target, props, responseState);
          case "menuitem":
            return pushStartMenuItem(target, props, responseState);
          case "title":
            return pushStartTitle(target, props, responseState);
          case "listing":
          case "pre": {
            return pushStartPreformattedElement(target, props, type145, responseState);
          }
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr": {
            return pushSelfClosing(target, props, type145, responseState);
          }
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph": {
            return pushStartGenericElement(target, props, type145, responseState);
          }
          case "html": {
            if (formatContext.insertionMode === ROOT_HTML_MODE) {
              target.push(DOCTYPE);
            }
            return pushStartGenericElement(target, props, type145, responseState);
          }
          default: {
            if (type145.indexOf("-") === -1 && typeof props.is !== "string") {
              return pushStartGenericElement(target, props, type145, responseState);
            } else {
              return pushStartCustomElement(target, props, type145, responseState);
            }
          }
        }
      }
      var endTag1 = stringToPrecomputedChunk("</");
      var endTag2 = stringToPrecomputedChunk(">");
      function pushEndInstance(target, type145, props) {
        switch (type145) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr": {
            break;
          }
          default: {
            target.push(endTag1, stringToChunk(type145), endTag2);
          }
        }
      }
      function writeCompletedRoot(destination, responseState) {
        var bootstrapChunks = responseState.bootstrapChunks;
        var i = 0;
        for (;i < bootstrapChunks.length - 1; i++) {
          writeChunk(destination, bootstrapChunks[i]);
        }
        if (i < bootstrapChunks.length) {
          return writeChunkAndReturn(destination, bootstrapChunks[i]);
        }
        return true;
      }
      var placeholder1 = stringToPrecomputedChunk('<template id="');
      var placeholder2 = stringToPrecomputedChunk('"></template>');
      function writePlaceholder(destination, responseState, id) {
        writeChunk(destination, placeholder1);
        writeChunk(destination, responseState.placeholderPrefix);
        var formattedID = stringToChunk(id.toString(16));
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, placeholder2);
      }
      var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
      var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
      var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
      var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
      var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
      var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
      var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
      var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
      var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
      var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
      var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
      function writeStartCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
      }
      function writeStartPendingSuspenseBoundary(destination, responseState, id) {
        writeChunk(destination, startPendingSuspenseBoundary1);
        if (id === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        writeChunk(destination, id);
        return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
      }
      function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
        var result;
        result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
        writeChunk(destination, clientRenderedSuspenseBoundaryError1);
        if (errorDigest) {
          writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
          writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
          writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
        }
        {
          if (errorMesssage) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
        }
        result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
        return result;
      }
      function writeEndCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndPendingSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
      var startSegmentHTML2 = stringToPrecomputedChunk('">');
      var endSegmentHTML = stringToPrecomputedChunk("</div>");
      var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
      var startSegmentSVG2 = stringToPrecomputedChunk('">');
      var endSegmentSVG = stringToPrecomputedChunk("</svg>");
      var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
      var startSegmentMathML2 = stringToPrecomputedChunk('">');
      var endSegmentMathML = stringToPrecomputedChunk("</math>");
      var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
      var startSegmentTable2 = stringToPrecomputedChunk('">');
      var endSegmentTable = stringToPrecomputedChunk("</table>");
      var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
      var startSegmentTableBody2 = stringToPrecomputedChunk('">');
      var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
      var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
      var startSegmentTableRow2 = stringToPrecomputedChunk('">');
      var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
      var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
      var startSegmentColGroup2 = stringToPrecomputedChunk('">');
      var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
      function writeStartSegment(destination, responseState, formatContext, id) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            writeChunk(destination, startSegmentHTML);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentHTML2);
          }
          case SVG_MODE: {
            writeChunk(destination, startSegmentSVG);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentSVG2);
          }
          case MATHML_MODE: {
            writeChunk(destination, startSegmentMathML);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentMathML2);
          }
          case HTML_TABLE_MODE: {
            writeChunk(destination, startSegmentTable);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTable2);
          }
          case HTML_TABLE_BODY_MODE: {
            writeChunk(destination, startSegmentTableBody);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTableBody2);
          }
          case HTML_TABLE_ROW_MODE: {
            writeChunk(destination, startSegmentTableRow);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTableRow2);
          }
          case HTML_COLGROUP_MODE: {
            writeChunk(destination, startSegmentColGroup);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentColGroup2);
          }
          default: {
            throw new Error("Unknown insertion mode. This is a bug in React.");
          }
        }
      }
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            return writeChunkAndReturn(destination, endSegmentHTML);
          }
          case SVG_MODE: {
            return writeChunkAndReturn(destination, endSegmentSVG);
          }
          case MATHML_MODE: {
            return writeChunkAndReturn(destination, endSegmentMathML);
          }
          case HTML_TABLE_MODE: {
            return writeChunkAndReturn(destination, endSegmentTable);
          }
          case HTML_TABLE_BODY_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableBody);
          }
          case HTML_TABLE_ROW_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableRow);
          }
          case HTML_COLGROUP_MODE: {
            return writeChunkAndReturn(destination, endSegmentColGroup);
          }
          default: {
            throw new Error("Unknown insertion mode. This is a bug in React.");
          }
        }
      }
      var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
      var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
      var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
      var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
      var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
      var completeSegmentScript2 = stringToPrecomputedChunk('","');
      var completeSegmentScript3 = stringToPrecomputedChunk('")</script>');
      function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteSegmentFunction) {
          responseState.sentCompleteSegmentFunction = true;
          writeChunk(destination, completeSegmentScript1Full);
        } else {
          writeChunk(destination, completeSegmentScript1Partial);
        }
        writeChunk(destination, responseState.segmentPrefix);
        var formattedID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, formattedID);
        writeChunk(destination, completeSegmentScript2);
        writeChunk(destination, responseState.placeholderPrefix);
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, completeSegmentScript3);
      }
      var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
      var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
      var completeBoundaryScript2 = stringToPrecomputedChunk('","');
      var completeBoundaryScript3 = stringToPrecomputedChunk('")</script>');
      function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteBoundaryFunction) {
          responseState.sentCompleteBoundaryFunction = true;
          writeChunk(destination, completeBoundaryScript1Full);
        } else {
          writeChunk(destination, completeBoundaryScript1Partial);
        }
        if (boundaryID === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        var formattedContentID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, boundaryID);
        writeChunk(destination, completeBoundaryScript2);
        writeChunk(destination, responseState.segmentPrefix);
        writeChunk(destination, formattedContentID);
        return writeChunkAndReturn(destination, completeBoundaryScript3);
      }
      var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
      var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
      var clientRenderScript1A = stringToPrecomputedChunk('"');
      var clientRenderScript2 = stringToPrecomputedChunk(")</script>");
      var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
      function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentClientRenderFunction) {
          responseState.sentClientRenderFunction = true;
          writeChunk(destination, clientRenderScript1Full);
        } else {
          writeChunk(destination, clientRenderScript1Partial);
        }
        if (boundaryID === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        writeChunk(destination, boundaryID);
        writeChunk(destination, clientRenderScript1A);
        if (errorDigest || errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
        }
        if (errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
        }
        if (errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
        }
        return writeChunkAndReturn(destination, clientRenderScript2);
      }
      var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
      function escapeJSStringsForInstructionScripts(input) {
        var escaped = JSON.stringify(input);
        return escaped.replace(regexForJSStringsInScripts, function(match) {
          switch (match) {
            case "<":
              return "\\u003c";
            case "\u2028":
              return "\\u2028";
            case "\u2029":
              return "\\u2029";
            default: {
              throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
            }
          }
        });
      }
      var assign = Object.assign;
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_SCOPE_TYPE = Symbol.for("react.scope");
      var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
      var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
      var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type145) {
        return type145.displayName || "Context";
      }
      function getComponentNameFromType(type145) {
        if (type145 == null) {
          return null;
        }
        {
          if (typeof type145.tag === "number") {
            error41("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type145 === "function") {
          return type145.displayName || type145.name || null;
        }
        if (typeof type145 === "string") {
          return type145;
        }
        switch (type145) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type145 === "object") {
          switch (type145.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type145;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type145;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type145, type145.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type145.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type145.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type145;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error41("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap;
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== undefined) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s3 = sampleLines.length - 1;
            var c3 = controlLines.length - 1;
            while (s3 >= 1 && c3 >= 0 && sampleLines[s3] !== controlLines[c3]) {
              c3--;
            }
            for (;s3 >= 1 && c3 >= 0; s3--, c3--) {
              if (sampleLines[s3] !== controlLines[c3]) {
                if (s3 !== 1 || c3 !== 1) {
                  do {
                    s3--;
                    c3--;
                    if (c3 < 0 || sampleLines[s3] !== controlLines[c3]) {
                      var _frame = "\n" + sampleLines[s3].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s3 >= 1 && c3 >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeClassComponentFrame(ctor, source, ownerFn) {
        {
          return describeNativeComponentFrame(ctor, true);
        }
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type145, source, ownerFn) {
        if (type145 == null) {
          return "";
        }
        if (typeof type145 === "function") {
          {
            return describeNativeComponentFrame(type145, shouldConstruct(type145));
          }
        }
        if (typeof type145 === "string") {
          return describeBuiltInComponentFrame(type145);
        }
        switch (type145) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type145 === "object") {
          switch (type145.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type145.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type145.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type145;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has3 = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has3(typeSpecs, typeSpecName)) {
              var error$1 = undefined;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error41("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error41("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var warnedAboutMissingGetChildContext;
      {
        warnedAboutMissingGetChildContext = {};
      }
      var emptyContextObject = {};
      {
        Object.freeze(emptyContextObject);
      }
      function getMaskedContext(type145, unmaskedContext) {
        {
          var contextTypes = type145.contextTypes;
          if (!contextTypes) {
            return emptyContextObject;
          }
          var context = {};
          for (var key in contextTypes) {
            context[key] = unmaskedContext[key];
          }
          {
            var name = getComponentNameFromType(type145) || "Unknown";
            checkPropTypes(contextTypes, context, "context", name);
          }
          return context;
        }
      }
      function processChildContext(instance, type145, parentContext, childContextTypes) {
        {
          if (typeof instance.getChildContext !== "function") {
            {
              var componentName = getComponentNameFromType(type145) || "Unknown";
              if (!warnedAboutMissingGetChildContext[componentName]) {
                warnedAboutMissingGetChildContext[componentName] = true;
                error41("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
              }
            }
            return parentContext;
          }
          var childContext = instance.getChildContext();
          for (var contextKey in childContext) {
            if (!(contextKey in childContextTypes)) {
              throw new Error((getComponentNameFromType(type145) || "Unknown") + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes.");
            }
          }
          {
            var name = getComponentNameFromType(type145) || "Unknown";
            checkPropTypes(childContextTypes, childContext, "child context", name);
          }
          return assign({}, parentContext, childContext);
        }
      }
      var rendererSigil;
      {
        rendererSigil = {};
      }
      var rootContextSnapshot = null;
      var currentActiveSnapshot = null;
      function popNode(prev) {
        {
          prev.context._currentValue = prev.parentValue;
        }
      }
      function pushNode(next) {
        {
          next.context._currentValue = next.value;
        }
      }
      function popToNearestCommonAncestor(prev, next) {
        if (prev === next)
          ;
        else {
          popNode(prev);
          var parentPrev = prev.parent;
          var parentNext = next.parent;
          if (parentPrev === null) {
            if (parentNext !== null) {
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            }
          } else {
            if (parentNext === null) {
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            }
            popToNearestCommonAncestor(parentPrev, parentNext);
          }
          pushNode(next);
        }
      }
      function popAllPrevious(prev) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev !== null) {
          popAllPrevious(parentPrev);
        }
      }
      function pushAllNext(next) {
        var parentNext = next.parent;
        if (parentNext !== null) {
          pushAllNext(parentNext);
        }
        pushNode(next);
      }
      function popPreviousToCommonLevel(prev, next) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev === null) {
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        }
        if (parentPrev.depth === next.depth) {
          popToNearestCommonAncestor(parentPrev, next);
        } else {
          popPreviousToCommonLevel(parentPrev, next);
        }
      }
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (parentNext === null) {
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        }
        if (prev.depth === parentNext.depth) {
          popToNearestCommonAncestor(prev, parentNext);
        } else {
          popNextToCommonLevel(prev, parentNext);
        }
        pushNode(next);
      }
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot;
        var next = newSnapshot;
        if (prev !== next) {
          if (prev === null) {
            pushAllNext(next);
          } else if (next === null) {
            popAllPrevious(prev);
          } else if (prev.depth === next.depth) {
            popToNearestCommonAncestor(prev, next);
          } else if (prev.depth > next.depth) {
            popPreviousToCommonLevel(prev, next);
          } else {
            popNextToCommonLevel(prev, next);
          }
          currentActiveSnapshot = next;
        }
      }
      function pushProvider(context, nextValue) {
        var prevValue;
        {
          prevValue = context._currentValue;
          context._currentValue = nextValue;
          {
            if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
              error41("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
            }
            context._currentRenderer = rendererSigil;
          }
        }
        var prevNode = currentActiveSnapshot;
        var newNode = {
          parent: prevNode,
          depth: prevNode === null ? 0 : prevNode.depth + 1,
          context,
          parentValue: prevValue,
          value: nextValue
        };
        currentActiveSnapshot = newNode;
        return newNode;
      }
      function popProvider(context) {
        var prevSnapshot = currentActiveSnapshot;
        if (prevSnapshot === null) {
          throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
        }
        {
          if (prevSnapshot.context !== context) {
            error41("The parent context is not the expected context. This is probably a bug in React.");
          }
        }
        {
          var value27 = prevSnapshot.parentValue;
          if (value27 === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
            prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
          } else {
            prevSnapshot.context._currentValue = value27;
          }
          {
            if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
              error41("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
            }
            context._currentRenderer = rendererSigil;
          }
        }
        return currentActiveSnapshot = prevSnapshot.parent;
      }
      function getActiveContext() {
        return currentActiveSnapshot;
      }
      function readContext(context) {
        var value27 = context._currentValue;
        return value27;
      }
      function get(key) {
        return key._reactInternals;
      }
      function set3(key, value27) {
        key._reactInternals = value27;
      }
      var didWarnAboutNoopUpdateForComponent = {};
      var didWarnAboutDeprecatedWillMount = {};
      var didWarnAboutUninitializedState;
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
      var didWarnAboutLegacyLifecyclesAndDerivedState;
      var didWarnAboutUndefinedDerivedState;
      var warnOnUndefinedDerivedState;
      var warnOnInvalidCallback;
      var didWarnAboutDirectlyAssigningPropsToState;
      var didWarnAboutContextTypeAndContextTypes;
      var didWarnAboutInvalidateContextType;
      {
        didWarnAboutUninitializedState = new Set;
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set;
        didWarnAboutLegacyLifecyclesAndDerivedState = new Set;
        didWarnAboutDirectlyAssigningPropsToState = new Set;
        didWarnAboutUndefinedDerivedState = new Set;
        didWarnAboutContextTypeAndContextTypes = new Set;
        didWarnAboutInvalidateContextType = new Set;
        var didWarnOnInvalidCallback = new Set;
        warnOnInvalidCallback = function(callback, callerName) {
          if (callback === null || typeof callback === "function") {
            return;
          }
          var key = callerName + "_" + callback;
          if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            error41("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
          }
        };
        warnOnUndefinedDerivedState = function(type145, partialState) {
          if (partialState === undefined) {
            var componentName = getComponentNameFromType(type145) || "Component";
            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
              didWarnAboutUndefinedDerivedState.add(componentName);
              error41("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
            }
          }
        };
      }
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor;
          var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
          var warningKey = componentName + "." + callerName;
          if (didWarnAboutNoopUpdateForComponent[warningKey]) {
            return;
          }
          error41("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
          didWarnAboutNoopUpdateForComponent[warningKey] = true;
        }
      }
      var classComponentUpdater = {
        isMounted: function(inst) {
          return false;
        },
        enqueueSetState: function(inst, payload, callback) {
          var internals = get(inst);
          if (internals.queue === null) {
            warnNoop(inst, "setState");
          } else {
            internals.queue.push(payload);
            {
              if (callback !== undefined && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          }
        },
        enqueueReplaceState: function(inst, payload, callback) {
          var internals = get(inst);
          internals.replace = true;
          internals.queue = [payload];
          {
            if (callback !== undefined && callback !== null) {
              warnOnInvalidCallback(callback, "setState");
            }
          }
        },
        enqueueForceUpdate: function(inst, callback) {
          var internals = get(inst);
          if (internals.queue === null) {
            warnNoop(inst, "forceUpdate");
          } else {
            {
              if (callback !== undefined && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          }
        }
      };
      function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        {
          warnOnUndefinedDerivedState(ctor, partialState);
        }
        var newState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);
        return newState;
      }
      function constructClassInstance(ctor, props, maskedLegacyContext) {
        var context = emptyContextObject;
        var contextType = ctor.contextType;
        {
          if ("contextType" in ctor) {
            var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined;
            if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
              didWarnAboutInvalidateContextType.add(ctor);
              var addendum = "";
              if (contextType === undefined) {
                addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
              } else if (typeof contextType !== "object") {
                addendum = " However, it is set to a " + typeof contextType + ".";
              } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                addendum = " Did you accidentally pass the Context.Provider instead?";
              } else if (contextType._context !== undefined) {
                addendum = " Did you accidentally pass the Context.Consumer instead?";
              } else {
                addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
              }
              error41("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
            }
          }
        }
        if (typeof contextType === "object" && contextType !== null) {
          context = readContext(contextType);
        } else {
          context = maskedLegacyContext;
        }
        var instance = new ctor(props, context);
        {
          if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === undefined)) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutUninitializedState.has(componentName)) {
              didWarnAboutUninitializedState.add(componentName);
              error41("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
            }
          }
          if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;
            if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
              foundWillMountName = "componentWillMount";
            } else if (typeof instance.UNSAFE_componentWillMount === "function") {
              foundWillMountName = "UNSAFE_componentWillMount";
            }
            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              foundWillReceivePropsName = "componentWillReceiveProps";
            } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
            }
            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              foundWillUpdateName = "componentWillUpdate";
            } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              foundWillUpdateName = "UNSAFE_componentWillUpdate";
            }
            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType(ctor) || "Component";
              var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                error41("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
              }
            }
          }
        }
        return instance;
      }
      function checkClassInstance(instance, ctor, newProps) {
        {
          var name = getComponentNameFromType(ctor) || "Component";
          var renderPresent = instance.render;
          if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === "function") {
              error41("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
            } else {
              error41("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
            }
          }
          if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
            error41("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
          }
          if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
            error41("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
          }
          if (instance.propTypes) {
            error41("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
          }
          if (instance.contextType) {
            error41("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
          }
          {
            if (instance.contextTypes) {
              error41("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
            }
            if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
              didWarnAboutContextTypeAndContextTypes.add(ctor);
              error41("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
            }
          }
          if (typeof instance.componentShouldUpdate === "function") {
            error41("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
            error41("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
          }
          if (typeof instance.componentDidUnmount === "function") {
            error41("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
          }
          if (typeof instance.componentDidReceiveProps === "function") {
            error41("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
          }
          if (typeof instance.componentWillRecieveProps === "function") {
            error41("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
          }
          if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
            error41("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
          }
          var hasMutatedProps = instance.props !== newProps;
          if (instance.props !== undefined && hasMutatedProps) {
            error41("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
          }
          if (instance.defaultProps) {
            error41("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            error41("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
          }
          if (typeof instance.getDerivedStateFromProps === "function") {
            error41("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
          }
          if (typeof instance.getDerivedStateFromError === "function") {
            error41("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
          }
          if (typeof ctor.getSnapshotBeforeUpdate === "function") {
            error41("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
          }
          var _state = instance.state;
          if (_state && (typeof _state !== "object" || isArray(_state))) {
            error41("%s.state: must be set to an object or null", name);
          }
          if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
            error41("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
          }
        }
      }
      function callComponentWillMount(type145, instance) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount === "function") {
          {
            if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
              var componentName = getComponentNameFromType(type145) || "Unknown";
              if (!didWarnAboutDeprecatedWillMount[componentName]) {
                warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s", componentName);
                didWarnAboutDeprecatedWillMount[componentName] = true;
              }
            }
          }
          instance.componentWillMount();
        }
        if (typeof instance.UNSAFE_componentWillMount === "function") {
          instance.UNSAFE_componentWillMount();
        }
        if (oldState !== instance.state) {
          {
            error41("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type145) || "Component");
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }
      function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
        if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
          var oldQueue = internalInstance.queue;
          var oldReplace = internalInstance.replace;
          internalInstance.queue = null;
          internalInstance.replace = false;
          if (oldReplace && oldQueue.length === 1) {
            inst.state = oldQueue[0];
          } else {
            var nextState = oldReplace ? oldQueue[0] : inst.state;
            var dontMutate = true;
            for (var i = oldReplace ? 1 : 0;i < oldQueue.length; i++) {
              var partial7 = oldQueue[i];
              var partialState = typeof partial7 === "function" ? partial7.call(inst, nextState, props, maskedLegacyContext) : partial7;
              if (partialState != null) {
                if (dontMutate) {
                  dontMutate = false;
                  nextState = assign({}, nextState, partialState);
                } else {
                  assign(nextState, partialState);
                }
              }
            }
            inst.state = nextState;
          }
        } else {
          internalInstance.queue = null;
        }
      }
      function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
        {
          checkClassInstance(instance, ctor, newProps);
        }
        var initialState = instance.state !== undefined ? instance.state : null;
        instance.updater = classComponentUpdater;
        instance.props = newProps;
        instance.state = initialState;
        var internalInstance = {
          queue: [],
          replace: false
        };
        set3(instance, internalInstance);
        var contextType = ctor.contextType;
        if (typeof contextType === "object" && contextType !== null) {
          instance.context = readContext(contextType);
        } else {
          instance.context = maskedLegacyContext;
        }
        {
          if (instance.state === newProps) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
              didWarnAboutDirectlyAssigningPropsToState.add(componentName);
              error41("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
            }
          }
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps === "function") {
          instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
        }
        if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
          callComponentWillMount(ctor, instance);
          processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
        }
      }
      var emptyTreeContext = {
        id: 1,
        overflow: ""
      };
      function getTreeId(context) {
        var overflow = context.overflow;
        var idWithLeadingBit = context.id;
        var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id.toString(32) + overflow;
      }
      function pushTreeContext(baseContext, totalChildren, index) {
        var baseIdWithLeadingBit = baseContext.id;
        var baseOverflow = baseContext.overflow;
        var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
        var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
        var slot = index + 1;
        var length = getBitLength(totalChildren) + baseLength;
        if (length > 30) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          var newOverflowBits = (1 << numberOfOverflowBits) - 1;
          var newOverflow = (baseId & newOverflowBits).toString(32);
          var restOfBaseId = baseId >> numberOfOverflowBits;
          var restOfBaseLength = baseLength - numberOfOverflowBits;
          var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
          var restOfNewBits = slot << restOfBaseLength;
          var id = restOfNewBits | restOfBaseId;
          var overflow = newOverflow + baseOverflow;
          return {
            id: 1 << restOfLength | id,
            overflow
          };
        } else {
          var newBits = slot << baseLength;
          var _id = newBits | baseId;
          var _overflow = baseOverflow;
          return {
            id: 1 << length | _id,
            overflow: _overflow
          };
        }
      }
      function getBitLength(number11) {
        return 32 - clz32(number11);
      }
      function getLeadingBit(id) {
        return 1 << getBitLength(id) - 1;
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
      var log = Math.log;
      var LN2 = Math.LN2;
      function clz32Fallback(x) {
        var asUint = x >>> 0;
        if (asUint === 0) {
          return 32;
        }
        return 31 - (log(asUint) / LN2 | 0) | 0;
      }
      function is(x, y3) {
        return x === y3 && (x !== 0 || 1 / x === 1 / y3) || x !== x && y3 !== y3;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is;
      var currentlyRenderingComponent = null;
      var currentlyRenderingTask = null;
      var firstWorkInProgressHook = null;
      var workInProgressHook = null;
      var isReRender = false;
      var didScheduleRenderPhaseUpdate = false;
      var localIdCounter = 0;
      var renderPhaseUpdates = null;
      var numberOfReRenders = 0;
      var RE_RENDER_LIMIT = 25;
      var isInHookUserCodeInDev = false;
      var currentHookNameInDev;
      function resolveCurrentlyRenderingComponent() {
        if (currentlyRenderingComponent === null) {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        }
        {
          if (isInHookUserCodeInDev) {
            error41("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
          }
        }
        return currentlyRenderingComponent;
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null) {
          {
            error41("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
          }
          return false;
        }
        {
          if (nextDeps.length !== prevDeps.length) {
            error41("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
          }
        }
        for (var i = 0;i < prevDeps.length && i < nextDeps.length; i++) {
          if (objectIs(nextDeps[i], prevDeps[i])) {
            continue;
          }
          return false;
        }
        return true;
      }
      function createHook() {
        if (numberOfReRenders > 0) {
          throw new Error("Rendered more hooks than during the previous render");
        }
        return {
          memoizedState: null,
          queue: null,
          next: null
        };
      }
      function createWorkInProgressHook() {
        if (workInProgressHook === null) {
          if (firstWorkInProgressHook === null) {
            isReRender = false;
            firstWorkInProgressHook = workInProgressHook = createHook();
          } else {
            isReRender = true;
            workInProgressHook = firstWorkInProgressHook;
          }
        } else {
          if (workInProgressHook.next === null) {
            isReRender = false;
            workInProgressHook = workInProgressHook.next = createHook();
          } else {
            isReRender = true;
            workInProgressHook = workInProgressHook.next;
          }
        }
        return workInProgressHook;
      }
      function prepareToUseHooks(task, componentIdentity) {
        currentlyRenderingComponent = componentIdentity;
        currentlyRenderingTask = task;
        {
          isInHookUserCodeInDev = false;
        }
        localIdCounter = 0;
      }
      function finishHooks(Component, props, children, refOrContext) {
        while (didScheduleRenderPhaseUpdate) {
          didScheduleRenderPhaseUpdate = false;
          localIdCounter = 0;
          numberOfReRenders += 1;
          workInProgressHook = null;
          children = Component(props, refOrContext);
        }
        resetHooksState();
        return children;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0;
        return didRenderIdHook;
      }
      function resetHooksState() {
        {
          isInHookUserCodeInDev = false;
        }
        currentlyRenderingComponent = null;
        currentlyRenderingTask = null;
        didScheduleRenderPhaseUpdate = false;
        firstWorkInProgressHook = null;
        numberOfReRenders = 0;
        renderPhaseUpdates = null;
        workInProgressHook = null;
      }
      function readContext$1(context) {
        {
          if (isInHookUserCodeInDev) {
            error41("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          }
        }
        return readContext(context);
      }
      function useContext(context) {
        {
          currentHookNameInDev = "useContext";
        }
        resolveCurrentlyRenderingComponent();
        return readContext(context);
      }
      function basicStateReducer(state, action) {
        return typeof action === "function" ? action(state) : action;
      }
      function useState(initialState) {
        {
          currentHookNameInDev = "useState";
        }
        return useReducer(basicStateReducer, initialState);
      }
      function useReducer(reducer, initialArg, init) {
        {
          if (reducer !== basicStateReducer) {
            currentHookNameInDev = "useReducer";
          }
        }
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        if (isReRender) {
          var queue = workInProgressHook.queue;
          var dispatch = queue.dispatch;
          if (renderPhaseUpdates !== null) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
            if (firstRenderPhaseUpdate !== undefined) {
              renderPhaseUpdates.delete(queue);
              var newState = workInProgressHook.memoizedState;
              var update = firstRenderPhaseUpdate;
              do {
                var action = update.action;
                {
                  isInHookUserCodeInDev = true;
                }
                newState = reducer(newState, action);
                {
                  isInHookUserCodeInDev = false;
                }
                update = update.next;
              } while (update !== null);
              workInProgressHook.memoizedState = newState;
              return [newState, dispatch];
            }
          }
          return [workInProgressHook.memoizedState, dispatch];
        } else {
          {
            isInHookUserCodeInDev = true;
          }
          var initialState;
          if (reducer === basicStateReducer) {
            initialState = typeof initialArg === "function" ? initialArg() : initialArg;
          } else {
            initialState = init !== undefined ? init(initialArg) : initialArg;
          }
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = initialState;
          var _queue = workInProgressHook.queue = {
            last: null,
            dispatch: null
          };
          var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
          return [workInProgressHook.memoizedState, _dispatch];
        }
      }
      function useMemo(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        if (workInProgressHook !== null) {
          var prevState = workInProgressHook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
        }
        {
          isInHookUserCodeInDev = true;
        }
        var nextValue = nextCreate();
        {
          isInHookUserCodeInDev = false;
        }
        workInProgressHook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }
      function useRef(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var previousRef = workInProgressHook.memoizedState;
        if (previousRef === null) {
          var ref5 = {
            current: initialValue
          };
          {
            Object.seal(ref5);
          }
          workInProgressHook.memoizedState = ref5;
          return ref5;
        } else {
          return previousRef;
        }
      }
      function useLayoutEffect(create7, inputs) {
        {
          currentHookNameInDev = "useLayoutEffect";
          error41("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
        }
      }
      function dispatchAction(componentIdentity, queue, action) {
        if (numberOfReRenders >= RE_RENDER_LIMIT) {
          throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        }
        if (componentIdentity === currentlyRenderingComponent) {
          didScheduleRenderPhaseUpdate = true;
          var update = {
            action,
            next: null
          };
          if (renderPhaseUpdates === null) {
            renderPhaseUpdates = new Map;
          }
          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
          if (firstRenderPhaseUpdate === undefined) {
            renderPhaseUpdates.set(queue, update);
          } else {
            var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
            while (lastRenderPhaseUpdate.next !== null) {
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            }
            lastRenderPhaseUpdate.next = update;
          }
        }
      }
      function useCallback(callback, deps) {
        return useMemo(function() {
          return callback;
        }, deps);
      }
      function useMutableSource(source, getSnapshot, subscribe) {
        resolveCurrentlyRenderingComponent();
        return getSnapshot(source._source);
      }
      function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        if (getServerSnapshot === undefined) {
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        }
        return getServerSnapshot();
      }
      function useDeferredValue(value27) {
        resolveCurrentlyRenderingComponent();
        return value27;
      }
      function unsupportedStartTransition() {
        throw new Error("startTransition cannot be called during server rendering.");
      }
      function useTransition() {
        resolveCurrentlyRenderingComponent();
        return [false, unsupportedStartTransition];
      }
      function useId() {
        var task = currentlyRenderingTask;
        var treeId = getTreeId(task.treeContext);
        var responseState = currentResponseState;
        if (responseState === null) {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
        }
        var localId = localIdCounter++;
        return makeId(responseState, treeId, localId);
      }
      function noop() {
      }
      var Dispatcher = {
        readContext: readContext$1,
        useContext,
        useMemo,
        useReducer,
        useRef,
        useState,
        useInsertionEffect: noop,
        useLayoutEffect,
        useCallback,
        useImperativeHandle: noop,
        useEffect: noop,
        useDebugValue: noop,
        useDeferredValue,
        useTransition,
        useId,
        useMutableSource,
        useSyncExternalStore
      };
      var currentResponseState = null;
      function setCurrentResponseState(responseState) {
        currentResponseState = responseState;
      }
      function getStackByComponentStackNode(componentStack) {
        try {
          var info = "";
          var node = componentStack;
          do {
            switch (node.tag) {
              case 0:
                info += describeBuiltInComponentFrame(node.type, null, null);
                break;
              case 1:
                info += describeFunctionComponentFrame(node.type, null, null);
                break;
              case 2:
                info += describeClassComponentFrame(node.type, null, null);
                break;
            }
            node = node.parent;
          } while (node);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      var PENDING = 0;
      var COMPLETED = 1;
      var FLUSHED = 2;
      var ABORTED = 3;
      var ERRORED = 4;
      var OPEN = 0;
      var CLOSING = 1;
      var CLOSED = 2;
      var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
      function defaultErrorHandler(error42) {
        console["error"](error42);
        return null;
      }
      function noop$1() {
      }
      function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {
        var pingedTasks = [];
        var abortSet = new Set;
        var request = {
          destination: null,
          responseState,
          progressiveChunkSize: progressiveChunkSize === undefined ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
          status: OPEN,
          fatalError: null,
          nextSegmentId: 0,
          allPendingTasks: 0,
          pendingRootTasks: 0,
          completedRootSegment: null,
          abortableTasks: abortSet,
          pingedTasks,
          clientRenderedBoundaries: [],
          completedBoundaries: [],
          partialBoundaries: [],
          onError: onError === undefined ? defaultErrorHandler : onError,
          onAllReady: onAllReady === undefined ? noop$1 : onAllReady,
          onShellReady: onShellReady === undefined ? noop$1 : onShellReady,
          onShellError: onShellError === undefined ? noop$1 : onShellError,
          onFatalError: onFatalError === undefined ? noop$1 : onFatalError
        };
        var rootSegment = createPendingSegment(request, 0, null, rootFormatContext, false, false);
        rootSegment.parentFlushed = true;
        var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
        pingedTasks.push(rootTask);
        return request;
      }
      function pingTask(request, task) {
        var pingedTasks = request.pingedTasks;
        pingedTasks.push(task);
        if (pingedTasks.length === 1) {
          scheduleWork(function() {
            return performWork(request);
          });
        }
      }
      function createSuspenseBoundary(request, fallbackAbortableTasks) {
        return {
          id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
          rootSegmentID: -1,
          parentFlushed: false,
          pendingTasks: 0,
          forceClientRender: false,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null
        };
      }
      function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
        request.allPendingTasks++;
        if (blockedBoundary === null) {
          request.pendingRootTasks++;
        } else {
          blockedBoundary.pendingTasks++;
        }
        var task = {
          node,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment,
          abortSet,
          legacyContext,
          context,
          treeContext
        };
        {
          task.componentStack = null;
        }
        abortSet.add(task);
        return task;
      }
      function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {
        return {
          status: PENDING,
          id: -1,
          index,
          parentFlushed: false,
          chunks: [],
          children: [],
          formatContext,
          boundary,
          lastPushedText,
          textEmbedded
        };
      }
      var currentTaskInDEV = null;
      function getCurrentStackInDEV() {
        {
          if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
            return "";
          }
          return getStackByComponentStackNode(currentTaskInDEV.componentStack);
        }
      }
      function pushBuiltInComponentStackInDEV(task, type145) {
        {
          task.componentStack = {
            tag: 0,
            parent: task.componentStack,
            type: type145
          };
        }
      }
      function pushFunctionComponentStackInDEV(task, type145) {
        {
          task.componentStack = {
            tag: 1,
            parent: task.componentStack,
            type: type145
          };
        }
      }
      function pushClassComponentStackInDEV(task, type145) {
        {
          task.componentStack = {
            tag: 2,
            parent: task.componentStack,
            type: type145
          };
        }
      }
      function popComponentStackInDEV(task) {
        {
          if (task.componentStack === null) {
            error41("Unexpectedly popped too many stack frames. This is a bug in React.");
          } else {
            task.componentStack = task.componentStack.parent;
          }
        }
      }
      var lastBoundaryErrorComponentStackDev = null;
      function captureBoundaryErrorDetailsDev(boundary, error42) {
        {
          var errorMessage;
          if (typeof error42 === "string") {
            errorMessage = error42;
          } else if (error42 && typeof error42.message === "string") {
            errorMessage = error42.message;
          } else {
            errorMessage = String(error42);
          }
          var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
          lastBoundaryErrorComponentStackDev = null;
          boundary.errorMessage = errorMessage;
          boundary.errorComponentStack = errorComponentStack;
        }
      }
      function logRecoverableError(request, error42) {
        var errorDigest = request.onError(error42);
        if (errorDigest != null && typeof errorDigest !== "string") {
          throw new Error("onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"" + typeof errorDigest + "\" instead");
        }
        return errorDigest;
      }
      function fatalError(request, error42) {
        var onShellError = request.onShellError;
        onShellError(error42);
        var onFatalError = request.onFatalError;
        onFatalError(error42);
        if (request.destination !== null) {
          request.status = CLOSED;
          closeWithError(request.destination, error42);
        } else {
          request.status = CLOSING;
          request.fatalError = error42;
        }
      }
      function renderSuspenseBoundary(request, task, props) {
        pushBuiltInComponentStackInDEV(task, "Suspense");
        var parentBoundary = task.blockedBoundary;
        var parentSegment = task.blockedSegment;
        var fallback = props.fallback;
        var content = props.children;
        var fallbackAbortSet = new Set;
        var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
        var insertionIndex = parentSegment.chunks.length;
        var boundarySegment = createPendingSegment(request, insertionIndex, newBoundary, parentSegment.formatContext, false, false);
        parentSegment.children.push(boundarySegment);
        parentSegment.lastPushedText = false;
        var contentRootSegment = createPendingSegment(request, 0, null, parentSegment.formatContext, false, false);
        contentRootSegment.parentFlushed = true;
        task.blockedBoundary = newBoundary;
        task.blockedSegment = contentRootSegment;
        try {
          renderNode(request, task, content);
          pushSegmentFinale(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
          contentRootSegment.status = COMPLETED;
          queueCompletedSegment(newBoundary, contentRootSegment);
          if (newBoundary.pendingTasks === 0) {
            popComponentStackInDEV(task);
            return;
          }
        } catch (error42) {
          contentRootSegment.status = ERRORED;
          newBoundary.forceClientRender = true;
          newBoundary.errorDigest = logRecoverableError(request, error42);
          {
            captureBoundaryErrorDetailsDev(newBoundary, error42);
          }
        } finally {
          task.blockedBoundary = parentBoundary;
          task.blockedSegment = parentSegment;
        }
        var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
        {
          suspendedFallbackTask.componentStack = task.componentStack;
        }
        request.pingedTasks.push(suspendedFallbackTask);
        popComponentStackInDEV(task);
      }
      function renderHostElement(request, task, type145, props) {
        pushBuiltInComponentStackInDEV(task, type145);
        var segment = task.blockedSegment;
        var children = pushStartInstance(segment.chunks, type145, props, request.responseState, segment.formatContext);
        segment.lastPushedText = false;
        var prevContext = segment.formatContext;
        segment.formatContext = getChildFormatContext(prevContext, type145, props);
        renderNode(request, task, children);
        segment.formatContext = prevContext;
        pushEndInstance(segment.chunks, type145);
        segment.lastPushedText = false;
        popComponentStackInDEV(task);
      }
      function shouldConstruct$1(Component) {
        return Component.prototype && Component.prototype.isReactComponent;
      }
      function renderWithHooks(request, task, Component, props, secondArg) {
        var componentIdentity = {};
        prepareToUseHooks(task, componentIdentity);
        var result = Component(props, secondArg);
        return finishHooks(Component, props, result, secondArg);
      }
      function finishClassComponent(request, task, instance, Component, props) {
        var nextChildren = instance.render();
        {
          if (instance.props !== props) {
            if (!didWarnAboutReassigningProps) {
              error41("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component");
            }
            didWarnAboutReassigningProps = true;
          }
        }
        {
          var childContextTypes = Component.childContextTypes;
          if (childContextTypes !== null && childContextTypes !== undefined) {
            var previousContext = task.legacyContext;
            var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
            task.legacyContext = mergedContext;
            renderNodeDestructive(request, task, nextChildren);
            task.legacyContext = previousContext;
            return;
          }
        }
        renderNodeDestructive(request, task, nextChildren);
      }
      function renderClassComponent(request, task, Component, props) {
        pushClassComponentStackInDEV(task, Component);
        var maskedContext = getMaskedContext(Component, task.legacyContext);
        var instance = constructClassInstance(Component, props, maskedContext);
        mountClassInstance(instance, Component, props, maskedContext);
        finishClassComponent(request, task, instance, Component, props);
        popComponentStackInDEV(task);
      }
      var didWarnAboutBadClass = {};
      var didWarnAboutModulePatternComponent = {};
      var didWarnAboutContextTypeOnFunctionComponent = {};
      var didWarnAboutGetDerivedStateOnFunctionComponent = {};
      var didWarnAboutReassigningProps = false;
      var didWarnAboutGenerators = false;
      var didWarnAboutMaps = false;
      var hasWarnedAboutUsingContextAsConsumer = false;
      function renderIndeterminateComponent(request, task, Component, props) {
        var legacyContext;
        {
          legacyContext = getMaskedContext(Component, task.legacyContext);
        }
        pushFunctionComponentStackInDEV(task, Component);
        {
          if (Component.prototype && typeof Component.prototype.render === "function") {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutBadClass[componentName]) {
              error41("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
              didWarnAboutBadClass[componentName] = true;
            }
          }
        }
        var value27 = renderWithHooks(request, task, Component, props, legacyContext);
        var hasId = checkDidRenderIdHook();
        {
          if (typeof value27 === "object" && value27 !== null && typeof value27.render === "function" && value27.$$typeof === undefined) {
            var _componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName]) {
              error41("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
              didWarnAboutModulePatternComponent[_componentName] = true;
            }
          }
        }
        if (typeof value27 === "object" && value27 !== null && typeof value27.render === "function" && value27.$$typeof === undefined) {
          {
            var _componentName2 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName2]) {
              error41("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
              didWarnAboutModulePatternComponent[_componentName2] = true;
            }
          }
          mountClassInstance(value27, Component, props, legacyContext);
          finishClassComponent(request, task, value27, Component, props);
        } else {
          {
            validateFunctionComponentInDev(Component);
          }
          if (hasId) {
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
            try {
              renderNodeDestructive(request, task, value27);
            } finally {
              task.treeContext = prevTreeContext;
            }
          } else {
            renderNodeDestructive(request, task, value27);
          }
        }
        popComponentStackInDEV(task);
      }
      function validateFunctionComponentInDev(Component) {
        {
          if (Component) {
            if (Component.childContextTypes) {
              error41("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
            }
          }
          if (typeof Component.getDerivedStateFromProps === "function") {
            var _componentName3 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
              error41("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
            }
          }
          if (typeof Component.contextType === "object" && Component.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
              error41("%s: Function components do not support contextType.", _componentName4);
              didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
            }
          }
        }
      }
      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = assign({}, baseProps);
          var defaultProps = Component.defaultProps;
          for (var propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
          return props;
        }
        return baseProps;
      }
      function renderForwardRef(request, task, type145, props, ref5) {
        pushFunctionComponentStackInDEV(task, type145.render);
        var children = renderWithHooks(request, task, type145.render, props, ref5);
        var hasId = checkDidRenderIdHook();
        if (hasId) {
          var prevTreeContext = task.treeContext;
          var totalChildren = 1;
          var index = 0;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
          try {
            renderNodeDestructive(request, task, children);
          } finally {
            task.treeContext = prevTreeContext;
          }
        } else {
          renderNodeDestructive(request, task, children);
        }
        popComponentStackInDEV(task);
      }
      function renderMemo(request, task, type145, props, ref5) {
        var innerType = type145.type;
        var resolvedProps = resolveDefaultProps(innerType, props);
        renderElement(request, task, innerType, resolvedProps, ref5);
      }
      function renderContextConsumer(request, task, context, props) {
        {
          if (context._context === undefined) {
            if (context !== context.Consumer) {
              if (!hasWarnedAboutUsingContextAsConsumer) {
                hasWarnedAboutUsingContextAsConsumer = true;
                error41("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
              }
            }
          } else {
            context = context._context;
          }
        }
        var render = props.children;
        {
          if (typeof render !== "function") {
            error41("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
          }
        }
        var newValue = readContext(context);
        var newChildren = render(newValue);
        renderNodeDestructive(request, task, newChildren);
      }
      function renderContextProvider(request, task, type145, props) {
        var context = type145._context;
        var value27 = props.value;
        var children = props.children;
        var prevSnapshot;
        {
          prevSnapshot = task.context;
        }
        task.context = pushProvider(context, value27);
        renderNodeDestructive(request, task, children);
        task.context = popProvider(context);
        {
          if (prevSnapshot !== task.context) {
            error41("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
          }
        }
      }
      function renderLazyComponent(request, task, lazyComponent, props, ref5) {
        pushBuiltInComponentStackInDEV(task, "Lazy");
        var payload = lazyComponent._payload;
        var init = lazyComponent._init;
        var Component = init(payload);
        var resolvedProps = resolveDefaultProps(Component, props);
        renderElement(request, task, Component, resolvedProps, ref5);
        popComponentStackInDEV(task);
      }
      function renderElement(request, task, type145, props, ref5) {
        if (typeof type145 === "function") {
          if (shouldConstruct$1(type145)) {
            renderClassComponent(request, task, type145, props);
            return;
          } else {
            renderIndeterminateComponent(request, task, type145, props);
            return;
          }
        }
        if (typeof type145 === "string") {
          renderHostElement(request, task, type145, props);
          return;
        }
        switch (type145) {
          case REACT_LEGACY_HIDDEN_TYPE:
          case REACT_DEBUG_TRACING_MODE_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_FRAGMENT_TYPE: {
            renderNodeDestructive(request, task, props.children);
            return;
          }
          case REACT_SUSPENSE_LIST_TYPE: {
            pushBuiltInComponentStackInDEV(task, "SuspenseList");
            renderNodeDestructive(request, task, props.children);
            popComponentStackInDEV(task);
            return;
          }
          case REACT_SCOPE_TYPE: {
            throw new Error("ReactDOMServer does not yet support scope components.");
          }
          case REACT_SUSPENSE_TYPE: {
            {
              renderSuspenseBoundary(request, task, props);
            }
            return;
          }
        }
        if (typeof type145 === "object" && type145 !== null) {
          switch (type145.$$typeof) {
            case REACT_FORWARD_REF_TYPE: {
              renderForwardRef(request, task, type145, props, ref5);
              return;
            }
            case REACT_MEMO_TYPE: {
              renderMemo(request, task, type145, props, ref5);
              return;
            }
            case REACT_PROVIDER_TYPE: {
              renderContextProvider(request, task, type145, props);
              return;
            }
            case REACT_CONTEXT_TYPE: {
              renderContextConsumer(request, task, type145, props);
              return;
            }
            case REACT_LAZY_TYPE: {
              renderLazyComponent(request, task, type145, props);
              return;
            }
          }
        }
        var info = "";
        {
          if (type145 === undefined || typeof type145 === "object" && type145 !== null && Object.keys(type145).length === 0) {
            info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          }
        }
        throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type145 == null ? type145 : typeof type145) + "." + info));
      }
      function validateIterable(iterable, iteratorFn) {
        {
          if (typeof Symbol === "function" && iterable[Symbol.toStringTag] === "Generator") {
            if (!didWarnAboutGenerators) {
              error41("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
            }
            didWarnAboutGenerators = true;
          }
          if (iterable.entries === iteratorFn) {
            if (!didWarnAboutMaps) {
              error41("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
            }
            didWarnAboutMaps = true;
          }
        }
      }
      function renderNodeDestructive(request, task, node) {
        {
          try {
            return renderNodeDestructiveImpl(request, task, node);
          } catch (x) {
            if (typeof x === "object" && x !== null && typeof x.then === "function")
              ;
            else {
              lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
            }
            throw x;
          }
        }
      }
      function renderNodeDestructiveImpl(request, task, node) {
        task.node = node;
        if (typeof node === "object" && node !== null) {
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              var element = node;
              var type145 = element.type;
              var props = element.props;
              var ref5 = element.ref;
              renderElement(request, task, type145, props, ref5);
              return;
            }
            case REACT_PORTAL_TYPE:
              throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
            case REACT_LAZY_TYPE: {
              var lazyNode = node;
              var payload = lazyNode._payload;
              var init = lazyNode._init;
              var resolvedNode;
              {
                try {
                  resolvedNode = init(payload);
                } catch (x) {
                  if (typeof x === "object" && x !== null && typeof x.then === "function") {
                    pushBuiltInComponentStackInDEV(task, "Lazy");
                  }
                  throw x;
                }
              }
              renderNodeDestructive(request, task, resolvedNode);
              return;
            }
          }
          if (isArray(node)) {
            renderChildrenArray(request, task, node);
            return;
          }
          var iteratorFn = getIteratorFn(node);
          if (iteratorFn) {
            {
              validateIterable(node, iteratorFn);
            }
            var iterator7 = iteratorFn.call(node);
            if (iterator7) {
              var step = iterator7.next();
              if (!step.done) {
                var children = [];
                do {
                  children.push(step.value);
                  step = iterator7.next();
                } while (!step.done);
                renderChildrenArray(request, task, children);
                return;
              }
              return;
            }
          }
          var childString = Object.prototype.toString.call(node);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
        }
        if (typeof node === "string") {
          var segment = task.blockedSegment;
          segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);
          return;
        }
        if (typeof node === "number") {
          var _segment = task.blockedSegment;
          _segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, "" + node, request.responseState, _segment.lastPushedText);
          return;
        }
        {
          if (typeof node === "function") {
            error41("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
          }
        }
      }
      function renderChildrenArray(request, task, children) {
        var totalChildren = children.length;
        for (var i = 0;i < totalChildren; i++) {
          var prevTreeContext = task.treeContext;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);
          try {
            renderNode(request, task, children[i]);
          } finally {
            task.treeContext = prevTreeContext;
          }
        }
      }
      function spawnNewSuspendedTask(request, task, x) {
        var segment = task.blockedSegment;
        var insertionIndex = segment.chunks.length;
        var newSegment = createPendingSegment(request, insertionIndex, null, segment.formatContext, segment.lastPushedText, true);
        segment.children.push(newSegment);
        segment.lastPushedText = false;
        var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
        {
          if (task.componentStack !== null) {
            newTask.componentStack = task.componentStack.parent;
          }
        }
        var ping = newTask.ping;
        x.then(ping, ping);
      }
      function renderNode(request, task, node) {
        var previousFormatContext = task.blockedSegment.formatContext;
        var previousLegacyContext = task.legacyContext;
        var previousContext = task.context;
        var previousComponentStack = null;
        {
          previousComponentStack = task.componentStack;
        }
        try {
          return renderNodeDestructive(request, task, node);
        } catch (x) {
          resetHooksState();
          if (typeof x === "object" && x !== null && typeof x.then === "function") {
            spawnNewSuspendedTask(request, task, x);
            task.blockedSegment.formatContext = previousFormatContext;
            task.legacyContext = previousLegacyContext;
            task.context = previousContext;
            switchContext(previousContext);
            {
              task.componentStack = previousComponentStack;
            }
            return;
          } else {
            task.blockedSegment.formatContext = previousFormatContext;
            task.legacyContext = previousLegacyContext;
            task.context = previousContext;
            switchContext(previousContext);
            {
              task.componentStack = previousComponentStack;
            }
            throw x;
          }
        }
      }
      function erroredTask(request, boundary, segment, error42) {
        var errorDigest = logRecoverableError(request, error42);
        if (boundary === null) {
          fatalError(request, error42);
        } else {
          boundary.pendingTasks--;
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true;
            boundary.errorDigest = errorDigest;
            {
              captureBoundaryErrorDetailsDev(boundary, error42);
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary);
            }
          }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function abortTaskSoft(task) {
        var request = this;
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        finishedTask(request, boundary, segment);
      }
      function abortTask(task, request, reason) {
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        if (boundary === null) {
          request.allPendingTasks--;
          if (request.status !== CLOSED) {
            request.status = CLOSED;
            if (request.destination !== null) {
              close(request.destination);
            }
          }
        } else {
          boundary.pendingTasks--;
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true;
            var _error = reason === undefined ? new Error("The render was aborted by the server without a reason.") : reason;
            boundary.errorDigest = request.onError(_error);
            {
              var errorPrefix = "The server did not finish this Suspense boundary: ";
              if (_error && typeof _error.message === "string") {
                _error = errorPrefix + _error.message;
              } else {
                _error = errorPrefix + String(_error);
              }
              var previousTaskInDev = currentTaskInDEV;
              currentTaskInDEV = task;
              try {
                captureBoundaryErrorDetailsDev(boundary, _error);
              } finally {
                currentTaskInDEV = previousTaskInDev;
              }
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary);
            }
          }
          boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, reason);
          });
          boundary.fallbackAbortableTasks.clear();
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
      }
      function queueCompletedSegment(boundary, segment) {
        if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
          var childSegment = segment.children[0];
          childSegment.id = segment.id;
          childSegment.parentFlushed = true;
          if (childSegment.status === COMPLETED) {
            queueCompletedSegment(boundary, childSegment);
          }
        } else {
          var completedSegments = boundary.completedSegments;
          completedSegments.push(segment);
        }
      }
      function finishedTask(request, boundary, segment) {
        if (boundary === null) {
          if (segment.parentFlushed) {
            if (request.completedRootSegment !== null) {
              throw new Error("There can only be one root segment. This is a bug in React.");
            }
            request.completedRootSegment = segment;
          }
          request.pendingRootTasks--;
          if (request.pendingRootTasks === 0) {
            request.onShellError = noop$1;
            var onShellReady = request.onShellReady;
            onShellReady();
          }
        } else {
          boundary.pendingTasks--;
          if (boundary.forceClientRender)
            ;
          else if (boundary.pendingTasks === 0) {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment);
              }
            }
            if (boundary.parentFlushed) {
              request.completedBoundaries.push(boundary);
            }
            boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
            boundary.fallbackAbortableTasks.clear();
          } else {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment);
                var completedSegments = boundary.completedSegments;
                if (completedSegments.length === 1) {
                  if (boundary.parentFlushed) {
                    request.partialBoundaries.push(boundary);
                  }
                }
              }
            }
          }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function retryTask(request, task) {
        var segment = task.blockedSegment;
        if (segment.status !== PENDING) {
          return;
        }
        switchContext(task.context);
        var prevTaskInDEV = null;
        {
          prevTaskInDEV = currentTaskInDEV;
          currentTaskInDEV = task;
        }
        try {
          renderNodeDestructive(request, task, task.node);
          pushSegmentFinale(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
          task.abortSet.delete(task);
          segment.status = COMPLETED;
          finishedTask(request, task.blockedBoundary, segment);
        } catch (x) {
          resetHooksState();
          if (typeof x === "object" && x !== null && typeof x.then === "function") {
            var ping = task.ping;
            x.then(ping, ping);
          } else {
            task.abortSet.delete(task);
            segment.status = ERRORED;
            erroredTask(request, task.blockedBoundary, segment, x);
          }
        } finally {
          {
            currentTaskInDEV = prevTaskInDEV;
          }
        }
      }
      function performWork(request) {
        if (request.status === CLOSED) {
          return;
        }
        var prevContext = getActiveContext();
        var prevDispatcher = ReactCurrentDispatcher$1.current;
        ReactCurrentDispatcher$1.current = Dispatcher;
        var prevGetCurrentStackImpl;
        {
          prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
          ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
        }
        var prevResponseState = currentResponseState;
        setCurrentResponseState(request.responseState);
        try {
          var pingedTasks = request.pingedTasks;
          var i;
          for (i = 0;i < pingedTasks.length; i++) {
            var task = pingedTasks[i];
            retryTask(request, task);
          }
          pingedTasks.splice(0, i);
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination);
          }
        } catch (error42) {
          logRecoverableError(request, error42);
          fatalError(request, error42);
        } finally {
          setCurrentResponseState(prevResponseState);
          ReactCurrentDispatcher$1.current = prevDispatcher;
          {
            ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
          }
          if (prevDispatcher === Dispatcher) {
            switchContext(prevContext);
          }
        }
      }
      function flushSubtree(request, destination, segment) {
        segment.parentFlushed = true;
        switch (segment.status) {
          case PENDING: {
            var segmentID = segment.id = request.nextSegmentId++;
            segment.lastPushedText = false;
            segment.textEmbedded = false;
            return writePlaceholder(destination, request.responseState, segmentID);
          }
          case COMPLETED: {
            segment.status = FLUSHED;
            var r = true;
            var chunks = segment.chunks;
            var chunkIdx = 0;
            var children = segment.children;
            for (var childIdx = 0;childIdx < children.length; childIdx++) {
              var nextChild = children[childIdx];
              for (;chunkIdx < nextChild.index; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx]);
              }
              r = flushSegment(request, destination, nextChild);
            }
            for (;chunkIdx < chunks.length - 1; chunkIdx++) {
              writeChunk(destination, chunks[chunkIdx]);
            }
            if (chunkIdx < chunks.length) {
              r = writeChunkAndReturn(destination, chunks[chunkIdx]);
            }
            return r;
          }
          default: {
            throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
          }
        }
      }
      function flushSegment(request, destination, segment) {
        var boundary = segment.boundary;
        if (boundary === null) {
          return flushSubtree(request, destination, segment);
        }
        boundary.parentFlushed = true;
        if (boundary.forceClientRender) {
          writeStartClientRenderedSuspenseBoundary(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
          flushSubtree(request, destination, segment);
          return writeEndClientRenderedSuspenseBoundary(destination, request.responseState);
        } else if (boundary.pendingTasks > 0) {
          boundary.rootSegmentID = request.nextSegmentId++;
          if (boundary.completedSegments.length > 0) {
            request.partialBoundaries.push(boundary);
          }
          var id = boundary.id = assignSuspenseBoundaryID(request.responseState);
          writeStartPendingSuspenseBoundary(destination, request.responseState, id);
          flushSubtree(request, destination, segment);
          return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else if (boundary.byteSize > request.progressiveChunkSize) {
          boundary.rootSegmentID = request.nextSegmentId++;
          request.completedBoundaries.push(boundary);
          writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id);
          flushSubtree(request, destination, segment);
          return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else {
          writeStartCompletedSuspenseBoundary(destination, request.responseState);
          var completedSegments = boundary.completedSegments;
          if (completedSegments.length !== 1) {
            throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
          }
          var contentSegment = completedSegments[0];
          flushSegment(request, destination, contentSegment);
          return writeEndCompletedSuspenseBoundary(destination, request.responseState);
        }
      }
      function flushClientRenderedBoundary(request, destination, boundary) {
        return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
      }
      function flushSegmentContainer(request, destination, segment) {
        writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
        flushSegment(request, destination, segment);
        return writeEndSegment(destination, segment.formatContext);
      }
      function flushCompletedBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for (;i < completedSegments.length; i++) {
          var segment = completedSegments[i];
          flushPartiallyCompletedSegment(request, destination, boundary, segment);
        }
        completedSegments.length = 0;
        return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
      }
      function flushPartialBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for (;i < completedSegments.length; i++) {
          var segment = completedSegments[i];
          if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
            i++;
            completedSegments.splice(0, i);
            return false;
          }
        }
        completedSegments.splice(0, i);
        return true;
      }
      function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED) {
          return true;
        }
        var segmentID = segment.id;
        if (segmentID === -1) {
          var rootSegmentID = segment.id = boundary.rootSegmentID;
          if (rootSegmentID === -1) {
            throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
          }
          return flushSegmentContainer(request, destination, segment);
        } else {
          flushSegmentContainer(request, destination, segment);
          return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
        }
      }
      function flushCompletedQueues(request, destination) {
        beginWriting();
        try {
          var completedRootSegment = request.completedRootSegment;
          if (completedRootSegment !== null && request.pendingRootTasks === 0) {
            flushSegment(request, destination, completedRootSegment);
            request.completedRootSegment = null;
            writeCompletedRoot(destination, request.responseState);
          }
          var clientRenderedBoundaries = request.clientRenderedBoundaries;
          var i;
          for (i = 0;i < clientRenderedBoundaries.length; i++) {
            var boundary = clientRenderedBoundaries[i];
            if (!flushClientRenderedBoundary(request, destination, boundary)) {
              request.destination = null;
              i++;
              clientRenderedBoundaries.splice(0, i);
              return;
            }
          }
          clientRenderedBoundaries.splice(0, i);
          var completedBoundaries = request.completedBoundaries;
          for (i = 0;i < completedBoundaries.length; i++) {
            var _boundary = completedBoundaries[i];
            if (!flushCompletedBoundary(request, destination, _boundary)) {
              request.destination = null;
              i++;
              completedBoundaries.splice(0, i);
              return;
            }
          }
          completedBoundaries.splice(0, i);
          completeWriting(destination);
          beginWriting(destination);
          var partialBoundaries = request.partialBoundaries;
          for (i = 0;i < partialBoundaries.length; i++) {
            var _boundary2 = partialBoundaries[i];
            if (!flushPartialBoundary(request, destination, _boundary2)) {
              request.destination = null;
              i++;
              partialBoundaries.splice(0, i);
              return;
            }
          }
          partialBoundaries.splice(0, i);
          var largeBoundaries = request.completedBoundaries;
          for (i = 0;i < largeBoundaries.length; i++) {
            var _boundary3 = largeBoundaries[i];
            if (!flushCompletedBoundary(request, destination, _boundary3)) {
              request.destination = null;
              i++;
              largeBoundaries.splice(0, i);
              return;
            }
          }
          largeBoundaries.splice(0, i);
        } finally {
          completeWriting(destination);
          flushBuffered(destination);
          if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0) {
            {
              if (request.abortableTasks.size !== 0) {
                error41("There was still abortable task at the root when we closed. This is a bug in React.");
              }
            }
            close(destination);
          }
        }
      }
      function startWork(request) {
        scheduleWork(function() {
          return performWork(request);
        });
      }
      function startFlowing(request, destination) {
        if (request.status === CLOSING) {
          request.status = CLOSED;
          closeWithError(destination, request.fatalError);
          return;
        }
        if (request.status === CLOSED) {
          return;
        }
        if (request.destination !== null) {
          return;
        }
        request.destination = destination;
        try {
          flushCompletedQueues(request, destination);
        } catch (error42) {
          logRecoverableError(request, error42);
          fatalError(request, error42);
        }
      }
      function abort(request, reason) {
        try {
          var abortableTasks = request.abortableTasks;
          abortableTasks.forEach(function(task) {
            return abortTask(task, request, reason);
          });
          abortableTasks.clear();
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination);
          }
        } catch (error42) {
          logRecoverableError(request, error42);
          fatalError(request, error42);
        }
      }
      function createDrainHandler(destination, request) {
        return function() {
          return startFlowing(request, destination);
        };
      }
      function createAbortHandler(request, reason) {
        return function() {
          return abort(request, reason);
        };
      }
      function createRequestImpl(children, options) {
        return createRequest(children, createResponseState(options ? options.identifierPrefix : undefined, options ? options.nonce : undefined, options ? options.bootstrapScriptContent : undefined, options ? options.bootstrapScripts : undefined, options ? options.bootstrapModules : undefined), createRootFormatContext(options ? options.namespaceURI : undefined), options ? options.progressiveChunkSize : undefined, options ? options.onError : undefined, options ? options.onAllReady : undefined, options ? options.onShellReady : undefined, options ? options.onShellError : undefined, undefined);
      }
      function renderToPipeableStream(children, options) {
        var request = createRequestImpl(children, options);
        var hasStartedFlowing = false;
        startWork(request);
        return {
          pipe: function(destination) {
            if (hasStartedFlowing) {
              throw new Error("React currently only supports piping to one writable stream.");
            }
            hasStartedFlowing = true;
            startFlowing(request, destination);
            destination.on("drain", createDrainHandler(destination, request));
            destination.on("error", createAbortHandler(request, new Error("The destination stream errored while writing data.")));
            destination.on("close", createAbortHandler(request, new Error("The destination stream closed early.")));
            return destination;
          },
          abort: function(reason) {
            abort(request, reason);
          }
        };
      }
      exports.renderToPipeableStream = renderToPipeableStream;
      exports.version = ReactVersion;
    })();
  }
});

// ../sisventa/node_modules/react-dom/server.node.js
var exports_server_node = {};
__export(exports_server_node, {
  version: () => {
    {
      return $version;
    }
  },
  renderToString: () => {
    {
      return $renderToString;
    }
  },
  renderToStaticNodeStream: () => {
    {
      return $renderToStaticNodeStream;
    }
  },
  renderToStaticMarkup: () => {
    {
      return $renderToStaticMarkup;
    }
  },
  renderToPipeableStream: () => {
    {
      return $renderToPipeableStream;
    }
  },
  renderToNodeStream: () => {
    {
      return $renderToNodeStream;
    }
  }
});
var $version, $renderToString, $renderToStaticMarkup, $renderToNodeStream, $renderToStaticNodeStream, $renderToPipeableStream;
var init_server_node = __esm(() => {
  var react_dom_server_legacy_node_development = __toESM(require_react_dom_server_legacy_node_development(), 1);
  var react_dom_server_node_development = __toESM(require_react_dom_server_node_development(), 1);
  var l3;
  var s3;
  if (false) {
  } else {
    l3 = react_dom_server_legacy_node_development;
    s3 = react_dom_server_node_development;
  }
  $version = l3.version;
  $renderToString = l3.renderToString;
  $renderToStaticMarkup = l3.renderToStaticMarkup;
  $renderToNodeStream = l3.renderToNodeStream;
  $renderToStaticNodeStream = l3.renderToStaticNodeStream;
  $renderToPipeableStream = s3.renderToPipeableStream;
});

// ../sisventa/node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS((exports, module) => {
  var isNonNullObject = function(value27) {
    return !!value27 && typeof value27 === "object";
  };
  var isSpecial = function(value27) {
    var stringValue = Object.prototype.toString.call(value27);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value27);
  };
  var isReactElement = function(value27) {
    return value27.$$typeof === REACT_ELEMENT_TYPE;
  };
  var emptyTarget = function(val) {
    return Array.isArray(val) ? [] : {};
  };
  var cloneUnlessOtherwiseSpecified = function(value27, options) {
    return options.clone !== false && options.isMergeableObject(value27) ? deepmerge(emptyTarget(value27), value27, options) : value27;
  };
  var defaultArrayMerge = function(target, source, options) {
    return target.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  };
  var getMergeFunction = function(key, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === "function" ? customMerge : deepmerge;
  };
  var getEnumerableOwnPropertySymbols = function(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol7) {
      return Object.propertyIsEnumerable.call(target, symbol7);
    }) : [];
  };
  var getKeys = function(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  };
  var propertyIsOnObject = function(object23, property) {
    try {
      return property in object23;
    } catch (_) {
      return false;
    }
  };
  var propertyIsUnsafe = function(target, key) {
    return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
  };
  var mergeObject = function(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function(key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  };
  var deepmerge = function(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  };
  var isMergeableObject = function isMergeableObject(value27) {
    return isNonNullObject(value27) && !isSpecial(value27);
  };
  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
  deepmerge.all = function deepmergeAll(array7, options) {
    if (!Array.isArray(array7)) {
      throw new Error("first argument should be an array");
    }
    return array7.reduce(function(prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  module.exports = deepmerge_1;
});

// ../sisventa/node_modules/js-beautify/js/src/core/output.js
var require_output = __commonJS((exports, module) => {
  var OutputLine = function(parent) {
    this.__parent = parent;
    this.__character_count = 0;
    this.__indent_count = -1;
    this.__alignment_count = 0;
    this.__wrap_point_index = 0;
    this.__wrap_point_character_count = 0;
    this.__wrap_point_indent_count = -1;
    this.__wrap_point_alignment_count = 0;
    this.__items = [];
  };
  var IndentStringCache = function(options, baseIndentString) {
    this.__cache = [""];
    this.__indent_size = options.indent_size;
    this.__indent_string = options.indent_char;
    if (!options.indent_with_tabs) {
      this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
    }
    baseIndentString = baseIndentString || "";
    if (options.indent_level > 0) {
      baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
    }
    this.__base_string = baseIndentString;
    this.__base_string_length = baseIndentString.length;
  };
  var Output = function(options, baseIndentString) {
    this.__indent_cache = new IndentStringCache(options, baseIndentString);
    this.raw = false;
    this._end_with_newline = options.end_with_newline;
    this.indent_size = options.indent_size;
    this.wrap_line_length = options.wrap_line_length;
    this.indent_empty_lines = options.indent_empty_lines;
    this.__lines = [];
    this.previous_line = null;
    this.current_line = null;
    this.next_line = new OutputLine(this);
    this.space_before_token = false;
    this.non_breaking_space = false;
    this.previous_token_wrapped = false;
    this.__add_outputline();
  };
  OutputLine.prototype.clone_empty = function() {
    var line = new OutputLine(this.__parent);
    line.set_indent(this.__indent_count, this.__alignment_count);
    return line;
  };
  OutputLine.prototype.item = function(index) {
    if (index < 0) {
      return this.__items[this.__items.length + index];
    } else {
      return this.__items[index];
    }
  };
  OutputLine.prototype.has_match = function(pattern5) {
    for (var lastCheckedOutput = this.__items.length - 1;lastCheckedOutput >= 0; lastCheckedOutput--) {
      if (this.__items[lastCheckedOutput].match(pattern5)) {
        return true;
      }
    }
    return false;
  };
  OutputLine.prototype.set_indent = function(indent, alignment) {
    if (this.is_empty()) {
      this.__indent_count = indent || 0;
      this.__alignment_count = alignment || 0;
      this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
    }
  };
  OutputLine.prototype._set_wrap_point = function() {
    if (this.__parent.wrap_line_length) {
      this.__wrap_point_index = this.__items.length;
      this.__wrap_point_character_count = this.__character_count;
      this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
      this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
    }
  };
  OutputLine.prototype._should_wrap = function() {
    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
  };
  OutputLine.prototype._allow_wrap = function() {
    if (this._should_wrap()) {
      this.__parent.add_new_line();
      var next = this.__parent.current_line;
      next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
      next.__items = this.__items.slice(this.__wrap_point_index);
      this.__items = this.__items.slice(0, this.__wrap_point_index);
      next.__character_count += this.__character_count - this.__wrap_point_character_count;
      this.__character_count = this.__wrap_point_character_count;
      if (next.__items[0] === " ") {
        next.__items.splice(0, 1);
        next.__character_count -= 1;
      }
      return true;
    }
    return false;
  };
  OutputLine.prototype.is_empty = function() {
    return this.__items.length === 0;
  };
  OutputLine.prototype.last = function() {
    if (!this.is_empty()) {
      return this.__items[this.__items.length - 1];
    } else {
      return null;
    }
  };
  OutputLine.prototype.push = function(item) {
    this.__items.push(item);
    var last_newline_index = item.lastIndexOf("\n");
    if (last_newline_index !== -1) {
      this.__character_count = item.length - last_newline_index;
    } else {
      this.__character_count += item.length;
    }
  };
  OutputLine.prototype.pop = function() {
    var item = null;
    if (!this.is_empty()) {
      item = this.__items.pop();
      this.__character_count -= item.length;
    }
    return item;
  };
  OutputLine.prototype._remove_indent = function() {
    if (this.__indent_count > 0) {
      this.__indent_count -= 1;
      this.__character_count -= this.__parent.indent_size;
    }
  };
  OutputLine.prototype._remove_wrap_indent = function() {
    if (this.__wrap_point_indent_count > 0) {
      this.__wrap_point_indent_count -= 1;
    }
  };
  OutputLine.prototype.trim = function() {
    while (this.last() === " ") {
      this.__items.pop();
      this.__character_count -= 1;
    }
  };
  OutputLine.prototype.toString = function() {
    var result = "";
    if (this.is_empty()) {
      if (this.__parent.indent_empty_lines) {
        result = this.__parent.get_indent_string(this.__indent_count);
      }
    } else {
      result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
      result += this.__items.join("");
    }
    return result;
  };
  IndentStringCache.prototype.get_indent_size = function(indent, column) {
    var result = this.__base_string_length;
    column = column || 0;
    if (indent < 0) {
      result = 0;
    }
    result += indent * this.__indent_size;
    result += column;
    return result;
  };
  IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
    var result = this.__base_string;
    column = column || 0;
    if (indent_level < 0) {
      indent_level = 0;
      result = "";
    }
    column += indent_level * this.__indent_size;
    this.__ensure_cache(column);
    result += this.__cache[column];
    return result;
  };
  IndentStringCache.prototype.__ensure_cache = function(column) {
    while (column >= this.__cache.length) {
      this.__add_column();
    }
  };
  IndentStringCache.prototype.__add_column = function() {
    var column = this.__cache.length;
    var indent = 0;
    var result = "";
    if (this.__indent_size && column >= this.__indent_size) {
      indent = Math.floor(column / this.__indent_size);
      column -= indent * this.__indent_size;
      result = new Array(indent + 1).join(this.__indent_string);
    }
    if (column) {
      result += new Array(column + 1).join(" ");
    }
    this.__cache.push(result);
  };
  Output.prototype.__add_outputline = function() {
    this.previous_line = this.current_line;
    this.current_line = this.next_line.clone_empty();
    this.__lines.push(this.current_line);
  };
  Output.prototype.get_line_number = function() {
    return this.__lines.length;
  };
  Output.prototype.get_indent_string = function(indent, column) {
    return this.__indent_cache.get_indent_string(indent, column);
  };
  Output.prototype.get_indent_size = function(indent, column) {
    return this.__indent_cache.get_indent_size(indent, column);
  };
  Output.prototype.is_empty = function() {
    return !this.previous_line && this.current_line.is_empty();
  };
  Output.prototype.add_new_line = function(force_newline) {
    if (this.is_empty() || !force_newline && this.just_added_newline()) {
      return false;
    }
    if (!this.raw) {
      this.__add_outputline();
    }
    return true;
  };
  Output.prototype.get_code = function(eol) {
    this.trim(true);
    var last_item = this.current_line.pop();
    if (last_item) {
      if (last_item[last_item.length - 1] === "\n") {
        last_item = last_item.replace(/\n+$/g, "");
      }
      this.current_line.push(last_item);
    }
    if (this._end_with_newline) {
      this.__add_outputline();
    }
    var sweet_code = this.__lines.join("\n");
    if (eol !== "\n") {
      sweet_code = sweet_code.replace(/[\n]/g, eol);
    }
    return sweet_code;
  };
  Output.prototype.set_wrap_point = function() {
    this.current_line._set_wrap_point();
  };
  Output.prototype.set_indent = function(indent, alignment) {
    indent = indent || 0;
    alignment = alignment || 0;
    this.next_line.set_indent(indent, alignment);
    if (this.__lines.length > 1) {
      this.current_line.set_indent(indent, alignment);
      return true;
    }
    this.current_line.set_indent();
    return false;
  };
  Output.prototype.add_raw_token = function(token2) {
    for (var x = 0;x < token2.newlines; x++) {
      this.__add_outputline();
    }
    this.current_line.set_indent(-1);
    this.current_line.push(token2.whitespace_before);
    this.current_line.push(token2.text);
    this.space_before_token = false;
    this.non_breaking_space = false;
    this.previous_token_wrapped = false;
  };
  Output.prototype.add_token = function(printable_token) {
    this.__add_space_before_token();
    this.current_line.push(printable_token);
    this.space_before_token = false;
    this.non_breaking_space = false;
    this.previous_token_wrapped = this.current_line._allow_wrap();
  };
  Output.prototype.__add_space_before_token = function() {
    if (this.space_before_token && !this.just_added_newline()) {
      if (!this.non_breaking_space) {
        this.set_wrap_point();
      }
      this.current_line.push(" ");
    }
  };
  Output.prototype.remove_indent = function(index) {
    var output_length = this.__lines.length;
    while (index < output_length) {
      this.__lines[index]._remove_indent();
      index++;
    }
    this.current_line._remove_wrap_indent();
  };
  Output.prototype.trim = function(eat_newlines) {
    eat_newlines = eat_newlines === undefined ? false : eat_newlines;
    this.current_line.trim();
    while (eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()) {
      this.__lines.pop();
      this.current_line = this.__lines[this.__lines.length - 1];
      this.current_line.trim();
    }
    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;
  };
  Output.prototype.just_added_newline = function() {
    return this.current_line.is_empty();
  };
  Output.prototype.just_added_blankline = function() {
    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
  };
  Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
    var index = this.__lines.length - 2;
    while (index >= 0) {
      var potentialEmptyLine = this.__lines[index];
      if (potentialEmptyLine.is_empty()) {
        break;
      } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {
        this.__lines.splice(index + 1, 0, new OutputLine(this));
        this.previous_line = this.__lines[this.__lines.length - 2];
        break;
      }
      index--;
    }
  };
  exports.Output = Output;
});

// ../sisventa/node_modules/js-beautify/js/src/core/token.js
var require_token = __commonJS((exports, module) => {
  var Token = function(type145, text, newlines, whitespace_before) {
    this.type = type145;
    this.text = text;
    this.comments_before = null;
    this.newlines = newlines || 0;
    this.whitespace_before = whitespace_before || "";
    this.parent = null;
    this.next = null;
    this.previous = null;
    this.opened = null;
    this.closed = null;
    this.directives = null;
  };
  exports.Token = Token;
});

// ../sisventa/node_modules/js-beautify/js/src/javascript/acorn.js
var require_acorn = __commonJS((exports) => {
  var baseASCIIidentifierStartChars = "\\x23\\x24\\x40\\x41-\\x5a\\x5f\\x61-\\x7a";
  var baseASCIIidentifierChars = "\\x24\\x30-\\x39\\x41-\\x5a\\x5f\\x61-\\x7a";
  var nonASCIIidentifierStartChars = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";
  var nonASCIIidentifierChars = "\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f";
  var unicodeEscapeOrCodePoint = "\\\\u[0-9a-fA-F]{4}|\\\\u\\{[0-9a-fA-F]+\\}";
  var identifierStart = "(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + "])";
  var identifierChars = "(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])*";
  exports.identifier = new RegExp(identifierStart + identifierChars, "g");
  exports.identifierStart = new RegExp(identifierStart);
  exports.identifierMatch = new RegExp("(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])+");
  exports.newline = /[\n\r\u2028\u2029]/;
  exports.lineBreak = new RegExp("\r\n|" + exports.newline.source);
  exports.allLineBreaks = new RegExp(exports.lineBreak.source, "g");
});

// ../sisventa/node_modules/js-beautify/js/src/core/options.js
var require_options = __commonJS((exports, module) => {
  var Options = function(options, merge_child_field) {
    this.raw_options = _mergeOpts(options, merge_child_field);
    this.disabled = this._get_boolean("disabled");
    this.eol = this._get_characters("eol", "auto");
    this.end_with_newline = this._get_boolean("end_with_newline");
    this.indent_size = this._get_number("indent_size", 4);
    this.indent_char = this._get_characters("indent_char", " ");
    this.indent_level = this._get_number("indent_level");
    this.preserve_newlines = this._get_boolean("preserve_newlines", true);
    this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786);
    if (!this.preserve_newlines) {
      this.max_preserve_newlines = 0;
    }
    this.indent_with_tabs = this._get_boolean("indent_with_tabs", this.indent_char === "\t");
    if (this.indent_with_tabs) {
      this.indent_char = "\t";
      if (this.indent_size === 1) {
        this.indent_size = 4;
      }
    }
    this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char"));
    this.indent_empty_lines = this._get_boolean("indent_empty_lines");
    this.templating = this._get_selection_list("templating", ["auto", "none", "django", "erb", "handlebars", "php", "smarty"], ["auto"]);
  };
  var _mergeOpts = function(allOptions, childFieldName) {
    var finalOpts = {};
    allOptions = _normalizeOpts(allOptions);
    var name2;
    for (name2 in allOptions) {
      if (name2 !== childFieldName) {
        finalOpts[name2] = allOptions[name2];
      }
    }
    if (childFieldName && allOptions[childFieldName]) {
      for (name2 in allOptions[childFieldName]) {
        finalOpts[name2] = allOptions[childFieldName][name2];
      }
    }
    return finalOpts;
  };
  var _normalizeOpts = function(options) {
    var convertedOpts = {};
    var key;
    for (key in options) {
      var newKey = key.replace(/-/g, "_");
      convertedOpts[newKey] = options[key];
    }
    return convertedOpts;
  };
  Options.prototype._get_array = function(name2, default_value) {
    var option_value = this.raw_options[name2];
    var result = default_value || [];
    if (typeof option_value === "object") {
      if (option_value !== null && typeof option_value.concat === "function") {
        result = option_value.concat();
      }
    } else if (typeof option_value === "string") {
      result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
    }
    return result;
  };
  Options.prototype._get_boolean = function(name2, default_value) {
    var option_value = this.raw_options[name2];
    var result = option_value === undefined ? !!default_value : !!option_value;
    return result;
  };
  Options.prototype._get_characters = function(name2, default_value) {
    var option_value = this.raw_options[name2];
    var result = default_value || "";
    if (typeof option_value === "string") {
      result = option_value.replace(/\\r/, "\r").replace(/\\n/, "\n").replace(/\\t/, "\t");
    }
    return result;
  };
  Options.prototype._get_number = function(name2, default_value) {
    var option_value = this.raw_options[name2];
    default_value = parseInt(default_value, 10);
    if (isNaN(default_value)) {
      default_value = 0;
    }
    var result = parseInt(option_value, 10);
    if (isNaN(result)) {
      result = default_value;
    }
    return result;
  };
  Options.prototype._get_selection = function(name2, selection_list, default_value) {
    var result = this._get_selection_list(name2, selection_list, default_value);
    if (result.length !== 1) {
      throw new Error("Invalid Option Value: The option '" + name2 + "' can only be one of the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name2] + "'");
    }
    return result[0];
  };
  Options.prototype._get_selection_list = function(name2, selection_list, default_value) {
    if (!selection_list || selection_list.length === 0) {
      throw new Error("Selection list cannot be empty.");
    }
    default_value = default_value || [selection_list[0]];
    if (!this._is_valid_selection(default_value, selection_list)) {
      throw new Error("Invalid Default Value!");
    }
    var result = this._get_array(name2, default_value);
    if (!this._is_valid_selection(result, selection_list)) {
      throw new Error("Invalid Option Value: The option '" + name2 + "' can contain only the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name2] + "'");
    }
    return result;
  };
  Options.prototype._is_valid_selection = function(result, selection_list) {
    return result.length && selection_list.length && !result.some(function(item) {
      return selection_list.indexOf(item) === -1;
    });
  };
  exports.Options = Options;
  exports.normalizeOpts = _normalizeOpts;
  exports.mergeOpts = _mergeOpts;
});

// ../sisventa/node_modules/js-beautify/js/src/javascript/options.js
var require_options2 = __commonJS((exports, module) => {
  var Options = function(options) {
    BaseOptions.call(this, options, "js");
    var raw_brace_style = this.raw_options.brace_style || null;
    if (raw_brace_style === "expand-strict") {
      this.raw_options.brace_style = "expand";
    } else if (raw_brace_style === "collapse-preserve-inline") {
      this.raw_options.brace_style = "collapse,preserve-inline";
    } else if (this.raw_options.braces_on_own_line !== undefined) {
      this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse";
    }
    var brace_style_split = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
    this.brace_preserve_inline = false;
    this.brace_style = "collapse";
    for (var bs = 0;bs < brace_style_split.length; bs++) {
      if (brace_style_split[bs] === "preserve-inline") {
        this.brace_preserve_inline = true;
      } else {
        this.brace_style = brace_style_split[bs];
      }
    }
    this.unindent_chained_methods = this._get_boolean("unindent_chained_methods");
    this.break_chained_methods = this._get_boolean("break_chained_methods");
    this.space_in_paren = this._get_boolean("space_in_paren");
    this.space_in_empty_paren = this._get_boolean("space_in_empty_paren");
    this.jslint_happy = this._get_boolean("jslint_happy");
    this.space_after_anon_function = this._get_boolean("space_after_anon_function");
    this.space_after_named_function = this._get_boolean("space_after_named_function");
    this.keep_array_indentation = this._get_boolean("keep_array_indentation");
    this.space_before_conditional = this._get_boolean("space_before_conditional", true);
    this.unescape_strings = this._get_boolean("unescape_strings");
    this.e4x = this._get_boolean("e4x");
    this.comma_first = this._get_boolean("comma_first");
    this.operator_position = this._get_selection("operator_position", validPositionValues);
    this.test_output_raw = this._get_boolean("test_output_raw");
    if (this.jslint_happy) {
      this.space_after_anon_function = true;
    }
  };
  var BaseOptions = require_options().Options;
  var validPositionValues = ["before-newline", "after-newline", "preserve-newline"];
  Options.prototype = new BaseOptions;
  exports.Options = Options;
});

// ../sisventa/node_modules/js-beautify/js/src/core/inputscanner.js
var require_inputscanner = __commonJS((exports, module) => {
  var InputScanner = function(input_string) {
    this.__input = input_string || "";
    this.__input_length = this.__input.length;
    this.__position = 0;
  };
  var regexp_has_sticky = RegExp.prototype.hasOwnProperty("sticky");
  InputScanner.prototype.restart = function() {
    this.__position = 0;
  };
  InputScanner.prototype.back = function() {
    if (this.__position > 0) {
      this.__position -= 1;
    }
  };
  InputScanner.prototype.hasNext = function() {
    return this.__position < this.__input_length;
  };
  InputScanner.prototype.next = function() {
    var val = null;
    if (this.hasNext()) {
      val = this.__input.charAt(this.__position);
      this.__position += 1;
    }
    return val;
  };
  InputScanner.prototype.peek = function(index) {
    var val = null;
    index = index || 0;
    index += this.__position;
    if (index >= 0 && index < this.__input_length) {
      val = this.__input.charAt(index);
    }
    return val;
  };
  InputScanner.prototype.__match = function(pattern5, index) {
    pattern5.lastIndex = index;
    var pattern_match = pattern5.exec(this.__input);
    if (pattern_match && !(regexp_has_sticky && pattern5.sticky)) {
      if (pattern_match.index !== index) {
        pattern_match = null;
      }
    }
    return pattern_match;
  };
  InputScanner.prototype.test = function(pattern5, index) {
    index = index || 0;
    index += this.__position;
    if (index >= 0 && index < this.__input_length) {
      return !!this.__match(pattern5, index);
    } else {
      return false;
    }
  };
  InputScanner.prototype.testChar = function(pattern5, index) {
    var val = this.peek(index);
    pattern5.lastIndex = 0;
    return val !== null && pattern5.test(val);
  };
  InputScanner.prototype.match = function(pattern5) {
    var pattern_match = this.__match(pattern5, this.__position);
    if (pattern_match) {
      this.__position += pattern_match[0].length;
    } else {
      pattern_match = null;
    }
    return pattern_match;
  };
  InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
    var val = "";
    var match;
    if (starting_pattern) {
      match = this.match(starting_pattern);
      if (match) {
        val += match[0];
      }
    }
    if (until_pattern && (match || !starting_pattern)) {
      val += this.readUntil(until_pattern, until_after);
    }
    return val;
  };
  InputScanner.prototype.readUntil = function(pattern5, until_after) {
    var val = "";
    var match_index = this.__position;
    pattern5.lastIndex = this.__position;
    var pattern_match = pattern5.exec(this.__input);
    if (pattern_match) {
      match_index = pattern_match.index;
      if (until_after) {
        match_index += pattern_match[0].length;
      }
    } else {
      match_index = this.__input_length;
    }
    val = this.__input.substring(this.__position, match_index);
    this.__position = match_index;
    return val;
  };
  InputScanner.prototype.readUntilAfter = function(pattern5) {
    return this.readUntil(pattern5, true);
  };
  InputScanner.prototype.get_regexp = function(pattern5, match_from) {
    var result = null;
    var flags = "g";
    if (match_from && regexp_has_sticky) {
      flags = "y";
    }
    if (typeof pattern5 === "string" && pattern5 !== "") {
      result = new RegExp(pattern5, flags);
    } else if (pattern5) {
      result = new RegExp(pattern5.source, flags);
    }
    return result;
  };
  InputScanner.prototype.get_literal_regexp = function(literal_string) {
    return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"));
  };
  InputScanner.prototype.peekUntilAfter = function(pattern5) {
    var start = this.__position;
    var val = this.readUntilAfter(pattern5);
    this.__position = start;
    return val;
  };
  InputScanner.prototype.lookBack = function(testVal) {
    var start = this.__position - 1;
    return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;
  };
  exports.InputScanner = InputScanner;
});

// ../sisventa/node_modules/js-beautify/js/src/core/tokenstream.js
var require_tokenstream = __commonJS((exports, module) => {
  var TokenStream = function(parent_token) {
    this.__tokens = [];
    this.__tokens_length = this.__tokens.length;
    this.__position = 0;
    this.__parent_token = parent_token;
  };
  TokenStream.prototype.restart = function() {
    this.__position = 0;
  };
  TokenStream.prototype.isEmpty = function() {
    return this.__tokens_length === 0;
  };
  TokenStream.prototype.hasNext = function() {
    return this.__position < this.__tokens_length;
  };
  TokenStream.prototype.next = function() {
    var val = null;
    if (this.hasNext()) {
      val = this.__tokens[this.__position];
      this.__position += 1;
    }
    return val;
  };
  TokenStream.prototype.peek = function(index) {
    var val = null;
    index = index || 0;
    index += this.__position;
    if (index >= 0 && index < this.__tokens_length) {
      val = this.__tokens[index];
    }
    return val;
  };
  TokenStream.prototype.add = function(token2) {
    if (this.__parent_token) {
      token2.parent = this.__parent_token;
    }
    this.__tokens.push(token2);
    this.__tokens_length += 1;
  };
  exports.TokenStream = TokenStream;
});

// ../sisventa/node_modules/js-beautify/js/src/core/pattern.js
var require_pattern = __commonJS((exports, module) => {
  var Pattern = function(input_scanner, parent) {
    this._input = input_scanner;
    this._starting_pattern = null;
    this._match_pattern = null;
    this._until_pattern = null;
    this._until_after = false;
    if (parent) {
      this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);
      this._match_pattern = this._input.get_regexp(parent._match_pattern, true);
      this._until_pattern = this._input.get_regexp(parent._until_pattern);
      this._until_after = parent._until_after;
    }
  };
  Pattern.prototype.read = function() {
    var result = this._input.read(this._starting_pattern);
    if (!this._starting_pattern || result) {
      result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
    }
    return result;
  };
  Pattern.prototype.read_match = function() {
    return this._input.match(this._match_pattern);
  };
  Pattern.prototype.until_after = function(pattern5) {
    var result = this._create();
    result._until_after = true;
    result._until_pattern = this._input.get_regexp(pattern5);
    result._update();
    return result;
  };
  Pattern.prototype.until = function(pattern5) {
    var result = this._create();
    result._until_after = false;
    result._until_pattern = this._input.get_regexp(pattern5);
    result._update();
    return result;
  };
  Pattern.prototype.starting_with = function(pattern5) {
    var result = this._create();
    result._starting_pattern = this._input.get_regexp(pattern5, true);
    result._update();
    return result;
  };
  Pattern.prototype.matching = function(pattern5) {
    var result = this._create();
    result._match_pattern = this._input.get_regexp(pattern5, true);
    result._update();
    return result;
  };
  Pattern.prototype._create = function() {
    return new Pattern(this._input, this);
  };
  Pattern.prototype._update = function() {
  };
  exports.Pattern = Pattern;
});

// ../sisventa/node_modules/js-beautify/js/src/core/whitespacepattern.js
var require_whitespacepattern = __commonJS((exports, module) => {
  var WhitespacePattern = function(input_scanner, parent) {
    Pattern.call(this, input_scanner, parent);
    if (parent) {
      this._line_regexp = this._input.get_regexp(parent._line_regexp);
    } else {
      this.__set_whitespace_patterns("", "");
    }
    this.newline_count = 0;
    this.whitespace_before_token = "";
  };
  var Pattern = require_pattern().Pattern;
  WhitespacePattern.prototype = new Pattern;
  WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
    whitespace_chars += "\\t ";
    newline_chars += "\\n\\r";
    this._match_pattern = this._input.get_regexp("[" + whitespace_chars + newline_chars + "]+", true);
    this._newline_regexp = this._input.get_regexp("\\r\\n|[" + newline_chars + "]");
  };
  WhitespacePattern.prototype.read = function() {
    this.newline_count = 0;
    this.whitespace_before_token = "";
    var resulting_string = this._input.read(this._match_pattern);
    if (resulting_string === " ") {
      this.whitespace_before_token = " ";
    } else if (resulting_string) {
      var matches = this.__split(this._newline_regexp, resulting_string);
      this.newline_count = matches.length - 1;
      this.whitespace_before_token = matches[this.newline_count];
    }
    return resulting_string;
  };
  WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {
    var result = this._create();
    result.__set_whitespace_patterns(whitespace_chars, newline_chars);
    result._update();
    return result;
  };
  WhitespacePattern.prototype._create = function() {
    return new WhitespacePattern(this._input, this);
  };
  WhitespacePattern.prototype.__split = function(regexp5, input_string) {
    regexp5.lastIndex = 0;
    var start_index = 0;
    var result = [];
    var next_match = regexp5.exec(input_string);
    while (next_match) {
      result.push(input_string.substring(start_index, next_match.index));
      start_index = next_match.index + next_match[0].length;
      next_match = regexp5.exec(input_string);
    }
    if (start_index < input_string.length) {
      result.push(input_string.substring(start_index, input_string.length));
    } else {
      result.push("");
    }
    return result;
  };
  exports.WhitespacePattern = WhitespacePattern;
});

// ../sisventa/node_modules/js-beautify/js/src/core/tokenizer.js
var require_tokenizer = __commonJS((exports, module) => {
  var InputScanner = require_inputscanner().InputScanner;
  var Token = require_token().Token;
  var TokenStream = require_tokenstream().TokenStream;
  var WhitespacePattern = require_whitespacepattern().WhitespacePattern;
  var TOKEN = {
    START: "TK_START",
    RAW: "TK_RAW",
    EOF: "TK_EOF"
  };
  var Tokenizer3 = function(input_string, options) {
    this._input = new InputScanner(input_string);
    this._options = options || {};
    this.__tokens = null;
    this._patterns = {};
    this._patterns.whitespace = new WhitespacePattern(this._input);
  };
  Tokenizer3.prototype.tokenize = function() {
    this._input.restart();
    this.__tokens = new TokenStream;
    this._reset();
    var current;
    var previous = new Token(TOKEN.START, "");
    var open_token = null;
    var open_stack = [];
    var comments = new TokenStream;
    while (previous.type !== TOKEN.EOF) {
      current = this._get_next_token(previous, open_token);
      while (this._is_comment(current)) {
        comments.add(current);
        current = this._get_next_token(previous, open_token);
      }
      if (!comments.isEmpty()) {
        current.comments_before = comments;
        comments = new TokenStream;
      }
      current.parent = open_token;
      if (this._is_opening(current)) {
        open_stack.push(open_token);
        open_token = current;
      } else if (open_token && this._is_closing(current, open_token)) {
        current.opened = open_token;
        open_token.closed = current;
        open_token = open_stack.pop();
        current.parent = open_token;
      }
      current.previous = previous;
      previous.next = current;
      this.__tokens.add(current);
      previous = current;
    }
    return this.__tokens;
  };
  Tokenizer3.prototype._is_first_token = function() {
    return this.__tokens.isEmpty();
  };
  Tokenizer3.prototype._reset = function() {
  };
  Tokenizer3.prototype._get_next_token = function(previous_token, open_token) {
    this._readWhitespace();
    var resulting_string = this._input.read(/.+/g);
    if (resulting_string) {
      return this._create_token(TOKEN.RAW, resulting_string);
    } else {
      return this._create_token(TOKEN.EOF, "");
    }
  };
  Tokenizer3.prototype._is_comment = function(current_token) {
    return false;
  };
  Tokenizer3.prototype._is_opening = function(current_token) {
    return false;
  };
  Tokenizer3.prototype._is_closing = function(current_token, open_token) {
    return false;
  };
  Tokenizer3.prototype._create_token = function(type145, text) {
    var token2 = new Token(type145, text, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);
    return token2;
  };
  Tokenizer3.prototype._readWhitespace = function() {
    return this._patterns.whitespace.read();
  };
  exports.Tokenizer = Tokenizer3;
  exports.TOKEN = TOKEN;
});

// ../sisventa/node_modules/js-beautify/js/src/core/directives.js
var require_directives = __commonJS((exports, module) => {
  var Directives = function(start_block_pattern, end_block_pattern) {
    start_block_pattern = typeof start_block_pattern === "string" ? start_block_pattern : start_block_pattern.source;
    end_block_pattern = typeof end_block_pattern === "string" ? end_block_pattern : end_block_pattern.source;
    this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, "g");
    this.__directive_pattern = / (\w+)[:](\w+)/g;
    this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, "g");
  };
  Directives.prototype.get_directives = function(text) {
    if (!text.match(this.__directives_block_pattern)) {
      return null;
    }
    var directives = {};
    this.__directive_pattern.lastIndex = 0;
    var directive_match = this.__directive_pattern.exec(text);
    while (directive_match) {
      directives[directive_match[1]] = directive_match[2];
      directive_match = this.__directive_pattern.exec(text);
    }
    return directives;
  };
  Directives.prototype.readIgnored = function(input) {
    return input.readUntilAfter(this.__directives_end_ignore_pattern);
  };
  exports.Directives = Directives;
});

// ../sisventa/node_modules/js-beautify/js/src/core/templatablepattern.js
var require_templatablepattern = __commonJS((exports, module) => {
  var TemplatablePattern = function(input_scanner, parent) {
    Pattern.call(this, input_scanner, parent);
    this.__template_pattern = null;
    this._disabled = Object.assign({}, template_names);
    this._excluded = Object.assign({}, template_names);
    if (parent) {
      this.__template_pattern = this._input.get_regexp(parent.__template_pattern);
      this._excluded = Object.assign(this._excluded, parent._excluded);
      this._disabled = Object.assign(this._disabled, parent._disabled);
    }
    var pattern5 = new Pattern(input_scanner);
    this.__patterns = {
      handlebars_comment: pattern5.starting_with(/{{!--/).until_after(/--}}/),
      handlebars_unescaped: pattern5.starting_with(/{{{/).until_after(/}}}/),
      handlebars: pattern5.starting_with(/{{/).until_after(/}}/),
      php: pattern5.starting_with(/<\?(?:[= ]|php)/).until_after(/\?>/),
      erb: pattern5.starting_with(/<%[^%]/).until_after(/[^%]%>/),
      django: pattern5.starting_with(/{%/).until_after(/%}/),
      django_value: pattern5.starting_with(/{{/).until_after(/}}/),
      django_comment: pattern5.starting_with(/{#/).until_after(/#}/),
      smarty: pattern5.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
      smarty_comment: pattern5.starting_with(/{\*/).until_after(/\*}/),
      smarty_literal: pattern5.starting_with(/{literal}/).until_after(/{\/literal}/)
    };
  };
  var Pattern = require_pattern().Pattern;
  var template_names = {
    django: false,
    erb: false,
    handlebars: false,
    php: false,
    smarty: false
  };
  TemplatablePattern.prototype = new Pattern;
  TemplatablePattern.prototype._create = function() {
    return new TemplatablePattern(this._input, this);
  };
  TemplatablePattern.prototype._update = function() {
    this.__set_templated_pattern();
  };
  TemplatablePattern.prototype.disable = function(language) {
    var result = this._create();
    result._disabled[language] = true;
    result._update();
    return result;
  };
  TemplatablePattern.prototype.read_options = function(options) {
    var result = this._create();
    for (var language in template_names) {
      result._disabled[language] = options.templating.indexOf(language) === -1;
    }
    result._update();
    return result;
  };
  TemplatablePattern.prototype.exclude = function(language) {
    var result = this._create();
    result._excluded[language] = true;
    result._update();
    return result;
  };
  TemplatablePattern.prototype.read = function() {
    var result = "";
    if (this._match_pattern) {
      result = this._input.read(this._starting_pattern);
    } else {
      result = this._input.read(this._starting_pattern, this.__template_pattern);
    }
    var next = this._read_template();
    while (next) {
      if (this._match_pattern) {
        next += this._input.read(this._match_pattern);
      } else {
        next += this._input.readUntil(this.__template_pattern);
      }
      result += next;
      next = this._read_template();
    }
    if (this._until_after) {
      result += this._input.readUntilAfter(this._until_pattern);
    }
    return result;
  };
  TemplatablePattern.prototype.__set_templated_pattern = function() {
    var items = [];
    if (!this._disabled.php) {
      items.push(this.__patterns.php._starting_pattern.source);
    }
    if (!this._disabled.handlebars) {
      items.push(this.__patterns.handlebars._starting_pattern.source);
    }
    if (!this._disabled.erb) {
      items.push(this.__patterns.erb._starting_pattern.source);
    }
    if (!this._disabled.django) {
      items.push(this.__patterns.django._starting_pattern.source);
      items.push(this.__patterns.django_value._starting_pattern.source);
      items.push(this.__patterns.django_comment._starting_pattern.source);
    }
    if (!this._disabled.smarty) {
      items.push(this.__patterns.smarty._starting_pattern.source);
    }
    if (this._until_pattern) {
      items.push(this._until_pattern.source);
    }
    this.__template_pattern = this._input.get_regexp("(?:" + items.join("|") + ")");
  };
  TemplatablePattern.prototype._read_template = function() {
    var resulting_string = "";
    var c4 = this._input.peek();
    if (c4 === "<") {
      var peek1 = this._input.peek(1);
      if (!this._disabled.php && !this._excluded.php && peek1 === "?") {
        resulting_string = resulting_string || this.__patterns.php.read();
      }
      if (!this._disabled.erb && !this._excluded.erb && peek1 === "%") {
        resulting_string = resulting_string || this.__patterns.erb.read();
      }
    } else if (c4 === "{") {
      if (!this._disabled.handlebars && !this._excluded.handlebars) {
        resulting_string = resulting_string || this.__patterns.handlebars_comment.read();
        resulting_string = resulting_string || this.__patterns.handlebars_unescaped.read();
        resulting_string = resulting_string || this.__patterns.handlebars.read();
      }
      if (!this._disabled.django) {
        if (!this._excluded.django && !this._excluded.handlebars) {
          resulting_string = resulting_string || this.__patterns.django_value.read();
        }
        if (!this._excluded.django) {
          resulting_string = resulting_string || this.__patterns.django_comment.read();
          resulting_string = resulting_string || this.__patterns.django.read();
        }
      }
      if (!this._disabled.smarty) {
        if (this._disabled.django && this._disabled.handlebars) {
          resulting_string = resulting_string || this.__patterns.smarty_comment.read();
          resulting_string = resulting_string || this.__patterns.smarty_literal.read();
          resulting_string = resulting_string || this.__patterns.smarty.read();
        }
      }
    }
    return resulting_string;
  };
  exports.TemplatablePattern = TemplatablePattern;
});

// ../sisventa/node_modules/js-beautify/js/src/javascript/tokenizer.js
var require_tokenizer2 = __commonJS((exports, module) => {
  var in_array = function(what, arr) {
    return arr.indexOf(what) !== -1;
  };
  var unescape_string = function(s5) {
    var out = "", escaped = 0;
    var input_scan = new InputScanner(s5);
    var matched = null;
    while (input_scan.hasNext()) {
      matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);
      if (matched) {
        out += matched[0];
      }
      if (input_scan.peek() === "\\") {
        input_scan.next();
        if (input_scan.peek() === "x") {
          matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
        } else if (input_scan.peek() === "u") {
          matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
          if (!matched) {
            matched = input_scan.match(/u\{([0-9A-Fa-f]+)\}/g);
          }
        } else {
          out += "\\";
          if (input_scan.hasNext()) {
            out += input_scan.next();
          }
          continue;
        }
        if (!matched) {
          return s5;
        }
        escaped = parseInt(matched[1], 16);
        if (escaped > 126 && escaped <= 255 && matched[0].indexOf("x") === 0) {
          return s5;
        } else if (escaped >= 0 && escaped < 32) {
          out += "\\" + matched[0];
        } else if (escaped > 1114111) {
          out += "\\" + matched[0];
        } else if (escaped === 34 || escaped === 39 || escaped === 92) {
          out += "\\" + String.fromCharCode(escaped);
        } else {
          out += String.fromCharCode(escaped);
        }
      }
    }
    return out;
  };
  var InputScanner = require_inputscanner().InputScanner;
  var BaseTokenizer = require_tokenizer().Tokenizer;
  var BASETOKEN = require_tokenizer().TOKEN;
  var Directives = require_directives().Directives;
  var acorn = require_acorn();
  var Pattern = require_pattern().Pattern;
  var TemplatablePattern = require_templatablepattern().TemplatablePattern;
  var TOKEN = {
    START_EXPR: "TK_START_EXPR",
    END_EXPR: "TK_END_EXPR",
    START_BLOCK: "TK_START_BLOCK",
    END_BLOCK: "TK_END_BLOCK",
    WORD: "TK_WORD",
    RESERVED: "TK_RESERVED",
    SEMICOLON: "TK_SEMICOLON",
    STRING: "TK_STRING",
    EQUALS: "TK_EQUALS",
    OPERATOR: "TK_OPERATOR",
    COMMA: "TK_COMMA",
    BLOCK_COMMENT: "TK_BLOCK_COMMENT",
    COMMENT: "TK_COMMENT",
    DOT: "TK_DOT",
    UNKNOWN: "TK_UNKNOWN",
    START: BASETOKEN.START,
    RAW: BASETOKEN.RAW,
    EOF: BASETOKEN.EOF
  };
  var directives_core = new Directives(/\/\*/, /\*\//);
  var number_pattern = /0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\d[\d_]*n|(?:\.\d[\d_]*|\d[\d_]*\.?[\d_]*)(?:[eE][+-]?[\d_]+)?/;
  var digit = /[0-9]/;
  var dot_pattern = /[^\d\.]/;
  var positionable_operators = ">>> === !== &&= ??= ||= << && >= ** != == <= >> || ?? |> < / - + > : & % ? ^ | *".split(" ");
  var punct = ">>>= ... >>= <<= === >>> !== **= &&= ??= ||= => ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> = ! ? > < : / ^ - + * & % ~ |";
  punct = punct.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
  punct = "\\?\\.(?!\\d) " + punct;
  punct = punct.replace(/ /g, "|");
  var punct_pattern = new RegExp(punct);
  var line_starters = "continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export".split(",");
  var reserved_words = line_starters.concat(["do", "in", "of", "else", "get", "set", "new", "catch", "finally", "typeof", "yield", "async", "await", "from", "as", "class", "extends"]);
  var reserved_word_pattern = new RegExp("^(?:" + reserved_words.join("|") + ")$");
  var in_html_comment;
  var Tokenizer3 = function(input_string, options) {
    BaseTokenizer.call(this, input_string, options);
    this._patterns.whitespace = this._patterns.whitespace.matching(/\u00A0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff/.source, /\u2028\u2029/.source);
    var pattern_reader = new Pattern(this._input);
    var templatable = new TemplatablePattern(this._input).read_options(this._options);
    this.__patterns = {
      template: templatable,
      identifier: templatable.starting_with(acorn.identifier).matching(acorn.identifierMatch),
      number: pattern_reader.matching(number_pattern),
      punct: pattern_reader.matching(punct_pattern),
      comment: pattern_reader.starting_with(/\/\//).until(/[\n\r\u2028\u2029]/),
      block_comment: pattern_reader.starting_with(/\/\*/).until_after(/\*\//),
      html_comment_start: pattern_reader.matching(/<!--/),
      html_comment_end: pattern_reader.matching(/-->/),
      include: pattern_reader.starting_with(/#include/).until_after(acorn.lineBreak),
      shebang: pattern_reader.starting_with(/#!/).until_after(acorn.lineBreak),
      xml: pattern_reader.matching(/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[^}]+?}|!\[CDATA\[[^\]]*?\]\]|)(\s*{[^}]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{([^{}]|{[^}]+?})+?}))*\s*(\/?)\s*>/),
      single_quote: templatable.until(/['\\\n\r\u2028\u2029]/),
      double_quote: templatable.until(/["\\\n\r\u2028\u2029]/),
      template_text: templatable.until(/[`\\$]/),
      template_expression: templatable.until(/[`}\\]/)
    };
  };
  Tokenizer3.prototype = new BaseTokenizer;
  Tokenizer3.prototype._is_comment = function(current_token) {
    return current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.BLOCK_COMMENT || current_token.type === TOKEN.UNKNOWN;
  };
  Tokenizer3.prototype._is_opening = function(current_token) {
    return current_token.type === TOKEN.START_BLOCK || current_token.type === TOKEN.START_EXPR;
  };
  Tokenizer3.prototype._is_closing = function(current_token, open_token) {
    return (current_token.type === TOKEN.END_BLOCK || current_token.type === TOKEN.END_EXPR) && (open_token && (current_token.text === "]" && open_token.text === "[" || current_token.text === ")" && open_token.text === "(" || current_token.text === "}" && open_token.text === "{"));
  };
  Tokenizer3.prototype._reset = function() {
    in_html_comment = false;
  };
  Tokenizer3.prototype._get_next_token = function(previous_token, open_token) {
    var token2 = null;
    this._readWhitespace();
    var c4 = this._input.peek();
    if (c4 === null) {
      return this._create_token(TOKEN.EOF, "");
    }
    token2 = token2 || this._read_non_javascript(c4);
    token2 = token2 || this._read_string(c4);
    token2 = token2 || this._read_pair(c4, this._input.peek(1));
    token2 = token2 || this._read_word(previous_token);
    token2 = token2 || this._read_singles(c4);
    token2 = token2 || this._read_comment(c4);
    token2 = token2 || this._read_regexp(c4, previous_token);
    token2 = token2 || this._read_xml(c4, previous_token);
    token2 = token2 || this._read_punctuation();
    token2 = token2 || this._create_token(TOKEN.UNKNOWN, this._input.next());
    return token2;
  };
  Tokenizer3.prototype._read_word = function(previous_token) {
    var resulting_string;
    resulting_string = this.__patterns.identifier.read();
    if (resulting_string !== "") {
      resulting_string = resulting_string.replace(acorn.allLineBreaks, "\n");
      if (!(previous_token.type === TOKEN.DOT || previous_token.type === TOKEN.RESERVED && (previous_token.text === "set" || previous_token.text === "get")) && reserved_word_pattern.test(resulting_string)) {
        if ((resulting_string === "in" || resulting_string === "of") && (previous_token.type === TOKEN.WORD || previous_token.type === TOKEN.STRING)) {
          return this._create_token(TOKEN.OPERATOR, resulting_string);
        }
        return this._create_token(TOKEN.RESERVED, resulting_string);
      }
      return this._create_token(TOKEN.WORD, resulting_string);
    }
    resulting_string = this.__patterns.number.read();
    if (resulting_string !== "") {
      return this._create_token(TOKEN.WORD, resulting_string);
    }
  };
  Tokenizer3.prototype._read_singles = function(c4) {
    var token2 = null;
    if (c4 === "(" || c4 === "[") {
      token2 = this._create_token(TOKEN.START_EXPR, c4);
    } else if (c4 === ")" || c4 === "]") {
      token2 = this._create_token(TOKEN.END_EXPR, c4);
    } else if (c4 === "{") {
      token2 = this._create_token(TOKEN.START_BLOCK, c4);
    } else if (c4 === "}") {
      token2 = this._create_token(TOKEN.END_BLOCK, c4);
    } else if (c4 === ";") {
      token2 = this._create_token(TOKEN.SEMICOLON, c4);
    } else if (c4 === "." && dot_pattern.test(this._input.peek(1))) {
      token2 = this._create_token(TOKEN.DOT, c4);
    } else if (c4 === ",") {
      token2 = this._create_token(TOKEN.COMMA, c4);
    }
    if (token2) {
      this._input.next();
    }
    return token2;
  };
  Tokenizer3.prototype._read_pair = function(c4, d3) {
    var token2 = null;
    if (c4 === "#" && d3 === "{") {
      token2 = this._create_token(TOKEN.START_BLOCK, c4 + d3);
    }
    if (token2) {
      this._input.next();
      this._input.next();
    }
    return token2;
  };
  Tokenizer3.prototype._read_punctuation = function() {
    var resulting_string = this.__patterns.punct.read();
    if (resulting_string !== "") {
      if (resulting_string === "=") {
        return this._create_token(TOKEN.EQUALS, resulting_string);
      } else if (resulting_string === "?.") {
        return this._create_token(TOKEN.DOT, resulting_string);
      } else {
        return this._create_token(TOKEN.OPERATOR, resulting_string);
      }
    }
  };
  Tokenizer3.prototype._read_non_javascript = function(c4) {
    var resulting_string = "";
    if (c4 === "#") {
      if (this._is_first_token()) {
        resulting_string = this.__patterns.shebang.read();
        if (resulting_string) {
          return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + "\n");
        }
      }
      resulting_string = this.__patterns.include.read();
      if (resulting_string) {
        return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + "\n");
      }
      c4 = this._input.next();
      var sharp = "#";
      if (this._input.hasNext() && this._input.testChar(digit)) {
        do {
          c4 = this._input.next();
          sharp += c4;
        } while (this._input.hasNext() && c4 !== "#" && c4 !== "=");
        if (c4 === "#") {
        } else if (this._input.peek() === "[" && this._input.peek(1) === "]") {
          sharp += "[]";
          this._input.next();
          this._input.next();
        } else if (this._input.peek() === "{" && this._input.peek(1) === "}") {
          sharp += "{}";
          this._input.next();
          this._input.next();
        }
        return this._create_token(TOKEN.WORD, sharp);
      }
      this._input.back();
    } else if (c4 === "<" && this._is_first_token()) {
      resulting_string = this.__patterns.html_comment_start.read();
      if (resulting_string) {
        while (this._input.hasNext() && !this._input.testChar(acorn.newline)) {
          resulting_string += this._input.next();
        }
        in_html_comment = true;
        return this._create_token(TOKEN.COMMENT, resulting_string);
      }
    } else if (in_html_comment && c4 === "-") {
      resulting_string = this.__patterns.html_comment_end.read();
      if (resulting_string) {
        in_html_comment = false;
        return this._create_token(TOKEN.COMMENT, resulting_string);
      }
    }
    return null;
  };
  Tokenizer3.prototype._read_comment = function(c4) {
    var token2 = null;
    if (c4 === "/") {
      var comment = "";
      if (this._input.peek(1) === "*") {
        comment = this.__patterns.block_comment.read();
        var directives = directives_core.get_directives(comment);
        if (directives && directives.ignore === "start") {
          comment += directives_core.readIgnored(this._input);
        }
        comment = comment.replace(acorn.allLineBreaks, "\n");
        token2 = this._create_token(TOKEN.BLOCK_COMMENT, comment);
        token2.directives = directives;
      } else if (this._input.peek(1) === "/") {
        comment = this.__patterns.comment.read();
        token2 = this._create_token(TOKEN.COMMENT, comment);
      }
    }
    return token2;
  };
  Tokenizer3.prototype._read_string = function(c4) {
    if (c4 === "`" || c4 === "'" || c4 === '"') {
      var resulting_string = this._input.next();
      this.has_char_escapes = false;
      if (c4 === "`") {
        resulting_string += this._read_string_recursive("`", true, "${");
      } else {
        resulting_string += this._read_string_recursive(c4);
      }
      if (this.has_char_escapes && this._options.unescape_strings) {
        resulting_string = unescape_string(resulting_string);
      }
      if (this._input.peek() === c4) {
        resulting_string += this._input.next();
      }
      resulting_string = resulting_string.replace(acorn.allLineBreaks, "\n");
      return this._create_token(TOKEN.STRING, resulting_string);
    }
    return null;
  };
  Tokenizer3.prototype._allow_regexp_or_xml = function(previous_token) {
    return previous_token.type === TOKEN.RESERVED && in_array(previous_token.text, ["return", "case", "throw", "else", "do", "typeof", "yield"]) || previous_token.type === TOKEN.END_EXPR && previous_token.text === ")" && previous_token.opened.previous.type === TOKEN.RESERVED && in_array(previous_token.opened.previous.text, ["if", "while", "for"]) || in_array(previous_token.type, [
      TOKEN.COMMENT,
      TOKEN.START_EXPR,
      TOKEN.START_BLOCK,
      TOKEN.START,
      TOKEN.END_BLOCK,
      TOKEN.OPERATOR,
      TOKEN.EQUALS,
      TOKEN.EOF,
      TOKEN.SEMICOLON,
      TOKEN.COMMA
    ]);
  };
  Tokenizer3.prototype._read_regexp = function(c4, previous_token) {
    if (c4 === "/" && this._allow_regexp_or_xml(previous_token)) {
      var resulting_string = this._input.next();
      var esc = false;
      var in_char_class = false;
      while (this._input.hasNext() && ((esc || in_char_class || this._input.peek() !== c4) && !this._input.testChar(acorn.newline))) {
        resulting_string += this._input.peek();
        if (!esc) {
          esc = this._input.peek() === "\\";
          if (this._input.peek() === "[") {
            in_char_class = true;
          } else if (this._input.peek() === "]") {
            in_char_class = false;
          }
        } else {
          esc = false;
        }
        this._input.next();
      }
      if (this._input.peek() === c4) {
        resulting_string += this._input.next();
        resulting_string += this._input.read(acorn.identifier);
      }
      return this._create_token(TOKEN.STRING, resulting_string);
    }
    return null;
  };
  Tokenizer3.prototype._read_xml = function(c4, previous_token) {
    if (this._options.e4x && c4 === "<" && this._allow_regexp_or_xml(previous_token)) {
      var xmlStr = "";
      var match = this.__patterns.xml.read_match();
      if (match) {
        var rootTag = match[2].replace(/^{\s+/, "{").replace(/\s+}$/, "}");
        var isCurlyRoot = rootTag.indexOf("{") === 0;
        var depth = 0;
        while (match) {
          var isEndTag = !!match[1];
          var tagName = match[2];
          var isSingletonTag = !!match[match.length - 1] || tagName.slice(0, 8) === "![CDATA[";
          if (!isSingletonTag && (tagName === rootTag || isCurlyRoot && tagName.replace(/^{\s+/, "{").replace(/\s+}$/, "}"))) {
            if (isEndTag) {
              --depth;
            } else {
              ++depth;
            }
          }
          xmlStr += match[0];
          if (depth <= 0) {
            break;
          }
          match = this.__patterns.xml.read_match();
        }
        if (!match) {
          xmlStr += this._input.match(/[\s\S]*/g)[0];
        }
        xmlStr = xmlStr.replace(acorn.allLineBreaks, "\n");
        return this._create_token(TOKEN.STRING, xmlStr);
      }
    }
    return null;
  };
  Tokenizer3.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {
    var current_char;
    var pattern5;
    if (delimiter === "\'") {
      pattern5 = this.__patterns.single_quote;
    } else if (delimiter === '"') {
      pattern5 = this.__patterns.double_quote;
    } else if (delimiter === "`") {
      pattern5 = this.__patterns.template_text;
    } else if (delimiter === "}") {
      pattern5 = this.__patterns.template_expression;
    }
    var resulting_string = pattern5.read();
    var next = "";
    while (this._input.hasNext()) {
      next = this._input.next();
      if (next === delimiter || !allow_unescaped_newlines && acorn.newline.test(next)) {
        this._input.back();
        break;
      } else if (next === "\\" && this._input.hasNext()) {
        current_char = this._input.peek();
        if (current_char === "x" || current_char === "u") {
          this.has_char_escapes = true;
        } else if (current_char === "\r" && this._input.peek(1) === "\n") {
          this._input.next();
        }
        next += this._input.next();
      } else if (start_sub) {
        if (start_sub === "${" && next === "$" && this._input.peek() === "{") {
          next += this._input.next();
        }
        if (start_sub === next) {
          if (delimiter === "`") {
            next += this._read_string_recursive("}", allow_unescaped_newlines, "`");
          } else {
            next += this._read_string_recursive("`", allow_unescaped_newlines, "${");
          }
          if (this._input.hasNext()) {
            next += this._input.next();
          }
        }
      }
      next += pattern5.read();
      resulting_string += next;
    }
    return resulting_string;
  };
  exports.Tokenizer = Tokenizer3;
  exports.TOKEN = TOKEN;
  exports.positionable_operators = positionable_operators.slice();
  exports.line_starters = line_starters.slice();
});

// ../sisventa/node_modules/js-beautify/js/src/javascript/beautifier.js
var require_beautifier = __commonJS((exports, module) => {
  var in_array = function(what, arr) {
    return arr.indexOf(what) !== -1;
  };
  var ltrim = function(s5) {
    return s5.replace(/^\s+/g, "");
  };
  var generateMapFromStrings = function(list) {
    var result = {};
    for (var x = 0;x < list.length; x++) {
      result[list[x].replace(/-/g, "_")] = list[x];
    }
    return result;
  };
  var reserved_word = function(token2, word) {
    return token2 && token2.type === TOKEN.RESERVED && token2.text === word;
  };
  var reserved_array = function(token2, words) {
    return token2 && token2.type === TOKEN.RESERVED && in_array(token2.text, words);
  };
  var remove_redundant_indentation = function(output, frame) {
    if (frame.multiline_frame || frame.mode === MODE.ForInitializer || frame.mode === MODE.Conditional) {
      return;
    }
    output.remove_indent(frame.start_line_index);
  };
  var split_linebreaks = function(s5) {
    s5 = s5.replace(acorn.allLineBreaks, "\n");
    var out = [], idx = s5.indexOf("\n");
    while (idx !== -1) {
      out.push(s5.substring(0, idx));
      s5 = s5.substring(idx + 1);
      idx = s5.indexOf("\n");
    }
    if (s5.length) {
      out.push(s5);
    }
    return out;
  };
  var is_array = function(mode) {
    return mode === MODE.ArrayLiteral;
  };
  var is_expression = function(mode) {
    return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
  };
  var all_lines_start_with = function(lines, c4) {
    for (var i = 0;i < lines.length; i++) {
      var line = lines[i].trim();
      if (line.charAt(0) !== c4) {
        return false;
      }
    }
    return true;
  };
  var each_line_matches_indent = function(lines, indent) {
    var i = 0, len = lines.length, line;
    for (;i < len; i++) {
      line = lines[i];
      if (line && line.indexOf(indent) !== 0) {
        return false;
      }
    }
    return true;
  };
  var Beautifier = function(source_text, options) {
    options = options || {};
    this._source_text = source_text || "";
    this._output = null;
    this._tokens = null;
    this._last_last_text = null;
    this._flags = null;
    this._previous_flags = null;
    this._flag_store = null;
    this._options = new Options(options);
  };
  var Output = require_output().Output;
  var Token = require_token().Token;
  var acorn = require_acorn();
  var Options = require_options2().Options;
  var Tokenizer3 = require_tokenizer2().Tokenizer;
  var line_starters = require_tokenizer2().line_starters;
  var positionable_operators = require_tokenizer2().positionable_operators;
  var TOKEN = require_tokenizer2().TOKEN;
  var special_words = ["case", "return", "do", "if", "throw", "else", "await", "break", "continue", "async"];
  var validPositionValues = ["before-newline", "after-newline", "preserve-newline"];
  var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);
  var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];
  var MODE = {
    BlockStatement: "BlockStatement",
    Statement: "Statement",
    ObjectLiteral: "ObjectLiteral",
    ArrayLiteral: "ArrayLiteral",
    ForInitializer: "ForInitializer",
    Conditional: "Conditional",
    Expression: "Expression"
  };
  Beautifier.prototype.create_flags = function(flags_base, mode) {
    var next_indent_level = 0;
    if (flags_base) {
      next_indent_level = flags_base.indentation_level;
      if (!this._output.just_added_newline() && flags_base.line_indent_level > next_indent_level) {
        next_indent_level = flags_base.line_indent_level;
      }
    }
    var next_flags = {
      mode,
      parent: flags_base,
      last_token: flags_base ? flags_base.last_token : new Token(TOKEN.START_BLOCK, ""),
      last_word: flags_base ? flags_base.last_word : "",
      declaration_statement: false,
      declaration_assignment: false,
      multiline_frame: false,
      inline_frame: false,
      if_block: false,
      else_block: false,
      class_start_block: false,
      do_block: false,
      do_while: false,
      import_block: false,
      in_case_statement: false,
      in_case: false,
      case_body: false,
      case_block: false,
      indentation_level: next_indent_level,
      alignment: 0,
      line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
      start_line_index: this._output.get_line_number(),
      ternary_depth: 0
    };
    return next_flags;
  };
  Beautifier.prototype._reset = function(source_text) {
    var baseIndentString = source_text.match(/^[\t ]*/)[0];
    this._last_last_text = "";
    this._output = new Output(this._options, baseIndentString);
    this._output.raw = this._options.test_output_raw;
    this._flag_store = [];
    this.set_mode(MODE.BlockStatement);
    var tokenizer = new Tokenizer3(source_text, this._options);
    this._tokens = tokenizer.tokenize();
    return source_text;
  };
  Beautifier.prototype.beautify = function() {
    if (this._options.disabled) {
      return this._source_text;
    }
    var sweet_code;
    var source_text = this._reset(this._source_text);
    var eol = this._options.eol;
    if (this._options.eol === "auto") {
      eol = "\n";
      if (source_text && acorn.lineBreak.test(source_text || "")) {
        eol = source_text.match(acorn.lineBreak)[0];
      }
    }
    var current_token = this._tokens.next();
    while (current_token) {
      this.handle_token(current_token);
      this._last_last_text = this._flags.last_token.text;
      this._flags.last_token = current_token;
      current_token = this._tokens.next();
    }
    sweet_code = this._output.get_code(eol);
    return sweet_code;
  };
  Beautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {
    if (current_token.type === TOKEN.START_EXPR) {
      this.handle_start_expr(current_token);
    } else if (current_token.type === TOKEN.END_EXPR) {
      this.handle_end_expr(current_token);
    } else if (current_token.type === TOKEN.START_BLOCK) {
      this.handle_start_block(current_token);
    } else if (current_token.type === TOKEN.END_BLOCK) {
      this.handle_end_block(current_token);
    } else if (current_token.type === TOKEN.WORD) {
      this.handle_word(current_token);
    } else if (current_token.type === TOKEN.RESERVED) {
      this.handle_word(current_token);
    } else if (current_token.type === TOKEN.SEMICOLON) {
      this.handle_semicolon(current_token);
    } else if (current_token.type === TOKEN.STRING) {
      this.handle_string(current_token);
    } else if (current_token.type === TOKEN.EQUALS) {
      this.handle_equals(current_token);
    } else if (current_token.type === TOKEN.OPERATOR) {
      this.handle_operator(current_token);
    } else if (current_token.type === TOKEN.COMMA) {
      this.handle_comma(current_token);
    } else if (current_token.type === TOKEN.BLOCK_COMMENT) {
      this.handle_block_comment(current_token, preserve_statement_flags);
    } else if (current_token.type === TOKEN.COMMENT) {
      this.handle_comment(current_token, preserve_statement_flags);
    } else if (current_token.type === TOKEN.DOT) {
      this.handle_dot(current_token);
    } else if (current_token.type === TOKEN.EOF) {
      this.handle_eof(current_token);
    } else if (current_token.type === TOKEN.UNKNOWN) {
      this.handle_unknown(current_token, preserve_statement_flags);
    } else {
      this.handle_unknown(current_token, preserve_statement_flags);
    }
  };
  Beautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {
    var newlines = current_token.newlines;
    var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);
    if (current_token.comments_before) {
      var comment_token = current_token.comments_before.next();
      while (comment_token) {
        this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);
        this.handle_token(comment_token, preserve_statement_flags);
        comment_token = current_token.comments_before.next();
      }
    }
    if (keep_whitespace) {
      for (var i = 0;i < newlines; i += 1) {
        this.print_newline(i > 0, preserve_statement_flags);
      }
    } else {
      if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {
        newlines = this._options.max_preserve_newlines;
      }
      if (this._options.preserve_newlines) {
        if (newlines > 1) {
          this.print_newline(false, preserve_statement_flags);
          for (var j = 1;j < newlines; j += 1) {
            this.print_newline(true, preserve_statement_flags);
          }
        }
      }
    }
  };
  var newline_restricted_tokens = ["async", "break", "continue", "return", "throw", "yield"];
  Beautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {
    force_linewrap = force_linewrap === undefined ? false : force_linewrap;
    if (this._output.just_added_newline()) {
      return;
    }
    var shouldPreserveOrForce = this._options.preserve_newlines && current_token.newlines || force_linewrap;
    var operatorLogicApplies = in_array(this._flags.last_token.text, positionable_operators) || in_array(current_token.text, positionable_operators);
    if (operatorLogicApplies) {
      var shouldPrintOperatorNewline = in_array(this._flags.last_token.text, positionable_operators) && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE) || in_array(current_token.text, positionable_operators);
      shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
    }
    if (shouldPreserveOrForce) {
      this.print_newline(false, true);
    } else if (this._options.wrap_line_length) {
      if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {
        return;
      }
      this._output.set_wrap_point();
    }
  };
  Beautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {
    if (!preserve_statement_flags) {
      if (this._flags.last_token.text !== ";" && this._flags.last_token.text !== "," && this._flags.last_token.text !== "=" && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === "--" || this._flags.last_token.text === "++")) {
        var next_token = this._tokens.peek();
        while (this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, "else")) && !this._flags.do_block) {
          this.restore_mode();
        }
      }
    }
    if (this._output.add_new_line(force_newline)) {
      this._flags.multiline_frame = true;
    }
  };
  Beautifier.prototype.print_token_line_indentation = function(current_token) {
    if (this._output.just_added_newline()) {
      if (this._options.keep_array_indentation && current_token.newlines && (current_token.text === "[" || is_array(this._flags.mode))) {
        this._output.current_line.set_indent(-1);
        this._output.current_line.push(current_token.whitespace_before);
        this._output.space_before_token = false;
      } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {
        this._flags.line_indent_level = this._flags.indentation_level;
      }
    }
  };
  Beautifier.prototype.print_token = function(current_token) {
    if (this._output.raw) {
      this._output.add_raw_token(current_token);
      return;
    }
    if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN.COMMA && this._output.just_added_newline()) {
      if (this._output.previous_line.last() === ",") {
        var popped = this._output.previous_line.pop();
        if (this._output.previous_line.is_empty()) {
          this._output.previous_line.push(popped);
          this._output.trim(true);
          this._output.current_line.pop();
          this._output.trim();
        }
        this.print_token_line_indentation(current_token);
        this._output.add_token(",");
        this._output.space_before_token = true;
      }
    }
    this.print_token_line_indentation(current_token);
    this._output.non_breaking_space = true;
    this._output.add_token(current_token.text);
    if (this._output.previous_token_wrapped) {
      this._flags.multiline_frame = true;
    }
  };
  Beautifier.prototype.indent = function() {
    this._flags.indentation_level += 1;
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  };
  Beautifier.prototype.deindent = function() {
    if (this._flags.indentation_level > 0 && (!this._flags.parent || this._flags.indentation_level > this._flags.parent.indentation_level)) {
      this._flags.indentation_level -= 1;
      this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
    }
  };
  Beautifier.prototype.set_mode = function(mode) {
    if (this._flags) {
      this._flag_store.push(this._flags);
      this._previous_flags = this._flags;
    } else {
      this._previous_flags = this.create_flags(null, mode);
    }
    this._flags = this.create_flags(this._previous_flags, mode);
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  };
  Beautifier.prototype.restore_mode = function() {
    if (this._flag_store.length > 0) {
      this._previous_flags = this._flags;
      this._flags = this._flag_store.pop();
      if (this._previous_flags.mode === MODE.Statement) {
        remove_redundant_indentation(this._output, this._previous_flags);
      }
      this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
    }
  };
  Beautifier.prototype.start_of_object_property = function() {
    return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, ["get", "set"]));
  };
  Beautifier.prototype.start_of_statement = function(current_token) {
    var start = false;
    start = start || reserved_array(this._flags.last_token, ["var", "let", "const"]) && current_token.type === TOKEN.WORD;
    start = start || reserved_word(this._flags.last_token, "do");
    start = start || !(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;
    start = start || reserved_word(this._flags.last_token, "else") && !(reserved_word(current_token, "if") && !current_token.comments_before);
    start = start || this._flags.last_token.type === TOKEN.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional);
    start = start || this._flags.last_token.type === TOKEN.WORD && this._flags.mode === MODE.BlockStatement && !this._flags.in_case && !(current_token.text === "--" || current_token.text === "++") && this._last_last_text !== "function" && current_token.type !== TOKEN.WORD && current_token.type !== TOKEN.RESERVED;
    start = start || this._flags.mode === MODE.ObjectLiteral && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, ["get", "set"]));
    if (start) {
      this.set_mode(MODE.Statement);
      this.indent();
      this.handle_whitespace_and_comments(current_token, true);
      if (!this.start_of_object_property()) {
        this.allow_wrap_or_preserved_newline(current_token, reserved_array(current_token, ["do", "for", "if", "while"]));
      }
      return true;
    }
    return false;
  };
  Beautifier.prototype.handle_start_expr = function(current_token) {
    if (!this.start_of_statement(current_token)) {
      this.handle_whitespace_and_comments(current_token);
    }
    var next_mode = MODE.Expression;
    if (current_token.text === "[") {
      if (this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === ")") {
        if (reserved_array(this._flags.last_token, line_starters)) {
          this._output.space_before_token = true;
        }
        this.print_token(current_token);
        this.set_mode(next_mode);
        this.indent();
        if (this._options.space_in_paren) {
          this._output.space_before_token = true;
        }
        return;
      }
      next_mode = MODE.ArrayLiteral;
      if (is_array(this._flags.mode)) {
        if (this._flags.last_token.text === "[" || this._flags.last_token.text === "," && (this._last_last_text === "]" || this._last_last_text === "}")) {
          if (!this._options.keep_array_indentation) {
            this.print_newline();
          }
        }
      }
      if (!in_array(this._flags.last_token.type, [TOKEN.START_EXPR, TOKEN.END_EXPR, TOKEN.WORD, TOKEN.OPERATOR, TOKEN.DOT])) {
        this._output.space_before_token = true;
      }
    } else {
      if (this._flags.last_token.type === TOKEN.RESERVED) {
        if (this._flags.last_token.text === "for") {
          this._output.space_before_token = this._options.space_before_conditional;
          next_mode = MODE.ForInitializer;
        } else if (in_array(this._flags.last_token.text, ["if", "while", "switch"])) {
          this._output.space_before_token = this._options.space_before_conditional;
          next_mode = MODE.Conditional;
        } else if (in_array(this._flags.last_word, ["await", "async"])) {
          this._output.space_before_token = true;
        } else if (this._flags.last_token.text === "import" && current_token.whitespace_before === "") {
          this._output.space_before_token = false;
        } else if (in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === "catch") {
          this._output.space_before_token = true;
        }
      } else if (this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
        if (!this.start_of_object_property()) {
          this.allow_wrap_or_preserved_newline(current_token);
        }
      } else if (this._flags.last_token.type === TOKEN.WORD) {
        this._output.space_before_token = false;
        var peek_back_two = this._tokens.peek(-3);
        if (this._options.space_after_named_function && peek_back_two) {
          var peek_back_three = this._tokens.peek(-4);
          if (reserved_array(peek_back_two, ["async", "function"]) || peek_back_two.text === "*" && reserved_array(peek_back_three, ["async", "function"])) {
            this._output.space_before_token = true;
          } else if (this._flags.mode === MODE.ObjectLiteral) {
            if (peek_back_two.text === "{" || peek_back_two.text === "," || peek_back_two.text === "*" && (peek_back_three.text === "{" || peek_back_three.text === ",")) {
              this._output.space_before_token = true;
            }
          } else if (this._flags.parent && this._flags.parent.class_start_block) {
            this._output.space_before_token = true;
          }
        }
      } else {
        this.allow_wrap_or_preserved_newline(current_token);
      }
      if (this._flags.last_token.type === TOKEN.RESERVED && (this._flags.last_word === "function" || this._flags.last_word === "typeof") || this._flags.last_token.text === "*" && (in_array(this._last_last_text, ["function", "yield"]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ["{", ","]))) {
        this._output.space_before_token = this._options.space_after_anon_function;
      }
    }
    if (this._flags.last_token.text === ";" || this._flags.last_token.type === TOKEN.START_BLOCK) {
      this.print_newline();
    } else if (this._flags.last_token.type === TOKEN.END_EXPR || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.END_BLOCK || this._flags.last_token.text === "." || this._flags.last_token.type === TOKEN.COMMA) {
      this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);
    }
    this.print_token(current_token);
    this.set_mode(next_mode);
    if (this._options.space_in_paren) {
      this._output.space_before_token = true;
    }
    this.indent();
  };
  Beautifier.prototype.handle_end_expr = function(current_token) {
    while (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }
    this.handle_whitespace_and_comments(current_token);
    if (this._flags.multiline_frame) {
      this.allow_wrap_or_preserved_newline(current_token, current_token.text === "]" && is_array(this._flags.mode) && !this._options.keep_array_indentation);
    }
    if (this._options.space_in_paren) {
      if (this._flags.last_token.type === TOKEN.START_EXPR && !this._options.space_in_empty_paren) {
        this._output.trim();
        this._output.space_before_token = false;
      } else {
        this._output.space_before_token = true;
      }
    }
    this.deindent();
    this.print_token(current_token);
    this.restore_mode();
    remove_redundant_indentation(this._output, this._previous_flags);
    if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {
      this._previous_flags.mode = MODE.Expression;
      this._flags.do_block = false;
      this._flags.do_while = false;
    }
  };
  Beautifier.prototype.handle_start_block = function(current_token) {
    this.handle_whitespace_and_comments(current_token);
    var next_token = this._tokens.peek();
    var second_token = this._tokens.peek(1);
    if (this._flags.last_word === "switch" && this._flags.last_token.type === TOKEN.END_EXPR) {
      this.set_mode(MODE.BlockStatement);
      this._flags.in_case_statement = true;
    } else if (this._flags.case_body) {
      this.set_mode(MODE.BlockStatement);
    } else if (second_token && (in_array(second_token.text, [":", ","]) && in_array(next_token.type, [TOKEN.STRING, TOKEN.WORD, TOKEN.RESERVED]) || in_array(next_token.text, ["get", "set", "..."]) && in_array(second_token.type, [TOKEN.WORD, TOKEN.RESERVED]))) {
      if (in_array(this._last_last_text, ["class", "interface"]) && !in_array(second_token.text, [":", ","])) {
        this.set_mode(MODE.BlockStatement);
      } else {
        this.set_mode(MODE.ObjectLiteral);
      }
    } else if (this._flags.last_token.type === TOKEN.OPERATOR && this._flags.last_token.text === "=>") {
      this.set_mode(MODE.BlockStatement);
    } else if (in_array(this._flags.last_token.type, [TOKEN.EQUALS, TOKEN.START_EXPR, TOKEN.COMMA, TOKEN.OPERATOR]) || reserved_array(this._flags.last_token, ["return", "throw", "import", "default"])) {
      this.set_mode(MODE.ObjectLiteral);
    } else {
      this.set_mode(MODE.BlockStatement);
    }
    if (this._flags.last_token) {
      if (reserved_array(this._flags.last_token.previous, ["class", "extends"])) {
        this._flags.class_start_block = true;
      }
    }
    var empty_braces = !next_token.comments_before && next_token.text === "}";
    var empty_anonymous_function = empty_braces && this._flags.last_word === "function" && this._flags.last_token.type === TOKEN.END_EXPR;
    if (this._options.brace_preserve_inline) {
      var index = 0;
      var check_token = null;
      this._flags.inline_frame = true;
      do {
        index += 1;
        check_token = this._tokens.peek(index - 1);
        if (check_token.newlines) {
          this._flags.inline_frame = false;
          break;
        }
      } while (check_token.type !== TOKEN.EOF && !(check_token.type === TOKEN.END_BLOCK && check_token.opened === current_token));
    }
    if ((this._options.brace_style === "expand" || this._options.brace_style === "none" && current_token.newlines) && !this._flags.inline_frame) {
      if (this._flags.last_token.type !== TOKEN.OPERATOR && (empty_anonymous_function || this._flags.last_token.type === TOKEN.EQUALS || reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== "else")) {
        this._output.space_before_token = true;
      } else {
        this.print_newline(false, true);
      }
    } else {
      if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.COMMA)) {
        if (this._flags.last_token.type === TOKEN.COMMA || this._options.space_in_paren) {
          this._output.space_before_token = true;
        }
        if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR && this._flags.inline_frame) {
          this.allow_wrap_or_preserved_newline(current_token);
          this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;
          this._flags.multiline_frame = false;
        }
      }
      if (this._flags.last_token.type !== TOKEN.OPERATOR && this._flags.last_token.type !== TOKEN.START_EXPR) {
        if (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.SEMICOLON]) && !this._flags.inline_frame) {
          this.print_newline();
        } else {
          this._output.space_before_token = true;
        }
      }
    }
    this.print_token(current_token);
    this.indent();
    if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {
      this.print_newline();
    }
  };
  Beautifier.prototype.handle_end_block = function(current_token) {
    this.handle_whitespace_and_comments(current_token);
    while (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }
    var empty_braces = this._flags.last_token.type === TOKEN.START_BLOCK;
    if (this._flags.inline_frame && !empty_braces) {
      this._output.space_before_token = true;
    } else if (this._options.brace_style === "expand") {
      if (!empty_braces) {
        this.print_newline();
      }
    } else {
      if (!empty_braces) {
        if (is_array(this._flags.mode) && this._options.keep_array_indentation) {
          this._options.keep_array_indentation = false;
          this.print_newline();
          this._options.keep_array_indentation = true;
        } else {
          this.print_newline();
        }
      }
    }
    this.restore_mode();
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_word = function(current_token) {
    if (current_token.type === TOKEN.RESERVED) {
      if (in_array(current_token.text, ["set", "get"]) && this._flags.mode !== MODE.ObjectLiteral) {
        current_token.type = TOKEN.WORD;
      } else if (current_token.text === "import" && in_array(this._tokens.peek().text, ["(", "."])) {
        current_token.type = TOKEN.WORD;
      } else if (in_array(current_token.text, ["as", "from"]) && !this._flags.import_block) {
        current_token.type = TOKEN.WORD;
      } else if (this._flags.mode === MODE.ObjectLiteral) {
        var next_token = this._tokens.peek();
        if (next_token.text === ":") {
          current_token.type = TOKEN.WORD;
        }
      }
    }
    if (this.start_of_statement(current_token)) {
      if (reserved_array(this._flags.last_token, ["var", "let", "const"]) && current_token.type === TOKEN.WORD) {
        this._flags.declaration_statement = true;
      }
    } else if (current_token.newlines && !is_expression(this._flags.mode) && (this._flags.last_token.type !== TOKEN.OPERATOR || (this._flags.last_token.text === "--" || this._flags.last_token.text === "++")) && this._flags.last_token.type !== TOKEN.EQUALS && (this._options.preserve_newlines || !reserved_array(this._flags.last_token, ["var", "let", "const", "set", "get"]))) {
      this.handle_whitespace_and_comments(current_token);
      this.print_newline();
    } else {
      this.handle_whitespace_and_comments(current_token);
    }
    if (this._flags.do_block && !this._flags.do_while) {
      if (reserved_word(current_token, "while")) {
        this._output.space_before_token = true;
        this.print_token(current_token);
        this._output.space_before_token = true;
        this._flags.do_while = true;
        return;
      } else {
        this.print_newline();
        this._flags.do_block = false;
      }
    }
    if (this._flags.if_block) {
      if (!this._flags.else_block && reserved_word(current_token, "else")) {
        this._flags.else_block = true;
      } else {
        while (this._flags.mode === MODE.Statement) {
          this.restore_mode();
        }
        this._flags.if_block = false;
        this._flags.else_block = false;
      }
    }
    if (this._flags.in_case_statement && reserved_array(current_token, ["case", "default"])) {
      this.print_newline();
      if (!this._flags.case_block && (this._flags.case_body || this._options.jslint_happy)) {
        this.deindent();
      }
      this._flags.case_body = false;
      this.print_token(current_token);
      this._flags.in_case = true;
      return;
    }
    if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
      if (!this.start_of_object_property() && !(in_array(this._flags.last_token.text, ["+", "-"]) && this._last_last_text === ":" && this._flags.parent.mode === MODE.ObjectLiteral)) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    }
    if (reserved_word(current_token, "function")) {
      if (in_array(this._flags.last_token.text, ["}", ";"]) || this._output.just_added_newline() && !(in_array(this._flags.last_token.text, ["(", "[", "{", ":", "=", ","]) || this._flags.last_token.type === TOKEN.OPERATOR)) {
        if (!this._output.just_added_blankline() && !current_token.comments_before) {
          this.print_newline();
          this.print_newline(true);
        }
      }
      if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD) {
        if (reserved_array(this._flags.last_token, ["get", "set", "new", "export"]) || reserved_array(this._flags.last_token, newline_restricted_tokens)) {
          this._output.space_before_token = true;
        } else if (reserved_word(this._flags.last_token, "default") && this._last_last_text === "export") {
          this._output.space_before_token = true;
        } else if (this._flags.last_token.text === "declare") {
          this._output.space_before_token = true;
        } else {
          this.print_newline();
        }
      } else if (this._flags.last_token.type === TOKEN.OPERATOR || this._flags.last_token.text === "=") {
        this._output.space_before_token = true;
      } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode))) {
      } else {
        this.print_newline();
      }
      this.print_token(current_token);
      this._flags.last_word = current_token.text;
      return;
    }
    var prefix = "NONE";
    if (this._flags.last_token.type === TOKEN.END_BLOCK) {
      if (this._previous_flags.inline_frame) {
        prefix = "SPACE";
      } else if (!reserved_array(current_token, ["else", "catch", "finally", "from"])) {
        prefix = "NEWLINE";
      } else {
        if (this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && current_token.newlines) {
          prefix = "NEWLINE";
        } else {
          prefix = "SPACE";
          this._output.space_before_token = true;
        }
      }
    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && this._flags.mode === MODE.BlockStatement) {
      prefix = "NEWLINE";
    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && is_expression(this._flags.mode)) {
      prefix = "SPACE";
    } else if (this._flags.last_token.type === TOKEN.STRING) {
      prefix = "NEWLINE";
    } else if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === "*" && (in_array(this._last_last_text, ["function", "yield"]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ["{", ","]))) {
      prefix = "SPACE";
    } else if (this._flags.last_token.type === TOKEN.START_BLOCK) {
      if (this._flags.inline_frame) {
        prefix = "SPACE";
      } else {
        prefix = "NEWLINE";
      }
    } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
      this._output.space_before_token = true;
      prefix = "NEWLINE";
    }
    if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ")") {
      if (this._flags.inline_frame || this._flags.last_token.text === "else" || this._flags.last_token.text === "export") {
        prefix = "SPACE";
      } else {
        prefix = "NEWLINE";
      }
    }
    if (reserved_array(current_token, ["else", "catch", "finally"])) {
      if ((!(this._flags.last_token.type === TOKEN.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) || this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && current_token.newlines) && !this._flags.inline_frame) {
        this.print_newline();
      } else {
        this._output.trim(true);
        var line = this._output.current_line;
        if (line.last() !== "}") {
          this.print_newline();
        }
        this._output.space_before_token = true;
      }
    } else if (prefix === "NEWLINE") {
      if (reserved_array(this._flags.last_token, special_words)) {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.text === "declare" && reserved_array(current_token, ["var", "let", "const"])) {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.type !== TOKEN.END_EXPR) {
        if ((this._flags.last_token.type !== TOKEN.START_EXPR || !reserved_array(current_token, ["var", "let", "const"])) && this._flags.last_token.text !== ":") {
          if (reserved_word(current_token, "if") && reserved_word(current_token.previous, "else")) {
            this._output.space_before_token = true;
          } else {
            this.print_newline();
          }
        }
      } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ")") {
        this.print_newline();
      }
    } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === "," && this._last_last_text === "}") {
      this.print_newline();
    } else if (prefix === "SPACE") {
      this._output.space_before_token = true;
    }
    if (current_token.previous && (current_token.previous.type === TOKEN.WORD || current_token.previous.type === TOKEN.RESERVED)) {
      this._output.space_before_token = true;
    }
    this.print_token(current_token);
    this._flags.last_word = current_token.text;
    if (current_token.type === TOKEN.RESERVED) {
      if (current_token.text === "do") {
        this._flags.do_block = true;
      } else if (current_token.text === "if") {
        this._flags.if_block = true;
      } else if (current_token.text === "import") {
        this._flags.import_block = true;
      } else if (this._flags.import_block && reserved_word(current_token, "from")) {
        this._flags.import_block = false;
      }
    }
  };
  Beautifier.prototype.handle_semicolon = function(current_token) {
    if (this.start_of_statement(current_token)) {
      this._output.space_before_token = false;
    } else {
      this.handle_whitespace_and_comments(current_token);
    }
    var next_token = this._tokens.peek();
    while (this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, "else")) && !this._flags.do_block) {
      this.restore_mode();
    }
    if (this._flags.import_block) {
      this._flags.import_block = false;
    }
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_string = function(current_token) {
    if (current_token.text.startsWith("`") && current_token.newlines === 0 && current_token.whitespace_before === "" && (current_token.previous.text === ")" || this._flags.last_token.type === TOKEN.WORD)) {
    } else if (this.start_of_statement(current_token)) {
      this._output.space_before_token = true;
    } else {
      this.handle_whitespace_and_comments(current_token);
      if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.inline_frame) {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
        if (!this.start_of_object_property()) {
          this.allow_wrap_or_preserved_newline(current_token);
        }
      } else if (current_token.text.startsWith("`") && this._flags.last_token.type === TOKEN.END_EXPR && (current_token.previous.text === "]" || current_token.previous.text === ")") && current_token.newlines === 0) {
        this._output.space_before_token = true;
      } else {
        this.print_newline();
      }
    }
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_equals = function(current_token) {
    if (this.start_of_statement(current_token)) {
    } else {
      this.handle_whitespace_and_comments(current_token);
    }
    if (this._flags.declaration_statement) {
      this._flags.declaration_assignment = true;
    }
    this._output.space_before_token = true;
    this.print_token(current_token);
    this._output.space_before_token = true;
  };
  Beautifier.prototype.handle_comma = function(current_token) {
    this.handle_whitespace_and_comments(current_token, true);
    this.print_token(current_token);
    this._output.space_before_token = true;
    if (this._flags.declaration_statement) {
      if (is_expression(this._flags.parent.mode)) {
        this._flags.declaration_assignment = false;
      }
      if (this._flags.declaration_assignment) {
        this._flags.declaration_assignment = false;
        this.print_newline(false, true);
      } else if (this._options.comma_first) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    } else if (this._flags.mode === MODE.ObjectLiteral || this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral) {
      if (this._flags.mode === MODE.Statement) {
        this.restore_mode();
      }
      if (!this._flags.inline_frame) {
        this.print_newline();
      }
    } else if (this._options.comma_first) {
      this.allow_wrap_or_preserved_newline(current_token);
    }
  };
  Beautifier.prototype.handle_operator = function(current_token) {
    var isGeneratorAsterisk = current_token.text === "*" && (reserved_array(this._flags.last_token, ["function", "yield"]) || in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.COMMA, TOKEN.END_BLOCK, TOKEN.SEMICOLON]));
    var isUnary = in_array(current_token.text, ["-", "+"]) && (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.START_EXPR, TOKEN.EQUALS, TOKEN.OPERATOR]) || in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === ",");
    if (this.start_of_statement(current_token)) {
    } else {
      var preserve_statement_flags = !isGeneratorAsterisk;
      this.handle_whitespace_and_comments(current_token, preserve_statement_flags);
    }
    if (current_token.text === "*" && this._flags.last_token.type === TOKEN.DOT) {
      this.print_token(current_token);
      return;
    }
    if (current_token.text === "::") {
      this.print_token(current_token);
      return;
    }
    if (in_array(current_token.text, ["-", "+"]) && this.start_of_object_property()) {
      this.print_token(current_token);
      return;
    }
    if (this._flags.last_token.type === TOKEN.OPERATOR && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
      this.allow_wrap_or_preserved_newline(current_token);
    }
    if (current_token.text === ":" && this._flags.in_case) {
      this.print_token(current_token);
      this._flags.in_case = false;
      this._flags.case_body = true;
      if (this._tokens.peek().type !== TOKEN.START_BLOCK) {
        this.indent();
        this.print_newline();
        this._flags.case_block = false;
      } else {
        this._flags.case_block = true;
        this._output.space_before_token = true;
      }
      return;
    }
    var space_before = true;
    var space_after = true;
    var in_ternary = false;
    if (current_token.text === ":") {
      if (this._flags.ternary_depth === 0) {
        space_before = false;
      } else {
        this._flags.ternary_depth -= 1;
        in_ternary = true;
      }
    } else if (current_token.text === "?") {
      this._flags.ternary_depth += 1;
    }
    if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array(current_token.text, positionable_operators)) {
      var isColon = current_token.text === ":";
      var isTernaryColon = isColon && in_ternary;
      var isOtherColon = isColon && !in_ternary;
      switch (this._options.operator_position) {
        case OPERATOR_POSITION.before_newline:
          this._output.space_before_token = !isOtherColon;
          this.print_token(current_token);
          if (!isColon || isTernaryColon) {
            this.allow_wrap_or_preserved_newline(current_token);
          }
          this._output.space_before_token = true;
          return;
        case OPERATOR_POSITION.after_newline:
          this._output.space_before_token = true;
          if (!isColon || isTernaryColon) {
            if (this._tokens.peek().newlines) {
              this.print_newline(false, true);
            } else {
              this.allow_wrap_or_preserved_newline(current_token);
            }
          } else {
            this._output.space_before_token = false;
          }
          this.print_token(current_token);
          this._output.space_before_token = true;
          return;
        case OPERATOR_POSITION.preserve_newline:
          if (!isOtherColon) {
            this.allow_wrap_or_preserved_newline(current_token);
          }
          space_before = !(this._output.just_added_newline() || isOtherColon);
          this._output.space_before_token = space_before;
          this.print_token(current_token);
          this._output.space_before_token = true;
          return;
      }
    }
    if (isGeneratorAsterisk) {
      this.allow_wrap_or_preserved_newline(current_token);
      space_before = false;
      var next_token = this._tokens.peek();
      space_after = next_token && in_array(next_token.type, [TOKEN.WORD, TOKEN.RESERVED]);
    } else if (current_token.text === "...") {
      this.allow_wrap_or_preserved_newline(current_token);
      space_before = this._flags.last_token.type === TOKEN.START_BLOCK;
      space_after = false;
    } else if (in_array(current_token.text, ["--", "++", "!", "~"]) || isUnary) {
      if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
      space_before = false;
      space_after = false;
      if (current_token.newlines && (current_token.text === "--" || current_token.text === "++" || current_token.text === "~")) {
        var new_line_needed = reserved_array(this._flags.last_token, special_words) && current_token.newlines;
        if (new_line_needed && (this._previous_flags.if_block || this._previous_flags.else_block)) {
          this.restore_mode();
        }
        this.print_newline(new_line_needed, true);
      }
      if (this._flags.last_token.text === ";" && is_expression(this._flags.mode)) {
        space_before = true;
      }
      if (this._flags.last_token.type === TOKEN.RESERVED) {
        space_before = true;
      } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
        space_before = !(this._flags.last_token.text === "]" && (current_token.text === "--" || current_token.text === "++"));
      } else if (this._flags.last_token.type === TOKEN.OPERATOR) {
        space_before = in_array(current_token.text, ["--", "-", "++", "+"]) && in_array(this._flags.last_token.text, ["--", "-", "++", "+"]);
        if (in_array(current_token.text, ["+", "-"]) && in_array(this._flags.last_token.text, ["--", "++"])) {
          space_after = true;
        }
      }
      if ((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame || this._flags.mode === MODE.Statement) && (this._flags.last_token.text === "{" || this._flags.last_token.text === ";")) {
        this.print_newline();
      }
    }
    this._output.space_before_token = this._output.space_before_token || space_before;
    this.print_token(current_token);
    this._output.space_before_token = space_after;
  };
  Beautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {
    if (this._output.raw) {
      this._output.add_raw_token(current_token);
      if (current_token.directives && current_token.directives.preserve === "end") {
        this._output.raw = this._options.test_output_raw;
      }
      return;
    }
    if (current_token.directives) {
      this.print_newline(false, preserve_statement_flags);
      this.print_token(current_token);
      if (current_token.directives.preserve === "start") {
        this._output.raw = true;
      }
      this.print_newline(false, true);
      return;
    }
    if (!acorn.newline.test(current_token.text) && !current_token.newlines) {
      this._output.space_before_token = true;
      this.print_token(current_token);
      this._output.space_before_token = true;
      return;
    } else {
      this.print_block_commment(current_token, preserve_statement_flags);
    }
  };
  Beautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {
    var lines = split_linebreaks(current_token.text);
    var j;
    var javadoc = false;
    var starless = false;
    var lastIndent = current_token.whitespace_before;
    var lastIndentLength = lastIndent.length;
    this.print_newline(false, preserve_statement_flags);
    this.print_token_line_indentation(current_token);
    this._output.add_token(lines[0]);
    this.print_newline(false, preserve_statement_flags);
    if (lines.length > 1) {
      lines = lines.slice(1);
      javadoc = all_lines_start_with(lines, "*");
      starless = each_line_matches_indent(lines, lastIndent);
      if (javadoc) {
        this._flags.alignment = 1;
      }
      for (j = 0;j < lines.length; j++) {
        if (javadoc) {
          this.print_token_line_indentation(current_token);
          this._output.add_token(ltrim(lines[j]));
        } else if (starless && lines[j]) {
          this.print_token_line_indentation(current_token);
          this._output.add_token(lines[j].substring(lastIndentLength));
        } else {
          this._output.current_line.set_indent(-1);
          this._output.add_token(lines[j]);
        }
        this.print_newline(false, preserve_statement_flags);
      }
      this._flags.alignment = 0;
    }
  };
  Beautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {
    if (current_token.newlines) {
      this.print_newline(false, preserve_statement_flags);
    } else {
      this._output.trim(true);
    }
    this._output.space_before_token = true;
    this.print_token(current_token);
    this.print_newline(false, preserve_statement_flags);
  };
  Beautifier.prototype.handle_dot = function(current_token) {
    if (this.start_of_statement(current_token)) {
    } else {
      this.handle_whitespace_and_comments(current_token, true);
    }
    if (this._flags.last_token.text.match("^[0-9]+$")) {
      this._output.space_before_token = true;
    }
    if (reserved_array(this._flags.last_token, special_words)) {
      this._output.space_before_token = false;
    } else {
      this.allow_wrap_or_preserved_newline(current_token, this._flags.last_token.text === ")" && this._options.break_chained_methods);
    }
    if (this._options.unindent_chained_methods && this._output.just_added_newline()) {
      this.deindent();
    }
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {
    this.print_token(current_token);
    if (current_token.text[current_token.text.length - 1] === "\n") {
      this.print_newline(false, preserve_statement_flags);
    }
  };
  Beautifier.prototype.handle_eof = function(current_token) {
    while (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }
    this.handle_whitespace_and_comments(current_token);
  };
  exports.Beautifier = Beautifier;
});

// ../sisventa/node_modules/js-beautify/js/src/javascript/index.js
var require_javascript = __commonJS((exports, module) => {
  var js_beautify = function(js_source_text, options) {
    var beautifier = new Beautifier(js_source_text, options);
    return beautifier.beautify();
  };
  var Beautifier = require_beautifier().Beautifier;
  var Options = require_options2().Options;
  module.exports = js_beautify;
  module.exports.defaultOptions = function() {
    return new Options;
  };
});

// ../sisventa/node_modules/js-beautify/js/src/css/options.js
var require_options3 = __commonJS((exports, module) => {
  var Options = function(options) {
    BaseOptions.call(this, options, "css");
    this.selector_separator_newline = this._get_boolean("selector_separator_newline", true);
    this.newline_between_rules = this._get_boolean("newline_between_rules", true);
    var space_around_selector_separator = this._get_boolean("space_around_selector_separator");
    this.space_around_combinator = this._get_boolean("space_around_combinator") || space_around_selector_separator;
    var brace_style_split = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
    this.brace_style = "collapse";
    for (var bs = 0;bs < brace_style_split.length; bs++) {
      if (brace_style_split[bs] !== "expand") {
        this.brace_style = "collapse";
      } else {
        this.brace_style = brace_style_split[bs];
      }
    }
  };
  var BaseOptions = require_options().Options;
  Options.prototype = new BaseOptions;
  exports.Options = Options;
});

// ../sisventa/node_modules/js-beautify/js/src/css/beautifier.js
var require_beautifier2 = __commonJS((exports, module) => {
  var Beautifier = function(source_text, options) {
    this._source_text = source_text || "";
    this._options = new Options(options);
    this._ch = null;
    this._input = null;
    this.NESTED_AT_RULE = {
      page: true,
      "font-face": true,
      keyframes: true,
      media: true,
      supports: true,
      document: true
    };
    this.CONDITIONAL_GROUP_RULE = {
      media: true,
      supports: true,
      document: true
    };
    this.NON_SEMICOLON_NEWLINE_PROPERTY = [
      "grid-template-areas",
      "grid-template"
    ];
  };
  var Options = require_options3().Options;
  var Output = require_output().Output;
  var InputScanner = require_inputscanner().InputScanner;
  var Directives = require_directives().Directives;
  var directives_core = new Directives(/\/\*/, /\*\//);
  var lineBreak = /\r\n|[\r\n]/;
  var allLineBreaks = /\r\n|[\r\n]/g;
  var whitespaceChar = /\s/;
  var whitespacePattern = /(?:\s|\n)+/g;
  var block_comment_pattern = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g;
  var comment_pattern = /\/\/(?:[^\n\r\u2028\u2029]*)/g;
  Beautifier.prototype.eatString = function(endChars) {
    var result = "";
    this._ch = this._input.next();
    while (this._ch) {
      result += this._ch;
      if (this._ch === "\\") {
        result += this._input.next();
      } else if (endChars.indexOf(this._ch) !== -1 || this._ch === "\n") {
        break;
      }
      this._ch = this._input.next();
    }
    return result;
  };
  Beautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {
    var result = whitespaceChar.test(this._input.peek());
    var newline_count = 0;
    while (whitespaceChar.test(this._input.peek())) {
      this._ch = this._input.next();
      if (allowAtLeastOneNewLine && this._ch === "\n") {
        if (newline_count === 0 || newline_count < this._options.max_preserve_newlines) {
          newline_count++;
          this._output.add_new_line(true);
        }
      }
    }
    return result;
  };
  Beautifier.prototype.foundNestedPseudoClass = function() {
    var openParen = 0;
    var i = 1;
    var ch = this._input.peek(i);
    while (ch) {
      if (ch === "{") {
        return true;
      } else if (ch === "(") {
        openParen += 1;
      } else if (ch === ")") {
        if (openParen === 0) {
          return false;
        }
        openParen -= 1;
      } else if (ch === ";" || ch === "}") {
        return false;
      }
      i++;
      ch = this._input.peek(i);
    }
    return false;
  };
  Beautifier.prototype.print_string = function(output_string) {
    this._output.set_indent(this._indentLevel);
    this._output.non_breaking_space = true;
    this._output.add_token(output_string);
  };
  Beautifier.prototype.preserveSingleSpace = function(isAfterSpace) {
    if (isAfterSpace) {
      this._output.space_before_token = true;
    }
  };
  Beautifier.prototype.indent = function() {
    this._indentLevel++;
  };
  Beautifier.prototype.outdent = function() {
    if (this._indentLevel > 0) {
      this._indentLevel--;
    }
  };
  Beautifier.prototype.beautify = function() {
    if (this._options.disabled) {
      return this._source_text;
    }
    var source_text = this._source_text;
    var eol = this._options.eol;
    if (eol === "auto") {
      eol = "\n";
      if (source_text && lineBreak.test(source_text || "")) {
        eol = source_text.match(lineBreak)[0];
      }
    }
    source_text = source_text.replace(allLineBreaks, "\n");
    var baseIndentString = source_text.match(/^[\t ]*/)[0];
    this._output = new Output(this._options, baseIndentString);
    this._input = new InputScanner(source_text);
    this._indentLevel = 0;
    this._nestedLevel = 0;
    this._ch = null;
    var parenLevel = 0;
    var insideRule = false;
    var insidePropertyValue = false;
    var enteringConditionalGroup = false;
    var insideNonNestedAtRule = false;
    var insideScssMap = false;
    var topCharacter = this._ch;
    var insideNonSemiColonValues = false;
    var whitespace;
    var isAfterSpace;
    var previous_ch;
    while (true) {
      whitespace = this._input.read(whitespacePattern);
      isAfterSpace = whitespace !== "";
      previous_ch = topCharacter;
      this._ch = this._input.next();
      if (this._ch === "\\" && this._input.hasNext()) {
        this._ch += this._input.next();
      }
      topCharacter = this._ch;
      if (!this._ch) {
        break;
      } else if (this._ch === "/" && this._input.peek() === "*") {
        this._output.add_new_line();
        this._input.back();
        var comment = this._input.read(block_comment_pattern);
        var directives = directives_core.get_directives(comment);
        if (directives && directives.ignore === "start") {
          comment += directives_core.readIgnored(this._input);
        }
        this.print_string(comment);
        this.eatWhitespace(true);
        this._output.add_new_line();
      } else if (this._ch === "/" && this._input.peek() === "/") {
        this._output.space_before_token = true;
        this._input.back();
        this.print_string(this._input.read(comment_pattern));
        this.eatWhitespace(true);
      } else if (this._ch === "$") {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch);
        var variable = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
        if (variable.match(/[ :]$/)) {
          variable = this.eatString(": ").replace(/\s+$/, "");
          this.print_string(variable);
          this._output.space_before_token = true;
        }
        if (parenLevel === 0 && variable.indexOf(":") !== -1) {
          insidePropertyValue = true;
          this.indent();
        }
      } else if (this._ch === "@") {
        this.preserveSingleSpace(isAfterSpace);
        if (this._input.peek() === "{") {
          this.print_string(this._ch + this.eatString("}"));
        } else {
          this.print_string(this._ch);
          var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
          if (variableOrRule.match(/[ :]$/)) {
            variableOrRule = this.eatString(": ").replace(/\s+$/, "");
            this.print_string(variableOrRule);
            this._output.space_before_token = true;
          }
          if (parenLevel === 0 && variableOrRule.indexOf(":") !== -1) {
            insidePropertyValue = true;
            this.indent();
          } else if (variableOrRule in this.NESTED_AT_RULE) {
            this._nestedLevel += 1;
            if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
              enteringConditionalGroup = true;
            }
          } else if (parenLevel === 0 && !insidePropertyValue) {
            insideNonNestedAtRule = true;
          }
        }
      } else if (this._ch === "#" && this._input.peek() === "{") {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch + this.eatString("}"));
      } else if (this._ch === "{") {
        if (insidePropertyValue) {
          insidePropertyValue = false;
          this.outdent();
        }
        insideNonNestedAtRule = false;
        if (enteringConditionalGroup) {
          enteringConditionalGroup = false;
          insideRule = this._indentLevel >= this._nestedLevel;
        } else {
          insideRule = this._indentLevel >= this._nestedLevel - 1;
        }
        if (this._options.newline_between_rules && insideRule) {
          if (this._output.previous_line && this._output.previous_line.item(-1) !== "{") {
            this._output.ensure_empty_line_above("/", ",");
          }
        }
        this._output.space_before_token = true;
        if (this._options.brace_style === "expand") {
          this._output.add_new_line();
          this.print_string(this._ch);
          this.indent();
          this._output.set_indent(this._indentLevel);
        } else {
          if (previous_ch === "(") {
            this._output.space_before_token = false;
          } else if (previous_ch !== ",") {
            this.indent();
          }
          this.print_string(this._ch);
        }
        this.eatWhitespace(true);
        this._output.add_new_line();
      } else if (this._ch === "}") {
        this.outdent();
        this._output.add_new_line();
        if (previous_ch === "{") {
          this._output.trim(true);
        }
        if (insidePropertyValue) {
          this.outdent();
          insidePropertyValue = false;
        }
        this.print_string(this._ch);
        insideRule = false;
        if (this._nestedLevel) {
          this._nestedLevel--;
        }
        this.eatWhitespace(true);
        this._output.add_new_line();
        if (this._options.newline_between_rules && !this._output.just_added_blankline()) {
          if (this._input.peek() !== "}") {
            this._output.add_new_line(true);
          }
        }
        if (this._input.peek() === ")") {
          this._output.trim(true);
          if (this._options.brace_style === "expand") {
            this._output.add_new_line(true);
          }
        }
      } else if (this._ch === ":") {
        for (var i = 0;i < this.NON_SEMICOLON_NEWLINE_PROPERTY.length; i++) {
          if (this._input.lookBack(this.NON_SEMICOLON_NEWLINE_PROPERTY[i])) {
            insideNonSemiColonValues = true;
            break;
          }
        }
        if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input.lookBack("(") && !insideNonNestedAtRule && parenLevel === 0) {
          this.print_string(":");
          if (!insidePropertyValue) {
            insidePropertyValue = true;
            this._output.space_before_token = true;
            this.eatWhitespace(true);
            this.indent();
          }
        } else {
          if (this._input.lookBack(" ")) {
            this._output.space_before_token = true;
          }
          if (this._input.peek() === ":") {
            this._ch = this._input.next();
            this.print_string("::");
          } else {
            this.print_string(":");
          }
        }
      } else if (this._ch === '"' || this._ch === "\'") {
        var preserveQuoteSpace = previous_ch === '"' || previous_ch === "\'";
        this.preserveSingleSpace(preserveQuoteSpace || isAfterSpace);
        this.print_string(this._ch + this.eatString(this._ch));
        this.eatWhitespace(true);
      } else if (this._ch === ";") {
        insideNonSemiColonValues = false;
        if (parenLevel === 0) {
          if (insidePropertyValue) {
            this.outdent();
            insidePropertyValue = false;
          }
          insideNonNestedAtRule = false;
          this.print_string(this._ch);
          this.eatWhitespace(true);
          if (this._input.peek() !== "/") {
            this._output.add_new_line();
          }
        } else {
          this.print_string(this._ch);
          this.eatWhitespace(true);
          this._output.space_before_token = true;
        }
      } else if (this._ch === "(") {
        if (this._input.lookBack("url")) {
          this.print_string(this._ch);
          this.eatWhitespace();
          parenLevel++;
          this.indent();
          this._ch = this._input.next();
          if (this._ch === ")" || this._ch === '"' || this._ch === "\'") {
            this._input.back();
          } else if (this._ch) {
            this.print_string(this._ch + this.eatString(")"));
            if (parenLevel) {
              parenLevel--;
              this.outdent();
            }
          }
        } else {
          var space_needed = false;
          if (this._input.lookBack("with")) {
            space_needed = true;
          }
          this.preserveSingleSpace(isAfterSpace || space_needed);
          this.print_string(this._ch);
          if (insidePropertyValue && previous_ch === "$" && this._options.selector_separator_newline) {
            this._output.add_new_line();
            insideScssMap = true;
          } else {
            this.eatWhitespace();
            parenLevel++;
            this.indent();
          }
        }
      } else if (this._ch === ")") {
        if (parenLevel) {
          parenLevel--;
          this.outdent();
        }
        if (insideScssMap && this._input.peek() === ";" && this._options.selector_separator_newline) {
          insideScssMap = false;
          this.outdent();
          this._output.add_new_line();
        }
        this.print_string(this._ch);
      } else if (this._ch === ",") {
        this.print_string(this._ch);
        this.eatWhitespace(true);
        if (this._options.selector_separator_newline && (!insidePropertyValue || insideScssMap) && parenLevel === 0 && !insideNonNestedAtRule) {
          this._output.add_new_line();
        } else {
          this._output.space_before_token = true;
        }
      } else if ((this._ch === ">" || this._ch === "+" || this._ch === "~") && !insidePropertyValue && parenLevel === 0) {
        if (this._options.space_around_combinator) {
          this._output.space_before_token = true;
          this.print_string(this._ch);
          this._output.space_before_token = true;
        } else {
          this.print_string(this._ch);
          this.eatWhitespace();
          if (this._ch && whitespaceChar.test(this._ch)) {
            this._ch = "";
          }
        }
      } else if (this._ch === "]") {
        this.print_string(this._ch);
      } else if (this._ch === "[") {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch);
      } else if (this._ch === "=") {
        this.eatWhitespace();
        this.print_string("=");
        if (whitespaceChar.test(this._ch)) {
          this._ch = "";
        }
      } else if (this._ch === "!" && !this._input.lookBack("\\")) {
        this._output.space_before_token = true;
        this.print_string(this._ch);
      } else {
        var preserveAfterSpace = previous_ch === '"' || previous_ch === "\'";
        this.preserveSingleSpace(preserveAfterSpace || isAfterSpace);
        this.print_string(this._ch);
        if (!this._output.just_added_newline() && this._input.peek() === "\n" && insideNonSemiColonValues) {
          this._output.add_new_line();
        }
      }
    }
    var sweetCode = this._output.get_code(eol);
    return sweetCode;
  };
  exports.Beautifier = Beautifier;
});

// ../sisventa/node_modules/js-beautify/js/src/css/index.js
var require_css = __commonJS((exports, module) => {
  var css_beautify = function(source_text, options) {
    var beautifier = new Beautifier(source_text, options);
    return beautifier.beautify();
  };
  var Beautifier = require_beautifier2().Beautifier;
  var Options = require_options3().Options;
  module.exports = css_beautify;
  module.exports.defaultOptions = function() {
    return new Options;
  };
});

// ../sisventa/node_modules/js-beautify/js/src/html/options.js
var require_options4 = __commonJS((exports, module) => {
  var Options = function(options) {
    BaseOptions.call(this, options, "html");
    if (this.templating.length === 1 && this.templating[0] === "auto") {
      this.templating = ["django", "erb", "handlebars", "php"];
    }
    this.indent_inner_html = this._get_boolean("indent_inner_html");
    this.indent_body_inner_html = this._get_boolean("indent_body_inner_html", true);
    this.indent_head_inner_html = this._get_boolean("indent_head_inner_html", true);
    this.indent_handlebars = this._get_boolean("indent_handlebars", true);
    this.wrap_attributes = this._get_selection("wrap_attributes", ["auto", "force", "force-aligned", "force-expand-multiline", "aligned-multiple", "preserve", "preserve-aligned"]);
    this.wrap_attributes_min_attrs = this._get_number("wrap_attributes_min_attrs", 2);
    this.wrap_attributes_indent_size = this._get_number("wrap_attributes_indent_size", this.indent_size);
    this.extra_liners = this._get_array("extra_liners", ["head", "body", "/html"]);
    this.inline = this._get_array("inline", [
      "a",
      "abbr",
      "area",
      "audio",
      "b",
      "bdi",
      "bdo",
      "br",
      "button",
      "canvas",
      "cite",
      "code",
      "data",
      "datalist",
      "del",
      "dfn",
      "em",
      "embed",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "keygen",
      "label",
      "map",
      "mark",
      "math",
      "meter",
      "noscript",
      "object",
      "output",
      "progress",
      "q",
      "ruby",
      "s",
      "samp",
      "select",
      "small",
      "span",
      "strong",
      "sub",
      "sup",
      "svg",
      "template",
      "textarea",
      "time",
      "u",
      "var",
      "video",
      "wbr",
      "text",
      "acronym",
      "big",
      "strike",
      "tt"
    ]);
    this.inline_custom_elements = this._get_boolean("inline_custom_elements", true);
    this.void_elements = this._get_array("void_elements", [
      "area",
      "base",
      "br",
      "col",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "menuitem",
      "meta",
      "param",
      "source",
      "track",
      "wbr",
      "!doctype",
      "?xml",
      "basefont",
      "isindex"
    ]);
    this.unformatted = this._get_array("unformatted", []);
    this.content_unformatted = this._get_array("content_unformatted", [
      "pre",
      "textarea"
    ]);
    this.unformatted_content_delimiter = this._get_characters("unformatted_content_delimiter");
    this.indent_scripts = this._get_selection("indent_scripts", ["normal", "keep", "separate"]);
  };
  var BaseOptions = require_options().Options;
  Options.prototype = new BaseOptions;
  exports.Options = Options;
});

// ../sisventa/node_modules/js-beautify/js/src/html/tokenizer.js
var require_tokenizer3 = __commonJS((exports, module) => {
  var BaseTokenizer = require_tokenizer().Tokenizer;
  var BASETOKEN = require_tokenizer().TOKEN;
  var Directives = require_directives().Directives;
  var TemplatablePattern = require_templatablepattern().TemplatablePattern;
  var Pattern = require_pattern().Pattern;
  var TOKEN = {
    TAG_OPEN: "TK_TAG_OPEN",
    TAG_CLOSE: "TK_TAG_CLOSE",
    ATTRIBUTE: "TK_ATTRIBUTE",
    EQUALS: "TK_EQUALS",
    VALUE: "TK_VALUE",
    COMMENT: "TK_COMMENT",
    TEXT: "TK_TEXT",
    UNKNOWN: "TK_UNKNOWN",
    START: BASETOKEN.START,
    RAW: BASETOKEN.RAW,
    EOF: BASETOKEN.EOF
  };
  var directives_core = new Directives(/<\!--/, /-->/);
  var Tokenizer3 = function(input_string, options) {
    BaseTokenizer.call(this, input_string, options);
    this._current_tag_name = "";
    var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);
    var pattern_reader = new Pattern(this._input);
    this.__patterns = {
      word: templatable_reader.until(/[\n\r\t <]/),
      single_quote: templatable_reader.until_after(/'/),
      double_quote: templatable_reader.until_after(/"/),
      attribute: templatable_reader.until(/[\n\r\t =>]|\/>/),
      element_name: templatable_reader.until(/[\n\r\t >\/]/),
      handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),
      handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),
      handlebars_open: pattern_reader.until(/[\n\r\t }]/),
      handlebars_raw_close: pattern_reader.until(/}}/),
      comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),
      cdata: pattern_reader.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
      conditional_comment: pattern_reader.starting_with(/<!\[/).until_after(/]>/),
      processing: pattern_reader.starting_with(/<\?/).until_after(/\?>/)
    };
    if (this._options.indent_handlebars) {
      this.__patterns.word = this.__patterns.word.exclude("handlebars");
    }
    this._unformatted_content_delimiter = null;
    if (this._options.unformatted_content_delimiter) {
      var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
      this.__patterns.unformatted_content_delimiter = pattern_reader.matching(literal_regexp).until_after(literal_regexp);
    }
  };
  Tokenizer3.prototype = new BaseTokenizer;
  Tokenizer3.prototype._is_comment = function(current_token) {
    return false;
  };
  Tokenizer3.prototype._is_opening = function(current_token) {
    return current_token.type === TOKEN.TAG_OPEN;
  };
  Tokenizer3.prototype._is_closing = function(current_token, open_token) {
    return current_token.type === TOKEN.TAG_CLOSE && (open_token && ((current_token.text === ">" || current_token.text === "/>") && open_token.text[0] === "<" || current_token.text === "}}" && open_token.text[0] === "{" && open_token.text[1] === "{"));
  };
  Tokenizer3.prototype._reset = function() {
    this._current_tag_name = "";
  };
  Tokenizer3.prototype._get_next_token = function(previous_token, open_token) {
    var token2 = null;
    this._readWhitespace();
    var c4 = this._input.peek();
    if (c4 === null) {
      return this._create_token(TOKEN.EOF, "");
    }
    token2 = token2 || this._read_open_handlebars(c4, open_token);
    token2 = token2 || this._read_attribute(c4, previous_token, open_token);
    token2 = token2 || this._read_close(c4, open_token);
    token2 = token2 || this._read_raw_content(c4, previous_token, open_token);
    token2 = token2 || this._read_content_word(c4);
    token2 = token2 || this._read_comment_or_cdata(c4);
    token2 = token2 || this._read_processing(c4);
    token2 = token2 || this._read_open(c4, open_token);
    token2 = token2 || this._create_token(TOKEN.UNKNOWN, this._input.next());
    return token2;
  };
  Tokenizer3.prototype._read_comment_or_cdata = function(c4) {
    var token2 = null;
    var resulting_string = null;
    var directives = null;
    if (c4 === "<") {
      var peek1 = this._input.peek(1);
      if (peek1 === "!") {
        resulting_string = this.__patterns.comment.read();
        if (resulting_string) {
          directives = directives_core.get_directives(resulting_string);
          if (directives && directives.ignore === "start") {
            resulting_string += directives_core.readIgnored(this._input);
          }
        } else {
          resulting_string = this.__patterns.cdata.read();
        }
      }
      if (resulting_string) {
        token2 = this._create_token(TOKEN.COMMENT, resulting_string);
        token2.directives = directives;
      }
    }
    return token2;
  };
  Tokenizer3.prototype._read_processing = function(c4) {
    var token2 = null;
    var resulting_string = null;
    var directives = null;
    if (c4 === "<") {
      var peek1 = this._input.peek(1);
      if (peek1 === "!" || peek1 === "?") {
        resulting_string = this.__patterns.conditional_comment.read();
        resulting_string = resulting_string || this.__patterns.processing.read();
      }
      if (resulting_string) {
        token2 = this._create_token(TOKEN.COMMENT, resulting_string);
        token2.directives = directives;
      }
    }
    return token2;
  };
  Tokenizer3.prototype._read_open = function(c4, open_token) {
    var resulting_string = null;
    var token2 = null;
    if (!open_token) {
      if (c4 === "<") {
        resulting_string = this._input.next();
        if (this._input.peek() === "/") {
          resulting_string += this._input.next();
        }
        resulting_string += this.__patterns.element_name.read();
        token2 = this._create_token(TOKEN.TAG_OPEN, resulting_string);
      }
    }
    return token2;
  };
  Tokenizer3.prototype._read_open_handlebars = function(c4, open_token) {
    var resulting_string = null;
    var token2 = null;
    if (!open_token) {
      if (this._options.indent_handlebars && c4 === "{" && this._input.peek(1) === "{") {
        if (this._input.peek(2) === "!") {
          resulting_string = this.__patterns.handlebars_comment.read();
          resulting_string = resulting_string || this.__patterns.handlebars.read();
          token2 = this._create_token(TOKEN.COMMENT, resulting_string);
        } else {
          resulting_string = this.__patterns.handlebars_open.read();
          token2 = this._create_token(TOKEN.TAG_OPEN, resulting_string);
        }
      }
    }
    return token2;
  };
  Tokenizer3.prototype._read_close = function(c4, open_token) {
    var resulting_string = null;
    var token2 = null;
    if (open_token) {
      if (open_token.text[0] === "<" && (c4 === ">" || c4 === "/" && this._input.peek(1) === ">")) {
        resulting_string = this._input.next();
        if (c4 === "/") {
          resulting_string += this._input.next();
        }
        token2 = this._create_token(TOKEN.TAG_CLOSE, resulting_string);
      } else if (open_token.text[0] === "{" && c4 === "}" && this._input.peek(1) === "}") {
        this._input.next();
        this._input.next();
        token2 = this._create_token(TOKEN.TAG_CLOSE, "}}");
      }
    }
    return token2;
  };
  Tokenizer3.prototype._read_attribute = function(c4, previous_token, open_token) {
    var token2 = null;
    var resulting_string = "";
    if (open_token && open_token.text[0] === "<") {
      if (c4 === "=") {
        token2 = this._create_token(TOKEN.EQUALS, this._input.next());
      } else if (c4 === '"' || c4 === "'") {
        var content = this._input.next();
        if (c4 === '"') {
          content += this.__patterns.double_quote.read();
        } else {
          content += this.__patterns.single_quote.read();
        }
        token2 = this._create_token(TOKEN.VALUE, content);
      } else {
        resulting_string = this.__patterns.attribute.read();
        if (resulting_string) {
          if (previous_token.type === TOKEN.EQUALS) {
            token2 = this._create_token(TOKEN.VALUE, resulting_string);
          } else {
            token2 = this._create_token(TOKEN.ATTRIBUTE, resulting_string);
          }
        }
      }
    }
    return token2;
  };
  Tokenizer3.prototype._is_content_unformatted = function(tag_name) {
    return this._options.void_elements.indexOf(tag_name) === -1 && (this._options.content_unformatted.indexOf(tag_name) !== -1 || this._options.unformatted.indexOf(tag_name) !== -1);
  };
  Tokenizer3.prototype._read_raw_content = function(c4, previous_token, open_token) {
    var resulting_string = "";
    if (open_token && open_token.text[0] === "{") {
      resulting_string = this.__patterns.handlebars_raw_close.read();
    } else if (previous_token.type === TOKEN.TAG_CLOSE && previous_token.opened.text[0] === "<" && previous_token.text[0] !== "/") {
      var tag_name = previous_token.opened.text.substr(1).toLowerCase();
      if (tag_name === "script" || tag_name === "style") {
        var token2 = this._read_comment_or_cdata(c4);
        if (token2) {
          token2.type = TOKEN.TEXT;
          return token2;
        }
        resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
      } else if (this._is_content_unformatted(tag_name)) {
        resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
      }
    }
    if (resulting_string) {
      return this._create_token(TOKEN.TEXT, resulting_string);
    }
    return null;
  };
  Tokenizer3.prototype._read_content_word = function(c4) {
    var resulting_string = "";
    if (this._options.unformatted_content_delimiter) {
      if (c4 === this._options.unformatted_content_delimiter[0]) {
        resulting_string = this.__patterns.unformatted_content_delimiter.read();
      }
    }
    if (!resulting_string) {
      resulting_string = this.__patterns.word.read();
    }
    if (resulting_string) {
      return this._create_token(TOKEN.TEXT, resulting_string);
    }
  };
  exports.Tokenizer = Tokenizer3;
  exports.TOKEN = TOKEN;
});

// ../sisventa/node_modules/js-beautify/js/src/html/beautifier.js
var require_beautifier3 = __commonJS((exports, module) => {
  var in_array = function(what, arr) {
    return arr.indexOf(what) !== -1;
  };
  var TagFrame = function(parent, parser_token, indent_level) {
    this.parent = parent || null;
    this.tag = parser_token ? parser_token.tag_name : "";
    this.indent_level = indent_level || 0;
    this.parser_token = parser_token || null;
  };
  var TagStack = function(printer) {
    this._printer = printer;
    this._current_frame = null;
  };
  var Beautifier = function(source_text, options, js_beautify, css_beautify) {
    this._source_text = source_text || "";
    options = options || {};
    this._js_beautify = js_beautify;
    this._css_beautify = css_beautify;
    this._tag_stack = null;
    var optionHtml = new Options(options, "html");
    this._options = optionHtml;
    this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, "force".length) === "force";
    this._is_wrap_attributes_force_expand_multiline = this._options.wrap_attributes === "force-expand-multiline";
    this._is_wrap_attributes_force_aligned = this._options.wrap_attributes === "force-aligned";
    this._is_wrap_attributes_aligned_multiple = this._options.wrap_attributes === "aligned-multiple";
    this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, "preserve".length) === "preserve";
    this._is_wrap_attributes_preserve_aligned = this._options.wrap_attributes === "preserve-aligned";
  };
  var Options = require_options4().Options;
  var Output = require_output().Output;
  var Tokenizer3 = require_tokenizer3().Tokenizer;
  var TOKEN = require_tokenizer3().TOKEN;
  var lineBreak = /\r\n|[\r\n]/;
  var allLineBreaks = /\r\n|[\r\n]/g;
  var Printer = function(options, base_indent_string) {
    this.indent_level = 0;
    this.alignment_size = 0;
    this.max_preserve_newlines = options.max_preserve_newlines;
    this.preserve_newlines = options.preserve_newlines;
    this._output = new Output(options, base_indent_string);
  };
  Printer.prototype.current_line_has_match = function(pattern5) {
    return this._output.current_line.has_match(pattern5);
  };
  Printer.prototype.set_space_before_token = function(value27, non_breaking) {
    this._output.space_before_token = value27;
    this._output.non_breaking_space = non_breaking;
  };
  Printer.prototype.set_wrap_point = function() {
    this._output.set_indent(this.indent_level, this.alignment_size);
    this._output.set_wrap_point();
  };
  Printer.prototype.add_raw_token = function(token2) {
    this._output.add_raw_token(token2);
  };
  Printer.prototype.print_preserved_newlines = function(raw_token) {
    var newlines = 0;
    if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {
      newlines = raw_token.newlines ? 1 : 0;
    }
    if (this.preserve_newlines) {
      newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;
    }
    for (var n4 = 0;n4 < newlines; n4++) {
      this.print_newline(n4 > 0);
    }
    return newlines !== 0;
  };
  Printer.prototype.traverse_whitespace = function(raw_token) {
    if (raw_token.whitespace_before || raw_token.newlines) {
      if (!this.print_preserved_newlines(raw_token)) {
        this._output.space_before_token = true;
      }
      return true;
    }
    return false;
  };
  Printer.prototype.previous_token_wrapped = function() {
    return this._output.previous_token_wrapped;
  };
  Printer.prototype.print_newline = function(force) {
    this._output.add_new_line(force);
  };
  Printer.prototype.print_token = function(token2) {
    if (token2.text) {
      this._output.set_indent(this.indent_level, this.alignment_size);
      this._output.add_token(token2.text);
    }
  };
  Printer.prototype.indent = function() {
    this.indent_level++;
  };
  Printer.prototype.get_full_indent = function(level) {
    level = this.indent_level + (level || 0);
    if (level < 1) {
      return "";
    }
    return this._output.get_indent_string(level);
  };
  var get_type_attribute = function(start_token) {
    var result = null;
    var raw_token = start_token.next;
    while (raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token) {
      if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === "type") {
        if (raw_token.next && raw_token.next.type === TOKEN.EQUALS && raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {
          result = raw_token.next.next.text;
        }
        break;
      }
      raw_token = raw_token.next;
    }
    return result;
  };
  var get_custom_beautifier_name = function(tag_check, raw_token) {
    var typeAttribute = null;
    var result = null;
    if (!raw_token.closed) {
      return null;
    }
    if (tag_check === "script") {
      typeAttribute = "text/javascript";
    } else if (tag_check === "style") {
      typeAttribute = "text/css";
    }
    typeAttribute = get_type_attribute(raw_token) || typeAttribute;
    if (typeAttribute.search("text/css") > -1) {
      result = "css";
    } else if (typeAttribute.search(/module|((text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect))/) > -1) {
      result = "javascript";
    } else if (typeAttribute.search(/(text|application|dojo)\/(x-)?(html)/) > -1) {
      result = "html";
    } else if (typeAttribute.search(/test\/null/) > -1) {
      result = "null";
    }
    return result;
  };
  TagStack.prototype.get_parser_token = function() {
    return this._current_frame ? this._current_frame.parser_token : null;
  };
  TagStack.prototype.record_tag = function(parser_token) {
    var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);
    this._current_frame = new_frame;
  };
  TagStack.prototype._try_pop_frame = function(frame) {
    var parser_token = null;
    if (frame) {
      parser_token = frame.parser_token;
      this._printer.indent_level = frame.indent_level;
      this._current_frame = frame.parent;
    }
    return parser_token;
  };
  TagStack.prototype._get_frame = function(tag_list, stop_list) {
    var frame = this._current_frame;
    while (frame) {
      if (tag_list.indexOf(frame.tag) !== -1) {
        break;
      } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {
        frame = null;
        break;
      }
      frame = frame.parent;
    }
    return frame;
  };
  TagStack.prototype.try_pop = function(tag, stop_list) {
    var frame = this._get_frame([tag], stop_list);
    return this._try_pop_frame(frame);
  };
  TagStack.prototype.indent_to_tag = function(tag_list) {
    var frame = this._get_frame(tag_list);
    if (frame) {
      this._printer.indent_level = frame.indent_level;
    }
  };
  Beautifier.prototype.beautify = function() {
    if (this._options.disabled) {
      return this._source_text;
    }
    var source_text = this._source_text;
    var eol = this._options.eol;
    if (this._options.eol === "auto") {
      eol = "\n";
      if (source_text && lineBreak.test(source_text)) {
        eol = source_text.match(lineBreak)[0];
      }
    }
    source_text = source_text.replace(allLineBreaks, "\n");
    var baseIndentString = source_text.match(/^[\t ]*/)[0];
    var last_token = {
      text: "",
      type: ""
    };
    var last_tag_token = new TagOpenParserToken;
    var printer = new Printer(this._options, baseIndentString);
    var tokens = new Tokenizer3(source_text, this._options).tokenize();
    this._tag_stack = new TagStack(printer);
    var parser_token = null;
    var raw_token = tokens.next();
    while (raw_token.type !== TOKEN.EOF) {
      if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {
        parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token, tokens);
        last_tag_token = parser_token;
      } else if (raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE || raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete) {
        parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, last_token);
      } else if (raw_token.type === TOKEN.TAG_CLOSE) {
        parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);
      } else if (raw_token.type === TOKEN.TEXT) {
        parser_token = this._handle_text(printer, raw_token, last_tag_token);
      } else {
        printer.add_raw_token(raw_token);
      }
      last_token = parser_token;
      raw_token = tokens.next();
    }
    var sweet_code = printer._output.get_code(eol);
    return sweet_code;
  };
  Beautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {
    var parser_token = {
      text: raw_token.text,
      type: raw_token.type
    };
    printer.alignment_size = 0;
    last_tag_token.tag_complete = true;
    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
    if (last_tag_token.is_unformatted) {
      printer.add_raw_token(raw_token);
    } else {
      if (last_tag_token.tag_start_char === "<") {
        printer.set_space_before_token(raw_token.text[0] === "/", true);
        if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {
          printer.print_newline(false);
        }
      }
      printer.print_token(raw_token);
    }
    if (last_tag_token.indent_content && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
      printer.indent();
      last_tag_token.indent_content = false;
    }
    if (!last_tag_token.is_inline_element && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
      printer.set_wrap_point();
    }
    return parser_token;
  };
  Beautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, last_token) {
    var wrapped = last_tag_token.has_wrapped_attrs;
    var parser_token = {
      text: raw_token.text,
      type: raw_token.type
    };
    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
    if (last_tag_token.is_unformatted) {
      printer.add_raw_token(raw_token);
    } else if (last_tag_token.tag_start_char === "{" && raw_token.type === TOKEN.TEXT) {
      if (printer.print_preserved_newlines(raw_token)) {
        raw_token.newlines = 0;
        printer.add_raw_token(raw_token);
      } else {
        printer.print_token(raw_token);
      }
    } else {
      if (raw_token.type === TOKEN.ATTRIBUTE) {
        printer.set_space_before_token(true);
      } else if (raw_token.type === TOKEN.EQUALS) {
        printer.set_space_before_token(false);
      } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) {
        printer.set_space_before_token(false);
      }
      if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === "<") {
        if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {
          printer.traverse_whitespace(raw_token);
          wrapped = wrapped || raw_token.newlines !== 0;
        }
        if (this._is_wrap_attributes_force && last_tag_token.attr_count >= this._options.wrap_attributes_min_attrs && (last_token.type !== TOKEN.TAG_OPEN || this._is_wrap_attributes_force_expand_multiline)) {
          printer.print_newline(false);
          wrapped = true;
        }
      }
      printer.print_token(raw_token);
      wrapped = wrapped || printer.previous_token_wrapped();
      last_tag_token.has_wrapped_attrs = wrapped;
    }
    return parser_token;
  };
  Beautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {
    var parser_token = {
      text: raw_token.text,
      type: "TK_CONTENT"
    };
    if (last_tag_token.custom_beautifier_name) {
      this._print_custom_beatifier_text(printer, raw_token, last_tag_token);
    } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {
      printer.add_raw_token(raw_token);
    } else {
      printer.traverse_whitespace(raw_token);
      printer.print_token(raw_token);
    }
    return parser_token;
  };
  Beautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {
    var local = this;
    if (raw_token.text !== "") {
      var text = raw_token.text, _beautifier, script_indent_level = 1, pre = "", post = "";
      if (last_tag_token.custom_beautifier_name === "javascript" && typeof this._js_beautify === "function") {
        _beautifier = this._js_beautify;
      } else if (last_tag_token.custom_beautifier_name === "css" && typeof this._css_beautify === "function") {
        _beautifier = this._css_beautify;
      } else if (last_tag_token.custom_beautifier_name === "html") {
        _beautifier = function(html_source, options) {
          var beautifier = new Beautifier(html_source, options, local._js_beautify, local._css_beautify);
          return beautifier.beautify();
        };
      }
      if (this._options.indent_scripts === "keep") {
        script_indent_level = 0;
      } else if (this._options.indent_scripts === "separate") {
        script_indent_level = -printer.indent_level;
      }
      var indentation = printer.get_full_indent(script_indent_level);
      text = text.replace(/\n[ \t]*$/, "");
      if (last_tag_token.custom_beautifier_name !== "html" && text[0] === "<" && text.match(/^(<!--|<!\[CDATA\[)/)) {
        var matched = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(text);
        if (!matched) {
          printer.add_raw_token(raw_token);
          return;
        }
        pre = indentation + matched[1] + "\n";
        text = matched[4];
        if (matched[5]) {
          post = indentation + matched[5];
        }
        text = text.replace(/\n[ \t]*$/, "");
        if (matched[2] || matched[3].indexOf("\n") !== -1) {
          matched = matched[3].match(/[ \t]+$/);
          if (matched) {
            raw_token.whitespace_before = matched[0];
          }
        }
      }
      if (text) {
        if (_beautifier) {
          var Child_options = function() {
            this.eol = "\n";
          };
          Child_options.prototype = this._options.raw_options;
          var child_options = new Child_options;
          text = _beautifier(indentation + text, child_options);
        } else {
          var white = raw_token.whitespace_before;
          if (white) {
            text = text.replace(new RegExp("\n(" + white + ")?", "g"), "\n");
          }
          text = indentation + text.replace(/\n/g, "\n" + indentation);
        }
      }
      if (pre) {
        if (!text) {
          text = pre + post;
        } else {
          text = pre + text + "\n" + post;
        }
      }
      printer.print_newline(false);
      if (text) {
        raw_token.text = text;
        raw_token.whitespace_before = "";
        raw_token.newlines = 0;
        printer.add_raw_token(raw_token);
        printer.print_newline(true);
      }
    }
  };
  Beautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token, tokens) {
    var parser_token = this._get_tag_open_token(raw_token);
    if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) && !last_tag_token.is_empty_element && raw_token.type === TOKEN.TAG_OPEN && !parser_token.is_start_tag) {
      printer.add_raw_token(raw_token);
      parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
    } else {
      printer.traverse_whitespace(raw_token);
      this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);
      if (!parser_token.is_inline_element) {
        printer.set_wrap_point();
      }
      printer.print_token(raw_token);
    }
    if (parser_token.is_start_tag && this._is_wrap_attributes_force) {
      var peek_index = 0;
      var peek_token;
      do {
        peek_token = tokens.peek(peek_index);
        if (peek_token.type === TOKEN.ATTRIBUTE) {
          parser_token.attr_count += 1;
        }
        peek_index += 1;
      } while (peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);
    }
    if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {
      parser_token.alignment_size = raw_token.text.length + 1;
    }
    if (!parser_token.tag_complete && !parser_token.is_unformatted) {
      printer.alignment_size = parser_token.alignment_size;
    }
    return parser_token;
  };
  var TagOpenParserToken = function(parent, raw_token) {
    this.parent = parent || null;
    this.text = "";
    this.type = "TK_TAG_OPEN";
    this.tag_name = "";
    this.is_inline_element = false;
    this.is_unformatted = false;
    this.is_content_unformatted = false;
    this.is_empty_element = false;
    this.is_start_tag = false;
    this.is_end_tag = false;
    this.indent_content = false;
    this.multiline_content = false;
    this.custom_beautifier_name = null;
    this.start_tag_token = null;
    this.attr_count = 0;
    this.has_wrapped_attrs = false;
    this.alignment_size = 0;
    this.tag_complete = false;
    this.tag_start_char = "";
    this.tag_check = "";
    if (!raw_token) {
      this.tag_complete = true;
    } else {
      var tag_check_match;
      this.tag_start_char = raw_token.text[0];
      this.text = raw_token.text;
      if (this.tag_start_char === "<") {
        tag_check_match = raw_token.text.match(/^<([^\s>]*)/);
        this.tag_check = tag_check_match ? tag_check_match[1] : "";
      } else {
        tag_check_match = raw_token.text.match(/^{{~?(?:[\^]|#\*?)?([^\s}]+)/);
        this.tag_check = tag_check_match ? tag_check_match[1] : "";
        if ((raw_token.text.startsWith("{{#>") || raw_token.text.startsWith("{{~#>")) && this.tag_check[0] === ">") {
          if (this.tag_check === ">" && raw_token.next !== null) {
            this.tag_check = raw_token.next.text.split(" ")[0];
          } else {
            this.tag_check = raw_token.text.split(">")[1];
          }
        }
      }
      this.tag_check = this.tag_check.toLowerCase();
      if (raw_token.type === TOKEN.COMMENT) {
        this.tag_complete = true;
      }
      this.is_start_tag = this.tag_check.charAt(0) !== "/";
      this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;
      this.is_end_tag = !this.is_start_tag || raw_token.closed && raw_token.closed.text === "/>";
      var handlebar_starts = 2;
      if (this.tag_start_char === "{" && this.text.length >= 3) {
        if (this.text.charAt(2) === "~") {
          handlebar_starts = 3;
        }
      }
      this.is_end_tag = this.is_end_tag || this.tag_start_char === "{" && (this.text.length < 3 || /[^#\^]/.test(this.text.charAt(handlebar_starts)));
    }
  };
  Beautifier.prototype._get_tag_open_token = function(raw_token) {
    var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);
    parser_token.alignment_size = this._options.wrap_attributes_indent_size;
    parser_token.is_end_tag = parser_token.is_end_tag || in_array(parser_token.tag_check, this._options.void_elements);
    parser_token.is_empty_element = parser_token.tag_complete || parser_token.is_start_tag && parser_token.is_end_tag;
    parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);
    parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);
    parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || this._options.inline_custom_elements && parser_token.tag_name.includes("-") || parser_token.tag_start_char === "{";
    return parser_token;
  };
  Beautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {
    if (!parser_token.is_empty_element) {
      if (parser_token.is_end_tag) {
        parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
      } else {
        if (this._do_optional_end_element(parser_token)) {
          if (!parser_token.is_inline_element) {
            printer.print_newline(false);
          }
        }
        this._tag_stack.record_tag(parser_token);
        if ((parser_token.tag_name === "script" || parser_token.tag_name === "style") && !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {
          parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);
        }
      }
    }
    if (in_array(parser_token.tag_check, this._options.extra_liners)) {
      printer.print_newline(false);
      if (!printer._output.just_added_blankline()) {
        printer.print_newline(true);
      }
    }
    if (parser_token.is_empty_element) {
      if (parser_token.tag_start_char === "{" && parser_token.tag_check === "else") {
        this._tag_stack.indent_to_tag(["if", "unless", "each"]);
        parser_token.indent_content = true;
        var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);
        if (!foundIfOnCurrentLine) {
          printer.print_newline(false);
        }
      }
      if (parser_token.tag_name === "!--" && last_token.type === TOKEN.TAG_CLOSE && last_tag_token.is_end_tag && parser_token.text.indexOf("\n") === -1) {
      } else {
        if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {
          printer.print_newline(false);
        }
        this._calcluate_parent_multiline(printer, parser_token);
      }
    } else if (parser_token.is_end_tag) {
      var do_end_expand = false;
      do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;
      do_end_expand = do_end_expand || !parser_token.is_inline_element && !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) && !(last_token.type === TOKEN.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) && last_token.type !== "TK_CONTENT";
      if (parser_token.is_content_unformatted || parser_token.is_unformatted) {
        do_end_expand = false;
      }
      if (do_end_expand) {
        printer.print_newline(false);
      }
    } else {
      parser_token.indent_content = !parser_token.custom_beautifier_name;
      if (parser_token.tag_start_char === "<") {
        if (parser_token.tag_name === "html") {
          parser_token.indent_content = this._options.indent_inner_html;
        } else if (parser_token.tag_name === "head") {
          parser_token.indent_content = this._options.indent_head_inner_html;
        } else if (parser_token.tag_name === "body") {
          parser_token.indent_content = this._options.indent_body_inner_html;
        }
      }
      if (!(parser_token.is_inline_element || parser_token.is_unformatted) && (last_token.type !== "TK_CONTENT" || parser_token.is_content_unformatted)) {
        printer.print_newline(false);
      }
      this._calcluate_parent_multiline(printer, parser_token);
    }
  };
  Beautifier.prototype._calcluate_parent_multiline = function(printer, parser_token) {
    if (parser_token.parent && printer._output.just_added_newline() && !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {
      parser_token.parent.multiline_content = true;
    }
  };
  var p_closers = ["address", "article", "aside", "blockquote", "details", "div", "dl", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hr", "main", "menu", "nav", "ol", "p", "pre", "section", "table", "ul"];
  var p_parent_excludes = ["a", "audio", "del", "ins", "map", "noscript", "video"];
  Beautifier.prototype._do_optional_end_element = function(parser_token) {
    var result = null;
    if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {
      return;
    }
    if (parser_token.tag_name === "body") {
      result = result || this._tag_stack.try_pop("head");
    } else if (parser_token.tag_name === "li") {
      result = result || this._tag_stack.try_pop("li", ["ol", "ul", "menu"]);
    } else if (parser_token.tag_name === "dd" || parser_token.tag_name === "dt") {
      result = result || this._tag_stack.try_pop("dt", ["dl"]);
      result = result || this._tag_stack.try_pop("dd", ["dl"]);
    } else if (parser_token.parent.tag_name === "p" && p_closers.indexOf(parser_token.tag_name) !== -1) {
      var p_parent = parser_token.parent.parent;
      if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {
        result = result || this._tag_stack.try_pop("p");
      }
    } else if (parser_token.tag_name === "rp" || parser_token.tag_name === "rt") {
      result = result || this._tag_stack.try_pop("rt", ["ruby", "rtc"]);
      result = result || this._tag_stack.try_pop("rp", ["ruby", "rtc"]);
    } else if (parser_token.tag_name === "optgroup") {
      result = result || this._tag_stack.try_pop("optgroup", ["select"]);
    } else if (parser_token.tag_name === "option") {
      result = result || this._tag_stack.try_pop("option", ["select", "datalist", "optgroup"]);
    } else if (parser_token.tag_name === "colgroup") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
    } else if (parser_token.tag_name === "thead") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
      result = result || this._tag_stack.try_pop("colgroup", ["table"]);
    } else if (parser_token.tag_name === "tbody" || parser_token.tag_name === "tfoot") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
      result = result || this._tag_stack.try_pop("colgroup", ["table"]);
      result = result || this._tag_stack.try_pop("thead", ["table"]);
      result = result || this._tag_stack.try_pop("tbody", ["table"]);
    } else if (parser_token.tag_name === "tr") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
      result = result || this._tag_stack.try_pop("colgroup", ["table"]);
      result = result || this._tag_stack.try_pop("tr", ["table", "thead", "tbody", "tfoot"]);
    } else if (parser_token.tag_name === "th" || parser_token.tag_name === "td") {
      result = result || this._tag_stack.try_pop("td", ["table", "thead", "tbody", "tfoot", "tr"]);
      result = result || this._tag_stack.try_pop("th", ["table", "thead", "tbody", "tfoot", "tr"]);
    }
    parser_token.parent = this._tag_stack.get_parser_token();
    return result;
  };
  exports.Beautifier = Beautifier;
});

// ../sisventa/node_modules/js-beautify/js/src/html/index.js
var require_html = __commonJS((exports, module) => {
  var style_html = function(html_source, options, js_beautify, css_beautify) {
    var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);
    return beautifier.beautify();
  };
  var Beautifier = require_beautifier3().Beautifier;
  var Options = require_options4().Options;
  module.exports = style_html;
  module.exports.defaultOptions = function() {
    return new Options;
  };
});

// ../sisventa/node_modules/js-beautify/js/src/index.js
var require_src = __commonJS((exports, module) => {
  var style_html = function(html_source, options, js, css) {
    js = js || js_beautify;
    css = css || css_beautify;
    return html_beautify(html_source, options, js, css);
  };
  var js_beautify = require_javascript();
  var css_beautify = require_css();
  var html_beautify = require_html();
  style_html.defaultOptions = html_beautify.defaultOptions;
  exports.js = js_beautify;
  exports.css = css_beautify;
  exports.html = style_html;
});

// ../sisventa/node_modules/js-beautify/js/index.js
var require_js = __commonJS((exports, module) => {
  var get_beautify = function(js_beautify, css_beautify, html_beautify) {
    var beautify = function(src, config2) {
      return js_beautify.js_beautify(src, config2);
    };
    beautify.js = js_beautify.js_beautify;
    beautify.css = css_beautify.css_beautify;
    beautify.html = html_beautify.html_beautify;
    beautify.js_beautify = js_beautify.js_beautify;
    beautify.css_beautify = css_beautify.css_beautify;
    beautify.html_beautify = html_beautify.html_beautify;
    return beautify;
  };
  if (typeof define === "function" && define.amd) {
    define([
      "./lib/beautify",
      "./lib/beautify-css",
      "./lib/beautify-html"
    ], function(js_beautify, css_beautify, html_beautify) {
      return get_beautify(js_beautify, css_beautify, html_beautify);
    });
  } else {
    (function(mod) {
      var beautifier = require_src();
      beautifier.js_beautify = beautifier.js;
      beautifier.css_beautify = beautifier.css;
      beautifier.html_beautify = beautifier.html;
      mod.exports = get_beautify(beautifier, beautifier, beautifier);
    })(module);
  }
});

// ../sisventa/node_modules/property-expr/index.js
var require_property_expr = __commonJS((exports, module) => {
  var Cache = function(maxSize) {
    this._maxSize = maxSize;
    this.clear();
  };
  var normalizePath = function(path) {
    return pathCache.get(path) || pathCache.set(path, split(path).map(function(part) {
      return part.replace(CLEAN_QUOTES_REGEX, "$2");
    }));
  };
  var split = function(path) {
    return path.match(SPLIT_REGEX) || [""];
  };
  var forEach = function(parts, iter, thisArg) {
    var len = parts.length, part, idx, isArray, isBracket;
    for (idx = 0;idx < len; idx++) {
      part = parts[idx];
      if (part) {
        if (shouldBeQuoted(part)) {
          part = '"' + part + '"';
        }
        isBracket = isQuoted(part);
        isArray = !isBracket && /^\d+$/.test(part);
        iter.call(thisArg, part, isBracket, isArray, idx, parts);
      }
    }
  };
  var isQuoted = function(str) {
    return typeof str === "string" && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
  };
  var hasLeadingNumber = function(part) {
    return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
  };
  var hasSpecialChars = function(part) {
    return SPEC_CHAR_REGEX.test(part);
  };
  var shouldBeQuoted = function(part) {
    return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
  };
  Cache.prototype.clear = function() {
    this._size = 0;
    this._values = Object.create(null);
  };
  Cache.prototype.get = function(key) {
    return this._values[key];
  };
  Cache.prototype.set = function(key, value27) {
    this._size >= this._maxSize && this.clear();
    if (!(key in this._values))
      this._size++;
    return this._values[key] = value27;
  };
  var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g;
  var DIGIT_REGEX = /^\d+$/;
  var LEAD_DIGIT_REGEX = /^\d/;
  var SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g;
  var CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/;
  var MAX_CACHE_SIZE = 512;
  var pathCache = new Cache(MAX_CACHE_SIZE);
  var setCache = new Cache(MAX_CACHE_SIZE);
  var getCache = new Cache(MAX_CACHE_SIZE);
  module.exports = {
    Cache,
    split,
    normalizePath,
    setter: function(path) {
      var parts = normalizePath(path);
      return setCache.get(path) || setCache.set(path, function setter(obj, value27) {
        var index = 0;
        var len = parts.length;
        var data = obj;
        while (index < len - 1) {
          var part = parts[index];
          if (part === "__proto__" || part === "constructor" || part === "prototype") {
            return obj;
          }
          data = data[parts[index++]];
        }
        data[parts[index]] = value27;
      });
    },
    getter: function(path, safe) {
      var parts = normalizePath(path);
      return getCache.get(path) || getCache.set(path, function getter(data) {
        var index = 0, len = parts.length;
        while (index < len) {
          if (data != null || !safe)
            data = data[parts[index++]];
          else
            return;
        }
        return data;
      });
    },
    join: function(segments) {
      return segments.reduce(function(path, part) {
        return path + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path ? "." : "") + part);
      }, "");
    },
    forEach: function(path, cb, thisArg) {
      forEach(Array.isArray(path) ? path : split(path), cb, thisArg);
    }
  };
});

// ../sisventa/node_modules/tiny-case/index.js
var require_tiny_case = __commonJS((exports, module) => {
  var reWords = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['\u2019](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['\u2019](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g;
  var words = (str) => str.match(reWords) || [];
  var upperFirst = (str) => str[0].toUpperCase() + str.slice(1);
  var join2 = (str, d3) => words(str).join(d3).toLowerCase();
  var camelCase = (str) => words(str).reduce((acc, next) => `${acc}${!acc ? next.toLowerCase() : next[0].toUpperCase() + next.slice(1).toLowerCase()}`, "");
  var pascalCase = (str) => upperFirst(camelCase(str));
  var snakeCase = (str) => join2(str, "_");
  var kebabCase = (str) => join2(str, "-");
  var sentenceCase = (str) => upperFirst(join2(str, " "));
  var titleCase = (str) => words(str).map(upperFirst).join(" ");
  module.exports = {
    words,
    upperFirst,
    camelCase,
    pascalCase,
    snakeCase,
    kebabCase,
    sentenceCase,
    titleCase
  };
});

// ../sisventa/node_modules/toposort/index.js
var require_toposort = __commonJS((exports, module) => {
  var toposort = function(nodes, edges) {
    var cursor = nodes.length, sorted = new Array(cursor), visited3 = {}, i = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
    edges.forEach(function(edge) {
      if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
        throw new Error("Unknown node. There is an unknown node in the supplied edges.");
      }
    });
    while (i--) {
      if (!visited3[i])
        visit(nodes[i], i, new Set);
    }
    return sorted;
    function visit(node3, i2, predecessors) {
      if (predecessors.has(node3)) {
        var nodeRep;
        try {
          nodeRep = ", node was:" + JSON.stringify(node3);
        } catch (e4) {
          nodeRep = "";
        }
        throw new Error("Cyclic dependency" + nodeRep);
      }
      if (!nodesHash.has(node3)) {
        throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node3));
      }
      if (visited3[i2])
        return;
      visited3[i2] = true;
      var outgoing = outgoingEdges.get(node3) || new Set;
      outgoing = Array.from(outgoing);
      if (i2 = outgoing.length) {
        predecessors.add(node3);
        do {
          var child = outgoing[--i2];
          visit(child, nodesHash.get(child), predecessors);
        } while (i2);
        predecessors.delete(node3);
      }
      sorted[--cursor] = node3;
    }
  };
  var uniqueNodes = function(arr) {
    var res = new Set;
    for (var i = 0, len = arr.length;i < len; i++) {
      var edge = arr[i];
      res.add(edge[0]);
      res.add(edge[1]);
    }
    return Array.from(res);
  };
  var makeOutgoingEdges = function(arr) {
    var edges = new Map;
    for (var i = 0, len = arr.length;i < len; i++) {
      var edge = arr[i];
      if (!edges.has(edge[0]))
        edges.set(edge[0], new Set);
      if (!edges.has(edge[1]))
        edges.set(edge[1], new Set);
      edges.get(edge[0]).add(edge[1]);
    }
    return edges;
  };
  var makeNodesHash = function(arr) {
    var res = new Map;
    for (var i = 0, len = arr.length;i < len; i++) {
      res.set(arr[i], i);
    }
    return res;
  };
  module.exports = function(edges) {
    return toposort(uniqueNodes(edges), edges);
  };
  module.exports.array = toposort;
});

// ../sisventa/prisma/client/runtime/library.js
var require_library = __commonJS((exports, module) => {
  var Vo = function(e4) {
    return typeof e4 == "function" ? e4 : (t4) => t4.$extends(e4);
  };
  var Uo = function(e4) {
    return e4;
  };
  var Ko = function(...e4) {
    return (t4) => t4;
  };
  var Wo = function(e4) {
    return e4.substring(0, 1).toLowerCase() + e4.substring(1);
  };
  var di = function(e4, t4) {
    return t4 ? `${t4}.${e4}` : e4;
  };
  var Xu = function(e4) {
    let t4 = (0, zr.default)(e4), r2 = Object.assign((...n4) => (t4.log = r2.log, n4.length !== 0 && zt.push([e4, ...n4]), zt.length > Zu && zt.shift(), t4("", ...n4)), t4);
    return r2;
  };
  var ss = function(e4 = 7500) {
    let t4 = zt.map((r2) => r2.map((n4) => typeof n4 == "string" ? n4 : JSON.stringify(n4)).join(" ")).join(`
`);
    return t4.length < e4 ? t4 : t4.slice(-e4);
  };
  var as = function() {
    zt.length = 0;
  };
  var q3 = function(e4, t4) {
    let r2 = new RegExp(`\\x1b\\[${t4}m`, "g"), n4 = `\x1B[${e4}m`, i = `\x1B[${t4}m`;
    return function(o4) {
      return !ec.enabled || o4 == null ? o4 : n4 + (~("" + o4).indexOf(i) ? o4.replace(r2, i + n4) : o4) + i;
    };
  };
  var Ei = function() {
    let e4 = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
    if (!(e4 && ds.default.existsSync(e4)) && process.arch === "ia32")
      throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)');
  };
  var Xr = function(e4, t4) {
    let r2 = t4 === "url";
    return e4.includes("windows") ? r2 ? "query_engine.dll.node" : `query_engine-${e4}.dll.node` : e4.includes("darwin") ? r2 ? `${Zr}.dylib.node` : `${Zr}-${e4}.dylib.node` : r2 ? `${Zr}.so.node` : `${Zr}-${e4}.so.node`;
  };
  var Te = function(e4) {
    return Object.assign(e4, { optional: () => rc(e4), and: (t4) => V2(e4, t4), or: (t4) => nc(e4, t4), select: (t4) => t4 === undefined ? ms(e4) : ms(t4, e4) });
  };
  var rc = function(e4) {
    return Te({ [Be]: () => ({ match: (t4) => {
      let r2 = {}, n4 = (i, o4) => {
        r2[i] = o4;
      };
      return t4 === undefined ? (Ze(e4).forEach((i) => n4(i, undefined)), { matched: true, selections: r2 }) : { matched: Ie(e4, t4, n4), selections: r2 };
    }, getSelectionKeys: () => Ze(e4), matcherType: "optional" }) });
  };
  var V2 = function(...e4) {
    return Te({ [Be]: () => ({ match: (t4) => {
      let r2 = {}, n4 = (i, o4) => {
        r2[i] = o4;
      };
      return { matched: e4.every((i) => Ie(i, t4, n4)), selections: r2 };
    }, getSelectionKeys: () => Yt(e4, Ze), matcherType: "and" }) });
  };
  var nc = function(...e4) {
    return Te({ [Be]: () => ({ match: (t4) => {
      let r2 = {}, n4 = (i, o4) => {
        r2[i] = o4;
      };
      return Yt(e4, Ze).forEach((i) => n4(i, undefined)), { matched: e4.some((i) => Ie(i, t4, n4)), selections: r2 };
    }, getSelectionKeys: () => Yt(e4, Ze), matcherType: "or" }) });
  };
  var k3 = function(e4) {
    return { [Be]: () => ({ match: (t4) => ({ matched: !!e4(t4) }) }) };
  };
  var ms = function(...e4) {
    let t4 = typeof e4[0] == "string" ? e4[0] : undefined, r2 = e4.length === 2 ? e4[1] : typeof e4[0] == "string" ? undefined : e4[0];
    return Te({ [Be]: () => ({ match: (n4) => {
      let i = { [t4 ?? tn]: n4 };
      return { matched: r2 === undefined || Ie(r2, n4, (o4, s5) => {
        i[o4] = s5;
      }), selections: i };
    }, getSelectionKeys: () => [t4 ?? tn].concat(r2 === undefined ? [] : Ze(r2)) }) });
  };
  var Me = function(e4) {
    return typeof e4 == "number";
  };
  var dt = function(e4) {
    return typeof e4 == "string";
  };
  var ze = function(e4) {
    return typeof e4 == "bigint";
  };
  var Mt = function(e4) {
    return new _i(e4, Ti);
  };
  var er = function(e4) {
    return (0, Es.default)(e4, e4, { fallback: ce });
  };
  var tr = function(e4, ...t4) {
    ac.warn() && console.warn(`${sc.warn} ${e4}`, ...t4);
  };
  async function Cs() {
    let e4 = on.default.platform(), t4 = process.arch;
    if (e4 === "freebsd") {
      let s5 = await sn("freebsd-version");
      if (s5 && s5.trim().length > 0) {
        let l5 = /^(\d+)\.?/.exec(s5);
        if (l5)
          return { platform: "freebsd", targetDistro: `freebsd${l5[1]}`, arch: t4 };
      }
    }
    if (e4 !== "linux")
      return { platform: e4, arch: t4 };
    let r2 = await pc(), n4 = await xc(), i = mc({ arch: t4, archFromUname: n4, familyDistro: r2.familyDistro }), { libssl: o4 } = await fc(i);
    return { platform: "linux", libssl: o4, arch: t4, archFromUname: n4, ...r2 };
  }
  var cc = function(e4) {
    let t4 = /^ID="?([^"\n]*)"?$/im, r2 = /^ID_LIKE="?([^"\n]*)"?$/im, n4 = t4.exec(e4), i = n4 && n4[1] && n4[1].toLowerCase() || "", o4 = r2.exec(e4), s5 = o4 && o4[1] && o4[1].toLowerCase() || "", a3 = Mt({ id: i, idLike: s5 }).with({ id: "alpine" }, ({ id: l5 }) => ({ targetDistro: "musl", familyDistro: l5, originalDistro: l5 })).with({ id: "raspbian" }, ({ id: l5 }) => ({ targetDistro: "arm", familyDistro: "debian", originalDistro: l5 })).with({ id: "nixos" }, ({ id: l5 }) => ({ targetDistro: "nixos", originalDistro: l5, familyDistro: "nixos" })).with({ id: "debian" }, { id: "ubuntu" }, ({ id: l5 }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l5 })).with({ id: "rhel" }, { id: "centos" }, { id: "fedora" }, ({ id: l5 }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l5 })).when(({ idLike: l5 }) => l5.includes("debian") || l5.includes("ubuntu"), ({ id: l5 }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l5 })).when(({ idLike: l5 }) => i === "arch" || l5.includes("arch"), ({ id: l5 }) => ({ targetDistro: "debian", familyDistro: "arch", originalDistro: l5 })).when(({ idLike: l5 }) => l5.includes("centos") || l5.includes("fedora") || l5.includes("rhel") || l5.includes("suse"), ({ id: l5 }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l5 })).otherwise(({ id: l5 }) => ({ targetDistro: undefined, familyDistro: undefined, originalDistro: l5 }));
    return me(`Found distro info:
${JSON.stringify(a3, null, 2)}`), a3;
  };
  async function pc() {
    let e4 = "/etc/os-release";
    try {
      let t4 = await Mi.default.readFile(e4, { encoding: "utf-8" });
      return cc(t4);
    } catch {
      return { targetDistro: undefined, familyDistro: undefined, originalDistro: undefined };
    }
  }
  var dc = function(e4) {
    let t4 = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e4);
    if (t4) {
      let r2 = `${t4[1]}.x`;
      return As(r2);
    }
  };
  var Ps = function(e4) {
    let t4 = /libssl\.so\.(\d)(\.\d)?/.exec(e4);
    if (t4) {
      let r2 = `${t4[1]}${t4[2] ?? ".0"}.x`;
      return As(r2);
    }
  };
  var As = function(e4) {
    let t4 = (() => {
      if (Ms(e4))
        return e4;
      let r2 = e4.split(".");
      return r2[1] = "0", r2.join(".");
    })();
    if (uc.includes(t4))
      return t4;
  };
  var mc = function(e4) {
    return Mt(e4).with({ familyDistro: "musl" }, () => (me('Trying platform-specific paths for "alpine"'), ["/lib"])).with({ familyDistro: "debian" }, ({ archFromUname: t4 }) => (me('Trying platform-specific paths for "debian" (and "ubuntu")'), [`/usr/lib/${t4}-linux-gnu`, `/lib/${t4}-linux-gnu`])).with({ familyDistro: "rhel" }, () => (me('Trying platform-specific paths for "rhel"'), ["/lib64", "/usr/lib64"])).otherwise(({ familyDistro: t4, arch: r2, archFromUname: n4 }) => (me(`Don't know any platform-specific paths for "${t4}" on ${r2} (${n4})`), []));
  };
  async function fc(e4) {
    let t4 = 'grep -v "libssl.so.0"', r2 = await vs(e4);
    if (r2) {
      me(`Found libssl.so file using platform-specific paths: ${r2}`);
      let o4 = Ps(r2);
      if (me(`The parsed libssl version is: ${o4}`), o4)
        return { libssl: o4, strategy: "libssl-specific-path" };
    }
    me('Falling back to "ldconfig" and other generic paths');
    let n4 = await sn(`ldconfig -p | sed "s/.*=>s*//" | sed "s|.*/||" | grep libssl | sort | ${t4}`);
    if (n4 || (n4 = await vs(["/lib64", "/usr/lib64", "/lib"])), n4) {
      me(`Found libssl.so file using "ldconfig" or other generic paths: ${n4}`);
      let o4 = Ps(n4);
      if (me(`The parsed libssl version is: ${o4}`), o4)
        return { libssl: o4, strategy: "ldconfig" };
    }
    let i = await sn("openssl version -v");
    if (i) {
      me(`Found openssl binary with version: ${i}`);
      let o4 = dc(i);
      if (me(`The parsed openssl version is: ${o4}`), o4)
        return { libssl: o4, strategy: "openssl-binary" };
    }
    return me("Couldn't find any version of libssl or OpenSSL in the system"), {};
  }
  async function vs(e4) {
    for (let t4 of e4) {
      let r2 = await gc(t4);
      if (r2)
        return r2;
    }
  }
  async function gc(e4) {
    try {
      return (await Mi.default.readdir(e4)).find((r2) => r2.startsWith("libssl.so.") && !r2.startsWith("libssl.so.0"));
    } catch (t4) {
      if (t4.code === "ENOENT")
        return;
      throw t4;
    }
  }
  async function ft() {
    let { binaryTarget: e4 } = await Rs();
    return e4;
  }
  var yc = function(e4) {
    return e4.binaryTarget !== undefined;
  };
  async function Si() {
    let { memoized: e4, ...t4 } = await Rs();
    return t4;
  }
  async function Rs() {
    if (yc(nn))
      return Promise.resolve({ ...nn, memoized: true });
    let e4 = await Cs(), t4 = hc(e4);
    return nn = { ...e4, binaryTarget: t4 }, { ...nn, memoized: false };
  }
  var hc = function(e4) {
    let { platform: t4, arch: r2, archFromUname: n4, libssl: i, targetDistro: o4, familyDistro: s5, originalDistro: a3 } = e4;
    t4 === "linux" && !["x64", "arm64"].includes(r2) && tr(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures. If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n4}".`);
    let l5 = "1.1.x";
    if (t4 === "linux" && i === undefined) {
      let c4 = Mt({ familyDistro: s5 }).with({ familyDistro: "debian" }, () => "Please manually install OpenSSL via `apt-get update -y && apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(() => "Please manually install OpenSSL and try installing Prisma again.");
      tr(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l5}".
${c4}`);
    }
    let u3 = "debian";
    if (t4 === "linux" && o4 === undefined && tr(`Prisma doesn't know which engines to download for the Linux distro "${a3}". Falling back to Prisma engines built "${u3}".
Please report your experience by creating an issue at ${er("https://github.com/prisma/prisma/issues")} so we can add your distro to the list of known supported distros.`), t4 === "darwin" && r2 === "arm64")
      return "darwin-arm64";
    if (t4 === "darwin")
      return "darwin";
    if (t4 === "win32")
      return "windows";
    if (t4 === "freebsd")
      return o4;
    if (t4 === "openbsd")
      return "openbsd";
    if (t4 === "netbsd")
      return "netbsd";
    if (t4 === "linux" && o4 === "nixos")
      return "linux-nixos";
    if (t4 === "linux" && r2 === "arm64")
      return `${o4 === "musl" ? "linux-musl-arm64" : "linux-arm64"}-openssl-${i || l5}`;
    if (t4 === "linux" && r2 === "arm")
      return `linux-arm-openssl-${i || l5}`;
    if (t4 === "linux" && o4 === "musl") {
      let c4 = "linux-musl";
      return !i || Ms(i) ? c4 : `${c4}-openssl-${i}`;
    }
    return t4 === "linux" && o4 && i ? `${o4}-openssl-${i}` : (t4 !== "linux" && tr(`Prisma detected unknown OS "${t4}" and may not work as expected. Defaulting to "linux".`), i ? `${u3}-openssl-${i}` : o4 ? `${o4}-openssl-${l5}` : `${u3}-openssl-${l5}`);
  };
  async function bc(e4) {
    try {
      return await e4();
    } catch {
      return;
    }
  }
  var sn = function(e4) {
    return bc(async () => {
      let t4 = await lc(e4);
      return me(`Command "${e4}" successfully returned "${t4.stdout}"`), t4.stdout;
    });
  };
  async function xc() {
    return typeof on.default.machine == "function" ? on.default.machine() : (await sn("uname -m"))?.trim();
  }
  var Ms = function(e4) {
    return e4.startsWith("1.");
  };
  var ks = function(e4) {
    let t4 = e4.ignoreProcessEnv ? {} : process.env, r2 = (n4) => n4.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(o4, s5) {
      let a3 = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s5);
      if (!a3)
        return o4;
      let l5 = a3[1], u3, c4;
      if (l5 === "\\")
        c4 = a3[0], u3 = c4.replace("\\$", "$");
      else {
        let p3 = a3[2];
        c4 = a3[0].substring(l5.length), u3 = Object.hasOwnProperty.call(t4, p3) ? t4[p3] : e4.parsed[p3] || "", u3 = r2(u3);
      }
      return o4.replace(c4, u3);
    }, n4) ?? n4;
    for (let n4 in e4.parsed) {
      let i = Object.hasOwnProperty.call(t4, n4) ? t4[n4] : e4.parsed[n4];
      e4.parsed[n4] = r2(i);
    }
    for (let n4 in e4.parsed)
      t4[n4] = e4.parsed[n4];
    return e4;
  };
  var rr = function({ rootEnvPath: e4, schemaEnvPath: t4 }, r2 = { conflictCheck: "none" }) {
    let n4 = Fs(e4);
    r2.conflictCheck !== "none" && Mc(n4, t4, r2.conflictCheck);
    let i = null;
    return Os(n4?.path, t4) || (i = Fs(t4)), !n4 && !i && Di("No Environment variables loaded"), i?.dotenvResult.error ? console.error(ve(de("Schema Env Error: ")) + i.dotenvResult.error) : { message: [n4?.message, i?.message].filter(Boolean).join(`
`), parsed: { ...n4?.dotenvResult?.parsed, ...i?.dotenvResult?.parsed } };
  };
  var Mc = function(e4, t4, r2) {
    let n4 = e4?.dotenvResult.parsed, i = !Os(e4?.path, t4);
    if (n4 && t4 && i && un.default.existsSync(t4)) {
      let o4 = ki.default.parse(un.default.readFileSync(t4)), s5 = [];
      for (let a3 in o4)
        n4[a3] === o4[a3] && s5.push(a3);
      if (s5.length > 0) {
        let a3 = Dt.default.relative(process.cwd(), e4.path), l5 = Dt.default.relative(process.cwd(), t4);
        if (r2 === "error") {
          let u3 = `There is a conflict between env var${s5.length > 1 ? "s" : ""} in ${ce(a3)} and ${ce(l5)}
Conflicting env vars:
${s5.map((c4) => `  ${de(c4)}`).join(`
`)}

We suggest to move the contents of ${ce(l5)} to ${ce(a3)} to consolidate your env vars.
`;
          throw new Error(u3);
        } else if (r2 === "warn") {
          let u3 = `Conflict for env var${s5.length > 1 ? "s" : ""} ${s5.map((c4) => de(c4)).join(", ")} in ${ce(a3)} and ${ce(l5)}
Env vars from ${ce(l5)} overwrite the ones from ${ce(a3)}
      `;
          console.warn(`${Re("warn(prisma)")} ${u3}`);
        }
      }
    }
  };
  var Fs = function(e4) {
    if (Sc(e4)) {
      Di(`Environment variables loaded from ${e4}`);
      let t4 = ki.default.config({ path: e4, debug: process.env.DOTENV_CONFIG_DEBUG ? true : undefined });
      return { dotenvResult: ks(t4), message: He(`Environment variables loaded from ${Dt.default.relative(process.cwd(), e4)}`), path: e4 };
    } else
      Di(`Environment variables not found at ${e4}`);
    return null;
  };
  var Os = function(e4, t4) {
    return e4 && t4 && Dt.default.resolve(e4) === Dt.default.resolve(t4);
  };
  var Sc = function(e4) {
    return !!(e4 && un.default.existsSync(e4));
  };
  var nr = function(e4) {
    let t4 = Ic();
    return t4 || (e4?.config.engineType === "library" ? "library" : e4?.config.engineType === "binary" ? "binary" : Ns);
  };
  var Ic = function() {
    let e4 = process.env.PRISMA_CLIENT_ENGINE_TYPE;
    return e4 === "library" ? "library" : e4 === "binary" ? "binary" : undefined;
  };
  var Vs = function() {
    return j.default.join(__dirname, "../");
  };
  var Ni = function(e4) {
    if (process.platform === "win32")
      return;
    let t4 = Oi.default.statSync(e4), r2 = t4.mode | 64 | 8 | 1;
    if (t4.mode === r2) {
      Us(`Execution permissions of ${e4} are fine`);
      return;
    }
    let n4 = r2.toString(8).slice(-3);
    Us(`Have to call chmodPlusX on ${e4}`), Oi.default.chmodSync(e4, n4);
  };
  var Li = function(e4) {
    let t4 = e4.e, r2 = (a3) => `Prisma cannot find the required \`${a3}\` system library in your system`, n4 = t4.message.includes("cannot open shared object file"), i = `Please refer to the documentation about Prisma's system requirements: ${er("https://pris.ly/d/system-requirements")}`, o4 = `Unable to require(\`${He(e4.id)}\`).`, s5 = Mt({ message: t4.message, code: t4.code }).with({ code: "ENOENT" }, () => "File does not exist.").when(({ message: a3 }) => n4 && a3.includes("libz"), () => `${r2("libz")}. Please install it and try again.`).when(({ message: a3 }) => n4 && a3.includes("libgcc_s"), () => `${r2("libgcc_s")}. Please install it and try again.`).when(({ message: a3 }) => n4 && a3.includes("libssl"), () => {
      let a3 = e4.platformInfo.libssl ? `openssl-${e4.platformInfo.libssl}` : "openssl";
      return `${r2("libssl")}. Please install ${a3} and try again.`;
    }).when(({ message: a3 }) => a3.includes("GLIBC"), () => `Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`).when(({ message: a3 }) => e4.platformInfo.platform === "linux" && a3.includes("symbol not found"), () => `The Prisma engines are not compatible with your system ${e4.platformInfo.originalDistro} on (${e4.platformInfo.archFromUname}) which uses the \`${e4.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`).otherwise(() => `The Prisma engines do not seem to be compatible with your system. ${i}`);
    return `${o4}
${s5}

Details: ${t4.message}`;
  };
  var $i = function(e4) {
    return ir.default.sep === ir.default.posix.sep ? e4 : e4.split(ir.default.sep).join(ir.default.posix.sep);
  };
  var Bi = function(e4) {
    return String(new ji(e4));
  };
  var Nc = function(e4) {
    let t4;
    if (e4.length > 0) {
      let r2 = e4.find((n4) => n4.fromEnvVar !== null);
      r2 ? t4 = `env("${r2.fromEnvVar}")` : t4 = e4.map((n4) => n4.native ? "native" : n4.value);
    } else
      t4 = undefined;
    return t4;
  };
  var Lc = function(e4) {
    let t4 = Object.keys(e4).reduce((r2, n4) => Math.max(r2, n4.length), 0);
    return Object.entries(e4).map(([r2, n4]) => `${r2.padEnd(t4)} = ${$c(n4)}`).join(`
`);
  };
  var $c = function(e4) {
    return JSON.parse(JSON.stringify(e4, (t4, r2) => Array.isArray(r2) ? `[${r2.map((n4) => JSON.stringify(n4)).join(", ")}]` : JSON.stringify(r2)));
  };
  var qc = function(...e4) {
    console.log(...e4);
  };
  var Vi = function(e4, ...t4) {
    Gs.warn() && console.warn(`${or.warn} ${e4}`, ...t4);
  };
  var jc = function(e4, ...t4) {
    console.info(`${or.info} ${e4}`, ...t4);
  };
  var Bc = function(e4, ...t4) {
    console.error(`${or.error} ${e4}`, ...t4);
  };
  var Vc = function(e4, ...t4) {
    console.log(`${or.query} ${e4}`, ...t4);
  };
  var pn = function(e4, t4) {
    if (!e4)
      throw new Error(`${t4}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`);
  };
  var gt = function(e4, t4) {
    throw new Error(t4);
  };
  var Ki = function(e4, t4) {
    return Object.prototype.hasOwnProperty.call(e4, t4);
  };
  var kt = function(e4, t4) {
    let r2 = {};
    for (let n4 of Object.keys(e4))
      r2[n4] = t4(e4[n4], n4);
    return r2;
  };
  var Gi = function(e4, t4) {
    if (e4.length === 0)
      return;
    let r2 = e4[0];
    for (let n4 = 1;n4 < e4.length; n4++)
      t4(r2, e4[n4]) < 0 && (r2 = e4[n4]);
    return r2;
  };
  var v3 = function(e4, t4) {
    Object.defineProperty(e4, "name", { value: t4, configurable: true });
  };
  var lr = function(e4) {
    let t4;
    return { get() {
      return t4 || (t4 = { value: e4() }), t4.value;
    } };
  };
  var Zs = function(e4, t4) {
    let r2 = lr(() => Kc(t4));
    Object.defineProperty(e4, "dmmf", { get: () => r2.get() });
  };
  var Kc = function(e4) {
    return { datamodel: { models: Ji(e4.models), enums: Ji(e4.enums), types: Ji(e4.types) } };
  };
  var Ji = function(e4) {
    return Object.entries(e4).map(([t4, r2]) => ({ name: t4, ...r2 }));
  };
  var zi = function(e4, t4) {
    Object.defineProperty(e4, "name", { value: t4, configurable: true });
  };
  var mr = function(e4) {
    return { ok: false, error: e4, map() {
      return mr(e4);
    }, flatMap() {
      return mr(e4);
    } };
  };
  var yt = function(e4, t4) {
    return async (...r2) => {
      try {
        return await t4(...r2);
      } catch (n4) {
        let i = e4.registerNewError(n4);
        return mr({ kind: "GenericJs", id: i });
      }
    };
  };
  var Hc = function(e4, t4) {
    return (...r2) => {
      try {
        return t4(...r2);
      } catch (n4) {
        let i = e4.registerNewError(n4);
        return mr({ kind: "GenericJs", id: i });
      }
    };
  };
  var Xs = function(e4, t4 = ",", r2 = "", n4 = "") {
    if (e4.length === 0)
      throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
    return new fe([r2, ...Array(e4.length - 1).fill(t4), n4], e4);
  };
  var Xi = function(e4) {
    return new fe([e4], []);
  };
  var eo = function(e4, ...t4) {
    return new fe(e4, t4);
  };
  var fr = function(e4) {
    return { getKeys() {
      return Object.keys(e4);
    }, getPropertyValue(t4) {
      return e4[t4];
    } };
  };
  var pe = function(e4, t4) {
    return { getKeys() {
      return [e4];
    }, getPropertyValue() {
      return t4();
    } };
  };
  var ht = function(e4) {
    let t4 = new ke;
    return { getKeys() {
      return e4.getKeys();
    }, getPropertyValue(r2) {
      return t4.getOrCreate(r2, () => e4.getPropertyValue(r2));
    }, getPropertyDescriptor(r2) {
      return e4.getPropertyDescriptor?.(r2);
    } };
  };
  var hn = function(e4) {
    let t4 = new Set(e4);
    return { getOwnPropertyDescriptor: () => yn, has: (r2, n4) => t4.has(n4), set: (r2, n4, i) => t4.add(n4) && Reflect.set(r2, n4, i), ownKeys: () => [...t4] };
  };
  var Fe = function(e4, t4) {
    let r2 = Wc(t4), n4 = new Set, i = new Proxy(e4, { get(o4, s5) {
      if (n4.has(s5))
        return o4[s5];
      let a3 = r2.get(s5);
      return a3 ? a3.getPropertyValue(s5) : o4[s5];
    }, has(o4, s5) {
      if (n4.has(s5))
        return true;
      let a3 = r2.get(s5);
      return a3 ? a3.has?.(s5) ?? true : Reflect.has(o4, s5);
    }, ownKeys(o4) {
      let s5 = ra(Reflect.ownKeys(o4), r2), a3 = ra(Array.from(r2.keys()), r2);
      return [...new Set([...s5, ...a3, ...n4])];
    }, set(o4, s5, a3) {
      return r2.get(s5)?.getPropertyDescriptor?.(s5)?.writable === false ? false : (n4.add(s5), Reflect.set(o4, s5, a3));
    }, getOwnPropertyDescriptor(o4, s5) {
      let a3 = Reflect.getOwnPropertyDescriptor(o4, s5);
      if (a3 && !a3.configurable)
        return a3;
      let l5 = r2.get(s5);
      return l5 ? l5.getPropertyDescriptor ? { ...yn, ...l5?.getPropertyDescriptor(s5) } : yn : a3;
    }, defineProperty(o4, s5, a3) {
      return n4.add(s5), Reflect.defineProperty(o4, s5, a3);
    } });
    return i[ta] = function(o4, s5, a3 = na.inspect) {
      let l5 = { ...this };
      return delete l5[ta], a3(l5, s5);
    }, i;
  };
  var Wc = function(e4) {
    let t4 = new Map;
    for (let r2 of e4) {
      let n4 = r2.getKeys();
      for (let i of n4)
        t4.set(i, r2);
    }
    return t4;
  };
  var ra = function(e4, t4) {
    return e4.filter((r2) => t4.get(r2)?.has?.(r2) ?? true);
  };
  var gr = function(e4) {
    return { getKeys() {
      return e4;
    }, has() {
      return false;
    }, getPropertyValue() {
    } };
  };
  var Nt = function(e4) {
    return e4 instanceof Date || Object.prototype.toString.call(e4) === "[object Date]";
  };
  var bn = function(e4) {
    return e4.toString() !== "Invalid Date";
  };
  var re = function(e4) {
    var t4, r2, n4, i = e4.length - 1, o4 = "", s5 = e4[0];
    if (i > 0) {
      for (o4 += s5, t4 = 1;t4 < i; t4++)
        n4 = e4[t4] + "", r2 = P - n4.length, r2 && (o4 += Xe(r2)), o4 += n4;
      s5 = e4[t4], n4 = s5 + "", r2 = P - n4.length, r2 && (o4 += Xe(r2));
    } else if (s5 === 0)
      return "0";
    for (;s5 % 10 === 0; )
      s5 /= 10;
    return o4 + s5;
  };
  var ge = function(e4, t4, r2) {
    if (e4 !== ~~e4 || e4 < t4 || e4 > r2)
      throw Error(tt + e4);
  };
  var yr = function(e4, t4, r2, n4) {
    var i, o4, s5, a3;
    for (o4 = e4[0];o4 >= 10; o4 /= 10)
      --t4;
    return --t4 < 0 ? (t4 += P, i = 0) : (i = Math.ceil((t4 + 1) / P), t4 %= P), o4 = G(10, P - t4), a3 = e4[i] % o4 | 0, n4 == null ? t4 < 3 ? (t4 == 0 ? a3 = a3 / 100 | 0 : t4 == 1 && (a3 = a3 / 10 | 0), s5 = r2 < 4 && a3 == 99999 || r2 > 3 && a3 == 49999 || a3 == 50000 || a3 == 0) : s5 = (r2 < 4 && a3 + 1 == o4 || r2 > 3 && a3 + 1 == o4 / 2) && (e4[i + 1] / o4 / 100 | 0) == G(10, t4 - 2) - 1 || (a3 == o4 / 2 || a3 == 0) && (e4[i + 1] / o4 / 100 | 0) == 0 : t4 < 4 ? (t4 == 0 ? a3 = a3 / 1000 | 0 : t4 == 1 ? a3 = a3 / 100 | 0 : t4 == 2 && (a3 = a3 / 10 | 0), s5 = (n4 || r2 < 4) && a3 == 9999 || !n4 && r2 > 3 && a3 == 4999) : s5 = ((n4 || r2 < 4) && a3 + 1 == o4 || !n4 && r2 > 3 && a3 + 1 == o4 / 2) && (e4[i + 1] / o4 / 1000 | 0) == G(10, t4 - 3) - 1, s5;
  };
  var xn = function(e4, t4, r2) {
    for (var n4, i = [0], o4, s5 = 0, a3 = e4.length;s5 < a3; ) {
      for (o4 = i.length;o4--; )
        i[o4] *= t4;
      for (i[0] += to.indexOf(e4.charAt(s5++)), n4 = 0;n4 < i.length; n4++)
        i[n4] > r2 - 1 && (i[n4 + 1] === undefined && (i[n4 + 1] = 0), i[n4 + 1] += i[n4] / r2 | 0, i[n4] %= r2);
    }
    return i.reverse();
  };
  var tp = function(e4, t4) {
    var r2, n4, i;
    if (t4.isZero())
      return t4;
    n4 = t4.d.length, n4 < 32 ? (r2 = Math.ceil(n4 / 3), i = (1 / _n(4, r2)).toString()) : (r2 = 16, i = "2.3283064365386962890625e-10"), e4.precision += r2, t4 = $t(e4, 1, t4.times(i), new e4(1));
    for (var o4 = r2;o4--; ) {
      var s5 = t4.times(t4);
      t4 = s5.times(s5).minus(s5).times(8).plus(1);
    }
    return e4.precision -= r2, t4;
  };
  var x = function(e4, t4, r2, n4) {
    var i, o4, s5, a3, l5, u3, c4, p3, d3, f = e4.constructor;
    e:
      if (t4 != null) {
        if (p3 = e4.d, !p3)
          return e4;
        for (i = 1, a3 = p3[0];a3 >= 10; a3 /= 10)
          i++;
        if (o4 = t4 - i, o4 < 0)
          o4 += P, s5 = t4, c4 = p3[d3 = 0], l5 = c4 / G(10, i - s5 - 1) % 10 | 0;
        else if (d3 = Math.ceil((o4 + 1) / P), a3 = p3.length, d3 >= a3)
          if (n4) {
            for (;a3++ <= d3; )
              p3.push(0);
            c4 = l5 = 0, i = 1, o4 %= P, s5 = o4 - P + 1;
          } else
            break e;
        else {
          for (c4 = a3 = p3[d3], i = 1;a3 >= 10; a3 /= 10)
            i++;
          o4 %= P, s5 = o4 - P + i, l5 = s5 < 0 ? 0 : c4 / G(10, i - s5 - 1) % 10 | 0;
        }
        if (n4 = n4 || t4 < 0 || p3[d3 + 1] !== undefined || (s5 < 0 ? c4 : c4 % G(10, i - s5 - 1)), u3 = r2 < 4 ? (l5 || n4) && (r2 == 0 || r2 == (e4.s < 0 ? 3 : 2)) : l5 > 5 || l5 == 5 && (r2 == 4 || n4 || r2 == 6 && (o4 > 0 ? s5 > 0 ? c4 / G(10, i - s5) : 0 : p3[d3 - 1]) % 10 & 1 || r2 == (e4.s < 0 ? 8 : 7)), t4 < 1 || !p3[0])
          return p3.length = 0, u3 ? (t4 -= e4.e + 1, p3[0] = G(10, (P - t4 % P) % P), e4.e = -t4 || 0) : p3[0] = e4.e = 0, e4;
        if (o4 == 0 ? (p3.length = d3, a3 = 1, d3--) : (p3.length = d3 + 1, a3 = G(10, P - o4), p3[d3] = s5 > 0 ? (c4 / G(10, i - s5) % G(10, s5) | 0) * a3 : 0), u3)
          for (;; )
            if (d3 == 0) {
              for (o4 = 1, s5 = p3[0];s5 >= 10; s5 /= 10)
                o4++;
              for (s5 = p3[0] += a3, a3 = 1;s5 >= 10; s5 /= 10)
                a3++;
              o4 != a3 && (e4.e++, p3[0] == Ce && (p3[0] = 1));
              break;
            } else {
              if (p3[d3] += a3, p3[d3] != Ce)
                break;
              p3[d3--] = 0, a3 = 1;
            }
        for (o4 = p3.length;p3[--o4] === 0; )
          p3.pop();
      }
    return T && (e4.e > f.maxE ? (e4.d = null, e4.e = NaN) : e4.e < f.minE && (e4.e = 0, e4.d = [0])), e4;
  };
  var Oe = function(e4, t4, r2) {
    if (!e4.isFinite())
      return ga(e4);
    var n4, i = e4.e, o4 = re(e4.d), s5 = o4.length;
    return t4 ? (r2 && (n4 = r2 - s5) > 0 ? o4 = o4.charAt(0) + "." + o4.slice(1) + Xe(n4) : s5 > 1 && (o4 = o4.charAt(0) + "." + o4.slice(1)), o4 = o4 + (e4.e < 0 ? "e" : "e+") + e4.e) : i < 0 ? (o4 = "0." + Xe(-i - 1) + o4, r2 && (n4 = r2 - s5) > 0 && (o4 += Xe(n4))) : i >= s5 ? (o4 += Xe(i + 1 - s5), r2 && (n4 = r2 - i - 1) > 0 && (o4 = o4 + "." + Xe(n4))) : ((n4 = i + 1) < s5 && (o4 = o4.slice(0, n4) + "." + o4.slice(n4)), r2 && (n4 = r2 - s5) > 0 && (i + 1 === s5 && (o4 += "."), o4 += Xe(n4))), o4;
  };
  var Tn = function(e4, t4) {
    var r2 = e4[0];
    for (t4 *= P;r2 >= 10; r2 /= 10)
      t4++;
    return t4;
  };
  var Pn = function(e4, t4, r2) {
    if (t4 > ep)
      throw T = true, r2 && (e4.precision = r2), Error(la);
    return x(new e4(wn), t4, 1, true);
  };
  var _e = function(e4, t4, r2) {
    if (t4 > no)
      throw Error(la);
    return x(new e4(En), t4, r2, true);
  };
  var da = function(e4) {
    var t4 = e4.length - 1, r2 = t4 * P + 1;
    if (t4 = e4[t4], t4) {
      for (;t4 % 10 == 0; t4 /= 10)
        r2--;
      for (t4 = e4[0];t4 >= 10; t4 /= 10)
        r2++;
    }
    return r2;
  };
  var Xe = function(e4) {
    for (var t4 = "";e4--; )
      t4 += "0";
    return t4;
  };
  var ma = function(e4, t4, r2, n4) {
    var i, o4 = new e4(1), s5 = Math.ceil(n4 / P + 4);
    for (T = false;; ) {
      if (r2 % 2 && (o4 = o4.times(t4), oa(o4.d, s5) && (i = true)), r2 = ae(r2 / 2), r2 === 0) {
        r2 = o4.d.length - 1, i && o4.d[r2] === 0 && ++o4.d[r2];
        break;
      }
      t4 = t4.times(t4), oa(t4.d, s5);
    }
    return T = true, o4;
  };
  var ia = function(e4) {
    return e4.d[e4.d.length - 1] & 1;
  };
  var fa = function(e4, t4, r2) {
    for (var n4, i = new e4(t4[0]), o4 = 0;++o4 < t4.length; )
      if (n4 = new e4(t4[o4]), n4.s)
        i[r2](n4) && (i = n4);
      else {
        i = n4;
        break;
      }
    return i;
  };
  var io = function(e4, t4) {
    var r2, n4, i, o4, s5, a3, l5, u3 = 0, c4 = 0, p3 = 0, d3 = e4.constructor, f = d3.rounding, h3 = d3.precision;
    if (!e4.d || !e4.d[0] || e4.e > 17)
      return new d3(e4.d ? e4.d[0] ? e4.s < 0 ? 0 : 1 / 0 : 1 : e4.s ? e4.s < 0 ? 0 : e4 : NaN);
    for (t4 == null ? (T = false, l5 = h3) : l5 = t4, a3 = new d3(0.03125);e4.e > -2; )
      e4 = e4.times(a3), p3 += 5;
    for (n4 = Math.log(G(2, p3)) / Math.LN10 * 2 + 5 | 0, l5 += n4, r2 = o4 = s5 = new d3(1), d3.precision = l5;; ) {
      if (o4 = x(o4.times(e4), l5, 1), r2 = r2.times(++c4), a3 = s5.plus(L3(o4, r2, l5, 1)), re(a3.d).slice(0, l5) === re(s5.d).slice(0, l5)) {
        for (i = p3;i--; )
          s5 = x(s5.times(s5), l5, 1);
        if (t4 == null)
          if (u3 < 3 && yr(s5.d, l5 - n4, f, u3))
            d3.precision = l5 += 10, r2 = o4 = a3 = new d3(1), c4 = 0, u3++;
          else
            return x(s5, d3.precision = h3, f, T = true);
        else
          return d3.precision = h3, s5;
      }
      s5 = a3;
    }
  };
  var et = function(e4, t4) {
    var r2, n4, i, o4, s5, a3, l5, u3, c4, p3, d3, f = 1, h3 = 10, g = e4, _ = g.d, A = g.constructor, R3 = A.rounding, E = A.precision;
    if (g.s < 0 || !_ || !_[0] || !g.e && _[0] == 1 && _.length == 1)
      return new A(_ && !_[0] ? -1 / 0 : g.s != 1 ? NaN : _ ? 0 : g);
    if (t4 == null ? (T = false, c4 = E) : c4 = t4, A.precision = c4 += h3, r2 = re(_), n4 = r2.charAt(0), Math.abs(o4 = g.e) < 1500000000000000) {
      for (;n4 < 7 && n4 != 1 || n4 == 1 && r2.charAt(1) > 3; )
        g = g.times(e4), r2 = re(g.d), n4 = r2.charAt(0), f++;
      o4 = g.e, n4 > 1 ? (g = new A("0." + r2), o4++) : g = new A(n4 + "." + r2.slice(1));
    } else
      return u3 = Pn(A, c4 + 2, E).times(o4 + ""), g = et(new A(n4 + "." + r2.slice(1)), c4 - h3).plus(u3), A.precision = E, t4 == null ? x(g, E, R3, T = true) : g;
    for (p3 = g, l5 = s5 = g = L3(g.minus(1), g.plus(1), c4, 1), d3 = x(g.times(g), c4, 1), i = 3;; ) {
      if (s5 = x(s5.times(d3), c4, 1), u3 = l5.plus(L3(s5, new A(i), c4, 1)), re(u3.d).slice(0, c4) === re(l5.d).slice(0, c4))
        if (l5 = l5.times(2), o4 !== 0 && (l5 = l5.plus(Pn(A, c4 + 2, E).times(o4 + ""))), l5 = L3(l5, new A(f), c4, 1), t4 == null)
          if (yr(l5.d, c4 - h3, R3, a3))
            A.precision = c4 += h3, u3 = s5 = g = L3(p3.minus(1), p3.plus(1), c4, 1), d3 = x(g.times(g), c4, 1), i = a3 = 1;
          else
            return x(l5, A.precision = E, R3, T = true);
        else
          return A.precision = E, l5;
      l5 = u3, i += 2;
    }
  };
  var ga = function(e4) {
    return String(e4.s * e4.s / 0);
  };
  var oo = function(e4, t4) {
    var r2, n4, i;
    for ((r2 = t4.indexOf(".")) > -1 && (t4 = t4.replace(".", "")), (n4 = t4.search(/e/i)) > 0 ? (r2 < 0 && (r2 = n4), r2 += +t4.slice(n4 + 1), t4 = t4.substring(0, n4)) : r2 < 0 && (r2 = t4.length), n4 = 0;t4.charCodeAt(n4) === 48; n4++)
      ;
    for (i = t4.length;t4.charCodeAt(i - 1) === 48; --i)
      ;
    if (t4 = t4.slice(n4, i), t4) {
      if (i -= n4, e4.e = r2 = r2 - n4 - 1, e4.d = [], n4 = (r2 + 1) % P, r2 < 0 && (n4 += P), n4 < i) {
        for (n4 && e4.d.push(+t4.slice(0, n4)), i -= P;n4 < i; )
          e4.d.push(+t4.slice(n4, n4 += P));
        t4 = t4.slice(n4), n4 = P - t4.length;
      } else
        n4 -= i;
      for (;n4--; )
        t4 += "0";
      e4.d.push(+t4), T && (e4.e > e4.constructor.maxE ? (e4.d = null, e4.e = NaN) : e4.e < e4.constructor.minE && (e4.e = 0, e4.d = [0]));
    } else
      e4.e = 0, e4.d = [0];
    return e4;
  };
  var rp = function(e4, t4) {
    var r2, n4, i, o4, s5, a3, l5, u3, c4;
    if (t4.indexOf("_") > -1) {
      if (t4 = t4.replace(/(\d)_(?=\d)/g, "$1"), pa.test(t4))
        return oo(e4, t4);
    } else if (t4 === "Infinity" || t4 === "NaN")
      return +t4 || (e4.s = NaN), e4.e = NaN, e4.d = null, e4;
    if (Yc.test(t4))
      r2 = 16, t4 = t4.toLowerCase();
    else if (zc.test(t4))
      r2 = 2;
    else if (Zc.test(t4))
      r2 = 8;
    else
      throw Error(tt + t4);
    for (o4 = t4.search(/p/i), o4 > 0 ? (l5 = +t4.slice(o4 + 1), t4 = t4.substring(2, o4)) : t4 = t4.slice(2), o4 = t4.indexOf("."), s5 = o4 >= 0, n4 = e4.constructor, s5 && (t4 = t4.replace(".", ""), a3 = t4.length, o4 = a3 - o4, i = ma(n4, new n4(r2), o4, o4 * 2)), u3 = xn(t4, r2, Ce), c4 = u3.length - 1, o4 = c4;u3[o4] === 0; --o4)
      u3.pop();
    return o4 < 0 ? new n4(e4.s * 0) : (e4.e = Tn(u3, c4), e4.d = u3, T = false, s5 && (e4 = L3(e4, i, a3 * 4)), l5 && (e4 = e4.times(Math.abs(l5) < 54 ? G(2, l5) : bt.pow(2, l5))), T = true, e4);
  };
  var np = function(e4, t4) {
    var r2, n4 = t4.d.length;
    if (n4 < 3)
      return t4.isZero() ? t4 : $t(e4, 2, t4, t4);
    r2 = 1.4 * Math.sqrt(n4), r2 = r2 > 16 ? 16 : r2 | 0, t4 = t4.times(1 / _n(5, r2)), t4 = $t(e4, 2, t4, t4);
    for (var i, o4 = new e4(5), s5 = new e4(16), a3 = new e4(20);r2--; )
      i = t4.times(t4), t4 = t4.times(o4.plus(i.times(s5.times(i).minus(a3))));
    return t4;
  };
  var $t = function(e4, t4, r2, n4, i) {
    var o4, s5, a3, l5, u3 = 1, c4 = e4.precision, p3 = Math.ceil(c4 / P);
    for (T = false, l5 = r2.times(r2), a3 = new e4(n4);; ) {
      if (s5 = L3(a3.times(l5), new e4(t4++ * t4++), c4, 1), a3 = i ? n4.plus(s5) : n4.minus(s5), n4 = L3(s5.times(l5), new e4(t4++ * t4++), c4, 1), s5 = a3.plus(n4), s5.d[p3] !== undefined) {
        for (o4 = p3;s5.d[o4] === a3.d[o4] && o4--; )
          ;
        if (o4 == -1)
          break;
      }
      o4 = a3, a3 = n4, n4 = s5, s5 = o4, u3++;
    }
    return T = true, s5.d.length = p3 + 1, s5;
  };
  var _n = function(e4, t4) {
    for (var r2 = e4;--t4; )
      r2 *= e4;
    return r2;
  };
  var ya = function(e4, t4) {
    var r2, n4 = t4.s < 0, i = _e(e4, e4.precision, 1), o4 = i.times(0.5);
    if (t4 = t4.abs(), t4.lte(o4))
      return Ue = n4 ? 4 : 1, t4;
    if (r2 = t4.divToInt(i), r2.isZero())
      Ue = n4 ? 3 : 2;
    else {
      if (t4 = t4.minus(r2.times(i)), t4.lte(o4))
        return Ue = ia(r2) ? n4 ? 2 : 3 : n4 ? 4 : 1, t4;
      Ue = ia(r2) ? n4 ? 1 : 4 : n4 ? 3 : 2;
    }
    return t4.minus(i).abs();
  };
  var so = function(e4, t4, r2, n4) {
    var i, o4, s5, a3, l5, u3, c4, p3, d3, f = e4.constructor, h3 = r2 !== undefined;
    if (h3 ? (ge(r2, 1, rt), n4 === undefined ? n4 = f.rounding : ge(n4, 0, 8)) : (r2 = f.precision, n4 = f.rounding), !e4.isFinite())
      c4 = ga(e4);
    else {
      for (c4 = Oe(e4), s5 = c4.indexOf("."), h3 ? (i = 2, t4 == 16 ? r2 = r2 * 4 - 3 : t4 == 8 && (r2 = r2 * 3 - 2)) : i = t4, s5 >= 0 && (c4 = c4.replace(".", ""), d3 = new f(1), d3.e = c4.length - s5, d3.d = xn(Oe(d3), 10, i), d3.e = d3.d.length), p3 = xn(c4, 10, i), o4 = l5 = p3.length;p3[--l5] == 0; )
        p3.pop();
      if (!p3[0])
        c4 = h3 ? "0p+0" : "0";
      else {
        if (s5 < 0 ? o4-- : (e4 = new f(e4), e4.d = p3, e4.e = o4, e4 = L3(e4, d3, r2, n4, 0, i), p3 = e4.d, o4 = e4.e, u3 = aa), s5 = p3[r2], a3 = i / 2, u3 = u3 || p3[r2 + 1] !== undefined, u3 = n4 < 4 ? (s5 !== undefined || u3) && (n4 === 0 || n4 === (e4.s < 0 ? 3 : 2)) : s5 > a3 || s5 === a3 && (n4 === 4 || u3 || n4 === 6 && p3[r2 - 1] & 1 || n4 === (e4.s < 0 ? 8 : 7)), p3.length = r2, u3)
          for (;++p3[--r2] > i - 1; )
            p3[r2] = 0, r2 || (++o4, p3.unshift(1));
        for (l5 = p3.length;!p3[l5 - 1]; --l5)
          ;
        for (s5 = 0, c4 = "";s5 < l5; s5++)
          c4 += to.charAt(p3[s5]);
        if (h3) {
          if (l5 > 1)
            if (t4 == 16 || t4 == 8) {
              for (s5 = t4 == 16 ? 4 : 3, --l5;l5 % s5; l5++)
                c4 += "0";
              for (p3 = xn(c4, i, t4), l5 = p3.length;!p3[l5 - 1]; --l5)
                ;
              for (s5 = 1, c4 = "1.";s5 < l5; s5++)
                c4 += to.charAt(p3[s5]);
            } else
              c4 = c4.charAt(0) + "." + c4.slice(1);
          c4 = c4 + (o4 < 0 ? "p" : "p+") + o4;
        } else if (o4 < 0) {
          for (;++o4; )
            c4 = "0" + c4;
          c4 = "0." + c4;
        } else if (++o4 > l5)
          for (o4 -= l5;o4--; )
            c4 += "0";
        else
          o4 < l5 && (c4 = c4.slice(0, o4) + "." + c4.slice(o4));
      }
      c4 = (t4 == 16 ? "0x" : t4 == 2 ? "0b" : t4 == 8 ? "0o" : "") + c4;
    }
    return e4.s < 0 ? "-" + c4 : c4;
  };
  var oa = function(e4, t4) {
    if (e4.length > t4)
      return e4.length = t4, true;
  };
  var ip = function(e4) {
    return new this(e4).abs();
  };
  var op = function(e4) {
    return new this(e4).acos();
  };
  var sp = function(e4) {
    return new this(e4).acosh();
  };
  var ap = function(e4, t4) {
    return new this(e4).plus(t4);
  };
  var lp = function(e4) {
    return new this(e4).asin();
  };
  var up = function(e4) {
    return new this(e4).asinh();
  };
  var cp = function(e4) {
    return new this(e4).atan();
  };
  var pp = function(e4) {
    return new this(e4).atanh();
  };
  var dp = function(e4, t4) {
    e4 = new this(e4), t4 = new this(t4);
    var r2, n4 = this.precision, i = this.rounding, o4 = n4 + 4;
    return !e4.s || !t4.s ? r2 = new this(NaN) : !e4.d && !t4.d ? (r2 = _e(this, o4, 1).times(t4.s > 0 ? 0.25 : 0.75), r2.s = e4.s) : !t4.d || e4.isZero() ? (r2 = t4.s < 0 ? _e(this, n4, i) : new this(0), r2.s = e4.s) : !e4.d || t4.isZero() ? (r2 = _e(this, o4, 1).times(0.5), r2.s = e4.s) : t4.s < 0 ? (this.precision = o4, this.rounding = 1, r2 = this.atan(L3(e4, t4, o4, 1)), t4 = _e(this, o4, 1), this.precision = n4, this.rounding = i, r2 = e4.s < 0 ? r2.minus(t4) : r2.plus(t4)) : r2 = this.atan(L3(e4, t4, o4, 1)), r2;
  };
  var mp = function(e4) {
    return new this(e4).cbrt();
  };
  var fp = function(e4) {
    return x(e4 = new this(e4), e4.e + 1, 2);
  };
  var gp = function(e4, t4, r2) {
    return new this(e4).clamp(t4, r2);
  };
  var yp = function(e4) {
    if (!e4 || typeof e4 != "object")
      throw Error(vn + "Object expected");
    var t4, r2, n4, i = e4.defaults === true, o4 = ["precision", 1, rt, "rounding", 0, 8, "toExpNeg", -Lt, 0, "toExpPos", 0, Lt, "maxE", 0, Lt, "minE", -Lt, 0, "modulo", 0, 9];
    for (t4 = 0;t4 < o4.length; t4 += 3)
      if (r2 = o4[t4], i && (this[r2] = ro[r2]), (n4 = e4[r2]) !== undefined)
        if (ae(n4) === n4 && n4 >= o4[t4 + 1] && n4 <= o4[t4 + 2])
          this[r2] = n4;
        else
          throw Error(tt + r2 + ": " + n4);
    if (r2 = "crypto", i && (this[r2] = ro[r2]), (n4 = e4[r2]) !== undefined)
      if (n4 === true || n4 === false || n4 === 0 || n4 === 1)
        if (n4)
          if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
            this[r2] = true;
          else
            throw Error(ua);
        else
          this[r2] = false;
      else
        throw Error(tt + r2 + ": " + n4);
    return this;
  };
  var hp = function(e4) {
    return new this(e4).cos();
  };
  var bp = function(e4) {
    return new this(e4).cosh();
  };
  var ha = function(e4) {
    var t4, r2, n4;
    function i(o4) {
      var s5, a3, l5, u3 = this;
      if (!(u3 instanceof i))
        return new i(o4);
      if (u3.constructor = i, sa(o4)) {
        u3.s = o4.s, T ? !o4.d || o4.e > i.maxE ? (u3.e = NaN, u3.d = null) : o4.e < i.minE ? (u3.e = 0, u3.d = [0]) : (u3.e = o4.e, u3.d = o4.d.slice()) : (u3.e = o4.e, u3.d = o4.d ? o4.d.slice() : o4.d);
        return;
      }
      if (l5 = typeof o4, l5 === "number") {
        if (o4 === 0) {
          u3.s = 1 / o4 < 0 ? -1 : 1, u3.e = 0, u3.d = [0];
          return;
        }
        if (o4 < 0 ? (o4 = -o4, u3.s = -1) : u3.s = 1, o4 === ~~o4 && o4 < 1e7) {
          for (s5 = 0, a3 = o4;a3 >= 10; a3 /= 10)
            s5++;
          T ? s5 > i.maxE ? (u3.e = NaN, u3.d = null) : s5 < i.minE ? (u3.e = 0, u3.d = [0]) : (u3.e = s5, u3.d = [o4]) : (u3.e = s5, u3.d = [o4]);
          return;
        } else if (o4 * 0 !== 0) {
          o4 || (u3.s = NaN), u3.e = NaN, u3.d = null;
          return;
        }
        return oo(u3, o4.toString());
      } else if (l5 !== "string")
        throw Error(tt + o4);
      return (a3 = o4.charCodeAt(0)) === 45 ? (o4 = o4.slice(1), u3.s = -1) : (a3 === 43 && (o4 = o4.slice(1)), u3.s = 1), pa.test(o4) ? oo(u3, o4) : rp(u3, o4);
    }
    if (i.prototype = m, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = yp, i.clone = ha, i.isDecimal = sa, i.abs = ip, i.acos = op, i.acosh = sp, i.add = ap, i.asin = lp, i.asinh = up, i.atan = cp, i.atanh = pp, i.atan2 = dp, i.cbrt = mp, i.ceil = fp, i.clamp = gp, i.cos = hp, i.cosh = bp, i.div = xp, i.exp = wp, i.floor = Ep, i.hypot = Pp, i.ln = vp, i.log = Tp, i.log10 = Cp, i.log2 = _p, i.max = Ap, i.min = Rp, i.mod = Mp, i.mul = Sp, i.pow = Ip, i.random = Dp, i.round = kp, i.sign = Fp, i.sin = Op, i.sinh = Np, i.sqrt = Lp, i.sub = $p, i.sum = qp, i.tan = jp, i.tanh = Bp, i.trunc = Vp, e4 === undefined && (e4 = {}), e4 && e4.defaults !== true)
      for (n4 = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t4 = 0;t4 < n4.length; )
        e4.hasOwnProperty(r2 = n4[t4++]) || (e4[r2] = this[r2]);
    return i.config(e4), i;
  };
  var xp = function(e4, t4) {
    return new this(e4).div(t4);
  };
  var wp = function(e4) {
    return new this(e4).exp();
  };
  var Ep = function(e4) {
    return x(e4 = new this(e4), e4.e + 1, 3);
  };
  var Pp = function() {
    var e4, t4, r2 = new this(0);
    for (T = false, e4 = 0;e4 < arguments.length; )
      if (t4 = new this(arguments[e4++]), t4.d)
        r2.d && (r2 = r2.plus(t4.times(t4)));
      else {
        if (t4.s)
          return T = true, new this(1 / 0);
        r2 = t4;
      }
    return T = true, r2.sqrt();
  };
  var sa = function(e4) {
    return e4 instanceof bt || e4 && e4.toStringTag === ca || false;
  };
  var vp = function(e4) {
    return new this(e4).ln();
  };
  var Tp = function(e4, t4) {
    return new this(e4).log(t4);
  };
  var _p = function(e4) {
    return new this(e4).log(2);
  };
  var Cp = function(e4) {
    return new this(e4).log(10);
  };
  var Ap = function() {
    return fa(this, arguments, "lt");
  };
  var Rp = function() {
    return fa(this, arguments, "gt");
  };
  var Mp = function(e4, t4) {
    return new this(e4).mod(t4);
  };
  var Sp = function(e4, t4) {
    return new this(e4).mul(t4);
  };
  var Ip = function(e4, t4) {
    return new this(e4).pow(t4);
  };
  var Dp = function(e4) {
    var t4, r2, n4, i, o4 = 0, s5 = new this(1), a3 = [];
    if (e4 === undefined ? e4 = this.precision : ge(e4, 1, rt), n4 = Math.ceil(e4 / P), this.crypto)
      if (crypto.getRandomValues)
        for (t4 = crypto.getRandomValues(new Uint32Array(n4));o4 < n4; )
          i = t4[o4], i >= 4290000000 ? t4[o4] = crypto.getRandomValues(new Uint32Array(1))[0] : a3[o4++] = i % 1e7;
      else if (crypto.randomBytes) {
        for (t4 = crypto.randomBytes(n4 *= 4);o4 < n4; )
          i = t4[o4] + (t4[o4 + 1] << 8) + (t4[o4 + 2] << 16) + ((t4[o4 + 3] & 127) << 24), i >= 2140000000 ? crypto.randomBytes(4).copy(t4, o4) : (a3.push(i % 1e7), o4 += 4);
        o4 = n4 / 4;
      } else
        throw Error(ua);
    else
      for (;o4 < n4; )
        a3[o4++] = Math.random() * 1e7 | 0;
    for (n4 = a3[--o4], e4 %= P, n4 && e4 && (i = G(10, P - e4), a3[o4] = (n4 / i | 0) * i);a3[o4] === 0; o4--)
      a3.pop();
    if (o4 < 0)
      r2 = 0, a3 = [0];
    else {
      for (r2 = -1;a3[0] === 0; r2 -= P)
        a3.shift();
      for (n4 = 1, i = a3[0];i >= 10; i /= 10)
        n4++;
      n4 < P && (r2 -= P - n4);
    }
    return s5.e = r2, s5.d = a3, s5;
  };
  var kp = function(e4) {
    return x(e4 = new this(e4), e4.e + 1, this.rounding);
  };
  var Fp = function(e4) {
    return e4 = new this(e4), e4.d ? e4.d[0] ? e4.s : 0 * e4.s : e4.s || NaN;
  };
  var Op = function(e4) {
    return new this(e4).sin();
  };
  var Np = function(e4) {
    return new this(e4).sinh();
  };
  var Lp = function(e4) {
    return new this(e4).sqrt();
  };
  var $p = function(e4, t4) {
    return new this(e4).sub(t4);
  };
  var qp = function() {
    var e4 = 0, t4 = arguments, r2 = new this(t4[e4]);
    for (T = false;r2.s && ++e4 < t4.length; )
      r2 = r2.plus(t4[e4]);
    return T = true, x(r2, this.precision, this.rounding);
  };
  var jp = function(e4) {
    return new this(e4).tan();
  };
  var Bp = function(e4) {
    return new this(e4).tanh();
  };
  var Vp = function(e4) {
    return x(e4 = new this(e4), e4.e + 1, 1);
  };
  var qt = function(e4) {
    return bt.isDecimal(e4) ? true : e4 !== null && typeof e4 == "object" && typeof e4.s == "number" && typeof e4.e == "number" && typeof e4.toFixed == "function" && Array.isArray(e4.d);
  };
  var jt = function(e4) {
    return e4 instanceof hr;
  };
  var Sn = function(e4) {
    return new ao(wa(e4));
  };
  var wa = function(e4) {
    let t4 = new z;
    for (let [r2, n4] of Object.entries(e4)) {
      let i = new Mn(r2, Ea(n4));
      t4.addField(i);
    }
    return t4;
  };
  var Ea = function(e4) {
    if (typeof e4 == "string")
      return new Y(JSON.stringify(e4));
    if (typeof e4 == "number" || typeof e4 == "boolean")
      return new Y(String(e4));
    if (typeof e4 == "bigint")
      return new Y(`${e4}n`);
    if (e4 === null)
      return new Y("null");
    if (e4 === undefined)
      return new Y("undefined");
    if (qt(e4))
      return new Y(`new Prisma.Decimal("${e4.toFixed()}")`);
    if (e4 instanceof Uint8Array)
      return Buffer.isBuffer(e4) ? new Y(`Buffer.alloc(${e4.byteLength})`) : new Y(`new Uint8Array(${e4.byteLength})`);
    if (e4 instanceof Date) {
      let t4 = bn(e4) ? e4.toISOString() : "Invalid Date";
      return new Y(`new Date("${t4}")`);
    }
    return e4 instanceof De ? new Y(`Prisma.${e4._getName()}`) : jt(e4) ? new Y(`prisma.${Wo(e4.modelName)}.\$fields.${e4.name}`) : Array.isArray(e4) ? Kp(e4) : typeof e4 == "object" ? wa(e4) : new Y(Object.prototype.toString.call(e4));
  };
  var Kp = function(e4) {
    let t4 = new Vt;
    for (let r2 of e4)
      t4.addItem(Ea(r2));
    return t4;
  };
  var Pa = function(e4) {
    if (e4 === undefined)
      return "";
    let t4 = Sn(e4);
    return new Ot(0, { colors: Rn }).write(t4).toString();
  };
  var va = function(e4) {
    var t4 = e4.split(`
`);
    return t4.reduce(function(r2, n4) {
      var i = Jp(n4) || Wp(n4) || Zp(n4) || rd(n4) || ed(n4);
      return i && r2.push(i), r2;
    }, []);
  };
  var Jp = function(e4) {
    var t4 = Qp.exec(e4);
    if (!t4)
      return null;
    var r2 = t4[2] && t4[2].indexOf("native") === 0, n4 = t4[2] && t4[2].indexOf("eval") === 0, i = Gp.exec(t4[2]);
    return n4 && i != null && (t4[2] = i[1], t4[3] = i[2], t4[4] = i[3]), { file: r2 ? null : t4[2], methodName: t4[1] || br, arguments: r2 ? [t4[2]] : [], lineNumber: t4[3] ? +t4[3] : null, column: t4[4] ? +t4[4] : null };
  };
  var Wp = function(e4) {
    var t4 = Hp.exec(e4);
    return t4 ? { file: t4[2], methodName: t4[1] || br, arguments: [], lineNumber: +t4[3], column: t4[4] ? +t4[4] : null } : null;
  };
  var Zp = function(e4) {
    var t4 = zp.exec(e4);
    if (!t4)
      return null;
    var r2 = t4[3] && t4[3].indexOf(" > eval") > -1, n4 = Yp.exec(t4[3]);
    return r2 && n4 != null && (t4[3] = n4[1], t4[4] = n4[2], t4[5] = null), { file: t4[3], methodName: t4[1] || br, arguments: t4[2] ? t4[2].split(",") : [], lineNumber: t4[4] ? +t4[4] : null, column: t4[5] ? +t4[5] : null };
  };
  var ed = function(e4) {
    var t4 = Xp.exec(e4);
    return t4 ? { file: t4[3], methodName: t4[1] || br, arguments: [], lineNumber: +t4[4], column: t4[5] ? +t4[5] : null } : null;
  };
  var rd = function(e4) {
    var t4 = td.exec(e4);
    return t4 ? { file: t4[2], methodName: t4[1] || br, arguments: [], lineNumber: +t4[3], column: t4[4] ? +t4[4] : null } : null;
  };
  var it = function(e4) {
    return e4 === "minimal" ? new lo : new uo;
  };
  var Ut = function(e4 = {}) {
    let t4 = id(e4);
    return Object.entries(t4).reduce((n4, [i, o4]) => (Ta[i] !== undefined ? n4.select[i] = { select: o4 } : n4[i] = o4, n4), { select: {} });
  };
  var id = function(e4 = {}) {
    return typeof e4._count == "boolean" ? { ...e4, _count: { _all: e4._count } } : e4;
  };
  var In = function(e4 = {}) {
    return (t4) => (typeof e4._count == "boolean" && (t4._count = t4._count._all), t4);
  };
  var _a2 = function(e4, t4) {
    let r2 = In(e4);
    return t4({ action: "aggregate", unpacker: r2, argsMapper: Ut })(e4);
  };
  var od = function(e4 = {}) {
    let { select: t4, ...r2 } = e4;
    return typeof t4 == "object" ? Ut({ ...r2, _count: t4 }) : Ut({ ...r2, _count: { _all: true } });
  };
  var sd = function(e4 = {}) {
    return typeof e4.select == "object" ? (t4) => In(e4)(t4)._count : (t4) => In(e4)(t4)._count._all;
  };
  var Ca = function(e4, t4) {
    return t4({ action: "count", unpacker: sd(e4), argsMapper: od })(e4);
  };
  var ad = function(e4 = {}) {
    let t4 = Ut(e4);
    if (Array.isArray(t4.by))
      for (let r2 of t4.by)
        typeof r2 == "string" && (t4.select[r2] = true);
    else
      typeof t4.by == "string" && (t4.select[t4.by] = true);
    return t4;
  };
  var ld = function(e4 = {}) {
    return (t4) => (typeof e4?._count == "boolean" && t4.forEach((r2) => {
      r2._count = r2._count._all;
    }), t4);
  };
  var Aa = function(e4, t4) {
    return t4({ action: "groupBy", unpacker: ld(e4), argsMapper: ad })(e4);
  };
  var Ra = function(e4, t4, r2) {
    if (t4 === "aggregate")
      return (n4) => _a2(n4, r2);
    if (t4 === "count")
      return (n4) => Ca(n4, r2);
    if (t4 === "groupBy")
      return (n4) => Aa(n4, r2);
  };
  var Ma = function(e4, t4) {
    let r2 = t4.fields.filter((i) => !i.relationName), n4 = Qi(r2, (i) => i.name);
    return new Proxy({}, { get(i, o4) {
      if (o4 in i || typeof o4 == "symbol")
        return i[o4];
      let s5 = n4[o4];
      if (s5)
        return new hr(e4, o4, s5.type, s5.isList, s5.kind === "enum");
    }, ...hn(Object.keys(n4)) });
  };
  var ud = function(e4, t4) {
    return e4 === undefined || t4 === undefined ? [] : [...t4, "select", e4];
  };
  var cd = function(e4, t4, r2) {
    return t4 === undefined ? e4 ?? {} : Ia(t4, r2, e4 || true);
  };
  var po = function(e4, t4, r2, n4, i, o4) {
    let a3 = e4._runtimeDataModel.models[t4].fields.reduce((l5, u3) => ({ ...l5, [u3.name]: u3 }), {});
    return (l5) => {
      let u3 = it(e4._errorFormat), c4 = ud(n4, i), p3 = cd(l5, o4, c4), d3 = r2({ dataPath: c4, callsite: u3 })(p3), f = pd(e4, t4);
      return new Proxy(d3, { get(h3, g) {
        if (!f.includes(g))
          return h3[g];
        let A = [a3[g].type, r2, g], R3 = [c4, p3];
        return po(e4, ...A, ...R3);
      }, ...hn([...f, ...Object.getOwnPropertyNames(d3)]) });
    };
  };
  var pd = function(e4, t4) {
    return e4._runtimeDataModel.models[t4].fields.filter((r2) => r2.kind === "object").map((r2) => r2.name);
  };
  var Ae = function(e4, t4, r2, n4, i) {
    this.type = e4, this.content = t4, this.alias = r2, this.length = (n4 || "").length | 0, this.greedy = !!i;
  };
  var fd = function(e4) {
    return Da[e4] || dd;
  };
  var ka = function(e4) {
    return gd(e4, C.languages.javascript);
  };
  var gd = function(e4, t4) {
    return C.tokenize(e4, t4).map((n4) => Ae.stringify(n4)).join("");
  };
  var Oa = function(e4) {
    return (0, Fa.default)(e4);
  };
  var bd = function({ callsite: e4, message: t4, originalMethod: r2, isPanic: n4, callArguments: i }, o4) {
    let s5 = { functionName: `prisma.${r2}()`, message: t4, isPanic: n4 ?? false, callArguments: i };
    if (!e4 || typeof window < "u" || false)
      return s5;
    let a3 = e4.getLocation();
    if (!a3 || !a3.lineNumber || !a3.columnNumber)
      return s5;
    let l5 = Math.max(1, a3.lineNumber - 3), u3 = kn.read(a3.fileName)?.slice(l5, a3.lineNumber), c4 = u3?.lineAt(a3.lineNumber);
    if (u3 && c4) {
      let p3 = wd(c4), d3 = xd(c4);
      if (!d3)
        return s5;
      s5.functionName = `${d3.code})`, s5.location = a3, n4 || (u3 = u3.mapLineAt(a3.lineNumber, (h3) => h3.slice(0, d3.openingBraceIndex))), u3 = o4.highlightSource(u3);
      let f = String(u3.lastLineNumber).length;
      if (s5.contextLines = u3.mapLines((h3, g) => o4.gray(String(g).padStart(f)) + " " + h3).mapLines((h3) => o4.dim(h3)).prependSymbolAt(a3.lineNumber, o4.bold(o4.red("\u2192"))), i) {
        let h3 = p3 + f + 1;
        h3 += 2, s5.callArguments = (0, La.default)(i, h3).slice(h3);
      }
    }
    return s5;
  };
  var xd = function(e4) {
    let t4 = Object.keys(Ee.ModelAction).join("|"), n4 = new RegExp(String.raw`\.(${t4})\(`).exec(e4);
    if (n4) {
      let i = n4.index + n4[0].length, o4 = e4.lastIndexOf(" ", n4.index) + 1;
      return { code: e4.slice(o4, i), openingBraceIndex: i };
    }
    return null;
  };
  var wd = function(e4) {
    let t4 = 0;
    for (let r2 = 0;r2 < e4.length; r2++) {
      if (e4.charAt(r2) !== " ")
        return t4;
      t4++;
    }
    return t4;
  };
  var Ed = function({ functionName: e4, location: t4, message: r2, isPanic: n4, contextLines: i, callArguments: o4 }, s5) {
    let a3 = [""], l5 = t4 ? " in" : ":";
    if (n4 ? (a3.push(s5.red(`Oops, an unknown error occurred! This is ${s5.bold("on us")}, you did nothing wrong.`)), a3.push(s5.red(`It occurred in the ${s5.bold(`\`${e4}\``)} invocation${l5}`))) : a3.push(s5.red(`Invalid ${s5.bold(`\`${e4}\``)} invocation${l5}`)), t4 && a3.push(s5.underline(Pd(t4))), i) {
      a3.push("");
      let u3 = [i.toString()];
      o4 && (u3.push(o4), u3.push(s5.dim(")"))), a3.push(u3.join("")), o4 && a3.push("");
    } else
      a3.push(""), o4 && a3.push(o4), a3.push("");
    return a3.push(r2), a3.join(`
`);
  };
  var Pd = function(e4) {
    let t4 = [e4.fileName];
    return e4.lineNumber && t4.push(String(e4.lineNumber)), e4.columnNumber && t4.push(String(e4.columnNumber)), t4.join(":");
  };
  var Kt = function(e4) {
    let t4 = e4.showColors ? yd : hd, r2 = bd(e4, t4);
    return Ed(r2, t4);
  };
  var $a = function(e4, t4, r2, n4) {
    return e4 === Ee.ModelAction.findFirstOrThrow || e4 === Ee.ModelAction.findUniqueOrThrow ? vd(t4, r2, n4) : n4;
  };
  var vd = function(e4, t4, r2) {
    return async (n4) => {
      if ("rejectOnNotFound" in n4.args) {
        let o4 = Kt({ originalMethod: n4.clientMethod, callsite: n4.callsite, message: "'rejectOnNotFound' option is not supported" });
        throw new te(o4, { clientVersion: t4 });
      }
      return await r2(n4).catch((o4) => {
        throw o4 instanceof H3 && o4.code === "P2025" ? new Ve(`No ${e4} found`, t4) : o4;
      });
    };
  };
  var $e = function(e4) {
    return e4.replace(/^./, (t4) => t4.toLowerCase());
  };
  var mo = function(e4, t4) {
    let r2 = e4._extensions.getAllModelExtensions(t4) ?? {}, n4 = [Cd(e4, t4), Rd(e4, t4), fr(r2), pe("name", () => t4), pe("$name", () => t4), pe("$parent", () => e4._appliedParent)];
    return Fe({}, n4);
  };
  var Cd = function(e4, t4) {
    let r2 = $e(t4), n4 = Object.keys(Ee.ModelAction).concat("count");
    return { getKeys() {
      return n4;
    }, getPropertyValue(i) {
      let o4 = i, s5 = (l5) => e4._request(l5);
      s5 = $a(o4, t4, e4._clientVersion, s5);
      let a3 = (l5) => (u3) => {
        let c4 = it(e4._errorFormat);
        return e4._createPrismaPromise((p3) => {
          let d3 = { args: u3, dataPath: [], action: o4, model: t4, clientMethod: `${r2}.${i}`, jsModelName: r2, transaction: p3, callsite: c4 };
          return s5({ ...d3, ...l5 });
        });
      };
      return Td.includes(o4) ? po(e4, t4, a3) : Ad(i) ? Ra(e4, i, a3) : a3({});
    } };
  };
  var Ad = function(e4) {
    return _d.includes(e4);
  };
  var Rd = function(e4, t4) {
    return ht(pe("fields", () => {
      let r2 = e4._runtimeDataModel.models[t4];
      return Ma(t4, r2);
    }));
  };
  var qa = function(e4) {
    return e4.replace(/^./, (t4) => t4.toUpperCase());
  };
  var xr = function(e4) {
    let t4 = [Md(e4), pe(fo, () => e4), pe("$parent", () => e4._appliedParent)], r2 = e4._extensions.getAllClientExtensions();
    return r2 && t4.push(fr(r2)), Fe(e4, t4);
  };
  var Md = function(e4) {
    let t4 = Object.keys(e4._runtimeDataModel.models), r2 = t4.map($e), n4 = [...new Set(t4.concat(r2))];
    return ht({ getKeys() {
      return n4;
    }, getPropertyValue(i) {
      let o4 = qa(i);
      if (e4._runtimeDataModel.models[o4] !== undefined)
        return mo(e4, o4);
      if (e4._runtimeDataModel.models[i] !== undefined)
        return mo(e4, i);
    }, getPropertyDescriptor(i) {
      if (!r2.includes(i))
        return { enumerable: false };
    } });
  };
  var Fn = function(e4) {
    return e4[fo] ? e4[fo] : e4;
  };
  var ja = function(e4) {
    if (typeof e4 == "function")
      return e4(this);
    let t4 = Fn(this), r2 = Object.create(t4, { _extensions: { value: this._extensions.append(e4) }, _appliedParent: { value: this, configurable: true }, $use: { value: undefined }, $on: { value: undefined } });
    return xr(r2);
  };
  var Ba = function({ result: e4, modelName: t4, select: r2, extensions: n4 }) {
    let i = n4.getAllComputedFields(t4);
    if (!i)
      return e4;
    let o4 = [], s5 = [];
    for (let a3 of Object.values(i)) {
      if (r2) {
        if (!r2[a3.name])
          continue;
        let l5 = a3.needs.filter((u3) => !r2[u3]);
        l5.length > 0 && s5.push(gr(l5));
      }
      Sd(e4, a3.needs) && o4.push(Id(a3, Fe(e4, o4)));
    }
    return o4.length > 0 || s5.length > 0 ? Fe(e4, [...o4, ...s5]) : e4;
  };
  var Sd = function(e4, t4) {
    return t4.every((r2) => Ki(e4, r2));
  };
  var Id = function(e4, t4) {
    return ht(pe(e4.name, () => e4.compute(t4)));
  };
  var On = function({ visitor: e4, result: t4, args: r2, runtimeDataModel: n4, modelName: i }) {
    if (Array.isArray(t4)) {
      for (let s5 = 0;s5 < t4.length; s5++)
        t4[s5] = On({ result: t4[s5], args: r2, modelName: i, runtimeDataModel: n4, visitor: e4 });
      return t4;
    }
    let o4 = e4(t4, i, r2) ?? t4;
    return r2.include && Va({ includeOrSelect: r2.include, result: o4, parentModelName: i, runtimeDataModel: n4, visitor: e4 }), r2.select && Va({ includeOrSelect: r2.select, result: o4, parentModelName: i, runtimeDataModel: n4, visitor: e4 }), o4;
  };
  var Va = function({ includeOrSelect: e4, result: t4, parentModelName: r2, runtimeDataModel: n4, visitor: i }) {
    for (let [o4, s5] of Object.entries(e4)) {
      if (!s5 || t4[o4] == null)
        continue;
      let l5 = n4.models[r2].fields.find((c4) => c4.name === o4);
      if (!l5 || l5.kind !== "object" || !l5.relationName)
        continue;
      let u3 = typeof s5 == "object" ? s5 : {};
      t4[o4] = On({ visitor: i, result: t4[o4], args: u3, modelName: l5.type, runtimeDataModel: n4 });
    }
  };
  var Ua = function({ result: e4, modelName: t4, args: r2, extensions: n4, runtimeDataModel: i }) {
    return n4.isEmpty() || e4 == null || typeof e4 != "object" || !i.models[t4] ? e4 : On({ result: e4, args: r2 ?? {}, modelName: t4, runtimeDataModel: i, visitor: (s5, a3, l5) => Ba({ result: s5, modelName: $e(a3), select: l5.select, extensions: n4 }) });
  };
  var Ka = function(e4) {
    if (e4 instanceof fe)
      return Dd(e4);
    if (Array.isArray(e4)) {
      let r2 = [e4[0]];
      for (let n4 = 1;n4 < e4.length; n4++)
        r2[n4] = wr(e4[n4]);
      return r2;
    }
    let t4 = {};
    for (let r2 in e4)
      t4[r2] = wr(e4[r2]);
    return t4;
  };
  var Dd = function(e4) {
    return new fe(e4.strings, e4.values);
  };
  var wr = function(e4) {
    if (typeof e4 != "object" || e4 == null || e4 instanceof De || jt(e4))
      return e4;
    if (qt(e4))
      return new Ne(e4.toFixed());
    if (Nt(e4))
      return new Date(+e4);
    if (ArrayBuffer.isView(e4))
      return e4.slice(0);
    if (Array.isArray(e4)) {
      let t4 = e4.length, r2;
      for (r2 = Array(t4);t4--; )
        r2[t4] = wr(e4[t4]);
      return r2;
    }
    if (typeof e4 == "object") {
      let t4 = {};
      for (let r2 in e4)
        r2 === "__proto__" ? Object.defineProperty(t4, r2, { value: wr(e4[r2]), configurable: true, enumerable: true, writable: true }) : t4[r2] = wr(e4[r2]);
      return t4;
    }
    gt(e4, "Unknown value");
  };
  var Ga = function(e4, t4, r2, n4 = 0) {
    return e4._createPrismaPromise((i) => {
      let o4 = t4.customDataProxyFetch;
      return "transaction" in t4 && i !== undefined && (t4.transaction?.kind === "batch" && t4.transaction.lock.then(), t4.transaction = i), n4 === r2.length ? e4._executeRequest(t4) : r2[n4]({ model: t4.model, operation: t4.model ? t4.action : t4.clientMethod, args: Ka(t4.args ?? {}), __internalParams: t4, query: (s5, a3 = t4) => {
        let l5 = a3.customDataProxyFetch;
        return a3.customDataProxyFetch = za(o4, l5), a3.args = s5, Ga(e4, a3, r2, n4 + 1);
      } });
    });
  };
  var Ja = function(e4, t4) {
    let { jsModelName: r2, action: n4, clientMethod: i } = t4, o4 = r2 ? n4 : i;
    if (e4._extensions.isEmpty())
      return e4._executeRequest(t4);
    let s5 = e4._extensions.getAllQueryCallbacks(r2 ?? "$none", o4);
    return Ga(e4, t4, s5);
  };
  var Ha = function(e4) {
    return (t4) => {
      let r2 = { requests: t4 }, n4 = t4[0].extensions.getAllBatchQueryCallbacks();
      return n4.length ? Wa(r2, n4, 0, e4) : e4(r2);
    };
  };
  var Wa = function(e4, t4, r2, n4) {
    if (r2 === t4.length)
      return n4(e4);
    let i = e4.customDataProxyFetch, o4 = e4.requests[0].transaction;
    return t4[r2]({ args: { queries: e4.requests.map((s5) => ({ model: s5.modelName, operation: s5.action, args: s5.args })), transaction: o4 ? { isolationLevel: o4.kind === "batch" ? o4.isolationLevel : undefined } : undefined }, __internalParams: e4, query(s5, a3 = e4) {
      let l5 = a3.customDataProxyFetch;
      return a3.customDataProxyFetch = za(i, l5), Wa(a3, t4, r2 + 1, n4);
    } });
  };
  var za = function(e4 = Qa, t4 = Qa) {
    return (r2) => e4(t4(r2));
  };
  var Za = function(e4, t4, r2) {
    let n4 = $e(r2);
    return !t4.result || !(t4.result.$allModels || t4.result[n4]) ? e4 : kd({ ...e4, ...Ya(t4.name, e4, t4.result.$allModels), ...Ya(t4.name, e4, t4.result[n4]) });
  };
  var kd = function(e4) {
    let t4 = new ke, r2 = (n4, i) => t4.getOrCreate(n4, () => i.has(n4) ? [n4] : (i.add(n4), e4[n4] ? e4[n4].needs.flatMap((o4) => r2(o4, i)) : [n4]));
    return kt(e4, (n4) => ({ ...n4, needs: r2(n4.name, new Set) }));
  };
  var Ya = function(e4, t4, r2) {
    return r2 ? kt(r2, ({ needs: n4, compute: i }, o4) => ({ name: o4, needs: n4 ? Object.keys(n4).filter((s5) => n4[s5]) : [], compute: Fd(t4, o4, i) })) : {};
  };
  var Fd = function(e4, t4, r2) {
    let n4 = e4?.[t4]?.compute;
    return n4 ? (i) => r2({ ...i, [t4]: n4(i) }) : r2;
  };
  var Xa = function(e4, t4) {
    if (!t4)
      return e4;
    let r2 = { ...e4 };
    for (let n4 of Object.values(t4))
      if (e4[n4.name])
        for (let i of n4.needs)
          r2[i] = true;
    return r2;
  };
  var rl = function({ postinstall: e4, ciName: t4, clientVersion: r2 }) {
    if (el("checkPlatformCaching:postinstall", e4), el("checkPlatformCaching:ciName", t4), e4 === true && t4 && t4 in tl) {
      let n4 = `Prisma has detected that this project was built on ${t4}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${tl[t4]}-build`;
      throw console.error(n4), new O(n4, r2);
    }
  };
  var nl2 = function(e4, t4) {
    return e4 ? e4.datasources ? e4.datasources : e4.datasourceUrl ? { [t4[0]]: { url: e4.datasourceUrl } } : {} : {};
  };
  var $n = function() {
    return typeof Netlify == "object" ? "netlify" : typeof EdgeRuntime == "string" ? "edge-light" : globalThis.navigator?.userAgent === Od ? "workerd" : globalThis.Deno ? "deno" : globalThis.__lagon__ ? "lagon" : globalThis.process?.release?.name === Nd ? "node" : globalThis.Bun ? "bun" : globalThis.fastly ? "fastly" : "unknown";
  };
  var Er = function({ error: e4, user_facing_error: t4 }, r2) {
    return t4.error_code ? new H3(t4.message, { code: t4.error_code, clientVersion: r2, meta: t4.meta, batchRequestIdx: t4.batch_request_idx }) : new W(e4, { clientVersion: r2, batchRequestIdx: t4.batch_request_idx });
  };
  var qn = function(e4) {
    let { runtimeBinaryTarget: t4 } = e4;
    return `Add "${t4}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:

${Ld(e4)}`;
  };
  var Ld = function(e4) {
    let { generator: t4, generatorBinaryTargets: r2, runtimeBinaryTarget: n4 } = e4, i = { fromEnvVar: null, value: n4 }, o4 = [...r2, i];
    return Bi({ ...t4, binaryTargets: o4 });
  };
  var ot = function(e4) {
    let { runtimeBinaryTarget: t4 } = e4;
    return `Prisma Client could not locate the Query Engine for runtime "${t4}".`;
  };
  var st = function(e4) {
    let { searchedLocations: t4 } = e4;
    return `The following locations have been searched:
${[...new Set(t4)].map((i) => `  ${i}`).join(`
`)}`;
  };
  var il = function(e4) {
    let { runtimeBinaryTarget: t4 } = e4;
    return `${ot(e4)}

This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${t4}".
${qn(e4)}

${st(e4)}`;
  };
  var jn = function(e4) {
    return `We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${e4}`;
  };
  var Bn = function(e4) {
    let { errorStack: t4 } = e4;
    return t4?.match(/\/\.next|\/next@|\/next\//) ? `

We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.` : "";
  };
  var ol = function(e4) {
    let { queryEngineName: t4 } = e4;
    return `${ot(e4)}${Bn(e4)}

This is likely caused by a bundler that has not copied "${t4}" next to the resulting bundle.
Ensure that "${t4}" has been copied next to the bundle or in "${e4.expectedLocation}".

${jn("engine-not-found-bundler-investigation")}

${st(e4)}`;
  };
  var sl = function(e4) {
    let { runtimeBinaryTarget: t4, generatorBinaryTargets: r2 } = e4, n4 = r2.find((i) => i.native);
    return `${ot(e4)}

This happened because Prisma Client was generated for "${n4?.value ?? "unknown"}", but the actual deployment required "${t4}".
${qn(e4)}

${st(e4)}`;
  };
  var al = function(e4) {
    let { queryEngineName: t4 } = e4;
    return `${ot(e4)}${Bn(e4)}

This is likely caused by tooling that has not copied "${t4}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${t4}" has been copied to "${e4.expectedLocation}".

${jn("engine-not-found-tooling-investigation")}

${st(e4)}`;
  };
  async function ul(e4, t4) {
    let r2 = { binary: process.env.PRISMA_QUERY_ENGINE_BINARY, library: process.env.PRISMA_QUERY_ENGINE_LIBRARY }[e4] ?? t4.prismaPath;
    if (r2 !== undefined)
      return r2;
    let { enginePath: n4, searchedLocations: i } = await jd(e4, t4);
    if ($d("enginePath", n4), n4 !== undefined && e4 === "binary" && Ni(n4), n4 !== undefined)
      return t4.prismaPath = n4;
    let o4 = await ft(), s5 = t4.generator?.binaryTargets ?? [], a3 = s5.some((d3) => d3.native), l5 = !s5.some((d3) => d3.value === o4), u3 = __filename.match(qd()) === null, c4 = { searchedLocations: i, generatorBinaryTargets: s5, generator: t4.generator, runtimeBinaryTarget: o4, queryEngineName: cl(e4, o4), expectedLocation: Pr.default.relative(process.cwd(), t4.dirname), errorStack: new Error().stack }, p3;
    throw a3 && l5 ? p3 = sl(c4) : l5 ? p3 = il(c4) : u3 ? p3 = ol(c4) : p3 = al(c4), new O(p3, t4.clientVersion);
  }
  async function jd(engineType, config) {
    let binaryTarget = await ft(), searchedLocations = [], dirname = eval("__dirname"), searchLocations = [config.dirname, Pr.default.resolve(dirname, ".."), config.generator?.output?.value ?? dirname, Pr.default.resolve(dirname, "../../../.prisma/client"), "/tmp/prisma-engines", config.cwd];
    __filename.includes("resolveEnginePath") && searchLocations.push(Vs());
    for (let e4 of searchLocations) {
      let t4 = cl(engineType, binaryTarget), r2 = Pr.default.join(e4, t4);
      if (searchedLocations.push(e4), ll.default.existsSync(r2))
        return { enginePath: r2, searchedLocations };
    }
    return { enginePath: undefined, searchedLocations };
  }
  function cl(e4, t4) {
    return e4 === "library" ? Xr(t4, "fs") : `query-engine-${t4}${t4 === "windows" ? ".exe" : ""}`;
  }
  function Vn(e4, t4) {
    return { batch: e4, transaction: t4?.kind === "batch" ? { isolationLevel: t4.options.isolationLevel } : undefined };
  }
  function pl(e4) {
    return e4 ? e4.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (t4) => `${t4[0]}5`) : "";
  }
  function dl(e4) {
    return e4.split(`
`).map((t4) => t4.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "")).join(`
`);
  }
  function fl({ title: e4, user: t4 = "prisma", repo: r2 = "prisma", template: n4 = "bug_report.yml", body: i }) {
    return (0, ml.default)({ user: t4, repo: r2, template: n4, title: e4, body: i });
  }
  function gl({ version: e4, binaryTarget: t4, title: r2, description: n4, engineVersion: i, database: o4, query: s5 }) {
    let a3 = ss(6000 - (s5?.length ?? 0)), l5 = dl((0, go.default)(a3)), u3 = n4 ? `# Description
\`\`\`
${n4}
\`\`\`` : "", c4 = (0, go.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${t4?.padEnd(19)}|
| Prisma Client   | ${e4?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o4?.padEnd(19)}|

${u3}

## Logs
\`\`\`
${l5}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s5 ? pl(s5) : ""}
\`\`\`
`), p3 = fl({ title: r2, body: c4 });
    return `${r2}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${ce(p3)}

If you want the Prisma team to look into it, please open the link above \uD83D\uDE4F
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
  }
  function Un({ inlineDatasources: e4, overrideDatasources: t4, env: r2, clientVersion: n4 }) {
    let i, o4 = Object.keys(e4)[0], s5 = e4[o4]?.url, a3 = t4[o4]?.url;
    if (o4 === undefined ? i = undefined : a3 ? i = a3 : s5?.value ? i = s5.value : s5?.fromEnvVar && (i = r2[s5.fromEnvVar]), s5?.fromEnvVar !== undefined && i === undefined)
      throw new O(`error: Environment variable not found: ${s5.fromEnvVar}.`, n4);
    if (i === undefined)
      throw new O("error: Missing URL environment variable, value, or override.", n4);
    return i;
  }
  function I2(e4, t4) {
    return { ...e4, isRetryable: t4 };
  }
  async function Ud(e4) {
    let t4;
    try {
      t4 = await e4.text();
    } catch {
      return { type: "EmptyError" };
    }
    try {
      let r2 = JSON.parse(t4);
      if (typeof r2 == "string")
        switch (r2) {
          case "InternalDataProxyError":
            return { type: "DataProxyError", body: r2 };
          default:
            return { type: "UnknownTextError", body: r2 };
        }
      if (typeof r2 == "object" && r2 !== null) {
        if ("is_panic" in r2 && "message" in r2 && "error_code" in r2)
          return { type: "QueryEngineError", body: r2 };
        if ("EngineNotStarted" in r2 || "InteractiveTransactionMisrouted" in r2 || "InvalidRequestError" in r2) {
          let n4 = Object.values(r2)[0].reason;
          return typeof n4 == "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(n4) ? { type: "UnknownJsonError", body: r2 } : { type: "DataProxyError", body: r2 };
        }
      }
      return { type: "UnknownJsonError", body: r2 };
    } catch {
      return t4 === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: t4 };
    }
  }
  async function kr(e4, t4) {
    if (e4.ok)
      return;
    let r2 = { clientVersion: t4, response: e4 }, n4 = await Ud(e4);
    if (n4.type === "QueryEngineError")
      throw new H3(n4.body.message, { code: n4.body.error_code, clientVersion: t4 });
    if (n4.type === "DataProxyError") {
      if (n4.body === "InternalDataProxyError")
        throw new Jt(r2, "Internal Data Proxy error");
      if ("EngineNotStarted" in n4.body) {
        if (n4.body.EngineNotStarted.reason === "SchemaMissing")
          return new Et(r2);
        if (n4.body.EngineNotStarted.reason === "EngineVersionNotSupported")
          throw new Cr(r2);
        if ("EngineStartupError" in n4.body.EngineNotStarted.reason) {
          let { msg: i, logs: o4 } = n4.body.EngineNotStarted.reason.EngineStartupError;
          throw new _r(r2, i, o4);
        }
        if ("KnownEngineStartupError" in n4.body.EngineNotStarted.reason) {
          let { msg: i, error_code: o4 } = n4.body.EngineNotStarted.reason.KnownEngineStartupError;
          throw new O(i, t4, o4);
        }
        if ("HealthcheckTimeout" in n4.body.EngineNotStarted.reason) {
          let { logs: i } = n4.body.EngineNotStarted.reason.HealthcheckTimeout;
          throw new Tr(r2, i);
        }
      }
      if ("InteractiveTransactionMisrouted" in n4.body) {
        let i = { IDParseError: "Could not parse interactive transaction ID", NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID", TransactionStartError: "Could not start interactive transaction" };
        throw new Rr(r2, i[n4.body.InteractiveTransactionMisrouted.reason]);
      }
      if ("InvalidRequestError" in n4.body)
        throw new Mr(r2, n4.body.InvalidRequestError.reason);
    }
    if (e4.status === 401 || e4.status === 403)
      throw new Ir(r2, Ht(wo, n4));
    if (e4.status === 404)
      return new Sr(r2, Ht(bo, n4));
    if (e4.status === 429)
      throw new Dr(r2, Ht(Eo, n4));
    if (e4.status === 504)
      throw new Ar(r2, Ht(ho, n4));
    if (e4.status >= 500)
      throw new Jt(r2, Ht(xo, n4));
    if (e4.status >= 400)
      throw new vr(r2, Ht(yo, n4));
  }
  function Ht(e4, t4) {
    return t4.type === "EmptyError" ? e4 : `${e4}: ${JSON.stringify(t4)}`;
  }
  function yl(e4) {
    let t4 = Math.pow(2, e4) * 50, r2 = Math.ceil(Math.random() * t4) - Math.ceil(t4 / 2), n4 = t4 + r2;
    return new Promise((i) => setTimeout(() => i(n4), n4));
  }
  function hl(e4) {
    if (!!e4.generator?.previewFeatures.some((r2) => r2.toLowerCase().includes("metrics")))
      throw new O("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate", e4.clientVersion);
  }
  function Kd(e4) {
    return e4[0] * 1000 + e4[1] / 1e6;
  }
  function bl(e4) {
    return new Date(Kd(e4));
  }
  async function Pt(e4, t4, r2 = (n4) => n4) {
    let n4 = t4.clientVersion;
    try {
      return typeof fetch == "function" ? await r2(fetch)(e4, t4) : await r2(Po)(e4, t4);
    } catch (i) {
      let o4 = i.message ?? "Unknown error";
      throw new Fr(o4, { clientVersion: n4 });
    }
  }
  function Gd(e4) {
    return { ...e4.headers, "Content-Type": "application/json" };
  }
  function Jd(e4) {
    return { method: e4.method, headers: Gd(e4) };
  }
  function Hd(e4, t4) {
    return { text: () => Promise.resolve(Buffer.concat(e4).toString()), json: () => Promise.resolve().then(() => JSON.parse(Buffer.concat(e4).toString())), ok: t4.statusCode >= 200 && t4.statusCode <= 299, status: t4.statusCode, url: t4.url, headers: new vo(t4.headers) };
  }
  async function Po(e4, t4 = {}) {
    let r2 = Wd("https"), n4 = Jd(t4), i = [], { origin: o4 } = new URL(e4);
    return new Promise((s5, a3) => {
      let l5 = r2.request(e4, n4, (u3) => {
        let { statusCode: c4, headers: { location: p3 } } = u3;
        c4 >= 301 && c4 <= 399 && p3 && (p3.startsWith("http") === false ? s5(Po(`${o4}${p3}`, t4)) : s5(Po(p3, t4))), u3.on("data", (d3) => i.push(d3)), u3.on("end", () => s5(Hd(i, u3))), u3.on("error", a3);
      });
      l5.on("error", a3), l5.end(t4.body ?? "");
    });
  }
  async function Yd(e4, t4) {
    let r2 = xl["@prisma/engines-version"], n4 = t4.clientVersion ?? "unknown";
    if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)
      return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
    if (e4.includes("accelerate") && n4 !== "0.0.0" && n4 !== "in-memory")
      return n4;
    let [i, o4] = n4?.split("-") ?? [];
    if (o4 === undefined && zd.test(i))
      return i;
    if (o4 !== undefined || n4 === "0.0.0" || n4 === "in-memory") {
      if (e4.startsWith("localhost") || e4.startsWith("127.0.0.1"))
        return "0.0.0";
      let [s5] = r2.split("-") ?? [], [a3, l5, u3] = s5.split("."), c4 = Zd(`<=${a3}.${l5}.${u3}`), p3 = await Pt(c4, { clientVersion: n4 });
      if (!p3.ok)
        throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p3.status} ${p3.statusText}, response body: ${await p3.text() || "<empty body>"}`);
      let d3 = await p3.text();
      wl("length of body fetched from unpkg.com", d3.length);
      let f;
      try {
        f = JSON.parse(d3);
      } catch (h3) {
        throw console.error("JSON.parse error: body fetched from unpkg.com: ", d3), h3;
      }
      return f.version;
    }
    throw new wt("Only `major.minor.patch` versions are supported by Accelerate.", { clientVersion: n4 });
  }
  async function El(e4, t4) {
    let r2 = await Yd(e4, t4);
    return wl("version", r2), r2;
  }
  function Zd(e4) {
    return encodeURI(`https://unpkg.com/prisma@${e4}/package.json`);
  }
  function vl(e4) {
    if (e4?.kind === "itx")
      return e4.options.id;
  }
  function Xd() {
    let e4 = globalThis;
    return e4[Co] === undefined && (e4[Co] = {}), e4[Co];
  }
  function em(e4) {
    let t4 = Xd();
    if (t4[e4] !== undefined)
      return t4[e4];
    let r2 = Tl.default.toNamespacedPath(e4), n4 = { exports: {} }, i = 0;
    return process.platform !== "win32" && (i = Ao.default.constants.dlopen.RTLD_LAZY | Ao.default.constants.dlopen.RTLD_DEEPBIND), process.dlopen(n4, r2, i), t4[e4] = n4.exports, n4.exports;
  }
  function Mo(e4) {
    b3 = e4;
  }
  function y3(e4) {
    return Ke[e4];
  }
  function Wn() {
    return (Qn === null || Qn.byteLength === 0) && (Qn = new Uint8Array(b3.memory.buffer)), Qn;
  }
  function le(e4, t4, r2) {
    if (r2 === undefined) {
      let a3 = zn.encode(e4), l5 = t4(a3.length, 1) >>> 0;
      return Wn().subarray(l5, l5 + a3.length).set(a3), Z = a3.length, l5;
    }
    let n4 = e4.length, i = t4(n4, 1) >>> 0, o4 = Wn(), s5 = 0;
    for (;s5 < n4; s5++) {
      let a3 = e4.charCodeAt(s5);
      if (a3 > 127)
        break;
      o4[i + s5] = a3;
    }
    if (s5 !== n4) {
      s5 !== 0 && (e4 = e4.slice(s5)), i = r2(i, n4, n4 = s5 + e4.length * 3, 1) >>> 0;
      let a3 = Wn().subarray(i + s5, i + n4), l5 = rm(e4, a3);
      s5 += l5.written;
    }
    return Z = s5, i;
  }
  function at(e4) {
    return e4 == null;
  }
  function xe() {
    return (Gn === null || Gn.byteLength === 0) && (Gn = new Int32Array(b3.memory.buffer)), Gn;
  }
  function $r(e4, t4) {
    return e4 = e4 >>> 0, Cl.decode(Wn().subarray(e4, e4 + t4));
  }
  function w(e4) {
    Nr === Ke.length && Ke.push(Ke.length + 1);
    let t4 = Nr;
    return Nr = Ke[t4], Ke[t4] = e4, t4;
  }
  function im(e4) {
    e4 < 132 || (Ke[e4] = Nr, Nr = e4);
  }
  function ne(e4) {
    let t4 = y3(e4);
    return im(e4), t4;
  }
  function om() {
    return (Jn === null || Jn.byteLength === 0) && (Jn = new Float64Array(b3.memory.buffer)), Jn;
  }
  function sm() {
    return (Hn === null || Hn.byteLength === 0) && (Hn = new BigInt64Array(b3.memory.buffer)), Hn;
  }
  function Ro(e4) {
    let t4 = typeof e4;
    if (t4 == "number" || t4 == "boolean" || e4 == null)
      return `${e4}`;
    if (t4 == "string")
      return `"${e4}"`;
    if (t4 == "symbol") {
      let i = e4.description;
      return i == null ? "Symbol" : `Symbol(${i})`;
    }
    if (t4 == "function") {
      let i = e4.name;
      return typeof i == "string" && i.length > 0 ? `Function(${i})` : "Function";
    }
    if (Array.isArray(e4)) {
      let i = e4.length, o4 = "[";
      i > 0 && (o4 += Ro(e4[0]));
      for (let s5 = 1;s5 < i; s5++)
        o4 += ", " + Ro(e4[s5]);
      return o4 += "]", o4;
    }
    let r2 = /\[object ([^\]]+)\]/.exec(toString.call(e4)), n4;
    if (r2.length > 1)
      n4 = r2[1];
    else
      return toString.call(e4);
    if (n4 == "Object")
      try {
        return "Object(" + JSON.stringify(e4) + ")";
      } catch {
        return "Object";
      }
    return e4 instanceof Error ? `${e4.name}: ${e4.message}
${e4.stack}` : n4;
  }
  function am(e4, t4, r2, n4) {
    let i = { a: e4, b: t4, cnt: 1, dtor: r2 }, o4 = (...s5) => {
      i.cnt++;
      let a3 = i.a;
      i.a = 0;
      try {
        return n4(a3, i.b, ...s5);
      } finally {
        --i.cnt === 0 ? b3.__wbindgen_export_2.get(i.dtor)(a3, i.b) : i.a = a3;
      }
    };
    return o4.original = i, o4;
  }
  function lm(e4, t4, r2) {
    b3.wasm_bindgen__convert__closures__invoke1_mut__hc386510de9598720(e4, t4, w(r2));
  }
  function um() {
    let e4 = b3.getBuildTimeInfo();
    return ne(e4);
  }
  function cm(e4) {
    try {
      let o4 = b3.__wbindgen_add_to_stack_pointer(-16);
      var t4 = at(e4) ? 0 : le(e4, b3.__wbindgen_malloc, b3.__wbindgen_realloc), r2 = Z;
      b3.debug_panic(o4, t4, r2);
      var n4 = xe()[o4 / 4 + 0], i = xe()[o4 / 4 + 1];
      if (i)
        throw ne(n4);
    } finally {
      b3.__wbindgen_add_to_stack_pointer(16);
    }
  }
  function ue(e4, t4) {
    try {
      return e4.apply(this, t4);
    } catch (r2) {
      b3.__wbindgen_exn_store(w(r2));
    }
  }
  function pm(e4, t4, r2, n4) {
    b3.wasm_bindgen__convert__closures__invoke2_mut__h3c34ccf7f9375d77(e4, t4, w(r2), w(n4));
  }
  function dm(e4, t4) {
    let r2 = y3(t4), n4 = typeof r2 == "string" ? r2 : undefined;
    var i = at(n4) ? 0 : le(n4, b3.__wbindgen_malloc, b3.__wbindgen_realloc), o4 = Z;
    xe()[e4 / 4 + 1] = o4, xe()[e4 / 4 + 0] = i;
  }
  function mm(e4, t4) {
    let r2 = new Error($r(e4, t4));
    return w(r2);
  }
  function fm(e4, t4) {
    try {
      var r2 = { a: e4, b: t4 }, n4 = (o4, s5) => {
        let a3 = r2.a;
        r2.a = 0;
        try {
          return pm(a3, r2.b, o4, s5);
        } finally {
          r2.a = a3;
        }
      };
      let i = new Promise(n4);
      return w(i);
    } finally {
      r2.a = r2.b = 0;
    }
  }
  function gm(e4, t4) {
    return setTimeout(y3(e4), t4 >>> 0);
  }
  function ym(e4, t4) {
    let r2 = $r(e4, t4);
    return w(r2);
  }
  function hm(e4) {
    let t4 = y3(e4);
    return w(t4);
  }
  function bm(e4) {
    return y3(e4) === undefined;
  }
  function xm() {
    return ue(function(e4, t4) {
      return Reflect.has(y3(e4), y3(t4));
    }, arguments);
  }
  function wm() {
    return ue(function(e4, t4) {
      let r2 = JSON.parse($r(e4, t4));
      return w(r2);
    }, arguments);
  }
  function Em() {
    return w(new Date);
  }
  function Pm(e4) {
    return y3(e4).getTime();
  }
  function vm(e4) {
    ne(e4);
  }
  function Tm(e4) {
    return y3(e4).now();
  }
  function _m() {
    return Date.now();
  }
  function Cm() {
    let e4 = performance;
    return at(e4) ? 0 : w(e4);
  }
  function Am(e4) {
    let t4 = y3(e4);
    return typeof t4 == "object" && t4 !== null;
  }
  function Rm(e4) {
    let t4;
    try {
      t4 = y3(e4) instanceof Promise;
    } catch {
      t4 = false;
    }
    return t4;
  }
  function Mm() {
    return w(Symbol.iterator);
  }
  function Sm(e4) {
    return y3(e4).length;
  }
  function Im(e4) {
    let t4 = y3(e4);
    return typeof t4 == "boolean" ? t4 ? 1 : 0 : 2;
  }
  function Dm(e4) {
    return typeof y3(e4) == "bigint";
  }
  function km(e4, t4) {
    let r2 = y3(t4), n4 = typeof r2 == "number" ? r2 : undefined;
    om()[e4 / 8 + 1] = at(n4) ? 0 : n4, xe()[e4 / 4 + 0] = !at(n4);
  }
  function Fm(e4) {
    return w(e4);
  }
  function Om(e4, t4) {
    return y3(e4) in y3(t4);
  }
  function Nm(e4) {
    let t4 = BigInt.asUintN(64, e4);
    return w(t4);
  }
  function Lm(e4, t4) {
    return y3(e4) === y3(t4);
  }
  function $m(e4) {
    return w(e4);
  }
  function qm() {
    let e4 = new Array;
    return w(e4);
  }
  function jm(e4, t4, r2) {
    y3(e4)[t4 >>> 0] = ne(r2);
  }
  function Bm() {
    return w(new Map);
  }
  function Vm() {
    let e4 = new Object;
    return w(e4);
  }
  function Um(e4) {
    return typeof y3(e4) == "string";
  }
  function Km(e4, t4, r2) {
    y3(e4)[ne(t4)] = ne(r2);
  }
  function Qm(e4, t4, r2) {
    let n4 = y3(e4).set(y3(t4), y3(r2));
    return w(n4);
  }
  function Gm(e4, t4) {
    let r2 = y3(e4)[y3(t4)];
    return w(r2);
  }
  function Jm(e4, t4) {
    return y3(e4).push(y3(t4));
  }
  function Hm() {
    return ue(function(e4, t4) {
      let r2 = y3(e4)[ne(t4)];
      return w(r2);
    }, arguments);
  }
  function Wm(e4, t4) {
    let r2 = String(y3(t4)), n4 = le(r2, b3.__wbindgen_malloc, b3.__wbindgen_realloc), i = Z;
    xe()[e4 / 4 + 1] = i, xe()[e4 / 4 + 0] = n4;
  }
  function zm() {
    let e4 = b3.memory;
    return w(e4);
  }
  function Ym(e4) {
    let t4 = y3(e4).buffer;
    return w(t4);
  }
  function Zm(e4, t4, r2) {
    let n4 = new Uint8Array(y3(e4), t4 >>> 0, r2 >>> 0);
    return w(n4);
  }
  function Xm(e4) {
    let t4 = new Uint8Array(y3(e4));
    return w(t4);
  }
  function ef(e4) {
    let t4 = Buffer.from(y3(e4));
    return w(t4);
  }
  function tf() {
    return ue(function(e4, t4) {
      y3(e4).randomFillSync(ne(t4));
    }, arguments);
  }
  function rf(e4, t4, r2) {
    let n4 = y3(e4).subarray(t4 >>> 0, r2 >>> 0);
    return w(n4);
  }
  function nf() {
    return ue(function(e4, t4) {
      y3(e4).getRandomValues(y3(t4));
    }, arguments);
  }
  function of(e4) {
    let t4 = y3(e4).crypto;
    return w(t4);
  }
  function sf(e4) {
    let t4 = y3(e4).process;
    return w(t4);
  }
  function af(e4) {
    let t4 = y3(e4).versions;
    return w(t4);
  }
  function lf(e4) {
    let t4 = y3(e4).node;
    return w(t4);
  }
  function uf() {
    return ue(function() {
      let e4 = module.require;
      return w(e4);
    }, arguments);
  }
  function cf(e4) {
    let t4 = y3(e4).msCrypto;
    return w(t4);
  }
  function pf(e4) {
    let t4 = new Uint8Array(e4 >>> 0);
    return w(t4);
  }
  function df(e4) {
    return typeof y3(e4) == "function";
  }
  function mf() {
    return ue(function(e4, t4) {
      let r2 = y3(e4).call(y3(t4));
      return w(r2);
    }, arguments);
  }
  function ff(e4, t4) {
    let r2 = y3(e4)[t4 >>> 0];
    return w(r2);
  }
  function gf(e4) {
    return y3(e4).valueOf();
  }
  function yf() {
    return ue(function(e4) {
      let t4 = y3(e4).next();
      return w(t4);
    }, arguments);
  }
  function hf(e4) {
    return y3(e4).done;
  }
  function bf(e4) {
    let t4 = y3(e4).value;
    return w(t4);
  }
  function xf(e4) {
    let t4 = y3(e4).next;
    return w(t4);
  }
  function wf() {
    return ue(function(e4, t4) {
      let r2 = Reflect.get(y3(e4), y3(t4));
      return w(r2);
    }, arguments);
  }
  function Ef() {
    return ue(function() {
      let e4 = self.self;
      return w(e4);
    }, arguments);
  }
  function Pf() {
    return ue(function() {
      let e4 = window.window;
      return w(e4);
    }, arguments);
  }
  function vf() {
    return ue(function() {
      let e4 = globalThis.globalThis;
      return w(e4);
    }, arguments);
  }
  function Tf() {
    return ue(function() {
      let e4 = global.global;
      return w(e4);
    }, arguments);
  }
  function _f(e4, t4) {
    let r2 = new Function($r(e4, t4));
    return w(r2);
  }
  function Cf(e4) {
    return Array.isArray(y3(e4));
  }
  function Af() {
    return ue(function(e4, t4, r2) {
      let n4 = y3(e4).call(y3(t4), y3(r2));
      return w(n4);
    }, arguments);
  }
  function Rf(e4) {
    return Number.isSafeInteger(y3(e4));
  }
  function Mf() {
    return ue(function(e4, t4, r2) {
      return Reflect.set(y3(e4), y3(t4), y3(r2));
    }, arguments);
  }
  function Sf() {
    return ue(function(e4) {
      let t4 = JSON.stringify(y3(e4));
      return w(t4);
    }, arguments);
  }
  function If(e4, t4, r2) {
    y3(e4).set(y3(t4), r2 >>> 0);
  }
  function Df(e4) {
    return y3(e4).length;
  }
  function kf(e4, t4) {
    return y3(e4) == y3(t4);
  }
  function Ff(e4) {
    let t4;
    try {
      t4 = y3(e4) instanceof Uint8Array;
    } catch {
      t4 = false;
    }
    return t4;
  }
  function Of(e4) {
    let t4;
    try {
      t4 = y3(e4) instanceof ArrayBuffer;
    } catch {
      t4 = false;
    }
    return t4;
  }
  function Nf(e4) {
    let t4 = Object.entries(y3(e4));
    return w(t4);
  }
  function Lf(e4, t4) {
    let r2 = y3(t4), n4 = typeof r2 == "bigint" ? r2 : undefined;
    sm()[e4 / 8 + 1] = at(n4) ? BigInt(0) : n4, xe()[e4 / 4 + 0] = !at(n4);
  }
  function $f(e4, t4) {
    let r2 = Ro(y3(t4)), n4 = le(r2, b3.__wbindgen_malloc, b3.__wbindgen_realloc), i = Z;
    xe()[e4 / 4 + 1] = i, xe()[e4 / 4 + 0] = n4;
  }
  function qf(e4, t4) {
    throw new Error($r(e4, t4));
  }
  function jf(e4) {
    let t4 = ne(e4).original;
    return t4.cnt-- == 1 ? (t4.a = 0, true) : false;
  }
  function Bf(e4, t4) {
    let r2 = y3(e4).then(y3(t4));
    return w(r2);
  }
  function Vf(e4, t4, r2) {
    let n4 = y3(e4).then(y3(t4), y3(r2));
    return w(n4);
  }
  function Uf(e4) {
    let t4 = Promise.resolve(y3(e4));
    return w(t4);
  }
  function Kf(e4, t4, r2) {
    let n4 = am(e4, t4, 332, lm);
    return w(n4);
  }
  function Gf(e4) {
    return e4.item_type === "query" && "query" in e4;
  }
  function Jf(e4) {
    return "level" in e4 ? e4.level === "error" && e4.message === "PANIC" : false;
  }
  function Hf(e4) {
    return typeof e4 == "object" && e4 !== null && e4.error_code !== undefined;
  }
  function Sl(e4, t4) {
    let r2;
    try {
      r2 = Un({ inlineDatasources: t4.inlineDatasources, overrideDatasources: t4.overrideDatasources, env: { ...t4.env, ...process.env }, clientVersion: t4.clientVersion });
    } catch {
    }
    e4.noEngine !== true && r2?.startsWith("prisma://") && ar("recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");
    let n4 = nr(t4.generator), i = !!(r2?.startsWith("prisma://") || e4.noEngine), o4 = !!t4.adapter, s5 = n4 === "library", a3 = n4 === "binary";
    if (i && o4 || o4 && false) {
      let l5;
      throw e4.noEngine ? l5 = ["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.", "Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."] : r2?.startsWith("prisma://") ? l5 = ["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.", "Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."] : l5 = ["Prisma Client was configured to use both the `adapter` and Accelerate, please chose one."], new te(l5.join(`
`), { clientVersion: t4.clientVersion });
    }
    if (i)
      return new Or3(t4);
    if (s5)
      return new qr(t4);
    throw new te("Invalid client engine type, please use `library` or `binary`", { clientVersion: t4.clientVersion });
  }
  function Yn({ generator: e4 }) {
    return e4?.previewFeatures ?? [];
  }
  function Fl(e4, t4) {
    let r2 = Ol(e4), n4 = Wf(r2), i = Yf(n4);
    i ? Zn(i, t4) : t4.addErrorMessage(() => "Unknown error");
  }
  function Ol(e4) {
    return e4.errors.flatMap((t4) => t4.kind === "Union" ? Ol(t4) : [t4]);
  }
  function Wf(e4) {
    let t4 = new Map, r2 = [];
    for (let n4 of e4) {
      if (n4.kind !== "InvalidArgumentType") {
        r2.push(n4);
        continue;
      }
      let i = `${n4.selectionPath.join(".")}:${n4.argumentPath.join(".")}`, o4 = t4.get(i);
      o4 ? t4.set(i, { ...n4, argument: { ...n4.argument, typeNames: zf(o4.argument.typeNames, n4.argument.typeNames) } }) : t4.set(i, n4);
    }
    return r2.push(...t4.values()), r2;
  }
  function zf(e4, t4) {
    return [...new Set(e4.concat(t4))];
  }
  function Yf(e4) {
    return Gi(e4, (t4, r2) => {
      let n4 = Dl(t4), i = Dl(r2);
      return n4 !== i ? n4 - i : kl(t4) - kl(r2);
    });
  }
  function Dl(e4) {
    let t4 = 0;
    return Array.isArray(e4.selectionPath) && (t4 += e4.selectionPath.length), Array.isArray(e4.argumentPath) && (t4 += e4.argumentPath.length), t4;
  }
  function kl(e4) {
    switch (e4.kind) {
      case "InvalidArgumentValue":
      case "ValueTooLarge":
        return 20;
      case "InvalidArgumentType":
        return 10;
      case "RequiredArgumentMissing":
        return -10;
      default:
        return 0;
    }
  }
  function Zn(e4, t4) {
    switch (e4.kind) {
      case "IncludeAndSelect":
        Zf(e4, t4);
        break;
      case "IncludeOnScalar":
        Xf(e4, t4);
        break;
      case "EmptySelection":
        eg(e4, t4);
        break;
      case "UnknownSelectionField":
        tg(e4, t4);
        break;
      case "UnknownArgument":
        rg(e4, t4);
        break;
      case "UnknownInputField":
        ng(e4, t4);
        break;
      case "RequiredArgumentMissing":
        ig(e4, t4);
        break;
      case "InvalidArgumentType":
        og(e4, t4);
        break;
      case "InvalidArgumentValue":
        sg(e4, t4);
        break;
      case "ValueTooLarge":
        ag(e4, t4);
        break;
      case "SomeFieldsMissing":
        lg(e4, t4);
        break;
      case "TooManyFieldsGiven":
        ug(e4, t4);
        break;
      case "Union":
        Fl(e4, t4);
        break;
      default:
        throw new Error("not implemented: " + e4.kind);
    }
  }
  function Zf(e4, t4) {
    let r2 = t4.arguments.getDeepSubSelectionValue(e4.selectionPath);
    r2 && r2 instanceof z && (r2.getField("include")?.markAsError(), r2.getField("select")?.markAsError()), t4.addErrorMessage((n4) => `Please ${n4.bold("either")} use ${n4.green("`include`")} or ${n4.green("`select`")}, but ${n4.red("not both")} at the same time.`);
  }
  function Xf(e4, t4) {
    let [r2, n4] = ei(e4.selectionPath), i = e4.outputType, o4 = t4.arguments.getDeepSelectionParent(r2)?.value;
    if (o4 && (o4.getField(n4)?.markAsError(), i))
      for (let s5 of i.fields)
        s5.isRelation && o4.addSuggestion(new Qe(s5.name, "true"));
    t4.addErrorMessage((s5) => {
      let a3 = `Invalid scalar field ${s5.red(`\`${n4}\``)} for ${s5.bold("include")} statement`;
      return i ? a3 += ` on model ${s5.bold(i.name)}. ${jr(s5)}` : a3 += ".", a3 += `
Note that ${s5.bold("include")} statements only accept relation fields.`, a3;
    });
  }
  function eg(e4, t4) {
    let r2 = e4.outputType, n4 = t4.arguments.getDeepSelectionParent(e4.selectionPath)?.value, i = n4?.isEmpty() ?? false;
    n4 && (n4.removeAllFields(), ql(n4, r2)), t4.addErrorMessage((o4) => i ? `The ${o4.red("`select`")} statement for type ${o4.bold(r2.name)} must not be empty. ${jr(o4)}` : `The ${o4.red("`select`")} statement for type ${o4.bold(r2.name)} needs ${o4.bold("at least one truthy value")}.`);
  }
  function tg(e4, t4) {
    let [r2, n4] = ei(e4.selectionPath), i = t4.arguments.getDeepSelectionParent(r2);
    i && (i.value.getField(n4)?.markAsError(), ql(i.value, e4.outputType)), t4.addErrorMessage((o4) => {
      let s5 = [`Unknown field ${o4.red(`\`${n4}\``)}`];
      return i && s5.push(`for ${o4.bold(i.kind)} statement`), s5.push(`on model ${o4.bold(`\`${e4.outputType.name}\``)}.`), s5.push(jr(o4)), s5.join(" ");
    });
  }
  function rg(e4, t4) {
    let r2 = e4.argumentPath[0], n4 = t4.arguments.getDeepSubSelectionValue(e4.selectionPath);
    n4 instanceof z && (n4.getField(r2)?.markAsError(), cg(n4, e4.arguments)), t4.addErrorMessage((i) => Ll(i, r2, e4.arguments.map((o4) => o4.name)));
  }
  function ng(e4, t4) {
    let [r2, n4] = ei(e4.argumentPath), i = t4.arguments.getDeepSubSelectionValue(e4.selectionPath);
    if (i instanceof z) {
      i.getDeepField(e4.argumentPath)?.markAsError();
      let o4 = i.getDeepFieldValue(r2);
      o4 instanceof z && jl(o4, e4.inputType);
    }
    t4.addErrorMessage((o4) => Ll(o4, n4, e4.inputType.fields.map((s5) => s5.name)));
  }
  function Ll(e4, t4, r2) {
    let n4 = [`Unknown argument \`${e4.red(t4)}\`.`], i = dg(t4, r2);
    return i && n4.push(`Did you mean \`${e4.green(i)}\`?`), r2.length > 0 && n4.push(jr(e4)), n4.join(" ");
  }
  function ig(e4, t4) {
    let r2;
    t4.addErrorMessage((l5) => r2?.value instanceof Y && r2.value.text === "null" ? `Argument \`${l5.green(o4)}\` must not be ${l5.red("null")}.` : `Argument \`${l5.green(o4)}\` is missing.`);
    let n4 = t4.arguments.getDeepSubSelectionValue(e4.selectionPath);
    if (!(n4 instanceof z))
      return;
    let [i, o4] = ei(e4.argumentPath), s5 = new Xn, a3 = n4.getDeepFieldValue(i);
    if (a3 instanceof z)
      if (r2 = a3.getField(o4), r2 && a3.removeField(o4), e4.inputTypes.length === 1 && e4.inputTypes[0].kind === "object") {
        for (let l5 of e4.inputTypes[0].fields)
          s5.addField(l5.name, l5.typeNames.join(" | "));
        a3.addSuggestion(new Qe(o4, s5).makeRequired());
      } else {
        let l5 = e4.inputTypes.map($l).join(" | ");
        a3.addSuggestion(new Qe(o4, l5).makeRequired());
      }
  }
  function $l(e4) {
    return e4.kind === "list" ? `${$l(e4.elementType)}[]` : e4.name;
  }
  function og(e4, t4) {
    let r2 = e4.argument.name, n4 = t4.arguments.getDeepSubSelectionValue(e4.selectionPath);
    n4 instanceof z && n4.getDeepFieldValue(e4.argumentPath)?.markAsError(), t4.addErrorMessage((i) => {
      let o4 = ti("or", e4.argument.typeNames.map((s5) => i.green(s5)));
      return `Argument \`${i.bold(r2)}\`: Invalid value provided. Expected ${o4}, provided ${i.red(e4.inferredType)}.`;
    });
  }
  function sg(e4, t4) {
    let r2 = e4.argument.name, n4 = t4.arguments.getDeepSubSelectionValue(e4.selectionPath);
    n4 instanceof z && n4.getDeepFieldValue(e4.argumentPath)?.markAsError(), t4.addErrorMessage((i) => {
      let o4 = [`Invalid value for argument \`${i.bold(r2)}\``];
      if (e4.underlyingError && o4.push(`: ${e4.underlyingError}`), o4.push("."), e4.argument.typeNames.length > 0) {
        let s5 = ti("or", e4.argument.typeNames.map((a3) => i.green(a3)));
        o4.push(` Expected ${s5}.`);
      }
      return o4.join("");
    });
  }
  function ag(e4, t4) {
    let r2 = e4.argument.name, n4 = t4.arguments.getDeepSubSelectionValue(e4.selectionPath), i;
    if (n4 instanceof z) {
      let s5 = n4.getDeepField(e4.argumentPath)?.value;
      s5?.markAsError(), s5 instanceof Y && (i = s5.text);
    }
    t4.addErrorMessage((o4) => {
      let s5 = ["Unable to fit value"];
      return i && s5.push(o4.red(i)), s5.push(`into a 64-bit signed integer for field \`${o4.bold(r2)}\``), s5.join(" ");
    });
  }
  function lg(e4, t4) {
    let r2 = e4.argumentPath[e4.argumentPath.length - 1], n4 = t4.arguments.getDeepSubSelectionValue(e4.selectionPath);
    if (n4 instanceof z) {
      let i = n4.getDeepFieldValue(e4.argumentPath);
      i instanceof z && jl(i, e4.inputType);
    }
    t4.addErrorMessage((i) => {
      let o4 = [`Argument \`${i.bold(r2)}\` of type ${i.bold(e4.inputType.name)} needs`];
      return e4.constraints.minFieldCount === 1 ? e4.constraints.requiredFields ? o4.push(`${i.green("at least one of")} ${ti("or", e4.constraints.requiredFields.map((s5) => `\`${i.bold(s5)}\``))} arguments.`) : o4.push(`${i.green("at least one")} argument.`) : o4.push(`${i.green(`at least ${e4.constraints.minFieldCount}`)} arguments.`), o4.push(jr(i)), o4.join(" ");
    });
  }
  function ug(e4, t4) {
    let r2 = e4.argumentPath[e4.argumentPath.length - 1], n4 = t4.arguments.getDeepSubSelectionValue(e4.selectionPath), i = [];
    if (n4 instanceof z) {
      let o4 = n4.getDeepFieldValue(e4.argumentPath);
      o4 instanceof z && (o4.markAsError(), i = Object.keys(o4.getFields()));
    }
    t4.addErrorMessage((o4) => {
      let s5 = [`Argument \`${o4.bold(r2)}\` of type ${o4.bold(e4.inputType.name)} needs`];
      return e4.constraints.minFieldCount === 1 && e4.constraints.maxFieldCount == 1 ? s5.push(`${o4.green("exactly one")} argument,`) : e4.constraints.maxFieldCount == 1 ? s5.push(`${o4.green("at most one")} argument,`) : s5.push(`${o4.green(`at most ${e4.constraints.maxFieldCount}`)} arguments,`), s5.push(`but you provided ${ti("and", i.map((a3) => o4.red(a3)))}. Please choose`), e4.constraints.maxFieldCount === 1 ? s5.push("one.") : s5.push(`${e4.constraints.maxFieldCount}.`), s5.join(" ");
    });
  }
  function ql(e4, t4) {
    for (let r2 of t4.fields)
      e4.hasField(r2.name) || e4.addSuggestion(new Qe(r2.name, "true"));
  }
  function cg(e4, t4) {
    for (let r2 of t4)
      e4.hasField(r2.name) || e4.addSuggestion(new Qe(r2.name, r2.typeNames.join(" | ")));
  }
  function jl(e4, t4) {
    if (t4.kind === "object")
      for (let r2 of t4.fields)
        e4.hasField(r2.name) || e4.addSuggestion(new Qe(r2.name, r2.typeNames.join(" | ")));
  }
  function ei(e4) {
    let t4 = [...e4], r2 = t4.pop();
    if (!r2)
      throw new Error("unexpected empty path");
    return [t4, r2];
  }
  function jr({ green: e4, enabled: t4 }) {
    return "Available options are " + (t4 ? `listed in ${e4("green")}` : "marked with ?") + ".";
  }
  function ti(e4, t4) {
    if (t4.length === 1)
      return t4[0];
    let r2 = [...t4], n4 = r2.pop();
    return `${r2.join(", ")} ${e4} ${n4}`;
  }
  function dg(e4, t4) {
    let r2 = 1 / 0, n4;
    for (let i of t4) {
      let o4 = (0, Nl.default)(e4, i);
      o4 > pg || o4 < r2 && (r2 = o4, n4 = i);
    }
    return n4;
  }
  function ri({ args: e4, errors: t4, errorFormat: r2, callsite: n4, originalMethod: i, clientVersion: o4 }) {
    let s5 = Sn(e4);
    for (let p3 of t4)
      Zn(p3, s5);
    let a3 = r2 === "pretty" ? ba : Rn, l5 = s5.renderAllMessages(a3), u3 = new Ot(0, { colors: a3 }).write(s5).toString(), c4 = Kt({ message: l5, callsite: n4, originalMethod: i, showColors: r2 === "pretty", callArguments: u3 });
    throw new te(c4, { clientVersion: o4 });
  }
  function Bl({ modelName: e4, action: t4, args: r2, runtimeDataModel: n4, extensions: i, callsite: o4, clientMethod: s5, errorFormat: a3, clientVersion: l5 }) {
    let u3 = new ko({ runtimeDataModel: n4, modelName: e4, action: t4, rootArgs: r2, callsite: o4, extensions: i, selectionPath: [], argumentPath: [], originalMethod: s5, errorFormat: a3, clientVersion: l5 });
    return { modelName: e4, action: mg[t4], query: Fo(r2, u3) };
  }
  function Fo({ select: e4, include: t4, ...r2 } = {}, n4) {
    return { arguments: Ul(r2, n4), selection: fg(e4, t4, n4) };
  }
  function fg(e4, t4, r2) {
    return e4 && t4 && r2.throwValidationError({ kind: "IncludeAndSelect", selectionPath: r2.getSelectionPath() }), e4 ? hg(e4, r2) : gg(r2, t4);
  }
  function gg(e4, t4) {
    let r2 = {};
    return e4.model && !e4.isRawAction() && (r2.$composites = true, r2.$scalars = true), t4 && yg(r2, t4, e4), r2;
  }
  function yg(e4, t4, r2) {
    for (let [n4, i] of Object.entries(t4)) {
      let o4 = r2.findField(n4);
      o4 && o4?.kind !== "object" && r2.throwValidationError({ kind: "IncludeOnScalar", selectionPath: r2.getSelectionPath().concat(n4), outputType: r2.getOutputTypeDescription() }), i === true ? e4[n4] = true : typeof i == "object" && (e4[n4] = Fo(i, r2.nestSelection(n4)));
    }
  }
  function hg(e4, t4) {
    let r2 = {}, n4 = t4.getComputedFields(), i = Xa(e4, n4);
    for (let [o4, s5] of Object.entries(i)) {
      let a3 = t4.findField(o4);
      n4?.[o4] && !a3 || (s5 === true ? r2[o4] = true : typeof s5 == "object" && (r2[o4] = Fo(s5, t4.nestSelection(o4))));
    }
    return r2;
  }
  function Vl(e4, t4) {
    if (e4 === null)
      return null;
    if (typeof e4 == "string" || typeof e4 == "number" || typeof e4 == "boolean")
      return e4;
    if (typeof e4 == "bigint")
      return { $type: "BigInt", value: String(e4) };
    if (Nt(e4)) {
      if (bn(e4))
        return { $type: "DateTime", value: e4.toISOString() };
      t4.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t4.getSelectionPath(), argumentPath: t4.getArgumentPath(), argument: { name: t4.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
    }
    if (jt(e4))
      return { $type: "FieldRef", value: { _ref: e4.name, _container: e4.modelName } };
    if (Array.isArray(e4))
      return bg(e4, t4);
    if (ArrayBuffer.isView(e4))
      return { $type: "Bytes", value: Buffer.from(e4).toString("base64") };
    if (xg(e4))
      return e4.values;
    if (qt(e4))
      return { $type: "Decimal", value: e4.toFixed() };
    if (e4 instanceof De) {
      if (e4 !== gn.instances[e4._getName()])
        throw new Error("Invalid ObjectEnumValue");
      return { $type: "Enum", value: e4._getName() };
    }
    if (wg(e4))
      return e4.toJSON();
    if (typeof e4 == "object")
      return Ul(e4, t4);
    t4.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t4.getSelectionPath(), argumentPath: t4.getArgumentPath(), argument: { name: t4.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(e4)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
  }
  function Ul(e4, t4) {
    if (e4.$type)
      return { $type: "Raw", value: e4 };
    let r2 = {};
    for (let n4 in e4) {
      let i = e4[n4];
      i !== undefined && (r2[n4] = Vl(i, t4.nestArgument(n4)));
    }
    return r2;
  }
  function bg(e4, t4) {
    let r2 = [];
    for (let n4 = 0;n4 < e4.length; n4++) {
      let i = t4.nestArgument(String(n4)), o4 = e4[n4];
      o4 === undefined && t4.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: i.getSelectionPath(), argumentPath: i.getArgumentPath(), argument: { name: `${t4.getArgumentName()}[${n4}]`, typeNames: [] }, underlyingError: "Can not use `undefined` value within array. Use `null` or filter out `undefined` values" }), r2.push(Vl(o4, i));
    }
    return r2;
  }
  function xg(e4) {
    return typeof e4 == "object" && e4 !== null && e4.__prismaRawParameters__ === true;
  }
  function wg(e4) {
    return typeof e4 == "object" && e4 !== null && typeof e4.toJSON == "function";
  }
  function Br(e4) {
    try {
      return Gl(e4, "fast");
    } catch {
      return Gl(e4, "slow");
    }
  }
  function Gl(e4, t4) {
    return JSON.stringify(e4.map((r2) => Eg(r2, t4)));
  }
  function Eg(e4, t4) {
    return typeof e4 == "bigint" ? { prisma__type: "bigint", prisma__value: e4.toString() } : Nt(e4) ? { prisma__type: "date", prisma__value: e4.toJSON() } : Ne.isDecimal(e4) ? { prisma__type: "decimal", prisma__value: e4.toJSON() } : Buffer.isBuffer(e4) ? { prisma__type: "bytes", prisma__value: e4.toString("base64") } : Pg(e4) || ArrayBuffer.isView(e4) ? { prisma__type: "bytes", prisma__value: Buffer.from(e4).toString("base64") } : typeof e4 == "object" && t4 === "slow" ? Hl(e4) : e4;
  }
  function Pg(e4) {
    return e4 instanceof ArrayBuffer || e4 instanceof SharedArrayBuffer ? true : typeof e4 == "object" && e4 !== null ? e4[Symbol.toStringTag] === "ArrayBuffer" || e4[Symbol.toStringTag] === "SharedArrayBuffer" : false;
  }
  function Hl(e4) {
    if (typeof e4 != "object" || e4 === null)
      return e4;
    if (typeof e4.toJSON == "function")
      return e4.toJSON();
    if (Array.isArray(e4))
      return e4.map(Jl);
    let t4 = {};
    for (let r2 of Object.keys(e4))
      t4[r2] = Jl(e4[r2]);
    return t4;
  }
  function Jl(e4) {
    return typeof e4 == "bigint" ? e4.toString() : Hl(e4);
  }
  function Oo(e4, t4, r2, n4) {
    if (!(e4 !== "postgresql" && e4 !== "cockroachdb") && r2.length > 0 && vg.exec(t4))
      throw new Error(`Running ALTER using ${n4} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
  }
  function Lo(e4) {
    return function(r2) {
      let n4, i = (o4 = e4) => {
        try {
          return o4 === undefined || o4?.kind === "itx" ? n4 ?? (n4 = Zl(r2(o4))) : Zl(r2(o4));
        } catch (s5) {
          return Promise.reject(s5);
        }
      };
      return { then(o4, s5) {
        return i().then(o4, s5);
      }, catch(o4) {
        return i().catch(o4);
      }, finally(o4) {
        return i().finally(o4);
      }, requestTransaction(o4) {
        let s5 = i(o4);
        return s5.requestTransaction ? s5.requestTransaction(o4) : s5;
      }, [Symbol.toStringTag]: "PrismaPromise" };
    };
  }
  function Zl(e4) {
    return typeof e4.then == "function" ? e4 : Promise.resolve(e4);
  }
  function eu(e4) {
    return e4.includes("tracing") ? new $o : Xl;
  }
  function tu(e4, t4 = () => {
  }) {
    let r2, n4 = new Promise((i) => r2 = i);
    return { then(i) {
      return --e4 === 0 && r2(t4()), i?.(n4);
    } };
  }
  function ru(e4) {
    return typeof e4 == "string" ? e4 : e4.reduce((t4, r2) => {
      let n4 = typeof r2 == "string" ? r2 : r2.level;
      return n4 === "query" ? t4 : t4 && (r2 === "info" || t4 === "info") ? "info" : n4;
    }, undefined);
  }
  function ii(e4) {
    return typeof e4.batchRequestIdx == "number";
  }
  function oi(e4) {
    return e4 === null ? e4 : Array.isArray(e4) ? e4.map(oi) : typeof e4 == "object" ? Tg(e4) ? _g(e4) : kt(e4, oi) : e4;
  }
  function Tg(e4) {
    return e4 !== null && typeof e4 == "object" && typeof e4.$type == "string";
  }
  function _g({ $type: e4, value: t4 }) {
    switch (e4) {
      case "BigInt":
        return BigInt(t4);
      case "Bytes":
        return Buffer.from(t4, "base64");
      case "DateTime":
        return new Date(t4);
      case "Decimal":
        return new Ne(t4);
      case "Json":
        return JSON.parse(t4);
      default:
        gt(t4, "Unknown tagged value");
    }
  }
  function nu(e4) {
    if (e4.action !== "findUnique" && e4.action !== "findUniqueOrThrow")
      return;
    let t4 = [];
    return e4.modelName && t4.push(e4.modelName), e4.query.arguments && t4.push(qo(e4.query.arguments)), t4.push(qo(e4.query.selection)), t4.join("");
  }
  function qo(e4) {
    return `(${Object.keys(e4).sort().map((r2) => {
      let n4 = e4[r2];
      return typeof n4 == "object" && n4 !== null ? `(${r2} ${qo(n4)})` : r2;
    }).join(" ")})`;
  }
  function jo(e4) {
    return Cg[e4];
  }
  function Rg(e4) {
    if (e4) {
      if (e4.kind === "batch")
        return { kind: "batch", options: { isolationLevel: e4.isolationLevel } };
      if (e4.kind === "itx")
        return { kind: "itx", options: ou(e4) };
      gt(e4, "Unknown transaction kind");
    }
  }
  function ou(e4) {
    return { id: e4.id, payload: e4.payload };
  }
  function Mg(e4, t4) {
    return ii(e4) && t4?.kind === "batch" && e4.batchRequestIdx !== t4.index;
  }
  function Sg(e4) {
    return e4.code === "P2009" || e4.code === "P2012";
  }
  function su(e4) {
    if (e4.kind === "Union")
      return { kind: "Union", errors: e4.errors.map(su) };
    if (Array.isArray(e4.selectionPath)) {
      let [, ...t4] = e4.selectionPath;
      return { ...e4, selectionPath: t4 };
    }
    return e4;
  }
  function uu(e4) {
    return e4.map((t4) => {
      let r2 = {};
      for (let n4 of Object.keys(t4))
        r2[n4] = cu(t4[n4]);
      return r2;
    });
  }
  function cu({ prisma__type: e4, prisma__value: t4 }) {
    switch (e4) {
      case "bigint":
        return BigInt(t4);
      case "bytes":
        return Buffer.from(t4, "base64");
      case "decimal":
        return new Ne(t4);
      case "datetime":
      case "date":
        return new Date(t4);
      case "time":
        return new Date(`1970-01-01T${t4}Z`);
      case "array":
        return t4.map(cu);
      default:
        return t4;
    }
  }
  function gu(e4, t4) {
    for (let [r2, n4] of Object.entries(e4)) {
      if (!pu.includes(r2)) {
        let i = Wt(r2, pu);
        throw new U(`Unknown property ${r2} provided to PrismaClient constructor.${i}`);
      }
      Dg[r2](n4, t4);
    }
    if (e4.datasourceUrl && e4.datasources)
      throw new U('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
  }
  function Wt(e4, t4) {
    if (t4.length === 0 || typeof e4 != "string")
      return "";
    let r2 = kg(e4, t4);
    return r2 ? ` Did you mean "${r2}"?` : "";
  }
  function kg(e4, t4) {
    if (t4.length === 0)
      return null;
    let r2 = t4.map((i) => ({ value: i, distance: (0, fu.default)(e4, i) }));
    r2.sort((i, o4) => i.distance < o4.distance ? -1 : 1);
    let n4 = r2[0];
    return n4.distance < 3 ? n4.value : null;
  }
  function yu(e4) {
    return e4.length === 0 ? Promise.resolve([]) : new Promise((t4, r2) => {
      let n4 = new Array(e4.length), i = null, o4 = false, s5 = 0, a3 = () => {
        o4 || (s5++, s5 === e4.length && (o4 = true, i ? r2(i) : t4(n4)));
      }, l5 = (u3) => {
        o4 || (o4 = true, r2(u3));
      };
      for (let u3 = 0;u3 < e4.length; u3++)
        e4[u3].then((c4) => {
          n4[u3] = c4, a3();
        }, (c4) => {
          if (!ii(c4)) {
            l5(c4);
            return;
          }
          c4.batchRequestIdx === u3 ? l5(c4) : (i || (i = c4), a3());
        });
    });
  }
  function Eu(e4) {

    class t4 {
      constructor(n4) {
        this._middlewares = new ni;
        this._createPrismaPromise = Lo();
        this.$extends = ja;
        e4 = { ...e4, ...n4?.__internal?.configOverride }, rl(e4), n4 && gu(n4, e4);
        let i = n4?.adapter ? Zi(n4.adapter) : undefined, o4 = new xu.EventEmitter().on("error", () => {
        });
        this._extensions = Ln.empty(), this._previewFeatures = Yn(e4), this._clientVersion = e4.clientVersion ?? lu, this._activeProvider = e4.activeProvider, this._tracingHelper = eu(this._previewFeatures);
        let s5 = { rootEnvPath: e4.relativeEnvPaths.rootEnvPath && Vr.default.resolve(e4.dirname, e4.relativeEnvPaths.rootEnvPath), schemaEnvPath: e4.relativeEnvPaths.schemaEnvPath && Vr.default.resolve(e4.dirname, e4.relativeEnvPaths.schemaEnvPath) }, a3 = !i && rr(s5, { conflictCheck: "none" }) || e4.injectableEdgeEnv?.();
        try {
          let l5 = n4 ?? {}, u3 = l5.__internal ?? {}, c4 = u3.debug === true;
          c4 && $.enable("prisma:client");
          let p3 = Vr.default.resolve(e4.dirname, e4.relativePath);
          wu.default.existsSync(p3) || (p3 = e4.dirname), lt("dirname", e4.dirname), lt("relativePath", e4.relativePath), lt("cwd", p3);
          let d3 = u3.engine || {};
          if (l5.errorFormat ? this._errorFormat = l5.errorFormat : process.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = e4.runtimeDataModel, this._engineConfig = { cwd: p3, dirname: e4.dirname, enableDebugLogs: c4, allowTriggerPanic: d3.allowTriggerPanic, datamodelPath: Vr.default.join(e4.dirname, e4.filename ?? "schema.prisma"), prismaPath: d3.binaryPath ?? undefined, engineEndpoint: d3.endpoint, generator: e4.generator, showColors: this._errorFormat === "pretty", logLevel: l5.log && ru(l5.log), logQueries: l5.log && !!(typeof l5.log == "string" ? l5.log === "query" : l5.log.find((f) => typeof f == "string" ? f === "query" : f.level === "query")), env: a3?.parsed ?? {}, flags: [], getQueryEngineWasmModule: e4.getQueryEngineWasmModule, clientVersion: e4.clientVersion, engineVersion: e4.engineVersion, previewFeatures: this._previewFeatures, activeProvider: e4.activeProvider, inlineSchema: e4.inlineSchema, overrideDatasources: nl2(l5, e4.datasourceNames), inlineDatasources: e4.inlineDatasources, inlineSchemaHash: e4.inlineSchemaHash, tracingHelper: this._tracingHelper, logEmitter: o4, isBundled: e4.isBundled, adapter: i }, lt("clientVersion", e4.clientVersion), this._engine = Sl(e4, this._engineConfig), this._requestHandler = new ai(this, o4), l5.log)
            for (let f of l5.log) {
              let h3 = typeof f == "string" ? f : f.emit === "stdout" ? f.level : null;
              h3 && this.$on(h3, (g) => {
                sr.log(`${sr.tags[h3] ?? ""}`, g.message || g.query);
              });
            }
          this._metrics = new Ft(this._engine);
        } catch (l5) {
          throw l5.clientVersion = this._clientVersion, l5;
        }
        return this._appliedParent = xr(this);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClient";
      }
      $use(n4) {
        this._middlewares.use(n4);
      }
      $on(n4, i) {
        n4 === "beforeExit" ? this._engine.onBeforeExit(i) : n4 && this._engineConfig.logEmitter.on(n4, i);
      }
      $connect() {
        try {
          return this._engine.start();
        } catch (n4) {
          throw n4.clientVersion = this._clientVersion, n4;
        }
      }
      async $disconnect() {
        try {
          await this._engine.stop();
        } catch (n4) {
          throw n4.clientVersion = this._clientVersion, n4;
        } finally {
          as();
        }
      }
      $executeRawInternal(n4, i, o4, s5) {
        let a3 = this._activeProvider;
        return this._request({ action: "executeRaw", args: o4, transaction: n4, clientMethod: i, argsMapper: No({ clientMethod: i, activeProvider: a3 }), callsite: it(this._errorFormat), dataPath: [], middlewareArgsMapper: s5 });
      }
      $executeRaw(n4, ...i) {
        return this._createPrismaPromise((o4) => {
          if (n4.raw !== undefined || n4.sql !== undefined) {
            let [s5, a3] = hu(n4, i);
            return Oo(this._activeProvider, s5.text, s5.values, Array.isArray(n4) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(o4, "$executeRaw", s5, a3);
          }
          throw new te("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
        });
      }
      $executeRawUnsafe(n4, ...i) {
        return this._createPrismaPromise((o4) => (Oo(this._activeProvider, n4, i, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(o4, "$executeRawUnsafe", [n4, ...i])));
      }
      $runCommandRaw(n4) {
        if (e4.activeProvider !== "mongodb")
          throw new te(`The ${e4.activeProvider} provider does not support \$runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
        return this._createPrismaPromise((i) => this._request({ args: n4, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: Kl, callsite: it(this._errorFormat), transaction: i }));
      }
      async $queryRawInternal(n4, i, o4, s5) {
        let a3 = this._activeProvider;
        return this._request({ action: "queryRaw", args: o4, transaction: n4, clientMethod: i, argsMapper: No({ clientMethod: i, activeProvider: a3 }), callsite: it(this._errorFormat), dataPath: [], middlewareArgsMapper: s5 }).then(uu);
      }
      $queryRaw(n4, ...i) {
        return this._createPrismaPromise((o4) => {
          if (n4.raw !== undefined || n4.sql !== undefined)
            return this.$queryRawInternal(o4, "$queryRaw", ...hu(n4, i));
          throw new te("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
        });
      }
      $queryRawUnsafe(n4, ...i) {
        return this._createPrismaPromise((o4) => this.$queryRawInternal(o4, "$queryRawUnsafe", [n4, ...i]));
      }
      _transactionWithArray({ promises: n4, options: i }) {
        let o4 = Ng.nextId(), s5 = tu(n4.length), a3 = n4.map((l5, u3) => {
          if (l5?.[Symbol.toStringTag] !== "PrismaPromise")
            throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
          let c4 = i?.isolationLevel, p3 = { kind: "batch", id: o4, index: u3, isolationLevel: c4, lock: s5 };
          return l5.requestTransaction?.(p3) ?? l5;
        });
        return yu(a3);
      }
      async _transactionWithCallback({ callback: n4, options: i }) {
        let o4 = { traceparent: this._tracingHelper.getTraceParent() }, s5 = await this._engine.transaction("start", o4, i), a3;
        try {
          let l5 = { kind: "itx", ...s5 };
          a3 = await n4(this._createItxClient(l5)), await this._engine.transaction("commit", o4, s5);
        } catch (l5) {
          throw await this._engine.transaction("rollback", o4, s5).catch(() => {
          }), l5;
        }
        return a3;
      }
      _createItxClient(n4) {
        return xr(Fe(Fn(this), [pe("_appliedParent", () => this._appliedParent._createItxClient(n4)), pe("_createPrismaPromise", () => Lo(n4)), pe(Og, () => n4.id), gr(Hi)]));
      }
      $transaction(n4, i) {
        let o4;
        typeof n4 == "function" ? o4 = () => this._transactionWithCallback({ callback: n4, options: i }) : o4 = () => this._transactionWithArray({ promises: n4, options: i });
        let s5 = { name: "transaction", attributes: { method: "$transaction" } };
        return this._tracingHelper.runInChildSpan(s5, o4);
      }
      _request(n4) {
        n4.otelParentCtx = this._tracingHelper.getActiveContext();
        let i = n4.middlewareArgsMapper ?? Fg, o4 = { args: i.requestArgsToMiddlewareArgs(n4.args), dataPath: n4.dataPath, runInTransaction: !!n4.transaction, action: n4.action, model: n4.model }, s5 = { middleware: { name: "middleware", middleware: true, attributes: { method: "$use" }, active: false }, operation: { name: "operation", attributes: { method: o4.action, model: o4.model, name: o4.model ? `${o4.model}.${o4.action}` : o4.action } } }, a3 = -1, l5 = async (u3) => {
          let c4 = this._middlewares.get(++a3);
          if (c4)
            return this._tracingHelper.runInChildSpan(s5.middleware, (_) => c4(u3, (A) => (_?.end(), l5(A))));
          let { runInTransaction: p3, args: d3, ...f } = u3, h3 = { ...n4, ...f };
          d3 && (h3.args = i.middlewareArgsToRequestArgs(d3)), n4.transaction !== undefined && p3 === false && delete h3.transaction;
          let g = await Ja(this, h3);
          return h3.model ? Ua({ result: g, modelName: h3.model, args: h3.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel }) : g;
        };
        return this._tracingHelper.runInChildSpan(s5.operation, () => new bu.AsyncResource("prisma-client-request").runInAsyncScope(() => l5(o4)));
      }
      async _executeRequest({ args: n4, clientMethod: i, dataPath: o4, callsite: s5, action: a3, model: l5, argsMapper: u3, transaction: c4, unpacker: p3, otelParentCtx: d3, customDataProxyFetch: f }) {
        try {
          n4 = u3 ? u3(n4) : n4;
          let h3 = { name: "serialize" }, g = this._tracingHelper.runInChildSpan(h3, () => Bl({ modelName: l5, runtimeDataModel: this._runtimeDataModel, action: a3, args: n4, clientMethod: i, callsite: s5, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion }));
          return $.enabled("prisma:client") && (lt("Prisma Client call:"), lt(`prisma.${i}(${Pa(n4)})`), lt("Generated request:"), lt(JSON.stringify(g, null, 2) + `
`)), c4?.kind === "batch" && await c4.lock, this._requestHandler.request({ protocolQuery: g, modelName: l5, action: a3, clientMethod: i, dataPath: o4, callsite: s5, args: n4, extensions: this._extensions, transaction: c4, unpacker: p3, otelParentCtx: d3, otelChildCtx: this._tracingHelper.getActiveContext(), customDataProxyFetch: f });
        } catch (h3) {
          throw h3.clientVersion = this._clientVersion, h3;
        }
      }
      get $metrics() {
        if (!this._hasPreviewFlag("metrics"))
          throw new te("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: this._clientVersion });
        return this._metrics;
      }
      _hasPreviewFlag(n4) {
        return !!this._engineConfig.previewFeatures?.includes(n4);
      }
    }
    return t4;
  }
  function hu(e4, t4) {
    return Lg(e4) ? [new fe(e4, t4), zl] : [e4, Yl];
  }
  function Lg(e4) {
    return Array.isArray(e4) && Array.isArray(e4.raw);
  }
  function Pu(e4) {
    return new Proxy(e4, { get(t4, r2) {
      if (r2 in t4)
        return t4[r2];
      if (!$g.has(r2))
        throw new TypeError(`Invalid enum value: ${String(r2)}`);
    } });
  }
  function vu(e4) {
    rr(e4, { conflictCheck: "warn" });
  }
  var __dirname = "/home/joel/Documentos/proyectos-javascript/JugueteriaApi/sisventa/prisma/client/runtime", __filename = "/home/joel/Documentos/proyectos-javascript/JugueteriaApi/sisventa/prisma/client/runtime/library.js";
  var Tu = Object.create;
  var Kr = Object.defineProperty;
  var _u = Object.getOwnPropertyDescriptor;
  var Cu = Object.getOwnPropertyNames;
  var Au = Object.getPrototypeOf;
  var Ru = Object.prototype.hasOwnProperty;
  var Q = (e4, t4) => () => (t4 || e4((t4 = { exports: {} }).exports, t4), t4.exports);
  var Tt = (e4, t4) => {
    for (var r2 in t4)
      Kr(e4, r2, { get: t4[r2], enumerable: true });
  };
  var Bo = (e4, t4, r2, n4) => {
    if (t4 && typeof t4 == "object" || typeof t4 == "function")
      for (let i of Cu(t4))
        !Ru.call(e4, i) && i !== r2 && Kr(e4, i, { get: () => t4[i], enumerable: !(n4 = _u(t4, i)) || n4.enumerable });
    return e4;
  };
  var D = (e4, t4, r2) => (r2 = e4 != null ? Tu(Au(e4)) : {}, Bo(t4 || !e4 || !e4.__esModule ? Kr(r2, "default", { value: e4, enumerable: true }) : r2, e4));
  var Mu = (e4) => Bo(Kr({}, "__esModule", { value: true }), e4);
  var Yo = Q((Yg, zo) => {
    var _t = 1000, Ct = _t * 60, At = Ct * 60, ct = At * 24, Su = ct * 7, Iu = ct * 365.25;
    zo.exports = function(e4, t4) {
      t4 = t4 || {};
      var r2 = typeof e4;
      if (r2 === "string" && e4.length > 0)
        return Du(e4);
      if (r2 === "number" && isFinite(e4))
        return t4.long ? Fu(e4) : ku(e4);
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e4));
    };
    function Du(e4) {
      if (e4 = String(e4), !(e4.length > 100)) {
        var t4 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e4);
        if (t4) {
          var r2 = parseFloat(t4[1]), n4 = (t4[2] || "ms").toLowerCase();
          switch (n4) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return r2 * Iu;
            case "weeks":
            case "week":
            case "w":
              return r2 * Su;
            case "days":
            case "day":
            case "d":
              return r2 * ct;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return r2 * At;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return r2 * Ct;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return r2 * _t;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return r2;
            default:
              return;
          }
        }
      }
    }
    function ku(e4) {
      var t4 = Math.abs(e4);
      return t4 >= ct ? Math.round(e4 / ct) + "d" : t4 >= At ? Math.round(e4 / At) + "h" : t4 >= Ct ? Math.round(e4 / Ct) + "m" : t4 >= _t ? Math.round(e4 / _t) + "s" : e4 + "ms";
    }
    function Fu(e4) {
      var t4 = Math.abs(e4);
      return t4 >= ct ? Gr(e4, t4, ct, "day") : t4 >= At ? Gr(e4, t4, At, "hour") : t4 >= Ct ? Gr(e4, t4, Ct, "minute") : t4 >= _t ? Gr(e4, t4, _t, "second") : e4 + " ms";
    }
    function Gr(e4, t4, r2, n4) {
      var i = t4 >= r2 * 1.5;
      return Math.round(e4 / r2) + " " + n4 + (i ? "s" : "");
    }
  });
  var mi = Q((Zg, Zo) => {
    function Ou(e4) {
      r2.debug = r2, r2.default = r2, r2.coerce = l5, r2.disable = o4, r2.enable = i, r2.enabled = s5, r2.humanize = Yo(), r2.destroy = u3, Object.keys(e4).forEach((c4) => {
        r2[c4] = e4[c4];
      }), r2.names = [], r2.skips = [], r2.formatters = {};
      function t4(c4) {
        let p3 = 0;
        for (let d3 = 0;d3 < c4.length; d3++)
          p3 = (p3 << 5) - p3 + c4.charCodeAt(d3), p3 |= 0;
        return r2.colors[Math.abs(p3) % r2.colors.length];
      }
      r2.selectColor = t4;
      function r2(c4) {
        let p3, d3 = null, f, h3;
        function g(..._) {
          if (!g.enabled)
            return;
          let A = g, R3 = Number(new Date), E = R3 - (p3 || R3);
          A.diff = E, A.prev = p3, A.curr = R3, p3 = R3, _[0] = r2.coerce(_[0]), typeof _[0] != "string" && _.unshift("%O");
          let S = 0;
          _[0] = _[0].replace(/%([a-zA-Z%])/g, (X, ut) => {
            if (X === "%%")
              return "%";
            S++;
            let K = r2.formatters[ut];
            if (typeof K == "function") {
              let ie = _[S];
              X = K.call(A, ie), _.splice(S, 1), S--;
            }
            return X;
          }), r2.formatArgs.call(A, _), (A.log || r2.log).apply(A, _);
        }
        return g.namespace = c4, g.useColors = r2.useColors(), g.color = r2.selectColor(c4), g.extend = n4, g.destroy = r2.destroy, Object.defineProperty(g, "enabled", { enumerable: true, configurable: false, get: () => d3 !== null ? d3 : (f !== r2.namespaces && (f = r2.namespaces, h3 = r2.enabled(c4)), h3), set: (_) => {
          d3 = _;
        } }), typeof r2.init == "function" && r2.init(g), g;
      }
      function n4(c4, p3) {
        let d3 = r2(this.namespace + (typeof p3 > "u" ? ":" : p3) + c4);
        return d3.log = this.log, d3;
      }
      function i(c4) {
        r2.save(c4), r2.namespaces = c4, r2.names = [], r2.skips = [];
        let p3, d3 = (typeof c4 == "string" ? c4 : "").split(/[\s,]+/), f = d3.length;
        for (p3 = 0;p3 < f; p3++)
          d3[p3] && (c4 = d3[p3].replace(/\*/g, ".*?"), c4[0] === "-" ? r2.skips.push(new RegExp("^" + c4.slice(1) + "$")) : r2.names.push(new RegExp("^" + c4 + "$")));
      }
      function o4() {
        let c4 = [...r2.names.map(a3), ...r2.skips.map(a3).map((p3) => "-" + p3)].join(",");
        return r2.enable(""), c4;
      }
      function s5(c4) {
        if (c4[c4.length - 1] === "*")
          return true;
        let p3, d3;
        for (p3 = 0, d3 = r2.skips.length;p3 < d3; p3++)
          if (r2.skips[p3].test(c4))
            return false;
        for (p3 = 0, d3 = r2.names.length;p3 < d3; p3++)
          if (r2.names[p3].test(c4))
            return true;
        return false;
      }
      function a3(c4) {
        return c4.toString().substring(2, c4.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function l5(c4) {
        return c4 instanceof Error ? c4.stack || c4.message : c4;
      }
      function u3() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      return r2.enable(r2.load()), r2;
    }
    Zo.exports = Ou;
  });
  var Xo = Q((he, Jr) => {
    he.formatArgs = Lu;
    he.save = $u;
    he.load = qu;
    he.useColors = Nu;
    he.storage = ju();
    he.destroy = (() => {
      let e4 = false;
      return () => {
        e4 || (e4 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })();
    he.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
    function Nu() {
      return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? true : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? false : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function Lu(e4) {
      if (e4[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e4[0] + (this.useColors ? "%c " : " ") + "+" + Jr.exports.humanize(this.diff), !this.useColors)
        return;
      let t4 = "color: " + this.color;
      e4.splice(1, 0, t4, "color: inherit");
      let r2 = 0, n4 = 0;
      e4[0].replace(/%[a-zA-Z%]/g, (i) => {
        i !== "%%" && (r2++, i === "%c" && (n4 = r2));
      }), e4.splice(n4, 0, t4);
    }
    he.log = console.debug || console.log || (() => {
    });
    function $u(e4) {
      try {
        e4 ? he.storage.setItem("debug", e4) : he.storage.removeItem("debug");
      } catch {
      }
    }
    function qu() {
      let e4;
      try {
        e4 = he.storage.getItem("debug");
      } catch {
      }
      return !e4 && typeof process < "u" && "env" in process && (e4 = process.env.DEBUG), e4;
    }
    function ju() {
      try {
        return localStorage;
      } catch {
      }
    }
    Jr.exports = mi()(he);
    var { formatters: Bu } = Jr.exports;
    Bu.j = function(e4) {
      try {
        return JSON.stringify(e4);
      } catch (t4) {
        return "[UnexpectedJSONParseError]: " + t4.message;
      }
    };
  });
  var fi = Q((Xg, es) => {
    es.exports = (e4, t4 = process.argv) => {
      let r2 = e4.startsWith("-") ? "" : e4.length === 1 ? "-" : "--", n4 = t4.indexOf(r2 + e4), i = t4.indexOf("--");
      return n4 !== -1 && (i === -1 || n4 < i);
    };
  });
  var hi = Q((ey, rs) => {
    var Vu = import.meta.require("os"), ts = import.meta.require("tty"), Pe = fi(), { env: J } = process, Je;
    Pe("no-color") || Pe("no-colors") || Pe("color=false") || Pe("color=never") ? Je = 0 : (Pe("color") || Pe("colors") || Pe("color=true") || Pe("color=always")) && (Je = 1);
    "FORCE_COLOR" in J && (J.FORCE_COLOR === "true" ? Je = 1 : J.FORCE_COLOR === "false" ? Je = 0 : Je = J.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(J.FORCE_COLOR, 10), 3));
    function gi(e4) {
      return e4 === 0 ? false : { level: e4, hasBasic: true, has256: e4 >= 2, has16m: e4 >= 3 };
    }
    function yi(e4, t4) {
      if (Je === 0)
        return 0;
      if (Pe("color=16m") || Pe("color=full") || Pe("color=truecolor"))
        return 3;
      if (Pe("color=256"))
        return 2;
      if (e4 && !t4 && Je === undefined)
        return 0;
      let r2 = Je || 0;
      if (J.TERM === "dumb")
        return r2;
      if (process.platform === "win32") {
        let n4 = Vu.release().split(".");
        return Number(n4[0]) >= 10 && Number(n4[2]) >= 10586 ? Number(n4[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in J)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((n4) => (n4 in J)) || J.CI_NAME === "codeship" ? 1 : r2;
      if ("TEAMCITY_VERSION" in J)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(J.TEAMCITY_VERSION) ? 1 : 0;
      if (J.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in J) {
        let n4 = parseInt((J.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (J.TERM_PROGRAM) {
          case "iTerm.app":
            return n4 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(J.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(J.TERM) || ("COLORTERM" in J) ? 1 : r2;
    }
    function Uu(e4) {
      let t4 = yi(e4, e4 && e4.isTTY);
      return gi(t4);
    }
    rs.exports = { supportsColor: Uu, stdout: gi(yi(true, ts.isatty(1))), stderr: gi(yi(true, ts.isatty(2))) };
  });
  var is = Q((ee, Wr) => {
    var Ku = import.meta.require("tty"), Hr = import.meta.require("util");
    ee.init = Yu;
    ee.log = Hu;
    ee.formatArgs = Gu;
    ee.save = Wu;
    ee.load = zu;
    ee.useColors = Qu;
    ee.destroy = Hr.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    ee.colors = [6, 2, 3, 4, 5, 1];
    try {
      let e4 = hi();
      e4 && (e4.stderr || e4).level >= 2 && (ee.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
    } catch {
    }
    ee.inspectOpts = Object.keys(process.env).filter((e4) => /^debug_/i.test(e4)).reduce((e4, t4) => {
      let r2 = t4.substring(6).toLowerCase().replace(/_([a-z])/g, (i, o4) => o4.toUpperCase()), n4 = process.env[t4];
      return /^(yes|on|true|enabled)$/i.test(n4) ? n4 = true : /^(no|off|false|disabled)$/i.test(n4) ? n4 = false : n4 === "null" ? n4 = null : n4 = Number(n4), e4[r2] = n4, e4;
    }, {});
    function Qu() {
      return "colors" in ee.inspectOpts ? !!ee.inspectOpts.colors : Ku.isatty(process.stderr.fd);
    }
    function Gu(e4) {
      let { namespace: t4, useColors: r2 } = this;
      if (r2) {
        let n4 = this.color, i = "\x1B[3" + (n4 < 8 ? n4 : "8;5;" + n4), o4 = `  ${i};1m${t4} \x1B[0m`;
        e4[0] = o4 + e4[0].split(`
`).join(`
` + o4), e4.push(i + "m+" + Wr.exports.humanize(this.diff) + "\x1B[0m");
      } else
        e4[0] = Ju() + t4 + " " + e4[0];
    }
    function Ju() {
      return ee.inspectOpts.hideDate ? "" : new Date().toISOString() + " ";
    }
    function Hu(...e4) {
      return process.stderr.write(Hr.format(...e4) + `
`);
    }
    function Wu(e4) {
      e4 ? process.env.DEBUG = e4 : delete process.env.DEBUG;
    }
    function zu() {
      return process.env.DEBUG;
    }
    function Yu(e4) {
      e4.inspectOpts = {};
      let t4 = Object.keys(ee.inspectOpts);
      for (let r2 = 0;r2 < t4.length; r2++)
        e4.inspectOpts[t4[r2]] = ee.inspectOpts[t4[r2]];
    }
    Wr.exports = mi()(ee);
    var { formatters: ns } = Wr.exports;
    ns.o = function(e4) {
      return this.inspectOpts.colors = this.useColors, Hr.inspect(e4, this.inspectOpts).split(`
`).map((t4) => t4.trim()).join(" ");
    };
    ns.O = function(e4) {
      return this.inspectOpts.colors = this.useColors, Hr.inspect(e4, this.inspectOpts);
    };
  });
  var os = Q((ty, bi) => {
    typeof process > "u" || process.type === "renderer" || false || process.__nwjs ? bi.exports = Xo() : bi.exports = is();
  });
  var gs = Q((Ly, Ci) => {
    var M = Ci.exports;
    Ci.exports.default = M;
    var F = "\x1B[", Zt = "\x1B]", St = "\x07", rn = ";", fs2 = false;
    M.cursorTo = (e4, t4) => {
      if (typeof e4 != "number")
        throw new TypeError("The `x` argument is required");
      return typeof t4 != "number" ? F + (e4 + 1) + "G" : F + (t4 + 1) + ";" + (e4 + 1) + "H";
    };
    M.cursorMove = (e4, t4) => {
      if (typeof e4 != "number")
        throw new TypeError("The `x` argument is required");
      let r2 = "";
      return e4 < 0 ? r2 += F + -e4 + "D" : e4 > 0 && (r2 += F + e4 + "C"), t4 < 0 ? r2 += F + -t4 + "A" : t4 > 0 && (r2 += F + t4 + "B"), r2;
    };
    M.cursorUp = (e4 = 1) => F + e4 + "A";
    M.cursorDown = (e4 = 1) => F + e4 + "B";
    M.cursorForward = (e4 = 1) => F + e4 + "C";
    M.cursorBackward = (e4 = 1) => F + e4 + "D";
    M.cursorLeft = F + "G";
    M.cursorSavePosition = fs2 ? "\x1B7" : F + "s";
    M.cursorRestorePosition = fs2 ? "\x1B8" : F + "u";
    M.cursorGetPosition = F + "6n";
    M.cursorNextLine = F + "E";
    M.cursorPrevLine = F + "F";
    M.cursorHide = F + "?25l";
    M.cursorShow = F + "?25h";
    M.eraseLines = (e4) => {
      let t4 = "";
      for (let r2 = 0;r2 < e4; r2++)
        t4 += M.eraseLine + (r2 < e4 - 1 ? M.cursorUp() : "");
      return e4 && (t4 += M.cursorLeft), t4;
    };
    M.eraseEndLine = F + "K";
    M.eraseStartLine = F + "1K";
    M.eraseLine = F + "2K";
    M.eraseDown = F + "J";
    M.eraseUp = F + "1J";
    M.eraseScreen = F + "2J";
    M.scrollUp = F + "S";
    M.scrollDown = F + "T";
    M.clearScreen = "\x1Bc";
    M.clearTerminal = process.platform === "win32" ? `${M.eraseScreen}${F}0f` : `${M.eraseScreen}${F}3J${F}H`;
    M.beep = St;
    M.link = (e4, t4) => [Zt, "8", rn, rn, t4, St, e4, Zt, "8", rn, rn, St].join("");
    M.image = (e4, t4 = {}) => {
      let r2 = `${Zt}1337;File=inline=1`;
      return t4.width && (r2 += `;width=${t4.width}`), t4.height && (r2 += `;height=${t4.height}`), t4.preserveAspectRatio === false && (r2 += ";preserveAspectRatio=0"), r2 + ":" + e4.toString("base64") + St;
    };
    M.iTerm = { setCwd: (e4 = process.cwd()) => `${Zt}50;CurrentDir=${e4}${St}`, annotation: (e4, t4 = {}) => {
      let r2 = `${Zt}1337;`, n4 = typeof t4.x < "u", i = typeof t4.y < "u";
      if ((n4 || i) && !(n4 && i && typeof t4.length < "u"))
        throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
      return e4 = e4.replace(/\|/g, ""), r2 += t4.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=", t4.length > 0 ? r2 += (n4 ? [e4, t4.length, t4.x, t4.y] : [t4.length, e4]).join("|") : r2 += e4, r2 + St;
    } };
  });
  var bs = Q(($y, hs) => {
    var ic = hi(), It = fi();
    function ys(e4) {
      if (/^\d{3,4}$/.test(e4)) {
        let r2 = /(\d{1,2})(\d{2})/.exec(e4);
        return { major: 0, minor: parseInt(r2[1], 10), patch: parseInt(r2[2], 10) };
      }
      let t4 = (e4 || "").split(".").map((r2) => parseInt(r2, 10));
      return { major: t4[0], minor: t4[1], patch: t4[2] };
    }
    function Ai(e4) {
      let { env: t4 } = process;
      if ("FORCE_HYPERLINK" in t4)
        return !(t4.FORCE_HYPERLINK.length > 0 && parseInt(t4.FORCE_HYPERLINK, 10) === 0);
      if (It("no-hyperlink") || It("no-hyperlinks") || It("hyperlink=false") || It("hyperlink=never"))
        return false;
      if (It("hyperlink=true") || It("hyperlink=always") || "NETLIFY" in t4)
        return true;
      if (!ic.supportsColor(e4) || e4 && !e4.isTTY || process.platform === "win32" || "CI" in t4 || "TEAMCITY_VERSION" in t4)
        return false;
      if ("TERM_PROGRAM" in t4) {
        let r2 = ys(t4.TERM_PROGRAM_VERSION);
        switch (t4.TERM_PROGRAM) {
          case "iTerm.app":
            return r2.major === 3 ? r2.minor >= 1 : r2.major > 3;
          case "WezTerm":
            return r2.major >= 20200620;
          case "vscode":
            return r2.major > 1 || r2.major === 1 && r2.minor >= 72;
        }
      }
      if ("VTE_VERSION" in t4) {
        if (t4.VTE_VERSION === "0.50.0")
          return false;
        let r2 = ys(t4.VTE_VERSION);
        return r2.major > 0 || r2.minor >= 50;
      }
      return false;
    }
    hs.exports = { supportsHyperlink: Ai, stdout: Ai(process.stdout), stderr: Ai(process.stderr) };
  });
  var ws2 = Q((qy, Xt) => {
    var oc = gs(), Ri = bs(), xs = (e4, t4, { target: r2 = "stdout", ...n4 } = {}) => Ri[r2] ? oc.link(e4, t4) : n4.fallback === false ? e4 : typeof n4.fallback == "function" ? n4.fallback(e4, t4) : `${e4} (\u200B${t4}\u200B)`;
    Xt.exports = (e4, t4, r2 = {}) => xs(e4, t4, r2);
    Xt.exports.stderr = (e4, t4, r2 = {}) => xs(e4, t4, { target: "stderr", ...r2 });
    Xt.exports.isSupported = Ri.stdout;
    Xt.exports.stderr.isSupported = Ri.stderr;
  });
  var Ss = Q((rh, wc) => {
    wc.exports = { name: "dotenv", version: "16.0.3", description: "Loads environment variables from .env file", main: "lib/main.js", types: "lib/main.d.ts", exports: { ".": { require: "./lib/main.js", types: "./lib/main.d.ts", default: "./lib/main.js" }, "./config": "./config.js", "./config.js": "./config.js", "./lib/env-options": "./lib/env-options.js", "./lib/env-options.js": "./lib/env-options.js", "./lib/cli-options": "./lib/cli-options.js", "./lib/cli-options.js": "./lib/cli-options.js", "./package.json": "./package.json" }, scripts: { "dts-check": "tsc --project tests/types/tsconfig.json", lint: "standard", "lint-readme": "standard-markdown", pretest: "npm run lint && npm run dts-check", test: "tap tests/*.js --100 -Rspec", prerelease: "npm test", release: "standard-version" }, repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" }, keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"], readmeFilename: "README.md", license: "BSD-2-Clause", devDependencies: { "@types/node": "^17.0.9", decache: "^4.6.1", dtslint: "^3.7.0", sinon: "^12.0.1", standard: "^16.0.4", "standard-markdown": "^7.1.0", "standard-version": "^9.3.2", tap: "^15.1.6", tar: "^6.1.11", typescript: "^4.5.4" }, engines: { node: ">=12" } };
  });
  var Ds = Q((nh, ln) => {
    var Ec = import.meta.require("fs"), Is = import.meta.require("path"), Pc = import.meta.require("os"), vc = Ss(), Tc = vc.version, _c = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function Cc(e4) {
      let t4 = {}, r2 = e4.toString();
      r2 = r2.replace(/\r\n?/mg, `
`);
      let n4;
      for (;(n4 = _c.exec(r2)) != null; ) {
        let i = n4[1], o4 = n4[2] || "";
        o4 = o4.trim();
        let s5 = o4[0];
        o4 = o4.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), s5 === '"' && (o4 = o4.replace(/\\n/g, `
`), o4 = o4.replace(/\\r/g, "\r")), t4[i] = o4;
      }
      return t4;
    }
    function Ii(e4) {
      console.log(`[dotenv@${Tc}][DEBUG] ${e4}`);
    }
    function Ac(e4) {
      return e4[0] === "~" ? Is.join(Pc.homedir(), e4.slice(1)) : e4;
    }
    function Rc(e4) {
      let t4 = Is.resolve(process.cwd(), ".env"), r2 = "utf8", n4 = !!(e4 && e4.debug), i = !!(e4 && e4.override);
      e4 && (e4.path != null && (t4 = Ac(e4.path)), e4.encoding != null && (r2 = e4.encoding));
      try {
        let o4 = an.parse(Ec.readFileSync(t4, { encoding: r2 }));
        return Object.keys(o4).forEach(function(s5) {
          Object.prototype.hasOwnProperty.call(process.env, s5) ? (i === true && (process.env[s5] = o4[s5]), n4 && Ii(i === true ? `"${s5}" is already defined in \`process.env\` and WAS overwritten` : `"${s5}" is already defined in \`process.env\` and was NOT overwritten`)) : process.env[s5] = o4[s5];
        }), { parsed: o4 };
      } catch (o4) {
        return n4 && Ii(`Failed to load ${t4} ${o4.message}`), { error: o4 };
      }
    }
    var an = { config: Rc, parse: Cc };
    ln.exports.config = an.config;
    ln.exports.parse = an.parse;
    ln.exports = an;
  });
  var $s = Q((ch, Ls) => {
    Ls.exports = (e4) => {
      let t4 = e4.match(/^[ \t]*(?=\S)/gm);
      return t4 ? t4.reduce((r2, n4) => Math.min(r2, n4.length), 1 / 0) : 0;
    };
  });
  var js = Q((ph, qs) => {
    var Dc = $s();
    qs.exports = (e4) => {
      let t4 = Dc(e4);
      if (t4 === 0)
        return e4;
      let r2 = new RegExp(`^[ \\t]{${t4}}`, "gm");
      return e4.replace(r2, "");
    };
  });
  var Bs = Q((dh, kc) => {
    kc.exports = { name: "@prisma/engines-version", version: "5.9.0-32.23fdc5965b1e05fc54e5f26ed3de66776b93de64", main: "index.js", types: "index.d.ts", license: "Apache-2.0", author: "Tim Suchanek <suchanek@prisma.io>", prisma: { enginesVersion: "23fdc5965b1e05fc54e5f26ed3de66776b93de64" }, repository: { type: "git", url: "https://github.com/prisma/engines-wrapper.git", directory: "packages/engines-version" }, devDependencies: { "@types/node": "18.19.8", typescript: "4.9.5" }, files: ["index.js", "index.d.ts"], scripts: { build: "tsc -d" } };
  });
  var Fi = Q((cn) => {
    Object.defineProperty(cn, "__esModule", { value: true });
    cn.enginesVersion = undefined;
    cn.enginesVersion = Bs().prisma.enginesVersion;
  });
  var qi = Q((Dh, Ks) => {
    Ks.exports = (e4, t4 = 1, r2) => {
      if (r2 = { indent: " ", includeEmptyLines: false, ...r2 }, typeof e4 != "string")
        throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e4}\``);
      if (typeof t4 != "number")
        throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t4}\``);
      if (typeof r2.indent != "string")
        throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r2.indent}\``);
      if (t4 === 0)
        return e4;
      let n4 = r2.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return e4.replace(n4, r2.indent.repeat(t4));
    };
  });
  var Hs = Q((Oh, Js) => {
    Js.exports = ({ onlyFirst: e4 = false } = {}) => {
      let t4 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(t4, e4 ? undefined : "g");
    };
  });
  var Ui = Q((Nh, Ws) => {
    var Uc = Hs();
    Ws.exports = (e4) => typeof e4 == "string" ? e4.replace(Uc(), "") : e4;
  });
  var zs = Q((qh, dn) => {
    dn.exports = (e4 = {}) => {
      let t4;
      if (e4.repoUrl)
        t4 = e4.repoUrl;
      else if (e4.user && e4.repo)
        t4 = `https://github.com/${e4.user}/${e4.repo}`;
      else
        throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
      let r2 = new URL(`${t4}/issues/new`), n4 = ["body", "title", "labels", "template", "milestone", "assignee", "projects"];
      for (let i of n4) {
        let o4 = e4[i];
        if (o4 !== undefined) {
          if (i === "labels" || i === "projects") {
            if (!Array.isArray(o4))
              throw new TypeError(`The \`${i}\` option should be an array`);
            o4 = o4.join(",");
          }
          r2.searchParams.set(i, o4);
        }
      }
      return r2.toString();
    };
    dn.exports.default = dn.exports;
  });
  var Do = Q((MT, Il) => {
    Il.exports = function() {
      function e4(t4, r2, n4, i, o4) {
        return t4 < r2 || n4 < r2 ? t4 > n4 ? n4 + 1 : t4 + 1 : i === o4 ? r2 : r2 + 1;
      }
      return function(t4, r2) {
        if (t4 === r2)
          return 0;
        if (t4.length > r2.length) {
          var n4 = t4;
          t4 = r2, r2 = n4;
        }
        for (var i = t4.length, o4 = r2.length;i > 0 && t4.charCodeAt(i - 1) === r2.charCodeAt(o4 - 1); )
          i--, o4--;
        for (var s5 = 0;s5 < i && t4.charCodeAt(s5) === r2.charCodeAt(s5); )
          s5++;
        if (i -= s5, o4 -= s5, i === 0 || o4 < 3)
          return o4;
        var a3 = 0, l5, u3, c4, p3, d3, f, h3, g, _, A, R3, E, S = [];
        for (l5 = 0;l5 < i; l5++)
          S.push(l5 + 1), S.push(t4.charCodeAt(s5 + l5));
        for (var we = S.length - 1;a3 < o4 - 3; )
          for (_ = r2.charCodeAt(s5 + (u3 = a3)), A = r2.charCodeAt(s5 + (c4 = a3 + 1)), R3 = r2.charCodeAt(s5 + (p3 = a3 + 2)), E = r2.charCodeAt(s5 + (d3 = a3 + 3)), f = a3 += 4, l5 = 0;l5 < we; l5 += 2)
            h3 = S[l5], g = S[l5 + 1], u3 = e4(h3, u3, c4, _, g), c4 = e4(u3, c4, p3, A, g), p3 = e4(c4, p3, d3, R3, g), f = e4(p3, d3, f, E, g), S[l5] = f, d3 = p3, p3 = c4, c4 = u3, u3 = h3;
        for (;a3 < o4; )
          for (_ = r2.charCodeAt(s5 + (u3 = a3)), f = ++a3, l5 = 0;l5 < we; l5 += 2)
            h3 = S[l5], S[l5] = f = e4(h3, u3, f, _, S[l5 + 1]), u3 = h3;
        return f;
      };
    }();
  });
  var qg = {};
  Tt(qg, { DMMF: () => Ee, DMMFClass: () => Qr, Debug: () => xi, Decimal: () => Ne, Extensions: () => ui, MetricsClient: () => Ft, NotFoundError: () => Ve, ObjectEnumValue: () => De, PrismaClientInitializationError: () => O, PrismaClientKnownRequestError: () => H3, PrismaClientRustPanicError: () => be, PrismaClientUnknownRequestError: () => W, PrismaClientValidationError: () => te, Public: () => ci, Sql: () => fe, Types: () => pi, defineDmmfProperty: () => Zs, detectRuntime: () => $n, empty: () => ea, getPrismaClient: () => Eu, itxClientDenyList: () => Hi, join: () => Xs, makeStrictEnum: () => Pu, objectEnumNames: () => Gc, objectEnumValues: () => gn, raw: () => Xi, sqltag: () => eo, warnEnvConflicts: () => vu, warnOnce: () => ar });
  module.exports = Mu(qg);
  var ui = {};
  Tt(ui, { defineExtension: () => Vo, getExtensionContext: () => Uo });
  var ci = {};
  Tt(ci, { validator: () => Ko });
  var pi = {};
  Tt(pi, { Extensions: () => Qo, Public: () => Go, Result: () => Jo, Utils: () => Ho });
  var Qo = {};
  var Go = {};
  var Jo = {};
  var Ho = {};
  var Ge = (e4, t4) => {
    let r2 = {};
    for (let n4 of e4) {
      let i = n4[t4];
      r2[i] = n4;
    }
    return r2;
  };
  var Qr = class {
    constructor(t4) {
      this.document = t4;
    }
    get compositeNames() {
      return this._compositeNames ?? (this._compositeNames = new Set(this.datamodel.types.map((t4) => t4.name)));
    }
    get inputTypesByName() {
      return this._inputTypesByName ?? (this._inputTypesByName = this.buildInputTypesMap());
    }
    get typeAndModelMap() {
      return this._typeAndModelMap ?? (this._typeAndModelMap = this.buildTypeModelMap());
    }
    get mappingsMap() {
      return this._mappingsMap ?? (this._mappingsMap = this.buildMappingsMap());
    }
    get outputTypeMap() {
      return this._outputTypeMap ?? (this._outputTypeMap = this.buildMergedOutputTypeMap());
    }
    get rootFieldMap() {
      return this._rootFieldMap ?? (this._rootFieldMap = this.buildRootFieldMap());
    }
    get datamodel() {
      return this.document.datamodel;
    }
    get mappings() {
      return this.document.mappings;
    }
    get schema() {
      return this.document.schema;
    }
    get inputObjectTypes() {
      return this.schema.inputObjectTypes;
    }
    get outputObjectTypes() {
      return this.schema.outputObjectTypes;
    }
    isComposite(t4) {
      return this.compositeNames.has(t4);
    }
    getOtherOperationNames() {
      return [Object.values(this.mappings.otherOperations.write), Object.values(this.mappings.otherOperations.read)].flat();
    }
    hasEnumInNamespace(t4, r2) {
      return this.schema.enumTypes[r2]?.find((n4) => n4.name === t4) !== undefined;
    }
    resolveInputObjectType(t4) {
      return this.inputTypesByName.get(di(t4.type, t4.namespace));
    }
    resolveOutputObjectType(t4) {
      if (t4.location === "outputObjectTypes")
        return this.outputObjectTypes[t4.namespace ?? "prisma"].find((r2) => r2.name === t4.type);
    }
    buildModelMap() {
      return Ge(this.datamodel.models, "name");
    }
    buildTypeMap() {
      return Ge(this.datamodel.types, "name");
    }
    buildTypeModelMap() {
      return { ...this.buildTypeMap(), ...this.buildModelMap() };
    }
    buildMappingsMap() {
      return Ge(this.mappings.modelOperations, "model");
    }
    buildMergedOutputTypeMap() {
      return { model: Ge(this.schema.outputObjectTypes.model, "name"), prisma: Ge(this.schema.outputObjectTypes.prisma, "name") };
    }
    buildRootFieldMap() {
      return { ...Ge(this.outputTypeMap.prisma.Query.fields, "name"), ...Ge(this.outputTypeMap.prisma.Mutation.fields, "name") };
    }
    buildInputTypesMap() {
      let t4 = new Map;
      for (let r2 of this.inputObjectTypes.prisma)
        t4.set(di(r2.name, "prisma"), r2);
      if (!this.inputObjectTypes.model)
        return t4;
      for (let r2 of this.inputObjectTypes.model)
        t4.set(di(r2.name, "model"), r2);
      return t4;
    }
  };
  var Ee;
  ((t4) => {
    let e4;
    ((E) => (E.findUnique = "findUnique", E.findUniqueOrThrow = "findUniqueOrThrow", E.findFirst = "findFirst", E.findFirstOrThrow = "findFirstOrThrow", E.findMany = "findMany", E.create = "create", E.createMany = "createMany", E.update = "update", E.updateMany = "updateMany", E.upsert = "upsert", E.delete = "delete", E.deleteMany = "deleteMany", E.groupBy = "groupBy", E.count = "count", E.aggregate = "aggregate", E.findRaw = "findRaw", E.aggregateRaw = "aggregateRaw"))(e4 = t4.ModelAction || (t4.ModelAction = {}));
  })(Ee || (Ee = {}));
  var zr = D(os());
  var Zu = 100;
  var zt = [];
  typeof process < "u" && typeof process.stderr?.write != "function" && (zr.default.log = console.debug ?? console.log);
  var xi = Object.assign(Xu, zr.default);
  var $ = xi;
  var wi;
  var ls;
  var us;
  var cs;
  var ps = true;
  typeof process < "u" && ({ FORCE_COLOR: wi, NODE_DISABLE_COLORS: ls, NO_COLOR: us, TERM: cs } = process.env || {}, ps = process.stdout && process.stdout.isTTY);
  var ec = { enabled: !ls && us == null && cs !== "dumb" && (wi != null && wi !== "0" || ps) };
  var ny = q3(0, 0);
  var de = q3(1, 22);
  var He = q3(2, 22);
  var iy = q3(3, 23);
  var ce = q3(4, 24);
  var oy = q3(7, 27);
  var sy = q3(8, 28);
  var ay = q3(9, 29);
  var ly = q3(30, 39);
  var ve = q3(31, 39);
  var pt = q3(32, 39);
  var Re = q3(33, 39);
  var Rt = q3(34, 39);
  var uy = q3(35, 39);
  var We = q3(36, 39);
  var cy = q3(37, 39);
  var Yr = q3(90, 39);
  var py = q3(90, 39);
  var dy = q3(40, 49);
  var my = q3(41, 49);
  var fy = q3(42, 49);
  var gy = q3(43, 49);
  var yy = q3(44, 49);
  var hy = q3(45, 49);
  var by = q3(46, 49);
  var xy = q3(47, 49);
  var ds = D(import.meta.require("fs"));
  var Pi = ["darwin", "darwin-arm64", "debian-openssl-1.0.x", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x", "rhel-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-1.0.x", "linux-arm64-openssl-3.0.x", "linux-arm-openssl-1.1.x", "linux-arm-openssl-1.0.x", "linux-arm-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-1.1.x", "linux-musl-arm64-openssl-3.0.x", "linux-nixos", "linux-static-x64", "linux-static-arm64", "windows", "freebsd11", "freebsd12", "freebsd13", "freebsd14", "openbsd", "netbsd", "arm"];
  var Zr = "libquery_engine";
  var Ts = D(import.meta.require("child_process"));
  var Mi = D(import.meta.require("fs/promises"));
  var on = D(import.meta.require("os"));
  var Be = Symbol.for("@ts-pattern/matcher");
  var tc = Symbol.for("@ts-pattern/isVariadic");
  var tn = "@ts-pattern/anonymous-select-key";
  var vi = (e4) => !!(e4 && typeof e4 == "object");
  var en = (e4) => e4 && !!e4[Be];
  var Ie = (e4, t4, r2) => {
    if (en(e4)) {
      let n4 = e4[Be](), { matched: i, selections: o4 } = n4.match(t4);
      return i && o4 && Object.keys(o4).forEach((s5) => r2(s5, o4[s5])), i;
    }
    if (vi(e4)) {
      if (!vi(t4))
        return false;
      if (Array.isArray(e4)) {
        if (!Array.isArray(t4))
          return false;
        let n4 = [], i = [], o4 = [];
        for (let s5 of e4.keys()) {
          let a3 = e4[s5];
          en(a3) && a3[tc] ? o4.push(a3) : o4.length ? i.push(a3) : n4.push(a3);
        }
        if (o4.length) {
          if (o4.length > 1)
            throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");
          if (t4.length < n4.length + i.length)
            return false;
          let s5 = t4.slice(0, n4.length), a3 = i.length === 0 ? [] : t4.slice(-i.length), l5 = t4.slice(n4.length, i.length === 0 ? 1 / 0 : -i.length);
          return n4.every((u3, c4) => Ie(u3, s5[c4], r2)) && i.every((u3, c4) => Ie(u3, a3[c4], r2)) && (o4.length === 0 || Ie(o4[0], l5, r2));
        }
        return e4.length === t4.length && e4.every((s5, a3) => Ie(s5, t4[a3], r2));
      }
      return Object.keys(e4).every((n4) => {
        let i = e4[n4];
        return ((n4 in t4) || en(o4 = i) && o4[Be]().matcherType === "optional") && Ie(i, t4[n4], r2);
        var o4;
      });
    }
    return Object.is(t4, e4);
  };
  var Ze = (e4) => {
    var t4, r2, n4;
    return vi(e4) ? en(e4) ? (t4 = (r2 = (n4 = e4[Be]()).getSelectionKeys) == null ? undefined : r2.call(n4)) != null ? t4 : [] : Array.isArray(e4) ? Yt(e4, Ze) : Yt(Object.values(e4), Ze) : [];
  };
  var Yt = (e4, t4) => e4.reduce((r2, n4) => r2.concat(t4(n4)), []);
  var My = Te(k3(function(e4) {
    return true;
  }));
  var mt = (e4) => Object.assign(Te(e4), { startsWith: (t4) => {
    return mt(V2(e4, (r2 = t4, k3((n4) => dt(n4) && n4.startsWith(r2)))));
    var r2;
  }, endsWith: (t4) => {
    return mt(V2(e4, (r2 = t4, k3((n4) => dt(n4) && n4.endsWith(r2)))));
    var r2;
  }, minLength: (t4) => mt(V2(e4, ((r2) => k3((n4) => dt(n4) && n4.length >= r2))(t4))), maxLength: (t4) => mt(V2(e4, ((r2) => k3((n4) => dt(n4) && n4.length <= r2))(t4))), includes: (t4) => {
    return mt(V2(e4, (r2 = t4, k3((n4) => dt(n4) && n4.includes(r2)))));
    var r2;
  }, regex: (t4) => {
    return mt(V2(e4, (r2 = t4, k3((n4) => dt(n4) && !!n4.match(r2)))));
    var r2;
  } });
  var Sy = mt(k3(dt));
  var Se = (e4) => Object.assign(Te(e4), { between: (t4, r2) => Se(V2(e4, ((n4, i) => k3((o4) => Me(o4) && n4 <= o4 && i >= o4))(t4, r2))), lt: (t4) => Se(V2(e4, ((r2) => k3((n4) => Me(n4) && n4 < r2))(t4))), gt: (t4) => Se(V2(e4, ((r2) => k3((n4) => Me(n4) && n4 > r2))(t4))), lte: (t4) => Se(V2(e4, ((r2) => k3((n4) => Me(n4) && n4 <= r2))(t4))), gte: (t4) => Se(V2(e4, ((r2) => k3((n4) => Me(n4) && n4 >= r2))(t4))), int: () => Se(V2(e4, k3((t4) => Me(t4) && Number.isInteger(t4)))), finite: () => Se(V2(e4, k3((t4) => Me(t4) && Number.isFinite(t4)))), positive: () => Se(V2(e4, k3((t4) => Me(t4) && t4 > 0))), negative: () => Se(V2(e4, k3((t4) => Me(t4) && t4 < 0))) });
  var Iy = Se(k3(Me));
  var Ye = (e4) => Object.assign(Te(e4), { between: (t4, r2) => Ye(V2(e4, ((n4, i) => k3((o4) => ze(o4) && n4 <= o4 && i >= o4))(t4, r2))), lt: (t4) => Ye(V2(e4, ((r2) => k3((n4) => ze(n4) && n4 < r2))(t4))), gt: (t4) => Ye(V2(e4, ((r2) => k3((n4) => ze(n4) && n4 > r2))(t4))), lte: (t4) => Ye(V2(e4, ((r2) => k3((n4) => ze(n4) && n4 <= r2))(t4))), gte: (t4) => Ye(V2(e4, ((r2) => k3((n4) => ze(n4) && n4 >= r2))(t4))), positive: () => Ye(V2(e4, k3((t4) => ze(t4) && t4 > 0))), negative: () => Ye(V2(e4, k3((t4) => ze(t4) && t4 < 0))) });
  var Dy = Ye(k3(ze));
  var ky = Te(k3(function(e4) {
    return typeof e4 == "boolean";
  }));
  var Fy = Te(k3(function(e4) {
    return typeof e4 == "symbol";
  }));
  var Oy = Te(k3(function(e4) {
    return e4 == null;
  }));
  var Ti = { matched: false, value: undefined };
  var _i = class e4 {
    constructor(t4, r2) {
      this.input = undefined, this.state = undefined, this.input = t4, this.state = r2;
    }
    with(...t4) {
      if (this.state.matched)
        return this;
      let r2 = t4[t4.length - 1], n4 = [t4[0]], i;
      t4.length === 3 && typeof t4[1] == "function" ? (n4.push(t4[0]), i = t4[1]) : t4.length > 2 && n4.push(...t4.slice(1, t4.length - 1));
      let o4 = false, s5 = {}, a3 = (u3, c4) => {
        o4 = true, s5[u3] = c4;
      }, l5 = !n4.some((u3) => Ie(u3, this.input, a3)) || i && !i(this.input) ? Ti : { matched: true, value: r2(o4 ? tn in s5 ? s5[tn] : s5 : this.input, this.input) };
      return new e4(this.input, l5);
    }
    when(t4, r2) {
      if (this.state.matched)
        return this;
      let n4 = !!t4(this.input);
      return new e4(this.input, n4 ? { matched: true, value: r2(this.input, this.input) } : Ti);
    }
    otherwise(t4) {
      return this.state.matched ? this.state.value : t4(this.input);
    }
    exhaustive() {
      return this.run();
    }
    run() {
      if (this.state.matched)
        return this.state.value;
      let t4;
      try {
        t4 = JSON.stringify(this.input);
      } catch {
        t4 = this.input;
      }
      throw new Error(`Pattern matching error: no pattern matches value ${t4}`);
    }
    returnType() {
      return this;
    }
  };
  var _s = import.meta.require("util");
  var Es = D(ws2());
  var sc = { warn: Re("prisma:warn") };
  var ac = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  var lc = (0, _s.promisify)(Ts.default.exec);
  var me = $("prisma:get-platform");
  var uc = ["1.0.x", "1.1.x", "3.0.x"];
  var nn = {};
  var ki = D(Ds());
  var un = D(import.meta.require("fs"));
  var Dt = D(import.meta.require("path"));
  var Di = $("prisma:tryLoadEnv");
  var Ns = "library";
  var Fc = D(Fi());
  var j = D(import.meta.require("path"));
  var Oc = D(Fi());
  var Ph = $("prisma:engines");
  var vh = "libquery-engine";
  j.default.join(__dirname, "../query-engine-darwin");
  j.default.join(__dirname, "../query-engine-darwin-arm64");
  j.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
  j.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
  j.default.join(__dirname, "../query-engine-debian-openssl-3.0.x");
  j.default.join(__dirname, "../query-engine-linux-static-x64");
  j.default.join(__dirname, "../query-engine-linux-static-arm64");
  j.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
  j.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
  j.default.join(__dirname, "../query-engine-rhel-openssl-3.0.x");
  j.default.join(__dirname, "../libquery_engine-darwin.dylib.node");
  j.default.join(__dirname, "../libquery_engine-darwin-arm64.dylib.node");
  j.default.join(__dirname, "../libquery_engine-debian-openssl-1.0.x.so.node");
  j.default.join(__dirname, "../libquery_engine-debian-openssl-1.1.x.so.node");
  j.default.join(__dirname, "../libquery_engine-debian-openssl-3.0.x.so.node");
  j.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
  j.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
  j.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-3.0.x.so.node");
  j.default.join(__dirname, "../libquery_engine-linux-musl.so.node");
  j.default.join(__dirname, "../libquery_engine-linux-musl-openssl-3.0.x.so.node");
  j.default.join(__dirname, "../libquery_engine-rhel-openssl-1.0.x.so.node");
  j.default.join(__dirname, "../libquery_engine-rhel-openssl-1.1.x.so.node");
  j.default.join(__dirname, "../libquery_engine-rhel-openssl-3.0.x.so.node");
  j.default.join(__dirname, "../query_engine-windows.dll.node");
  var Oi = D(import.meta.require("fs"));
  var Us = $("chmodPlusX");
  var ir = D(import.meta.require("path"));
  var Qs = D(qi());
  var ji = class {
    constructor(t4) {
      this.config = t4;
    }
    toString() {
      let { config: t4 } = this, r2 = t4.provider.fromEnvVar ? `env("${t4.provider.fromEnvVar}")` : t4.provider.value, n4 = JSON.parse(JSON.stringify({ provider: r2, binaryTargets: Nc(t4.binaryTargets) }));
      return `generator ${t4.name} {
${(0, Qs.default)(Lc(n4), 2)}
}`;
    }
  };
  var sr = {};
  Tt(sr, { error: () => Bc, info: () => jc, log: () => qc, query: () => Vc, should: () => Gs, tags: () => or, warn: () => Vi });
  var or = { error: ve("prisma:error"), warn: Re("prisma:warn"), info: We("prisma:info"), query: Rt("prisma:query") };
  var Gs = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  var Qi = (e4, t4) => e4.reduce((r2, n4) => (r2[t4(n4)] = n4, r2), {});
  var Ys = new Set;
  var ar = (e4, t4, ...r2) => {
    Ys.has(e4) || (Ys.add(e4), Vi(t4, ...r2));
  };
  var H3 = class extends Error {
    constructor(t4, { code: r2, clientVersion: n4, meta: i, batchRequestIdx: o4 }) {
      super(t4), this.name = "PrismaClientKnownRequestError", this.code = r2, this.clientVersion = n4, this.meta = i, Object.defineProperty(this, "batchRequestIdx", { value: o4, enumerable: false, writable: true });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientKnownRequestError";
    }
  };
  v3(H3, "PrismaClientKnownRequestError");
  var Ve = class extends H3 {
    constructor(t4, r2) {
      super(t4, { code: "P2025", clientVersion: r2 }), this.name = "NotFoundError";
    }
  };
  v3(Ve, "NotFoundError");
  var O = class e4 extends Error {
    constructor(t4, r2, n4) {
      super(t4), this.name = "PrismaClientInitializationError", this.clientVersion = r2, this.errorCode = n4, Error.captureStackTrace(e4);
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientInitializationError";
    }
  };
  v3(O, "PrismaClientInitializationError");
  var be = class extends Error {
    constructor(t4, r2) {
      super(t4), this.name = "PrismaClientRustPanicError", this.clientVersion = r2;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientRustPanicError";
    }
  };
  v3(be, "PrismaClientRustPanicError");
  var W = class extends Error {
    constructor(t4, { clientVersion: r2, batchRequestIdx: n4 }) {
      super(t4), this.name = "PrismaClientUnknownRequestError", this.clientVersion = r2, Object.defineProperty(this, "batchRequestIdx", { value: n4, writable: true, enumerable: false });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientUnknownRequestError";
    }
  };
  v3(W, "PrismaClientUnknownRequestError");
  var te = class extends Error {
    constructor(r2, { clientVersion: n4 }) {
      super(r2);
      this.name = "PrismaClientValidationError";
      this.clientVersion = n4;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientValidationError";
    }
  };
  v3(te, "PrismaClientValidationError");
  var Ft = class {
    constructor(t4) {
      this._engine = t4;
    }
    prometheus(t4) {
      return this._engine.metrics({ format: "prometheus", ...t4 });
    }
    json(t4) {
      return this._engine.metrics({ format: "json", ...t4 });
    }
  };
  var Qc = ["$connect", "$disconnect", "$on", "$transaction", "$use", "$extends"];
  var Hi = Qc;
  var Gc = ["JsonNullValueInput", "NullableJsonNullValueInput", "JsonNullValueFilter"];
  var fn = Symbol();
  var Wi = new WeakMap;
  var De = class {
    constructor(t4) {
      t4 === fn ? Wi.set(this, `Prisma.${this._getName()}`) : Wi.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
    }
    _getName() {
      return this.constructor.name;
    }
    toString() {
      return Wi.get(this);
    }
  };
  var ur = class extends De {
    _getNamespace() {
      return "NullTypes";
    }
  };
  var cr = class extends ur {
  };
  zi(cr, "DbNull");
  var pr = class extends ur {
  };
  zi(pr, "JsonNull");
  var dr = class extends ur {
  };
  zi(dr, "AnyNull");
  var gn = { classes: { DbNull: cr, JsonNull: pr, AnyNull: dr }, instances: { DbNull: new cr(fn), JsonNull: new pr(fn), AnyNull: new dr(fn) } };
  var Yi = class {
    constructor() {
      this.registeredErrors = [];
    }
    consumeError(t4) {
      return this.registeredErrors[t4];
    }
    registerNewError(t4) {
      let r2 = 0;
      for (;this.registeredErrors[r2] !== undefined; )
        r2++;
      return this.registeredErrors[r2] = { error: t4 }, r2;
    }
  };
  var Zi = (e4) => {
    let t4 = new Yi, r2 = yt(t4, e4.startTransaction.bind(e4)), n4 = { errorRegistry: t4, queryRaw: yt(t4, e4.queryRaw.bind(e4)), executeRaw: yt(t4, e4.executeRaw.bind(e4)), provider: e4.provider, startTransaction: async (...i) => (await r2(...i)).map((s5) => Jc(t4, s5)) };
    return e4.getConnectionInfo && (n4.getConnectionInfo = Hc(t4, e4.getConnectionInfo.bind(e4))), n4;
  };
  var Jc = (e4, t4) => ({ provider: t4.provider, options: t4.options, queryRaw: yt(e4, t4.queryRaw.bind(t4)), executeRaw: yt(e4, t4.executeRaw.bind(t4)), commit: yt(e4, t4.commit.bind(t4)), rollback: yt(e4, t4.rollback.bind(t4)) });
  var bu = import.meta.require("async_hooks");
  var xu = import.meta.require("events");
  var wu = D(import.meta.require("fs"));
  var Vr = D(import.meta.require("path"));
  var fe = class e4 {
    constructor(t4, r2) {
      if (t4.length - 1 !== r2.length)
        throw t4.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${t4.length} strings to have ${t4.length - 1} values`);
      let n4 = r2.reduce((s5, a3) => s5 + (a3 instanceof e4 ? a3.values.length : 1), 0);
      this.values = new Array(n4), this.strings = new Array(n4 + 1), this.strings[0] = t4[0];
      let i = 0, o4 = 0;
      for (;i < r2.length; ) {
        let s5 = r2[i++], a3 = t4[i];
        if (s5 instanceof e4) {
          this.strings[o4] += s5.strings[0];
          let l5 = 0;
          for (;l5 < s5.values.length; )
            this.values[o4++] = s5.values[l5++], this.strings[o4] = s5.strings[l5];
          this.strings[o4] += a3;
        } else
          this.values[o4++] = s5, this.strings[o4] = a3;
      }
    }
    get text() {
      let t4 = this.strings.length, r2 = 1, n4 = this.strings[0];
      for (;r2 < t4; )
        n4 += `\$${r2}${this.strings[r2++]}`;
      return n4;
    }
    get sql() {
      let t4 = this.strings.length, r2 = 1, n4 = this.strings[0];
      for (;r2 < t4; )
        n4 += `?${this.strings[r2++]}`;
      return n4;
    }
    get statement() {
      let t4 = this.strings.length, r2 = 1, n4 = this.strings[0];
      for (;r2 < t4; )
        n4 += `:${r2}${this.strings[r2++]}`;
      return n4;
    }
    inspect() {
      return { text: this.text, sql: this.sql, values: this.values };
    }
  };
  var ea = Xi("");
  var ke = class {
    constructor() {
      this._map = new Map;
    }
    get(t4) {
      return this._map.get(t4)?.value;
    }
    set(t4, r2) {
      this._map.set(t4, { value: r2 });
    }
    getOrCreate(t4, r2) {
      let n4 = this._map.get(t4);
      if (n4)
        return n4.value;
      let i = r2();
      return this.set(t4, i), i;
    }
  };
  var na = import.meta.require("util");
  var yn = { enumerable: true, configurable: true, writable: true };
  var ta = Symbol.for("nodejs.util.inspect.custom");
  var Ot = class {
    constructor(t4 = 0, r2) {
      this.context = r2;
      this.lines = [];
      this.currentLine = "";
      this.currentIndent = 0;
      this.currentIndent = t4;
    }
    write(t4) {
      return typeof t4 == "string" ? this.currentLine += t4 : t4.write(this), this;
    }
    writeJoined(t4, r2) {
      let n4 = r2.length - 1;
      for (let i = 0;i < r2.length; i++)
        this.write(r2[i]), i !== n4 && this.write(t4);
      return this;
    }
    writeLine(t4) {
      return this.write(t4).newLine();
    }
    newLine() {
      this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = undefined;
      let t4 = this.afterNextNewLineCallback;
      return this.afterNextNewLineCallback = undefined, t4?.(), this;
    }
    withIndent(t4) {
      return this.indent(), t4(this), this.unindent(), this;
    }
    afterNextNewline(t4) {
      return this.afterNextNewLineCallback = t4, this;
    }
    indent() {
      return this.currentIndent++, this;
    }
    unindent() {
      return this.currentIndent > 0 && this.currentIndent--, this;
    }
    addMarginSymbol(t4) {
      return this.marginSymbol = t4, this;
    }
    toString() {
      return this.lines.concat(this.indentedCurrentLine()).join(`
`);
    }
    getCurrentLineLength() {
      return this.currentLine.length;
    }
    indentedCurrentLine() {
      let t4 = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
      return this.marginSymbol ? this.marginSymbol + t4.slice(1) : t4;
    }
  };
  var Lt = 9000000000000000;
  var rt = 1e9;
  var to = "0123456789abcdef";
  var wn = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
  var En = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
  var ro = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -Lt, maxE: Lt, crypto: false };
  var aa;
  var Ue;
  var T = true;
  var vn = "[DecimalError] ";
  var tt = vn + "Invalid argument: ";
  var la = vn + "Precision limit exceeded";
  var ua = vn + "crypto unavailable";
  var ca = "[object Decimal]";
  var ae = Math.floor;
  var G = Math.pow;
  var zc = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
  var Yc = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
  var Zc = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
  var pa = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  var Ce = 1e7;
  var P = 7;
  var Xc = 9007199254740991;
  var ep = wn.length - 1;
  var no = En.length - 1;
  var m = { toStringTag: ca };
  m.absoluteValue = m.abs = function() {
    var e4 = new this.constructor(this);
    return e4.s < 0 && (e4.s = 1), x(e4);
  };
  m.ceil = function() {
    return x(new this.constructor(this), this.e + 1, 2);
  };
  m.clampedTo = m.clamp = function(e4, t4) {
    var r2, n4 = this, i = n4.constructor;
    if (e4 = new i(e4), t4 = new i(t4), !e4.s || !t4.s)
      return new i(NaN);
    if (e4.gt(t4))
      throw Error(tt + t4);
    return r2 = n4.cmp(e4), r2 < 0 ? e4 : n4.cmp(t4) > 0 ? t4 : new i(n4);
  };
  m.comparedTo = m.cmp = function(e4) {
    var t4, r2, n4, i, o4 = this, s5 = o4.d, a3 = (e4 = new o4.constructor(e4)).d, l5 = o4.s, u3 = e4.s;
    if (!s5 || !a3)
      return !l5 || !u3 ? NaN : l5 !== u3 ? l5 : s5 === a3 ? 0 : !s5 ^ l5 < 0 ? 1 : -1;
    if (!s5[0] || !a3[0])
      return s5[0] ? l5 : a3[0] ? -u3 : 0;
    if (l5 !== u3)
      return l5;
    if (o4.e !== e4.e)
      return o4.e > e4.e ^ l5 < 0 ? 1 : -1;
    for (n4 = s5.length, i = a3.length, t4 = 0, r2 = n4 < i ? n4 : i;t4 < r2; ++t4)
      if (s5[t4] !== a3[t4])
        return s5[t4] > a3[t4] ^ l5 < 0 ? 1 : -1;
    return n4 === i ? 0 : n4 > i ^ l5 < 0 ? 1 : -1;
  };
  m.cosine = m.cos = function() {
    var e4, t4, r2 = this, n4 = r2.constructor;
    return r2.d ? r2.d[0] ? (e4 = n4.precision, t4 = n4.rounding, n4.precision = e4 + Math.max(r2.e, r2.sd()) + P, n4.rounding = 1, r2 = tp(n4, ya(n4, r2)), n4.precision = e4, n4.rounding = t4, x(Ue == 2 || Ue == 3 ? r2.neg() : r2, e4, t4, true)) : new n4(1) : new n4(NaN);
  };
  m.cubeRoot = m.cbrt = function() {
    var e4, t4, r2, n4, i, o4, s5, a3, l5, u3, c4 = this, p3 = c4.constructor;
    if (!c4.isFinite() || c4.isZero())
      return new p3(c4);
    for (T = false, o4 = c4.s * G(c4.s * c4, 1 / 3), !o4 || Math.abs(o4) == 1 / 0 ? (r2 = re(c4.d), e4 = c4.e, (o4 = (e4 - r2.length + 1) % 3) && (r2 += o4 == 1 || o4 == -2 ? "0" : "00"), o4 = G(r2, 1 / 3), e4 = ae((e4 + 1) / 3) - (e4 % 3 == (e4 < 0 ? -1 : 2)), o4 == 1 / 0 ? r2 = "5e" + e4 : (r2 = o4.toExponential(), r2 = r2.slice(0, r2.indexOf("e") + 1) + e4), n4 = new p3(r2), n4.s = c4.s) : n4 = new p3(o4.toString()), s5 = (e4 = p3.precision) + 3;; )
      if (a3 = n4, l5 = a3.times(a3).times(a3), u3 = l5.plus(c4), n4 = L3(u3.plus(c4).times(a3), u3.plus(l5), s5 + 2, 1), re(a3.d).slice(0, s5) === (r2 = re(n4.d)).slice(0, s5))
        if (r2 = r2.slice(s5 - 3, s5 + 1), r2 == "9999" || !i && r2 == "4999") {
          if (!i && (x(a3, e4 + 1, 0), a3.times(a3).times(a3).eq(c4))) {
            n4 = a3;
            break;
          }
          s5 += 4, i = 1;
        } else {
          (!+r2 || !+r2.slice(1) && r2.charAt(0) == "5") && (x(n4, e4 + 1, 1), t4 = !n4.times(n4).times(n4).eq(c4));
          break;
        }
    return T = true, x(n4, e4, p3.rounding, t4);
  };
  m.decimalPlaces = m.dp = function() {
    var e4, t4 = this.d, r2 = NaN;
    if (t4) {
      if (e4 = t4.length - 1, r2 = (e4 - ae(this.e / P)) * P, e4 = t4[e4], e4)
        for (;e4 % 10 == 0; e4 /= 10)
          r2--;
      r2 < 0 && (r2 = 0);
    }
    return r2;
  };
  m.dividedBy = m.div = function(e4) {
    return L3(this, new this.constructor(e4));
  };
  m.dividedToIntegerBy = m.divToInt = function(e4) {
    var t4 = this, r2 = t4.constructor;
    return x(L3(t4, new r2(e4), 0, 1, 1), r2.precision, r2.rounding);
  };
  m.equals = m.eq = function(e4) {
    return this.cmp(e4) === 0;
  };
  m.floor = function() {
    return x(new this.constructor(this), this.e + 1, 3);
  };
  m.greaterThan = m.gt = function(e4) {
    return this.cmp(e4) > 0;
  };
  m.greaterThanOrEqualTo = m.gte = function(e4) {
    var t4 = this.cmp(e4);
    return t4 == 1 || t4 === 0;
  };
  m.hyperbolicCosine = m.cosh = function() {
    var e4, t4, r2, n4, i, o4 = this, s5 = o4.constructor, a3 = new s5(1);
    if (!o4.isFinite())
      return new s5(o4.s ? 1 / 0 : NaN);
    if (o4.isZero())
      return a3;
    r2 = s5.precision, n4 = s5.rounding, s5.precision = r2 + Math.max(o4.e, o4.sd()) + 4, s5.rounding = 1, i = o4.d.length, i < 32 ? (e4 = Math.ceil(i / 3), t4 = (1 / _n(4, e4)).toString()) : (e4 = 16, t4 = "2.3283064365386962890625e-10"), o4 = $t(s5, 1, o4.times(t4), new s5(1), true);
    for (var l5, u3 = e4, c4 = new s5(8);u3--; )
      l5 = o4.times(o4), o4 = a3.minus(l5.times(c4.minus(l5.times(c4))));
    return x(o4, s5.precision = r2, s5.rounding = n4, true);
  };
  m.hyperbolicSine = m.sinh = function() {
    var e4, t4, r2, n4, i = this, o4 = i.constructor;
    if (!i.isFinite() || i.isZero())
      return new o4(i);
    if (t4 = o4.precision, r2 = o4.rounding, o4.precision = t4 + Math.max(i.e, i.sd()) + 4, o4.rounding = 1, n4 = i.d.length, n4 < 3)
      i = $t(o4, 2, i, i, true);
    else {
      e4 = 1.4 * Math.sqrt(n4), e4 = e4 > 16 ? 16 : e4 | 0, i = i.times(1 / _n(5, e4)), i = $t(o4, 2, i, i, true);
      for (var s5, a3 = new o4(5), l5 = new o4(16), u3 = new o4(20);e4--; )
        s5 = i.times(i), i = i.times(a3.plus(s5.times(l5.times(s5).plus(u3))));
    }
    return o4.precision = t4, o4.rounding = r2, x(i, t4, r2, true);
  };
  m.hyperbolicTangent = m.tanh = function() {
    var e4, t4, r2 = this, n4 = r2.constructor;
    return r2.isFinite() ? r2.isZero() ? new n4(r2) : (e4 = n4.precision, t4 = n4.rounding, n4.precision = e4 + 7, n4.rounding = 1, L3(r2.sinh(), r2.cosh(), n4.precision = e4, n4.rounding = t4)) : new n4(r2.s);
  };
  m.inverseCosine = m.acos = function() {
    var e4, t4 = this, r2 = t4.constructor, n4 = t4.abs().cmp(1), i = r2.precision, o4 = r2.rounding;
    return n4 !== -1 ? n4 === 0 ? t4.isNeg() ? _e(r2, i, o4) : new r2(0) : new r2(NaN) : t4.isZero() ? _e(r2, i + 4, o4).times(0.5) : (r2.precision = i + 6, r2.rounding = 1, t4 = t4.asin(), e4 = _e(r2, i + 4, o4).times(0.5), r2.precision = i, r2.rounding = o4, e4.minus(t4));
  };
  m.inverseHyperbolicCosine = m.acosh = function() {
    var e4, t4, r2 = this, n4 = r2.constructor;
    return r2.lte(1) ? new n4(r2.eq(1) ? 0 : NaN) : r2.isFinite() ? (e4 = n4.precision, t4 = n4.rounding, n4.precision = e4 + Math.max(Math.abs(r2.e), r2.sd()) + 4, n4.rounding = 1, T = false, r2 = r2.times(r2).minus(1).sqrt().plus(r2), T = true, n4.precision = e4, n4.rounding = t4, r2.ln()) : new n4(r2);
  };
  m.inverseHyperbolicSine = m.asinh = function() {
    var e4, t4, r2 = this, n4 = r2.constructor;
    return !r2.isFinite() || r2.isZero() ? new n4(r2) : (e4 = n4.precision, t4 = n4.rounding, n4.precision = e4 + 2 * Math.max(Math.abs(r2.e), r2.sd()) + 6, n4.rounding = 1, T = false, r2 = r2.times(r2).plus(1).sqrt().plus(r2), T = true, n4.precision = e4, n4.rounding = t4, r2.ln());
  };
  m.inverseHyperbolicTangent = m.atanh = function() {
    var e4, t4, r2, n4, i = this, o4 = i.constructor;
    return i.isFinite() ? i.e >= 0 ? new o4(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e4 = o4.precision, t4 = o4.rounding, n4 = i.sd(), Math.max(n4, e4) < 2 * -i.e - 1 ? x(new o4(i), e4, t4, true) : (o4.precision = r2 = n4 - i.e, i = L3(i.plus(1), new o4(1).minus(i), r2 + e4, 1), o4.precision = e4 + 4, o4.rounding = 1, i = i.ln(), o4.precision = e4, o4.rounding = t4, i.times(0.5))) : new o4(NaN);
  };
  m.inverseSine = m.asin = function() {
    var e4, t4, r2, n4, i = this, o4 = i.constructor;
    return i.isZero() ? new o4(i) : (t4 = i.abs().cmp(1), r2 = o4.precision, n4 = o4.rounding, t4 !== -1 ? t4 === 0 ? (e4 = _e(o4, r2 + 4, n4).times(0.5), e4.s = i.s, e4) : new o4(NaN) : (o4.precision = r2 + 6, o4.rounding = 1, i = i.div(new o4(1).minus(i.times(i)).sqrt().plus(1)).atan(), o4.precision = r2, o4.rounding = n4, i.times(2)));
  };
  m.inverseTangent = m.atan = function() {
    var e4, t4, r2, n4, i, o4, s5, a3, l5, u3 = this, c4 = u3.constructor, p3 = c4.precision, d3 = c4.rounding;
    if (u3.isFinite()) {
      if (u3.isZero())
        return new c4(u3);
      if (u3.abs().eq(1) && p3 + 4 <= no)
        return s5 = _e(c4, p3 + 4, d3).times(0.25), s5.s = u3.s, s5;
    } else {
      if (!u3.s)
        return new c4(NaN);
      if (p3 + 4 <= no)
        return s5 = _e(c4, p3 + 4, d3).times(0.5), s5.s = u3.s, s5;
    }
    for (c4.precision = a3 = p3 + 10, c4.rounding = 1, r2 = Math.min(28, a3 / P + 2 | 0), e4 = r2;e4; --e4)
      u3 = u3.div(u3.times(u3).plus(1).sqrt().plus(1));
    for (T = false, t4 = Math.ceil(a3 / P), n4 = 1, l5 = u3.times(u3), s5 = new c4(u3), i = u3;e4 !== -1; )
      if (i = i.times(l5), o4 = s5.minus(i.div(n4 += 2)), i = i.times(l5), s5 = o4.plus(i.div(n4 += 2)), s5.d[t4] !== undefined)
        for (e4 = t4;s5.d[e4] === o4.d[e4] && e4--; )
          ;
    return r2 && (s5 = s5.times(2 << r2 - 1)), T = true, x(s5, c4.precision = p3, c4.rounding = d3, true);
  };
  m.isFinite = function() {
    return !!this.d;
  };
  m.isInteger = m.isInt = function() {
    return !!this.d && ae(this.e / P) > this.d.length - 2;
  };
  m.isNaN = function() {
    return !this.s;
  };
  m.isNegative = m.isNeg = function() {
    return this.s < 0;
  };
  m.isPositive = m.isPos = function() {
    return this.s > 0;
  };
  m.isZero = function() {
    return !!this.d && this.d[0] === 0;
  };
  m.lessThan = m.lt = function(e4) {
    return this.cmp(e4) < 0;
  };
  m.lessThanOrEqualTo = m.lte = function(e4) {
    return this.cmp(e4) < 1;
  };
  m.logarithm = m.log = function(e4) {
    var t4, r2, n4, i, o4, s5, a3, l5, u3 = this, c4 = u3.constructor, p3 = c4.precision, d3 = c4.rounding, f = 5;
    if (e4 == null)
      e4 = new c4(10), t4 = true;
    else {
      if (e4 = new c4(e4), r2 = e4.d, e4.s < 0 || !r2 || !r2[0] || e4.eq(1))
        return new c4(NaN);
      t4 = e4.eq(10);
    }
    if (r2 = u3.d, u3.s < 0 || !r2 || !r2[0] || u3.eq(1))
      return new c4(r2 && !r2[0] ? -1 / 0 : u3.s != 1 ? NaN : r2 ? 0 : 1 / 0);
    if (t4)
      if (r2.length > 1)
        o4 = true;
      else {
        for (i = r2[0];i % 10 === 0; )
          i /= 10;
        o4 = i !== 1;
      }
    if (T = false, a3 = p3 + f, s5 = et(u3, a3), n4 = t4 ? Pn(c4, a3 + 10) : et(e4, a3), l5 = L3(s5, n4, a3, 1), yr(l5.d, i = p3, d3))
      do
        if (a3 += 10, s5 = et(u3, a3), n4 = t4 ? Pn(c4, a3 + 10) : et(e4, a3), l5 = L3(s5, n4, a3, 1), !o4) {
          +re(l5.d).slice(i + 1, i + 15) + 1 == 100000000000000 && (l5 = x(l5, p3 + 1, 0));
          break;
        }
      while (yr(l5.d, i += 10, d3));
    return T = true, x(l5, p3, d3);
  };
  m.minus = m.sub = function(e4) {
    var t4, r2, n4, i, o4, s5, a3, l5, u3, c4, p3, d3, f = this, h3 = f.constructor;
    if (e4 = new h3(e4), !f.d || !e4.d)
      return !f.s || !e4.s ? e4 = new h3(NaN) : f.d ? e4.s = -e4.s : e4 = new h3(e4.d || f.s !== e4.s ? f : NaN), e4;
    if (f.s != e4.s)
      return e4.s = -e4.s, f.plus(e4);
    if (u3 = f.d, d3 = e4.d, a3 = h3.precision, l5 = h3.rounding, !u3[0] || !d3[0]) {
      if (d3[0])
        e4.s = -e4.s;
      else if (u3[0])
        e4 = new h3(f);
      else
        return new h3(l5 === 3 ? -0 : 0);
      return T ? x(e4, a3, l5) : e4;
    }
    if (r2 = ae(e4.e / P), c4 = ae(f.e / P), u3 = u3.slice(), o4 = c4 - r2, o4) {
      for (p3 = o4 < 0, p3 ? (t4 = u3, o4 = -o4, s5 = d3.length) : (t4 = d3, r2 = c4, s5 = u3.length), n4 = Math.max(Math.ceil(a3 / P), s5) + 2, o4 > n4 && (o4 = n4, t4.length = 1), t4.reverse(), n4 = o4;n4--; )
        t4.push(0);
      t4.reverse();
    } else {
      for (n4 = u3.length, s5 = d3.length, p3 = n4 < s5, p3 && (s5 = n4), n4 = 0;n4 < s5; n4++)
        if (u3[n4] != d3[n4]) {
          p3 = u3[n4] < d3[n4];
          break;
        }
      o4 = 0;
    }
    for (p3 && (t4 = u3, u3 = d3, d3 = t4, e4.s = -e4.s), s5 = u3.length, n4 = d3.length - s5;n4 > 0; --n4)
      u3[s5++] = 0;
    for (n4 = d3.length;n4 > o4; ) {
      if (u3[--n4] < d3[n4]) {
        for (i = n4;i && u3[--i] === 0; )
          u3[i] = Ce - 1;
        --u3[i], u3[n4] += Ce;
      }
      u3[n4] -= d3[n4];
    }
    for (;u3[--s5] === 0; )
      u3.pop();
    for (;u3[0] === 0; u3.shift())
      --r2;
    return u3[0] ? (e4.d = u3, e4.e = Tn(u3, r2), T ? x(e4, a3, l5) : e4) : new h3(l5 === 3 ? -0 : 0);
  };
  m.modulo = m.mod = function(e4) {
    var t4, r2 = this, n4 = r2.constructor;
    return e4 = new n4(e4), !r2.d || !e4.s || e4.d && !e4.d[0] ? new n4(NaN) : !e4.d || r2.d && !r2.d[0] ? x(new n4(r2), n4.precision, n4.rounding) : (T = false, n4.modulo == 9 ? (t4 = L3(r2, e4.abs(), 0, 3, 1), t4.s *= e4.s) : t4 = L3(r2, e4, 0, n4.modulo, 1), t4 = t4.times(e4), T = true, r2.minus(t4));
  };
  m.naturalExponential = m.exp = function() {
    return io(this);
  };
  m.naturalLogarithm = m.ln = function() {
    return et(this);
  };
  m.negated = m.neg = function() {
    var e4 = new this.constructor(this);
    return e4.s = -e4.s, x(e4);
  };
  m.plus = m.add = function(e4) {
    var t4, r2, n4, i, o4, s5, a3, l5, u3, c4, p3 = this, d3 = p3.constructor;
    if (e4 = new d3(e4), !p3.d || !e4.d)
      return !p3.s || !e4.s ? e4 = new d3(NaN) : p3.d || (e4 = new d3(e4.d || p3.s === e4.s ? p3 : NaN)), e4;
    if (p3.s != e4.s)
      return e4.s = -e4.s, p3.minus(e4);
    if (u3 = p3.d, c4 = e4.d, a3 = d3.precision, l5 = d3.rounding, !u3[0] || !c4[0])
      return c4[0] || (e4 = new d3(p3)), T ? x(e4, a3, l5) : e4;
    if (o4 = ae(p3.e / P), n4 = ae(e4.e / P), u3 = u3.slice(), i = o4 - n4, i) {
      for (i < 0 ? (r2 = u3, i = -i, s5 = c4.length) : (r2 = c4, n4 = o4, s5 = u3.length), o4 = Math.ceil(a3 / P), s5 = o4 > s5 ? o4 + 1 : s5 + 1, i > s5 && (i = s5, r2.length = 1), r2.reverse();i--; )
        r2.push(0);
      r2.reverse();
    }
    for (s5 = u3.length, i = c4.length, s5 - i < 0 && (i = s5, r2 = c4, c4 = u3, u3 = r2), t4 = 0;i; )
      t4 = (u3[--i] = u3[i] + c4[i] + t4) / Ce | 0, u3[i] %= Ce;
    for (t4 && (u3.unshift(t4), ++n4), s5 = u3.length;u3[--s5] == 0; )
      u3.pop();
    return e4.d = u3, e4.e = Tn(u3, n4), T ? x(e4, a3, l5) : e4;
  };
  m.precision = m.sd = function(e4) {
    var t4, r2 = this;
    if (e4 !== undefined && e4 !== !!e4 && e4 !== 1 && e4 !== 0)
      throw Error(tt + e4);
    return r2.d ? (t4 = da(r2.d), e4 && r2.e + 1 > t4 && (t4 = r2.e + 1)) : t4 = NaN, t4;
  };
  m.round = function() {
    var e4 = this, t4 = e4.constructor;
    return x(new t4(e4), e4.e + 1, t4.rounding);
  };
  m.sine = m.sin = function() {
    var e4, t4, r2 = this, n4 = r2.constructor;
    return r2.isFinite() ? r2.isZero() ? new n4(r2) : (e4 = n4.precision, t4 = n4.rounding, n4.precision = e4 + Math.max(r2.e, r2.sd()) + P, n4.rounding = 1, r2 = np(n4, ya(n4, r2)), n4.precision = e4, n4.rounding = t4, x(Ue > 2 ? r2.neg() : r2, e4, t4, true)) : new n4(NaN);
  };
  m.squareRoot = m.sqrt = function() {
    var e4, t4, r2, n4, i, o4, s5 = this, a3 = s5.d, l5 = s5.e, u3 = s5.s, c4 = s5.constructor;
    if (u3 !== 1 || !a3 || !a3[0])
      return new c4(!u3 || u3 < 0 && (!a3 || a3[0]) ? NaN : a3 ? s5 : 1 / 0);
    for (T = false, u3 = Math.sqrt(+s5), u3 == 0 || u3 == 1 / 0 ? (t4 = re(a3), (t4.length + l5) % 2 == 0 && (t4 += "0"), u3 = Math.sqrt(t4), l5 = ae((l5 + 1) / 2) - (l5 < 0 || l5 % 2), u3 == 1 / 0 ? t4 = "5e" + l5 : (t4 = u3.toExponential(), t4 = t4.slice(0, t4.indexOf("e") + 1) + l5), n4 = new c4(t4)) : n4 = new c4(u3.toString()), r2 = (l5 = c4.precision) + 3;; )
      if (o4 = n4, n4 = o4.plus(L3(s5, o4, r2 + 2, 1)).times(0.5), re(o4.d).slice(0, r2) === (t4 = re(n4.d)).slice(0, r2))
        if (t4 = t4.slice(r2 - 3, r2 + 1), t4 == "9999" || !i && t4 == "4999") {
          if (!i && (x(o4, l5 + 1, 0), o4.times(o4).eq(s5))) {
            n4 = o4;
            break;
          }
          r2 += 4, i = 1;
        } else {
          (!+t4 || !+t4.slice(1) && t4.charAt(0) == "5") && (x(n4, l5 + 1, 1), e4 = !n4.times(n4).eq(s5));
          break;
        }
    return T = true, x(n4, l5, c4.rounding, e4);
  };
  m.tangent = m.tan = function() {
    var e4, t4, r2 = this, n4 = r2.constructor;
    return r2.isFinite() ? r2.isZero() ? new n4(r2) : (e4 = n4.precision, t4 = n4.rounding, n4.precision = e4 + 10, n4.rounding = 1, r2 = r2.sin(), r2.s = 1, r2 = L3(r2, new n4(1).minus(r2.times(r2)).sqrt(), e4 + 10, 0), n4.precision = e4, n4.rounding = t4, x(Ue == 2 || Ue == 4 ? r2.neg() : r2, e4, t4, true)) : new n4(NaN);
  };
  m.times = m.mul = function(e4) {
    var t4, r2, n4, i, o4, s5, a3, l5, u3, c4 = this, p3 = c4.constructor, d3 = c4.d, f = (e4 = new p3(e4)).d;
    if (e4.s *= c4.s, !d3 || !d3[0] || !f || !f[0])
      return new p3(!e4.s || d3 && !d3[0] && !f || f && !f[0] && !d3 ? NaN : !d3 || !f ? e4.s / 0 : e4.s * 0);
    for (r2 = ae(c4.e / P) + ae(e4.e / P), l5 = d3.length, u3 = f.length, l5 < u3 && (o4 = d3, d3 = f, f = o4, s5 = l5, l5 = u3, u3 = s5), o4 = [], s5 = l5 + u3, n4 = s5;n4--; )
      o4.push(0);
    for (n4 = u3;--n4 >= 0; ) {
      for (t4 = 0, i = l5 + n4;i > n4; )
        a3 = o4[i] + f[n4] * d3[i - n4 - 1] + t4, o4[i--] = a3 % Ce | 0, t4 = a3 / Ce | 0;
      o4[i] = (o4[i] + t4) % Ce | 0;
    }
    for (;!o4[--s5]; )
      o4.pop();
    return t4 ? ++r2 : o4.shift(), e4.d = o4, e4.e = Tn(o4, r2), T ? x(e4, p3.precision, p3.rounding) : e4;
  };
  m.toBinary = function(e4, t4) {
    return so(this, 2, e4, t4);
  };
  m.toDecimalPlaces = m.toDP = function(e4, t4) {
    var r2 = this, n4 = r2.constructor;
    return r2 = new n4(r2), e4 === undefined ? r2 : (ge(e4, 0, rt), t4 === undefined ? t4 = n4.rounding : ge(t4, 0, 8), x(r2, e4 + r2.e + 1, t4));
  };
  m.toExponential = function(e4, t4) {
    var r2, n4 = this, i = n4.constructor;
    return e4 === undefined ? r2 = Oe(n4, true) : (ge(e4, 0, rt), t4 === undefined ? t4 = i.rounding : ge(t4, 0, 8), n4 = x(new i(n4), e4 + 1, t4), r2 = Oe(n4, true, e4 + 1)), n4.isNeg() && !n4.isZero() ? "-" + r2 : r2;
  };
  m.toFixed = function(e4, t4) {
    var r2, n4, i = this, o4 = i.constructor;
    return e4 === undefined ? r2 = Oe(i) : (ge(e4, 0, rt), t4 === undefined ? t4 = o4.rounding : ge(t4, 0, 8), n4 = x(new o4(i), e4 + i.e + 1, t4), r2 = Oe(n4, false, e4 + n4.e + 1)), i.isNeg() && !i.isZero() ? "-" + r2 : r2;
  };
  m.toFraction = function(e4) {
    var t4, r2, n4, i, o4, s5, a3, l5, u3, c4, p3, d3, f = this, h3 = f.d, g = f.constructor;
    if (!h3)
      return new g(f);
    if (u3 = r2 = new g(1), n4 = l5 = new g(0), t4 = new g(n4), o4 = t4.e = da(h3) - f.e - 1, s5 = o4 % P, t4.d[0] = G(10, s5 < 0 ? P + s5 : s5), e4 == null)
      e4 = o4 > 0 ? t4 : u3;
    else {
      if (a3 = new g(e4), !a3.isInt() || a3.lt(u3))
        throw Error(tt + a3);
      e4 = a3.gt(t4) ? o4 > 0 ? t4 : u3 : a3;
    }
    for (T = false, a3 = new g(re(h3)), c4 = g.precision, g.precision = o4 = h3.length * P * 2;p3 = L3(a3, t4, 0, 1, 1), i = r2.plus(p3.times(n4)), i.cmp(e4) != 1; )
      r2 = n4, n4 = i, i = u3, u3 = l5.plus(p3.times(i)), l5 = i, i = t4, t4 = a3.minus(p3.times(i)), a3 = i;
    return i = L3(e4.minus(r2), n4, 0, 1, 1), l5 = l5.plus(i.times(u3)), r2 = r2.plus(i.times(n4)), l5.s = u3.s = f.s, d3 = L3(u3, n4, o4, 1).minus(f).abs().cmp(L3(l5, r2, o4, 1).minus(f).abs()) < 1 ? [u3, n4] : [l5, r2], g.precision = c4, T = true, d3;
  };
  m.toHexadecimal = m.toHex = function(e4, t4) {
    return so(this, 16, e4, t4);
  };
  m.toNearest = function(e4, t4) {
    var r2 = this, n4 = r2.constructor;
    if (r2 = new n4(r2), e4 == null) {
      if (!r2.d)
        return r2;
      e4 = new n4(1), t4 = n4.rounding;
    } else {
      if (e4 = new n4(e4), t4 === undefined ? t4 = n4.rounding : ge(t4, 0, 8), !r2.d)
        return e4.s ? r2 : e4;
      if (!e4.d)
        return e4.s && (e4.s = r2.s), e4;
    }
    return e4.d[0] ? (T = false, r2 = L3(r2, e4, 0, t4, 1).times(e4), T = true, x(r2)) : (e4.s = r2.s, r2 = e4), r2;
  };
  m.toNumber = function() {
    return +this;
  };
  m.toOctal = function(e4, t4) {
    return so(this, 8, e4, t4);
  };
  m.toPower = m.pow = function(e4) {
    var t4, r2, n4, i, o4, s5, a3 = this, l5 = a3.constructor, u3 = +(e4 = new l5(e4));
    if (!a3.d || !e4.d || !a3.d[0] || !e4.d[0])
      return new l5(G(+a3, u3));
    if (a3 = new l5(a3), a3.eq(1))
      return a3;
    if (n4 = l5.precision, o4 = l5.rounding, e4.eq(1))
      return x(a3, n4, o4);
    if (t4 = ae(e4.e / P), t4 >= e4.d.length - 1 && (r2 = u3 < 0 ? -u3 : u3) <= Xc)
      return i = ma(l5, a3, r2, n4), e4.s < 0 ? new l5(1).div(i) : x(i, n4, o4);
    if (s5 = a3.s, s5 < 0) {
      if (t4 < e4.d.length - 1)
        return new l5(NaN);
      if (e4.d[t4] & 1 || (s5 = 1), a3.e == 0 && a3.d[0] == 1 && a3.d.length == 1)
        return a3.s = s5, a3;
    }
    return r2 = G(+a3, u3), t4 = r2 == 0 || !isFinite(r2) ? ae(u3 * (Math.log("0." + re(a3.d)) / Math.LN10 + a3.e + 1)) : new l5(r2 + "").e, t4 > l5.maxE + 1 || t4 < l5.minE - 1 ? new l5(t4 > 0 ? s5 / 0 : 0) : (T = false, l5.rounding = a3.s = 1, r2 = Math.min(12, (t4 + "").length), i = io(e4.times(et(a3, n4 + r2)), n4), i.d && (i = x(i, n4 + 5, 1), yr(i.d, n4, o4) && (t4 = n4 + 10, i = x(io(e4.times(et(a3, t4 + r2)), t4), t4 + 5, 1), +re(i.d).slice(n4 + 1, n4 + 15) + 1 == 100000000000000 && (i = x(i, n4 + 1, 0)))), i.s = s5, T = true, l5.rounding = o4, x(i, n4, o4));
  };
  m.toPrecision = function(e4, t4) {
    var r2, n4 = this, i = n4.constructor;
    return e4 === undefined ? r2 = Oe(n4, n4.e <= i.toExpNeg || n4.e >= i.toExpPos) : (ge(e4, 1, rt), t4 === undefined ? t4 = i.rounding : ge(t4, 0, 8), n4 = x(new i(n4), e4, t4), r2 = Oe(n4, e4 <= n4.e || n4.e <= i.toExpNeg, e4)), n4.isNeg() && !n4.isZero() ? "-" + r2 : r2;
  };
  m.toSignificantDigits = m.toSD = function(e4, t4) {
    var r2 = this, n4 = r2.constructor;
    return e4 === undefined ? (e4 = n4.precision, t4 = n4.rounding) : (ge(e4, 1, rt), t4 === undefined ? t4 = n4.rounding : ge(t4, 0, 8)), x(new n4(r2), e4, t4);
  };
  m.toString = function() {
    var e4 = this, t4 = e4.constructor, r2 = Oe(e4, e4.e <= t4.toExpNeg || e4.e >= t4.toExpPos);
    return e4.isNeg() && !e4.isZero() ? "-" + r2 : r2;
  };
  m.truncated = m.trunc = function() {
    return x(new this.constructor(this), this.e + 1, 1);
  };
  m.valueOf = m.toJSON = function() {
    var e4 = this, t4 = e4.constructor, r2 = Oe(e4, e4.e <= t4.toExpNeg || e4.e >= t4.toExpPos);
    return e4.isNeg() ? "-" + r2 : r2;
  };
  var L3 = function() {
    function e4(n4, i, o4) {
      var s5, a3 = 0, l5 = n4.length;
      for (n4 = n4.slice();l5--; )
        s5 = n4[l5] * i + a3, n4[l5] = s5 % o4 | 0, a3 = s5 / o4 | 0;
      return a3 && n4.unshift(a3), n4;
    }
    function t4(n4, i, o4, s5) {
      var a3, l5;
      if (o4 != s5)
        l5 = o4 > s5 ? 1 : -1;
      else
        for (a3 = l5 = 0;a3 < o4; a3++)
          if (n4[a3] != i[a3]) {
            l5 = n4[a3] > i[a3] ? 1 : -1;
            break;
          }
      return l5;
    }
    function r2(n4, i, o4, s5) {
      for (var a3 = 0;o4--; )
        n4[o4] -= a3, a3 = n4[o4] < i[o4] ? 1 : 0, n4[o4] = a3 * s5 + n4[o4] - i[o4];
      for (;!n4[0] && n4.length > 1; )
        n4.shift();
    }
    return function(n4, i, o4, s5, a3, l5) {
      var u3, c4, p3, d3, f, h3, g, _, A, R3, E, S, we, X, ut, K, ie, je, oe, vt, Ur = n4.constructor, li = n4.s == i.s ? 1 : -1, se = n4.d, N = i.d;
      if (!se || !se[0] || !N || !N[0])
        return new Ur(!n4.s || !i.s || (se ? N && se[0] == N[0] : !N) ? NaN : se && se[0] == 0 || !N ? li * 0 : li / 0);
      for (l5 ? (f = 1, c4 = n4.e - i.e) : (l5 = Ce, f = P, c4 = ae(n4.e / f) - ae(i.e / f)), oe = N.length, ie = se.length, A = new Ur(li), R3 = A.d = [], p3 = 0;N[p3] == (se[p3] || 0); p3++)
        ;
      if (N[p3] > (se[p3] || 0) && c4--, o4 == null ? (X = o4 = Ur.precision, s5 = Ur.rounding) : a3 ? X = o4 + (n4.e - i.e) + 1 : X = o4, X < 0)
        R3.push(1), h3 = true;
      else {
        if (X = X / f + 2 | 0, p3 = 0, oe == 1) {
          for (d3 = 0, N = N[0], X++;(p3 < ie || d3) && X--; p3++)
            ut = d3 * l5 + (se[p3] || 0), R3[p3] = ut / N | 0, d3 = ut % N | 0;
          h3 = d3 || p3 < ie;
        } else {
          for (d3 = l5 / (N[0] + 1) | 0, d3 > 1 && (N = e4(N, d3, l5), se = e4(se, d3, l5), oe = N.length, ie = se.length), K = oe, E = se.slice(0, oe), S = E.length;S < oe; )
            E[S++] = 0;
          vt = N.slice(), vt.unshift(0), je = N[0], N[1] >= l5 / 2 && ++je;
          do
            d3 = 0, u3 = t4(N, E, oe, S), u3 < 0 ? (we = E[0], oe != S && (we = we * l5 + (E[1] || 0)), d3 = we / je | 0, d3 > 1 ? (d3 >= l5 && (d3 = l5 - 1), g = e4(N, d3, l5), _ = g.length, S = E.length, u3 = t4(g, E, _, S), u3 == 1 && (d3--, r2(g, oe < _ ? vt : N, _, l5))) : (d3 == 0 && (u3 = d3 = 1), g = N.slice()), _ = g.length, _ < S && g.unshift(0), r2(E, g, S, l5), u3 == -1 && (S = E.length, u3 = t4(N, E, oe, S), u3 < 1 && (d3++, r2(E, oe < S ? vt : N, S, l5))), S = E.length) : u3 === 0 && (d3++, E = [0]), R3[p3++] = d3, u3 && E[0] ? E[S++] = se[K] || 0 : (E = [se[K]], S = 1);
          while ((K++ < ie || E[0] !== undefined) && X--);
          h3 = E[0] !== undefined;
        }
        R3[0] || R3.shift();
      }
      if (f == 1)
        A.e = c4, aa = h3;
      else {
        for (p3 = 1, d3 = R3[0];d3 >= 10; d3 /= 10)
          p3++;
        A.e = p3 + c4 * f - 1, x(A, a3 ? o4 + A.e + 1 : o4, s5, h3);
      }
      return A;
    };
  }();
  m[Symbol.for("nodejs.util.inspect.custom")] = m.toString;
  m[Symbol.toStringTag] = "Decimal";
  var bt = m.constructor = ha(ro);
  wn = new bt(wn);
  En = new bt(En);
  var Ne = bt;
  var hr = class {
    constructor(t4, r2, n4, i, o4) {
      this.modelName = t4, this.name = r2, this.typeName = n4, this.isList = i, this.isEnum = o4;
    }
    _toGraphQLInputType() {
      let t4 = this.isList ? "List" : "", r2 = this.isEnum ? "Enum" : "";
      return `${t4}${r2}${this.typeName}FieldRefInput<${this.modelName}>`;
    }
  };
  var Cn = class {
    constructor(t4) {
      this.value = t4;
    }
    write(t4) {
      t4.write(this.value);
    }
    markAsError() {
      this.value.markAsError();
    }
  };
  var An = (e4) => e4;
  var Rn = { bold: An, red: An, green: An, dim: An, enabled: false };
  var ba = { bold: de, red: ve, green: pt, dim: He, enabled: true };
  var Bt = { write(e4) {
    e4.writeLine(",");
  } };
  var Le = class {
    constructor(t4) {
      this.contents = t4;
      this.isUnderlined = false;
      this.color = (t5) => t5;
    }
    underline() {
      return this.isUnderlined = true, this;
    }
    setColor(t4) {
      return this.color = t4, this;
    }
    write(t4) {
      let r2 = t4.getCurrentLineLength();
      t4.write(this.color(this.contents)), this.isUnderlined && t4.afterNextNewline(() => {
        t4.write(" ".repeat(r2)).writeLine(this.color("~".repeat(this.contents.length)));
      });
    }
  };
  var nt = class {
    constructor() {
      this.hasError = false;
    }
    markAsError() {
      return this.hasError = true, this;
    }
  };
  var Vt = class extends nt {
    constructor() {
      super(...arguments);
      this.items = [];
    }
    addItem(r2) {
      return this.items.push(new Cn(r2)), this;
    }
    getField(r2) {
      return this.items[r2];
    }
    getPrintWidth() {
      return this.items.length === 0 ? 2 : Math.max(...this.items.map((n4) => n4.value.getPrintWidth())) + 2;
    }
    write(r2) {
      if (this.items.length === 0) {
        this.writeEmpty(r2);
        return;
      }
      this.writeWithItems(r2);
    }
    writeEmpty(r2) {
      let n4 = new Le("[]");
      this.hasError && n4.setColor(r2.context.colors.red).underline(), r2.write(n4);
    }
    writeWithItems(r2) {
      let { colors: n4 } = r2.context;
      r2.writeLine("[").withIndent(() => r2.writeJoined(Bt, this.items).newLine()).write("]"), this.hasError && r2.afterNextNewline(() => {
        r2.writeLine(n4.red("~".repeat(this.getPrintWidth())));
      });
    }
  };
  var xa = ": ";
  var Mn = class {
    constructor(t4, r2) {
      this.name = t4;
      this.value = r2;
      this.hasError = false;
    }
    markAsError() {
      this.hasError = true;
    }
    getPrintWidth() {
      return this.name.length + this.value.getPrintWidth() + xa.length;
    }
    write(t4) {
      let r2 = new Le(this.name);
      this.hasError && r2.underline().setColor(t4.context.colors.red), t4.write(r2).write(xa).write(this.value);
    }
  };
  var z = class e4 extends nt {
    constructor() {
      super(...arguments);
      this.fields = {};
      this.suggestions = [];
    }
    addField(r2) {
      this.fields[r2.name] = r2;
    }
    addSuggestion(r2) {
      this.suggestions.push(r2);
    }
    getField(r2) {
      return this.fields[r2];
    }
    getDeepField(r2) {
      let [n4, ...i] = r2, o4 = this.getField(n4);
      if (!o4)
        return;
      let s5 = o4;
      for (let a3 of i) {
        let l5;
        if (s5.value instanceof e4 ? l5 = s5.value.getField(a3) : s5.value instanceof Vt && (l5 = s5.value.getField(Number(a3))), !l5)
          return;
        s5 = l5;
      }
      return s5;
    }
    getDeepFieldValue(r2) {
      return r2.length === 0 ? this : this.getDeepField(r2)?.value;
    }
    hasField(r2) {
      return !!this.getField(r2);
    }
    removeAllFields() {
      this.fields = {};
    }
    removeField(r2) {
      delete this.fields[r2];
    }
    getFields() {
      return this.fields;
    }
    isEmpty() {
      return Object.keys(this.fields).length === 0;
    }
    getFieldValue(r2) {
      return this.getField(r2)?.value;
    }
    getDeepSubSelectionValue(r2) {
      let n4 = this;
      for (let i of r2) {
        if (!(n4 instanceof e4))
          return;
        let o4 = n4.getSubSelectionValue(i);
        if (!o4)
          return;
        n4 = o4;
      }
      return n4;
    }
    getDeepSelectionParent(r2) {
      let n4 = this.getSelectionParent();
      if (!n4)
        return;
      let i = n4;
      for (let o4 of r2) {
        let s5 = i.value.getFieldValue(o4);
        if (!s5 || !(s5 instanceof e4))
          return;
        let a3 = s5.getSelectionParent();
        if (!a3)
          return;
        i = a3;
      }
      return i;
    }
    getSelectionParent() {
      let r2 = this.getField("select");
      if (r2?.value instanceof e4)
        return { kind: "select", value: r2.value };
      let n4 = this.getField("include");
      if (n4?.value instanceof e4)
        return { kind: "include", value: n4.value };
    }
    getSubSelectionValue(r2) {
      return this.getSelectionParent()?.value.fields[r2].value;
    }
    getPrintWidth() {
      let r2 = Object.values(this.fields);
      return r2.length == 0 ? 2 : Math.max(...r2.map((i) => i.getPrintWidth())) + 2;
    }
    write(r2) {
      let n4 = Object.values(this.fields);
      if (n4.length === 0 && this.suggestions.length === 0) {
        this.writeEmpty(r2);
        return;
      }
      this.writeWithContents(r2, n4);
    }
    writeEmpty(r2) {
      let n4 = new Le("{}");
      this.hasError && n4.setColor(r2.context.colors.red).underline(), r2.write(n4);
    }
    writeWithContents(r2, n4) {
      r2.writeLine("{").withIndent(() => {
        r2.writeJoined(Bt, [...n4, ...this.suggestions]).newLine();
      }), r2.write("}"), this.hasError && r2.afterNextNewline(() => {
        r2.writeLine(r2.context.colors.red("~".repeat(this.getPrintWidth())));
      });
    }
  };
  var Y = class extends nt {
    constructor(r2) {
      super();
      this.text = r2;
    }
    getPrintWidth() {
      return this.text.length;
    }
    write(r2) {
      let n4 = new Le(this.text);
      this.hasError && n4.underline().setColor(r2.context.colors.red), r2.write(n4);
    }
  };
  var ao = class {
    constructor(t4) {
      this.errorMessages = [];
      this.arguments = t4;
    }
    write(t4) {
      t4.write(this.arguments);
    }
    addErrorMessage(t4) {
      this.errorMessages.push(t4);
    }
    renderAllMessages(t4) {
      return this.errorMessages.map((r2) => r2(t4)).join(`
`);
    }
  };
  var br = "<unknown>";
  var Qp = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var Gp = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  var Hp = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var zp = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  var Yp = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  var Xp = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
  var td = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var lo = class {
    getLocation() {
      return null;
    }
  };
  var uo = class {
    constructor() {
      this._error = new Error;
    }
    getLocation() {
      let t4 = this._error.stack;
      if (!t4)
        return null;
      let n4 = va(t4).find((i) => {
        if (!i.file)
          return false;
        let o4 = $i(i.file);
        return o4 !== "<anonymous>" && !o4.includes("@prisma") && !o4.includes("/packages/client/src/runtime/") && !o4.endsWith("/runtime/binary.js") && !o4.endsWith("/runtime/library.js") && !o4.endsWith("/runtime/edge.js") && !o4.endsWith("/runtime/edge-esm.js") && !o4.startsWith("internal/") && !i.methodName.includes("new ") && !i.methodName.includes("getCallSite") && !i.methodName.includes("Proxy.") && i.methodName.split(".").length < 4;
      });
      return !n4 || !n4.file ? null : { fileName: n4.file, lineNumber: n4.lineNumber, columnNumber: n4.column };
    }
  };
  var Ta = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
  var Sa = (e4) => Array.isArray(e4) ? e4 : e4.split(".");
  var co = (e4, t4) => Sa(t4).reduce((r2, n4) => r2 && r2[n4], e4);
  var Ia = (e4, t4, r2) => Sa(t4).reduceRight((n4, i, o4, s5) => Object.assign({}, co(e4, s5.slice(0, o4)), { [i]: n4 }), r2);
  var La = D(qi());
  var Na = D(import.meta.require("fs"));
  var Da = { keyword: We, entity: We, value: (e4) => de(Rt(e4)), punctuation: Rt, directive: We, function: We, variable: (e4) => de(Rt(e4)), string: (e4) => de(pt(e4)), boolean: Re, number: We, comment: Yr };
  var dd = (e4) => e4;
  var Dn = {};
  var md = 0;
  var C = { manual: Dn.Prism && Dn.Prism.manual, disableWorkerMessageHandler: Dn.Prism && Dn.Prism.disableWorkerMessageHandler, util: { encode: function(e4) {
    if (e4 instanceof Ae) {
      let t4 = e4;
      return new Ae(t4.type, C.util.encode(t4.content), t4.alias);
    } else
      return Array.isArray(e4) ? e4.map(C.util.encode) : e4.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
  }, type: function(e4) {
    return Object.prototype.toString.call(e4).slice(8, -1);
  }, objId: function(e4) {
    return e4.__id || Object.defineProperty(e4, "__id", { value: ++md }), e4.__id;
  }, clone: function e(t4, r2) {
    let n4, i, o4 = C.util.type(t4);
    switch (r2 = r2 || {}, o4) {
      case "Object":
        if (i = C.util.objId(t4), r2[i])
          return r2[i];
        n4 = {}, r2[i] = n4;
        for (let s5 in t4)
          t4.hasOwnProperty(s5) && (n4[s5] = e(t4[s5], r2));
        return n4;
      case "Array":
        return i = C.util.objId(t4), r2[i] ? r2[i] : (n4 = [], r2[i] = n4, t4.forEach(function(s5, a3) {
          n4[a3] = e(s5, r2);
        }), n4);
      default:
        return t4;
    }
  } }, languages: { extend: function(e4, t4) {
    let r2 = C.util.clone(C.languages[e4]);
    for (let n4 in t4)
      r2[n4] = t4[n4];
    return r2;
  }, insertBefore: function(e4, t4, r2, n4) {
    n4 = n4 || C.languages;
    let i = n4[e4], o4 = {};
    for (let a3 in i)
      if (i.hasOwnProperty(a3)) {
        if (a3 == t4)
          for (let l5 in r2)
            r2.hasOwnProperty(l5) && (o4[l5] = r2[l5]);
        r2.hasOwnProperty(a3) || (o4[a3] = i[a3]);
      }
    let s5 = n4[e4];
    return n4[e4] = o4, C.languages.DFS(C.languages, function(a3, l5) {
      l5 === s5 && a3 != e4 && (this[a3] = o4);
    }), o4;
  }, DFS: function e(t4, r2, n4, i) {
    i = i || {};
    let o4 = C.util.objId;
    for (let s5 in t4)
      if (t4.hasOwnProperty(s5)) {
        r2.call(t4, s5, t4[s5], n4 || s5);
        let a3 = t4[s5], l5 = C.util.type(a3);
        l5 === "Object" && !i[o4(a3)] ? (i[o4(a3)] = true, e(a3, r2, null, i)) : l5 === "Array" && !i[o4(a3)] && (i[o4(a3)] = true, e(a3, r2, s5, i));
      }
  } }, plugins: {}, highlight: function(e4, t4, r2) {
    let n4 = { code: e4, grammar: t4, language: r2 };
    return C.hooks.run("before-tokenize", n4), n4.tokens = C.tokenize(n4.code, n4.grammar), C.hooks.run("after-tokenize", n4), Ae.stringify(C.util.encode(n4.tokens), n4.language);
  }, matchGrammar: function(e4, t4, r2, n4, i, o4, s5) {
    for (let g in r2) {
      if (!r2.hasOwnProperty(g) || !r2[g])
        continue;
      if (g == s5)
        return;
      let _ = r2[g];
      _ = C.util.type(_) === "Array" ? _ : [_];
      for (let A = 0;A < _.length; ++A) {
        let R3 = _[A], E = R3.inside, S = !!R3.lookbehind, we = !!R3.greedy, X = 0, ut = R3.alias;
        if (we && !R3.pattern.global) {
          let K = R3.pattern.toString().match(/[imuy]*$/)[0];
          R3.pattern = RegExp(R3.pattern.source, K + "g");
        }
        R3 = R3.pattern || R3;
        for (let K = n4, ie = i;K < t4.length; ie += t4[K].length, ++K) {
          let je = t4[K];
          if (t4.length > e4.length)
            return;
          if (je instanceof Ae)
            continue;
          if (we && K != t4.length - 1) {
            R3.lastIndex = ie;
            var p3 = R3.exec(e4);
            if (!p3)
              break;
            var c4 = p3.index + (S ? p3[1].length : 0), d3 = p3.index + p3[0].length, a3 = K, l5 = ie;
            for (let N = t4.length;a3 < N && (l5 < d3 || !t4[a3].type && !t4[a3 - 1].greedy); ++a3)
              l5 += t4[a3].length, c4 >= l5 && (++K, ie = l5);
            if (t4[K] instanceof Ae)
              continue;
            u3 = a3 - K, je = e4.slice(ie, l5), p3.index -= ie;
          } else {
            R3.lastIndex = 0;
            var p3 = R3.exec(je), u3 = 1;
          }
          if (!p3) {
            if (o4)
              break;
            continue;
          }
          S && (X = p3[1] ? p3[1].length : 0);
          var c4 = p3.index + X, p3 = p3[0].slice(X), d3 = c4 + p3.length, f = je.slice(0, c4), h3 = je.slice(d3);
          let oe = [K, u3];
          f && (++K, ie += f.length, oe.push(f));
          let vt = new Ae(g, E ? C.tokenize(p3, E) : p3, ut, p3, we);
          if (oe.push(vt), h3 && oe.push(h3), Array.prototype.splice.apply(t4, oe), u3 != 1 && C.matchGrammar(e4, t4, r2, K, ie, true, g), o4)
            break;
        }
      }
    }
  }, tokenize: function(e4, t4) {
    let r2 = [e4], n4 = t4.rest;
    if (n4) {
      for (let i in n4)
        t4[i] = n4[i];
      delete t4.rest;
    }
    return C.matchGrammar(e4, r2, t4, 0, 0, false), r2;
  }, hooks: { all: {}, add: function(e4, t4) {
    let r2 = C.hooks.all;
    r2[e4] = r2[e4] || [], r2[e4].push(t4);
  }, run: function(e4, t4) {
    let r2 = C.hooks.all[e4];
    if (!(!r2 || !r2.length))
      for (var n4 = 0, i;i = r2[n4++]; )
        i(t4);
  } }, Token: Ae };
  C.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
  C.languages.javascript = C.languages.extend("clike", { "class-name": [C.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
  C.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
  C.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: C.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: C.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: C.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: C.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
  C.languages.markup && C.languages.markup.tag.addInlined("script", "javascript");
  C.languages.js = C.languages.javascript;
  C.languages.typescript = C.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
  C.languages.ts = C.languages.typescript;
  Ae.stringify = function(e4, t4) {
    return typeof e4 == "string" ? e4 : Array.isArray(e4) ? e4.map(function(r2) {
      return Ae.stringify(r2, t4);
    }).join("") : fd(e4.type)(e4.content);
  };
  var Fa = D(js());
  var kn = class e4 {
    static read(t4) {
      let r2;
      try {
        typeof $fs < "u" ? r2 = $fs.readFileSync(t4, "utf-8") : r2 = Na.default.readFileSync(t4, "utf-8");
      } catch {
        return null;
      }
      return e4.fromContent(r2);
    }
    static fromContent(t4) {
      let r2 = t4.split(/\r?\n/);
      return new e4(1, r2);
    }
    constructor(t4, r2) {
      this.firstLineNumber = t4, this.lines = r2;
    }
    get lastLineNumber() {
      return this.firstLineNumber + this.lines.length - 1;
    }
    mapLineAt(t4, r2) {
      if (t4 < this.firstLineNumber || t4 > this.lines.length + this.firstLineNumber)
        return this;
      let n4 = t4 - this.firstLineNumber, i = [...this.lines];
      return i[n4] = r2(i[n4]), new e4(this.firstLineNumber, i);
    }
    mapLines(t4) {
      return new e4(this.firstLineNumber, this.lines.map((r2, n4) => t4(r2, this.firstLineNumber + n4)));
    }
    lineAt(t4) {
      return this.lines[t4 - this.firstLineNumber];
    }
    prependSymbolAt(t4, r2) {
      return this.mapLines((n4, i) => i === t4 ? `${r2} ${n4}` : `  ${n4}`);
    }
    slice(t4, r2) {
      let n4 = this.lines.slice(t4 - 1, r2).join(`
`);
      return new e4(t4, Oa(n4).split(`
`));
    }
    highlight() {
      let t4 = ka(this.toString());
      return new e4(this.firstLineNumber, t4.split(`
`));
    }
    toString() {
      return this.lines.join(`
`);
    }
  };
  var yd = { red: ve, gray: Yr, dim: He, bold: de, underline: ce, highlightSource: (e4) => e4.highlight() };
  var hd = { red: (e4) => e4, gray: (e4) => e4, dim: (e4) => e4, bold: (e4) => e4, underline: (e4) => e4, highlightSource: (e4) => e4 };
  var Td = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
  var _d = ["aggregate", "count", "groupBy"];
  var fo = Symbol();
  var Qa = (e4) => e4;
  var Nn = class {
    constructor(t4, r2) {
      this.extension = t4;
      this.previous = r2;
      this.computedFieldsCache = new ke;
      this.modelExtensionsCache = new ke;
      this.queryCallbacksCache = new ke;
      this.clientExtensions = lr(() => this.extension.client ? { ...this.previous?.getAllClientExtensions(), ...this.extension.client } : this.previous?.getAllClientExtensions());
      this.batchCallbacks = lr(() => {
        let t5 = this.previous?.getAllBatchQueryCallbacks() ?? [], r3 = this.extension.query?.$__internalBatch;
        return r3 ? t5.concat(r3) : t5;
      });
    }
    getAllComputedFields(t4) {
      return this.computedFieldsCache.getOrCreate(t4, () => Za(this.previous?.getAllComputedFields(t4), this.extension, t4));
    }
    getAllClientExtensions() {
      return this.clientExtensions.get();
    }
    getAllModelExtensions(t4) {
      return this.modelExtensionsCache.getOrCreate(t4, () => {
        let r2 = $e(t4);
        return !this.extension.model || !(this.extension.model[r2] || this.extension.model.$allModels) ? this.previous?.getAllModelExtensions(t4) : { ...this.previous?.getAllModelExtensions(t4), ...this.extension.model.$allModels, ...this.extension.model[r2] };
      });
    }
    getAllQueryCallbacks(t4, r2) {
      return this.queryCallbacksCache.getOrCreate(`${t4}:${r2}`, () => {
        let n4 = this.previous?.getAllQueryCallbacks(t4, r2) ?? [], i = [], o4 = this.extension.query;
        return !o4 || !(o4[t4] || o4.$allModels || o4[r2] || o4.$allOperations) ? n4 : (o4[t4] !== undefined && (o4[t4][r2] !== undefined && i.push(o4[t4][r2]), o4[t4].$allOperations !== undefined && i.push(o4[t4].$allOperations)), t4 !== "$none" && o4.$allModels !== undefined && (o4.$allModels[r2] !== undefined && i.push(o4.$allModels[r2]), o4.$allModels.$allOperations !== undefined && i.push(o4.$allModels.$allOperations)), o4[r2] !== undefined && i.push(o4[r2]), o4.$allOperations !== undefined && i.push(o4.$allOperations), n4.concat(i));
      });
    }
    getAllBatchQueryCallbacks() {
      return this.batchCallbacks.get();
    }
  };
  var Ln = class e4 {
    constructor(t4) {
      this.head = t4;
    }
    static empty() {
      return new e4;
    }
    static single(t4) {
      return new e4(new Nn(t4));
    }
    isEmpty() {
      return this.head === undefined;
    }
    append(t4) {
      return new e4(new Nn(t4, this.head));
    }
    getAllComputedFields(t4) {
      return this.head?.getAllComputedFields(t4);
    }
    getAllClientExtensions() {
      return this.head?.getAllClientExtensions();
    }
    getAllModelExtensions(t4) {
      return this.head?.getAllModelExtensions(t4);
    }
    getAllQueryCallbacks(t4, r2) {
      return this.head?.getAllQueryCallbacks(t4, r2) ?? [];
    }
    getAllBatchQueryCallbacks() {
      return this.head?.getAllBatchQueryCallbacks() ?? [];
    }
  };
  var el = $("prisma:client");
  var tl = { Vercel: "vercel", "Netlify CI": "netlify" };
  var Od = "Cloudflare-Workers";
  var Nd = "node";
  var Qt = class {
  };
  var ll = D(import.meta.require("fs"));
  var Pr = D(import.meta.require("path"));
  var $d = $("prisma:client:engines:resolveEnginePath");
  var qd = () => new RegExp("runtime[\\\\/]library\\.m?js$");
  var go = D(Ui());
  var ml = D(zs());
  var Kn = class extends Error {
    constructor(t4, r2) {
      super(t4), this.clientVersion = r2.clientVersion, this.cause = r2.cause;
    }
    get [Symbol.toStringTag]() {
      return this.name;
    }
  };
  var ye = class extends Kn {
    constructor(t4, r2) {
      super(t4, r2), this.isRetryable = r2.isRetryable ?? true;
    }
  };
  var Gt = class extends ye {
    constructor(r2) {
      super("This request must be retried", I2(r2, true));
      this.name = "ForcedRetryError";
      this.code = "P5001";
    }
  };
  v3(Gt, "ForcedRetryError");
  var xt = class extends ye {
    constructor(r2, n4) {
      super(r2, I2(n4, false));
      this.name = "InvalidDatasourceError";
      this.code = "P6001";
    }
  };
  v3(xt, "InvalidDatasourceError");
  var wt = class extends ye {
    constructor(r2, n4) {
      super(r2, I2(n4, false));
      this.name = "NotImplementedYetError";
      this.code = "P5004";
    }
  };
  v3(wt, "NotImplementedYetError");
  var B = class extends ye {
    constructor(t4, r2) {
      super(t4, r2), this.response = r2.response;
      let n4 = this.response.headers.get("prisma-request-id");
      if (n4) {
        let i = `(The request id was: ${n4})`;
        this.message = this.message + " " + i;
      }
    }
  };
  var Et = class extends B {
    constructor(r2) {
      super("Schema needs to be uploaded", I2(r2, true));
      this.name = "SchemaMissingError";
      this.code = "P5005";
    }
  };
  v3(Et, "SchemaMissingError");
  var yo = "This request could not be understood by the server";
  var vr = class extends B {
    constructor(r2, n4, i) {
      super(n4 || yo, I2(r2, false));
      this.name = "BadRequestError";
      this.code = "P5000";
      i && (this.code = i);
    }
  };
  v3(vr, "BadRequestError");
  var Tr = class extends B {
    constructor(r2, n4) {
      super("Engine not started: healthcheck timeout", I2(r2, true));
      this.name = "HealthcheckTimeoutError";
      this.code = "P5013";
      this.logs = n4;
    }
  };
  v3(Tr, "HealthcheckTimeoutError");
  var _r = class extends B {
    constructor(r2, n4, i) {
      super(n4, I2(r2, true));
      this.name = "EngineStartupError";
      this.code = "P5014";
      this.logs = i;
    }
  };
  v3(_r, "EngineStartupError");
  var Cr = class extends B {
    constructor(r2) {
      super("Engine version is not supported", I2(r2, false));
      this.name = "EngineVersionNotSupportedError";
      this.code = "P5012";
    }
  };
  v3(Cr, "EngineVersionNotSupportedError");
  var ho = "Request timed out";
  var Ar = class extends B {
    constructor(r2, n4 = ho) {
      super(n4, I2(r2, false));
      this.name = "GatewayTimeoutError";
      this.code = "P5009";
    }
  };
  v3(Ar, "GatewayTimeoutError");
  var Bd = "Interactive transaction error";
  var Rr = class extends B {
    constructor(r2, n4 = Bd) {
      super(n4, I2(r2, false));
      this.name = "InteractiveTransactionError";
      this.code = "P5015";
    }
  };
  v3(Rr, "InteractiveTransactionError");
  var Vd = "Request parameters are invalid";
  var Mr = class extends B {
    constructor(r2, n4 = Vd) {
      super(n4, I2(r2, false));
      this.name = "InvalidRequestError";
      this.code = "P5011";
    }
  };
  v3(Mr, "InvalidRequestError");
  var bo = "Requested resource does not exist";
  var Sr = class extends B {
    constructor(r2, n4 = bo) {
      super(n4, I2(r2, false));
      this.name = "NotFoundError";
      this.code = "P5003";
    }
  };
  v3(Sr, "NotFoundError");
  var xo = "Unknown server error";
  var Jt = class extends B {
    constructor(r2, n4, i) {
      super(n4 || xo, I2(r2, true));
      this.name = "ServerError";
      this.code = "P5006";
      this.logs = i;
    }
  };
  v3(Jt, "ServerError");
  var wo = "Unauthorized, check your connection string";
  var Ir = class extends B {
    constructor(r2, n4 = wo) {
      super(n4, I2(r2, false));
      this.name = "UnauthorizedError";
      this.code = "P5007";
    }
  };
  v3(Ir, "UnauthorizedError");
  var Eo = "Usage exceeded, retry again later";
  var Dr = class extends B {
    constructor(r2, n4 = Eo) {
      super(n4, I2(r2, true));
      this.name = "UsageExceededError";
      this.code = "P5008";
    }
  };
  v3(Dr, "UsageExceededError");
  var xl = { "@prisma/debug": "workspace:*", "@prisma/engines-version": "5.9.0-32.23fdc5965b1e05fc54e5f26ed3de66776b93de64", "@prisma/fetch-engine": "workspace:*", "@prisma/get-platform": "workspace:*" };
  var Fr = class extends ye {
    constructor(r2, n4) {
      super(`Cannot fetch data from service:
${r2}`, I2(n4, true));
      this.name = "RequestError";
      this.code = "P5010";
    }
  };
  v3(Fr, "RequestError");
  var Wd = typeof import.meta.require < "u" ? import.meta.require : () => {
  };
  var vo = class {
    constructor(t4 = {}) {
      this.headers = new Map;
      for (let [r2, n4] of Object.entries(t4))
        if (typeof n4 == "string")
          this.headers.set(r2, n4);
        else if (Array.isArray(n4))
          for (let i of n4)
            this.headers.set(r2, i);
    }
    append(t4, r2) {
      this.headers.set(t4, r2);
    }
    delete(t4) {
      this.headers.delete(t4);
    }
    get(t4) {
      return this.headers.get(t4) ?? null;
    }
    has(t4) {
      return this.headers.has(t4);
    }
    set(t4, r2) {
      this.headers.set(t4, r2);
    }
    forEach(t4, r2) {
      for (let [n4, i] of this.headers)
        t4.call(r2, i, n4, this);
    }
  };
  var zd = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
  var wl = $("prisma:client:dataproxyEngine");
  var Pl = 3;
  var To = $("prisma:client:dataproxyEngine");
  var _o = class {
    constructor({ apiKey: t4, tracingHelper: r2, logLevel: n4, logQueries: i, engineHash: o4 }) {
      this.apiKey = t4, this.tracingHelper = r2, this.logLevel = n4, this.logQueries = i, this.engineHash = o4;
    }
    build({ traceparent: t4, interactiveTransaction: r2 } = {}) {
      let n4 = { Authorization: `Bearer ${this.apiKey}`, "Prisma-Engine-Hash": this.engineHash };
      this.tracingHelper.isEnabled() && (n4.traceparent = t4 ?? this.tracingHelper.getTraceParent()), r2 && (n4["X-transaction-id"] = r2.id);
      let i = this.buildCaptureSettings();
      return i.length > 0 && (n4["X-capture-telemetry"] = i.join(", ")), n4;
    }
    buildCaptureSettings() {
      let t4 = [];
      return this.tracingHelper.isEnabled() && t4.push("tracing"), this.logLevel && t4.push(this.logLevel), this.logQueries && t4.push("query"), t4;
    }
  };
  var Or3 = class extends Qt {
    constructor(t4) {
      super(), hl(t4), this.config = t4, this.env = { ...this.config.env, ...process.env }, this.inlineSchema = t4.inlineSchema, this.inlineDatasources = t4.inlineDatasources, this.inlineSchemaHash = t4.inlineSchemaHash, this.clientVersion = t4.clientVersion, this.engineHash = t4.engineVersion, this.logEmitter = t4.logEmitter, this.tracingHelper = this.config.tracingHelper;
    }
    apiKey() {
      return this.headerBuilder.apiKey;
    }
    version() {
      return this.engineHash;
    }
    async start() {
      this.startPromise !== undefined && await this.startPromise, this.startPromise = (async () => {
        let [t4, r2] = this.extractHostAndApiKey();
        this.host = t4, this.headerBuilder = new _o({ apiKey: r2, tracingHelper: this.tracingHelper, logLevel: this.config.logLevel, logQueries: this.config.logQueries, engineHash: this.engineHash }), this.remoteClientVersion = await El(t4, this.config), To("host", this.host);
      })(), await this.startPromise;
    }
    async stop() {
    }
    propagateResponseExtensions(t4) {
      t4?.logs?.length && t4.logs.forEach((r2) => {
        switch (r2.level) {
          case "debug":
          case "error":
          case "trace":
          case "warn":
          case "info":
            break;
          case "query": {
            let n4 = typeof r2.attributes.query == "string" ? r2.attributes.query : "";
            if (!this.tracingHelper.isEnabled()) {
              let [i] = n4.split("/* traceparent");
              n4 = i;
            }
            this.logEmitter.emit("query", { query: n4, timestamp: bl(r2.timestamp), duration: Number(r2.attributes.duration_ms), params: r2.attributes.params, target: r2.attributes.target });
          }
        }
      }), t4?.traces?.length && this.tracingHelper.createEngineSpan({ span: true, spans: t4.traces });
    }
    onBeforeExit() {
      throw new Error('"beforeExit" hook is not applicable to the remote query engine');
    }
    async url(t4) {
      return await this.start(), `https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${t4}`;
    }
    async uploadSchema() {
      let t4 = { name: "schemaUpload", internal: true };
      return this.tracingHelper.runInChildSpan(t4, async () => {
        let r2 = await Pt(await this.url("schema"), { method: "PUT", headers: this.headerBuilder.build(), body: this.inlineSchema, clientVersion: this.clientVersion });
        r2.ok || To("schema response status", r2.status);
        let n4 = await kr(r2, this.clientVersion);
        if (n4)
          throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${n4.message}`, timestamp: new Date, target: "" }), n4;
        this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})`, timestamp: new Date, target: "" });
      });
    }
    request(t4, { traceparent: r2, interactiveTransaction: n4, customDataProxyFetch: i }) {
      return this.requestInternal({ body: t4, traceparent: r2, interactiveTransaction: n4, customDataProxyFetch: i });
    }
    async requestBatch(t4, { traceparent: r2, transaction: n4, customDataProxyFetch: i }) {
      let o4 = n4?.kind === "itx" ? n4.options : undefined, s5 = Vn(t4, n4), { batchResult: a3, elapsed: l5 } = await this.requestInternal({ body: s5, customDataProxyFetch: i, interactiveTransaction: o4, traceparent: r2 });
      return a3.map((u3) => ("errors" in u3) && u3.errors.length > 0 ? Er(u3.errors[0], this.clientVersion) : { data: u3, elapsed: l5 });
    }
    requestInternal({ body: t4, traceparent: r2, customDataProxyFetch: n4, interactiveTransaction: i }) {
      return this.withRetry({ actionGerund: "querying", callback: async ({ logHttpCall: o4 }) => {
        let s5 = i ? `${i.payload.endpoint}/graphql` : await this.url("graphql");
        o4(s5);
        let a3 = await Pt(s5, { method: "POST", headers: this.headerBuilder.build({ traceparent: r2, interactiveTransaction: i }), body: JSON.stringify(t4), clientVersion: this.clientVersion }, n4);
        a3.ok || To("graphql response status", a3.status), await this.handleError(await kr(a3, this.clientVersion));
        let l5 = await a3.json(), u3 = l5.extensions;
        if (u3 && this.propagateResponseExtensions(u3), l5.errors)
          throw l5.errors.length === 1 ? Er(l5.errors[0], this.config.clientVersion) : new W(l5.errors, { clientVersion: this.config.clientVersion });
        return l5;
      } });
    }
    async transaction(t4, r2, n4) {
      let i = { start: "starting", commit: "committing", rollback: "rolling back" };
      return this.withRetry({ actionGerund: `${i[t4]} transaction`, callback: async ({ logHttpCall: o4 }) => {
        if (t4 === "start") {
          let s5 = JSON.stringify({ max_wait: n4?.maxWait ?? 2000, timeout: n4?.timeout ?? 5000, isolation_level: n4?.isolationLevel }), a3 = await this.url("transaction/start");
          o4(a3);
          let l5 = await Pt(a3, { method: "POST", headers: this.headerBuilder.build({ traceparent: r2.traceparent }), body: s5, clientVersion: this.clientVersion });
          await this.handleError(await kr(l5, this.clientVersion));
          let u3 = await l5.json(), c4 = u3.extensions;
          c4 && this.propagateResponseExtensions(c4);
          let p3 = u3.id, d3 = u3["data-proxy"].endpoint;
          return { id: p3, payload: { endpoint: d3 } };
        } else {
          let s5 = `${n4.payload.endpoint}/${t4}`;
          o4(s5);
          let a3 = await Pt(s5, { method: "POST", headers: this.headerBuilder.build({ traceparent: r2.traceparent }), clientVersion: this.clientVersion });
          await this.handleError(await kr(a3, this.clientVersion));
          let u3 = (await a3.json()).extensions;
          u3 && this.propagateResponseExtensions(u3);
          return;
        }
      } });
    }
    extractHostAndApiKey() {
      let t4 = { clientVersion: this.clientVersion }, r2 = Object.keys(this.inlineDatasources)[0], n4 = Un({ inlineDatasources: this.inlineDatasources, overrideDatasources: this.config.overrideDatasources, clientVersion: this.clientVersion, env: this.env }), i;
      try {
        i = new URL(n4);
      } catch {
        throw new xt(`Error validating datasource \`${r2}\`: the URL must start with the protocol \`prisma://\``, t4);
      }
      let { protocol: o4, host: s5, searchParams: a3 } = i;
      if (o4 !== "prisma:")
        throw new xt(`Error validating datasource \`${r2}\`: the URL must start with the protocol \`prisma://\``, t4);
      let l5 = a3.get("api_key");
      if (l5 === null || l5.length < 1)
        throw new xt(`Error validating datasource \`${r2}\`: the URL must contain a valid API key`, t4);
      return [s5, l5];
    }
    metrics() {
      throw new wt("Metrics are not yet supported for Accelerate", { clientVersion: this.clientVersion });
    }
    async withRetry(t4) {
      for (let r2 = 0;; r2++) {
        let n4 = (i) => {
          this.logEmitter.emit("info", { message: `Calling ${i} (n=${r2})`, timestamp: new Date, target: "" });
        };
        try {
          return await t4.callback({ logHttpCall: n4 });
        } catch (i) {
          if (!(i instanceof ye) || !i.isRetryable)
            throw i;
          if (r2 >= Pl)
            throw i instanceof Gt ? i.cause : i;
          this.logEmitter.emit("warn", { message: `Attempt ${r2 + 1}/${Pl} failed for ${t4.actionGerund}: ${i.message ?? "(unknown)"}`, timestamp: new Date, target: "" });
          let o4 = await yl(r2);
          this.logEmitter.emit("warn", { message: `Retrying after ${o4}ms`, timestamp: new Date, target: "" });
        }
      }
    }
    async handleError(t4) {
      if (t4 instanceof Et)
        throw await this.uploadSchema(), new Gt({ clientVersion: this.clientVersion, cause: t4 });
      if (t4)
        throw t4;
    }
  };
  var Ao = D(import.meta.require("os"));
  var Tl = D(import.meta.require("path"));
  var Co = Symbol("PrismaLibraryEngineCache");
  var _l = { async loadLibrary(e4) {
    let t4 = await Si(), r2 = await ul("library", e4);
    try {
      return e4.tracingHelper.runInChildSpan({ name: "loadLibrary", internal: true }, () => em(r2));
    } catch (n4) {
      let i = Li({ e: n4, platformInfo: t4, id: r2 });
      throw new O(i, e4.clientVersion);
    }
  } };
  var So = {};
  Tt(So, { QueryEngine: () => Lr, __wbg_String_88810dfeb4021902: () => Wm, __wbg_buffer_344d9b41efe96da7: () => Ym, __wbg_call_53fc3abd42e24ec8: () => Af, __wbg_call_669127b9d730c650: () => mf, __wbg_crypto_58f13aa23ffcb166: () => of, __wbg_done_bc26bf4ada718266: () => hf, __wbg_entries_6d727b73ee02b7ce: () => Nf, __wbg_from_422023050439b190: () => ef, __wbg_getRandomValues_504510b5564925af: () => nf, __wbg_getTime_ed6ee333b702f8fc: () => Pm, __wbg_get_2aff440840bb6202: () => wf, __wbg_get_4a9aa5157afeb382: () => ff, __wbg_get_94990005bd6ca07c: () => Hm, __wbg_getwithrefkey_5e6d9547403deab8: () => Gm, __wbg_globalThis_17eff828815f7d84: () => vf, __wbg_global_46f939f6541643c5: () => Tf, __wbg_has_cdf8b85f6e903c80: () => xm, __wbg_instanceof_ArrayBuffer_c7cc317e5c29cc0d: () => Of, __wbg_instanceof_Promise_cfbcc42300367513: () => Rm, __wbg_instanceof_Uint8Array_19e6f142a5e7e1e1: () => Ff, __wbg_isArray_38525be7442aa21e: () => Cf, __wbg_isSafeInteger_c38b0a16d0c7cef7: () => Rf, __wbg_iterator_7ee1a391d310f8e4: () => Mm, __wbg_length_a5587d6cd79ab197: () => Df, __wbg_length_cace2e0b3ddc0502: () => Sm, __wbg_msCrypto_abcb1295e768d1f2: () => cf, __wbg_new0_ad75dd38f92424e2: () => Em, __wbg_new_08236689f0afb357: () => qm, __wbg_new_1b94180eeb48f2a2: () => Bm, __wbg_new_c728d68b8b34487e: () => Vm, __wbg_new_d8a000788389a31e: () => Xm, __wbg_new_feb65b865d980ae2: () => fm, __wbg_newnoargs_ccdcae30fd002262: () => _f, __wbg_newwithbyteoffsetandlength_2dc04d99088b15e3: () => Zm, __wbg_newwithlength_13b5319ab422dcf6: () => pf, __wbg_next_15da6a3df9290720: () => xf, __wbg_next_1989a20442400aaa: () => yf, __wbg_node_523d7bd03ef69fba: () => lf, __wbg_now_4579335d3581594c: () => _m, __wbg_now_8ed1a4454e40ecd1: () => Tm, __wbg_parse_3f0cb48976ca4123: () => wm, __wbg_process_5b786e71d465a513: () => sf, __wbg_push_fd3233d09cf81821: () => Jm, __wbg_randomFillSync_a0d98aa11c81fe89: () => tf, __wbg_require_2784e593a4674877: () => uf, __wbg_resolve_a3252b2860f0a09e: () => Uf, __wbg_self_3fad056edded10bd: () => Ef, __wbg_setTimeout_631fe61f31fa2fad: () => gm, __wbg_set_0ac78a2bc07da03c: () => jm, __wbg_set_3355b9f2d3092e3b: () => Qm, __wbg_set_40f7786a25a9cc7e: () => Mf, __wbg_set_841ac57cff3d672b: () => Km, __wbg_set_dcfd613a3420f908: () => If, __wbg_set_wasm: () => Mo, __wbg_static_accessor_PERFORMANCE_1a325848eb3ce65a: () => Cm, __wbg_stringify_4039297315a25b00: () => Sf, __wbg_subarray_6ca5cfa7fbb9abbe: () => rf, __wbg_then_1bbc9edafd859b06: () => Vf, __wbg_then_89e1c559530b85cf: () => Bf, __wbg_valueOf_ff4b62641803432a: () => gf, __wbg_value_0570714ff7d75f35: () => bf, __wbg_versions_c2ab80650590b6a2: () => af, __wbg_window_a4f46c98a61d4089: () => Pf, __wbindgen_bigint_from_i64: () => Fm, __wbindgen_bigint_from_u64: () => Nm, __wbindgen_bigint_get_as_i64: () => Lf, __wbindgen_boolean_get: () => Im, __wbindgen_cb_drop: () => jf, __wbindgen_closure_wrapper7401: () => Kf, __wbindgen_debug_string: () => $f, __wbindgen_error_new: () => mm, __wbindgen_in: () => Om, __wbindgen_is_bigint: () => Dm, __wbindgen_is_function: () => df, __wbindgen_is_object: () => Am, __wbindgen_is_string: () => Um, __wbindgen_is_undefined: () => bm, __wbindgen_jsval_eq: () => Lm, __wbindgen_jsval_loose_eq: () => kf, __wbindgen_memory: () => zm, __wbindgen_number_get: () => km, __wbindgen_number_new: () => $m, __wbindgen_object_clone_ref: () => hm, __wbindgen_object_drop_ref: () => vm, __wbindgen_string_get: () => dm, __wbindgen_string_new: () => ym, __wbindgen_throw: () => qf, debug_panic: () => cm, getBuildTimeInfo: () => um });
  var b3;
  var Ke = new Array(128).fill(undefined);
  Ke.push(undefined, null, true, false);
  var Z = 0;
  var Qn = null;
  var tm = typeof TextEncoder > "u" ? (0, module.require)("util").TextEncoder : TextEncoder;
  var zn = new tm("utf-8");
  var rm = typeof zn.encodeInto == "function" ? function(e4, t4) {
    return zn.encodeInto(e4, t4);
  } : function(e4, t4) {
    let r2 = zn.encode(e4);
    return t4.set(r2), { read: e4.length, written: r2.length };
  };
  var Gn = null;
  var nm = typeof TextDecoder > "u" ? (0, module.require)("util").TextDecoder : TextDecoder;
  var Cl = new nm("utf-8", { ignoreBOM: true, fatal: true });
  Cl.decode();
  var Nr = Ke.length;
  var Jn = null;
  var Hn = null;
  var Lr = class {
    __destroy_into_raw() {
      let t4 = this.__wbg_ptr;
      return this.__wbg_ptr = 0, t4;
    }
    free() {
      let t4 = this.__destroy_into_raw();
      b3.__wbg_queryengine_free(t4);
    }
    constructor(t4, r2, n4) {
      try {
        let a3 = b3.__wbindgen_add_to_stack_pointer(-16);
        b3.queryengine_new(a3, w(t4), w(r2), w(n4));
        var i = xe()[a3 / 4 + 0], o4 = xe()[a3 / 4 + 1], s5 = xe()[a3 / 4 + 2];
        if (s5)
          throw ne(o4);
        return this.__wbg_ptr = i >>> 0, this;
      } finally {
        b3.__wbindgen_add_to_stack_pointer(16);
      }
    }
    connect(t4) {
      let r2 = le(t4, b3.__wbindgen_malloc, b3.__wbindgen_realloc), n4 = Z, i = b3.queryengine_connect(this.__wbg_ptr, r2, n4);
      return ne(i);
    }
    disconnect(t4) {
      let r2 = le(t4, b3.__wbindgen_malloc, b3.__wbindgen_realloc), n4 = Z, i = b3.queryengine_disconnect(this.__wbg_ptr, r2, n4);
      return ne(i);
    }
    query(t4, r2, n4) {
      let i = le(t4, b3.__wbindgen_malloc, b3.__wbindgen_realloc), o4 = Z, s5 = le(r2, b3.__wbindgen_malloc, b3.__wbindgen_realloc), a3 = Z;
      var l5 = at(n4) ? 0 : le(n4, b3.__wbindgen_malloc, b3.__wbindgen_realloc), u3 = Z;
      let c4 = b3.queryengine_query(this.__wbg_ptr, i, o4, s5, a3, l5, u3);
      return ne(c4);
    }
    startTransaction(t4, r2) {
      let n4 = le(t4, b3.__wbindgen_malloc, b3.__wbindgen_realloc), i = Z, o4 = le(r2, b3.__wbindgen_malloc, b3.__wbindgen_realloc), s5 = Z, a3 = b3.queryengine_startTransaction(this.__wbg_ptr, n4, i, o4, s5);
      return ne(a3);
    }
    commitTransaction(t4, r2) {
      let n4 = le(t4, b3.__wbindgen_malloc, b3.__wbindgen_realloc), i = Z, o4 = le(r2, b3.__wbindgen_malloc, b3.__wbindgen_realloc), s5 = Z, a3 = b3.queryengine_commitTransaction(this.__wbg_ptr, n4, i, o4, s5);
      return ne(a3);
    }
    rollbackTransaction(t4, r2) {
      let n4 = le(t4, b3.__wbindgen_malloc, b3.__wbindgen_realloc), i = Z, o4 = le(r2, b3.__wbindgen_malloc, b3.__wbindgen_realloc), s5 = Z, a3 = b3.queryengine_rollbackTransaction(this.__wbg_ptr, n4, i, o4, s5);
      return ne(a3);
    }
    metrics(t4) {
      let r2 = le(t4, b3.__wbindgen_malloc, b3.__wbindgen_realloc), n4 = Z, i = b3.queryengine_metrics(this.__wbg_ptr, r2, n4);
      return ne(i);
    }
  };
  var Io;
  var Al = { async loadLibrary(e4) {
    let { clientVersion: t4, adapter: r2 } = e4;
    if (r2 === undefined)
      throw new O(`The \`adapter\` option for \`PrismaClient\` is required in this context (${$n()})`, t4);
    return Io === undefined && (Io = (async () => {
      let n4 = await e4.getQueryEngineWasmModule?.();
      if (n4 == null)
        throw new O("The loaded wasm module was unexpectedly `undefined` or `null` once loaded", t4);
      let i = { "./query_engine_bg.js": So }, o4 = new WebAssembly.Instance(n4, i);
      Mo(o4.exports);
    })()), await Io, { debugPanic() {
      return Promise.reject("{}");
    }, dmmf() {
      return Promise.resolve("{}");
    }, version() {
      return { commit: "unknown", version: "unknown" };
    }, QueryEngine: Lr };
  } };
  var Qf = "P2036";
  var qe = $("prisma:client:libraryEngine");
  var Rl = [...Pi, "native"];
  var Ml = 0;
  var qr = class extends Qt {
    constructor(t4, r2) {
      super(), this.libraryLoader = r2 ?? _l, t4.getQueryEngineWasmModule !== undefined && (this.libraryLoader = r2 ?? Al), this.config = t4, this.libraryStarted = false, this.logQueries = t4.logQueries ?? false, this.logLevel = t4.logLevel ?? "error", this.logEmitter = t4.logEmitter, this.datamodel = atob(t4.inlineSchema), t4.enableDebugLogs && (this.logLevel = "debug");
      let n4 = Object.keys(t4.overrideDatasources)[0], i = t4.overrideDatasources[n4]?.url;
      n4 !== undefined && i !== undefined && (this.datasourceOverrides = { [n4]: i }), this.libraryInstantiationPromise = this.instantiateLibrary(), this.checkForTooManyEngines();
    }
    checkForTooManyEngines() {
      Ml === 10 && console.warn(`${Re("warn(prisma-client)")} This is the 10th instance of Prisma Client being started. Make sure this is intentional.`);
    }
    async transaction(t4, r2, n4) {
      await this.start();
      let i = JSON.stringify(r2), o4;
      if (t4 === "start") {
        let a3 = JSON.stringify({ max_wait: n4?.maxWait ?? 2000, timeout: n4?.timeout ?? 5000, isolation_level: n4?.isolationLevel });
        o4 = await this.engine?.startTransaction(a3, i);
      } else
        t4 === "commit" ? o4 = await this.engine?.commitTransaction(n4.id, i) : t4 === "rollback" && (o4 = await this.engine?.rollbackTransaction(n4.id, i));
      let s5 = this.parseEngineResponse(o4);
      if (Hf(s5)) {
        let a3 = this.getExternalAdapterError(s5);
        throw a3 ? a3.error : new H3(s5.message, { code: s5.error_code, clientVersion: this.config.clientVersion, meta: s5.meta });
      }
      return s5;
    }
    async instantiateLibrary() {
      if (qe("internalSetup"), this.libraryInstantiationPromise)
        return this.libraryInstantiationPromise;
      Ei(), this.binaryTarget = await this.getCurrentBinaryTarget(), await this.loadEngine(), this.version();
    }
    async getCurrentBinaryTarget() {
      {
        if (this.binaryTarget)
          return this.binaryTarget;
        let t4 = await ft();
        if (!Rl.includes(t4))
          throw new O(`Unknown ${ve("PRISMA_QUERY_ENGINE_LIBRARY")} ${ve(de(t4))}. Possible binaryTargets: ${pt(Rl.join(", "))} or a path to the query engine library.
You may have to run ${pt("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
        return t4;
      }
    }
    parseEngineResponse(t4) {
      if (!t4)
        throw new W("Response from the Engine was empty", { clientVersion: this.config.clientVersion });
      try {
        return JSON.parse(t4);
      } catch {
        throw new W("Unable to JSON.parse response from engine", { clientVersion: this.config.clientVersion });
      }
    }
    async loadEngine() {
      if (!this.engine) {
        this.QueryEngineConstructor || (this.library = await this.libraryLoader.loadLibrary(this.config), this.QueryEngineConstructor = this.library.QueryEngine);
        try {
          let t4 = new WeakRef(this), { adapter: r2 } = this.config;
          r2 && qe("Using driver adapter: %O", r2), this.engine = new this.QueryEngineConstructor({ datamodel: this.datamodel, env: process.env, logQueries: this.config.logQueries ?? false, ignoreEnvVarErrors: true, datasourceOverrides: this.datasourceOverrides ?? {}, logLevel: this.logLevel, configDir: this.config.cwd, engineProtocol: "json" }, (n4) => {
            t4.deref()?.logger(n4);
          }, r2), Ml++;
        } catch (t4) {
          let r2 = t4, n4 = this.parseInitError(r2.message);
          throw typeof n4 == "string" ? r2 : new O(n4.message, this.config.clientVersion, n4.error_code);
        }
      }
    }
    logger(t4) {
      let r2 = this.parseEngineResponse(t4);
      if (r2) {
        if ("span" in r2) {
          this.config.tracingHelper.createEngineSpan(r2);
          return;
        }
        r2.level = r2?.level.toLowerCase() ?? "unknown", Gf(r2) ? this.logEmitter.emit("query", { timestamp: new Date, query: r2.query, params: r2.params, duration: Number(r2.duration_ms), target: r2.module_path }) : Jf(r2) ? this.loggerRustPanic = new be(this.getErrorMessageWithLink(`${r2.message}: ${r2.reason} in ${r2.file}:${r2.line}:${r2.column}`), this.config.clientVersion) : this.logEmitter.emit(r2.level, { timestamp: new Date, message: r2.message, target: r2.module_path });
      }
    }
    getErrorMessageWithLink(t4) {
      return gl({ binaryTarget: this.binaryTarget, title: t4, version: this.config.clientVersion, engineVersion: this.versionInfo?.commit, database: this.config.activeProvider, query: this.lastQuery });
    }
    parseInitError(t4) {
      try {
        return JSON.parse(t4);
      } catch {
      }
      return t4;
    }
    parseRequestError(t4) {
      try {
        return JSON.parse(t4);
      } catch {
      }
      return t4;
    }
    onBeforeExit() {
      throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.');
    }
    async start() {
      if (await this.libraryInstantiationPromise, await this.libraryStoppingPromise, this.libraryStartingPromise)
        return qe(`library already starting, this.libraryStarted: ${this.libraryStarted}`), this.libraryStartingPromise;
      if (this.libraryStarted)
        return;
      let t4 = async () => {
        qe("library starting");
        try {
          let r2 = { traceparent: this.config.tracingHelper.getTraceParent() };
          await this.engine?.connect(JSON.stringify(r2)), this.libraryStarted = true, qe("library started");
        } catch (r2) {
          let n4 = this.parseInitError(r2.message);
          throw typeof n4 == "string" ? r2 : new O(n4.message, this.config.clientVersion, n4.error_code);
        } finally {
          this.libraryStartingPromise = undefined;
        }
      };
      return this.libraryStartingPromise = this.config.tracingHelper.runInChildSpan("connect", t4), this.libraryStartingPromise;
    }
    async stop() {
      if (await this.libraryStartingPromise, await this.executingQueryPromise, this.libraryStoppingPromise)
        return qe("library is already stopping"), this.libraryStoppingPromise;
      if (!this.libraryStarted)
        return;
      let t4 = async () => {
        await new Promise((n4) => setTimeout(n4, 5)), qe("library stopping");
        let r2 = { traceparent: this.config.tracingHelper.getTraceParent() };
        await this.engine?.disconnect(JSON.stringify(r2)), this.libraryStarted = false, this.libraryStoppingPromise = undefined, qe("library stopped");
      };
      return this.libraryStoppingPromise = this.config.tracingHelper.runInChildSpan("disconnect", t4), this.libraryStoppingPromise;
    }
    version() {
      return this.versionInfo = this.library?.version(), this.versionInfo?.version ?? "unknown";
    }
    debugPanic(t4) {
      return this.library?.debugPanic(t4);
    }
    async request(t4, { traceparent: r2, interactiveTransaction: n4 }) {
      qe(`sending request, this.libraryStarted: ${this.libraryStarted}`);
      let i = JSON.stringify({ traceparent: r2 }), o4 = JSON.stringify(t4);
      try {
        await this.start(), this.executingQueryPromise = this.engine?.query(o4, i, n4?.id), this.lastQuery = o4;
        let s5 = this.parseEngineResponse(await this.executingQueryPromise);
        if (s5.errors)
          throw s5.errors.length === 1 ? this.buildQueryError(s5.errors[0]) : new W(JSON.stringify(s5.errors), { clientVersion: this.config.clientVersion });
        if (this.loggerRustPanic)
          throw this.loggerRustPanic;
        return { data: s5, elapsed: 0 };
      } catch (s5) {
        if (s5 instanceof O)
          throw s5;
        if (s5.code === "GenericFailure" && s5.message?.startsWith("PANIC:"))
          throw new be(this.getErrorMessageWithLink(s5.message), this.config.clientVersion);
        let a3 = this.parseRequestError(s5.message);
        throw typeof a3 == "string" ? s5 : new W(`${a3.message}
${a3.backtrace}`, { clientVersion: this.config.clientVersion });
      }
    }
    async requestBatch(t4, { transaction: r2, traceparent: n4 }) {
      qe("requestBatch");
      let i = Vn(t4, r2);
      await this.start(), this.lastQuery = JSON.stringify(i), this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify({ traceparent: n4 }), vl(r2));
      let o4 = await this.executingQueryPromise, s5 = this.parseEngineResponse(o4);
      if (s5.errors)
        throw s5.errors.length === 1 ? this.buildQueryError(s5.errors[0]) : new W(JSON.stringify(s5.errors), { clientVersion: this.config.clientVersion });
      let { batchResult: a3, errors: l5 } = s5;
      if (Array.isArray(a3))
        return a3.map((u3) => u3.errors && u3.errors.length > 0 ? this.loggerRustPanic ?? this.buildQueryError(u3.errors[0]) : { data: u3, elapsed: 0 });
      throw l5 && l5.length === 1 ? new Error(l5[0].error) : new Error(JSON.stringify(s5));
    }
    buildQueryError(t4) {
      if (t4.user_facing_error.is_panic)
        return new be(this.getErrorMessageWithLink(t4.user_facing_error.message), this.config.clientVersion);
      let r2 = this.getExternalAdapterError(t4.user_facing_error);
      return r2 ? r2.error : Er(t4, this.config.clientVersion);
    }
    getExternalAdapterError(t4) {
      if (t4.error_code === Qf && this.config.adapter) {
        let r2 = t4.meta?.id;
        pn(typeof r2 == "number", "Malformed external JS error received from the engine");
        let n4 = this.config.adapter.errorRegistry.consumeError(r2);
        return pn(n4, "External error with reported id was not registered"), n4;
      }
    }
    async metrics(t4) {
      await this.start();
      let r2 = await this.engine.metrics(JSON.stringify(t4));
      return t4.format === "prometheus" ? r2 : this.parseEngineResponse(r2);
    }
  };
  var Nl = D(Do());
  var Qe = class {
    constructor(t4, r2) {
      this.name = t4;
      this.value = r2;
      this.isRequired = false;
    }
    makeRequired() {
      return this.isRequired = true, this;
    }
    write(t4) {
      let { colors: { green: r2 } } = t4.context;
      t4.addMarginSymbol(r2(this.isRequired ? "+" : "?")), t4.write(r2(this.name)), this.isRequired || t4.write(r2("?")), t4.write(r2(": ")), typeof this.value == "string" ? t4.write(r2(this.value)) : t4.write(this.value);
    }
  };
  var Xn = class {
    constructor() {
      this.fields = [];
    }
    addField(t4, r2) {
      return this.fields.push({ write(n4) {
        let { green: i, dim: o4 } = n4.context.colors;
        n4.write(i(o4(`${t4}: ${r2}`))).addMarginSymbol(i(o4("+")));
      } }), this;
    }
    write(t4) {
      let { colors: { green: r2 } } = t4.context;
      t4.writeLine(r2("{")).withIndent(() => {
        t4.writeJoined(Bt, this.fields).newLine();
      }).write(r2("}")).addMarginSymbol(r2("+"));
    }
  };
  var pg = 3;
  var mg = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", update: "updateOne", updateMany: "updateMany", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
  var ko = class e4 {
    constructor(t4) {
      this.params = t4;
      this.params.modelName && (this.model = this.params.runtimeDataModel.models[this.params.modelName]);
    }
    throwValidationError(t4) {
      ri({ errors: [t4], originalMethod: this.params.originalMethod, args: this.params.rootArgs ?? {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion });
    }
    getSelectionPath() {
      return this.params.selectionPath;
    }
    getArgumentPath() {
      return this.params.argumentPath;
    }
    getArgumentName() {
      return this.params.argumentPath[this.params.argumentPath.length - 1];
    }
    getOutputTypeDescription() {
      if (!(!this.params.modelName || !this.model))
        return { name: this.params.modelName, fields: this.model.fields.map((t4) => ({ name: t4.name, typeName: "boolean", isRelation: t4.kind === "object" })) };
    }
    isRawAction() {
      return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
    }
    getComputedFields() {
      if (this.params.modelName)
        return this.params.extensions.getAllComputedFields(this.params.modelName);
    }
    findField(t4) {
      return this.model?.fields.find((r2) => r2.name === t4);
    }
    nestSelection(t4) {
      let r2 = this.findField(t4), n4 = r2?.kind === "object" ? r2.type : undefined;
      return new e4({ ...this.params, modelName: n4, selectionPath: this.params.selectionPath.concat(t4) });
    }
    nestArgument(t4) {
      return new e4({ ...this.params, argumentPath: this.params.argumentPath.concat(t4) });
    }
  };
  var Kl = (e4) => ({ command: e4 });
  var Ql = (e4) => e4.strings.reduce((t4, r2, n4) => `${t4}@P${n4}${r2}`);
  var vg = /^(\s*alter\s)/i;
  var Wl = $("prisma:client");
  var No = ({ clientMethod: e4, activeProvider: t4 }) => (r2) => {
    let n4 = "", i;
    if (Array.isArray(r2)) {
      let [o4, ...s5] = r2;
      n4 = o4, i = { values: Br(s5 || []), __prismaRawParameters__: true };
    } else
      switch (t4) {
        case "sqlite":
        case "mysql": {
          n4 = r2.sql, i = { values: Br(r2.values), __prismaRawParameters__: true };
          break;
        }
        case "cockroachdb":
        case "postgresql":
        case "postgres": {
          n4 = r2.text, i = { values: Br(r2.values), __prismaRawParameters__: true };
          break;
        }
        case "sqlserver": {
          n4 = Ql(r2), i = { values: Br(r2.values), __prismaRawParameters__: true };
          break;
        }
        default:
          throw new Error(`The ${t4} provider does not support ${e4}`);
      }
    return i?.values ? Wl(`prisma.${e4}(${n4}, ${i.values})`) : Wl(`prisma.${e4}(${n4})`), { query: n4, parameters: i };
  };
  var zl = { requestArgsToMiddlewareArgs(e4) {
    return [e4.strings, ...e4.values];
  }, middlewareArgsToRequestArgs(e4) {
    let [t4, ...r2] = e4;
    return new fe(t4, r2);
  } };
  var Yl = { requestArgsToMiddlewareArgs(e4) {
    return [e4];
  }, middlewareArgsToRequestArgs(e4) {
    return e4[0];
  } };
  var Xl = { isEnabled() {
    return false;
  }, getTraceParent() {
    return "00-10-10-00";
  }, async createEngineSpan() {
  }, getActiveContext() {
  }, runInChildSpan(e4, t4) {
    return t4();
  } };
  var $o = class {
    isEnabled() {
      return this.getGlobalTracingHelper().isEnabled();
    }
    getTraceParent(t4) {
      return this.getGlobalTracingHelper().getTraceParent(t4);
    }
    createEngineSpan(t4) {
      return this.getGlobalTracingHelper().createEngineSpan(t4);
    }
    getActiveContext() {
      return this.getGlobalTracingHelper().getActiveContext();
    }
    runInChildSpan(t4, r2) {
      return this.getGlobalTracingHelper().runInChildSpan(t4, r2);
    }
    getGlobalTracingHelper() {
      return globalThis.PRISMA_INSTRUMENTATION?.helper ?? Xl;
    }
  };
  var ni = class {
    constructor() {
      this._middlewares = [];
    }
    use(t4) {
      this._middlewares.push(t4);
    }
    get(t4) {
      return this._middlewares[t4];
    }
    has(t4) {
      return !!this._middlewares[t4];
    }
    length() {
      return this._middlewares.length;
    }
  };
  var iu = D(Ui());
  var Cg = { aggregate: false, aggregateRaw: false, createMany: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateOne: true, upsertOne: true };
  var si = class {
    constructor(t4) {
      this.options = t4;
      this.tickActive = false;
      this.batches = {};
    }
    request(t4) {
      let r2 = this.options.batchBy(t4);
      return r2 ? (this.batches[r2] || (this.batches[r2] = [], this.tickActive || (this.tickActive = true, process.nextTick(() => {
        this.dispatchBatches(), this.tickActive = false;
      }))), new Promise((n4, i) => {
        this.batches[r2].push({ request: t4, resolve: n4, reject: i });
      })) : this.options.singleLoader(t4);
    }
    dispatchBatches() {
      for (let t4 in this.batches) {
        let r2 = this.batches[t4];
        delete this.batches[t4], r2.length === 1 ? this.options.singleLoader(r2[0].request).then((n4) => {
          n4 instanceof Error ? r2[0].reject(n4) : r2[0].resolve(n4);
        }).catch((n4) => {
          r2[0].reject(n4);
        }) : (r2.sort((n4, i) => this.options.batchOrder(n4.request, i.request)), this.options.batchLoader(r2.map((n4) => n4.request)).then((n4) => {
          if (n4 instanceof Error)
            for (let i = 0;i < r2.length; i++)
              r2[i].reject(n4);
          else
            for (let i = 0;i < r2.length; i++) {
              let o4 = n4[i];
              o4 instanceof Error ? r2[i].reject(o4) : r2[i].resolve(o4);
            }
        }).catch((n4) => {
          for (let i = 0;i < r2.length; i++)
            r2[i].reject(n4);
        }));
      }
    }
    get [Symbol.toStringTag]() {
      return "DataLoader";
    }
  };
  var Ag = $("prisma:client:request_handler");
  var ai = class {
    constructor(t4, r2) {
      this.logEmitter = r2, this.client = t4, this.dataloader = new si({ batchLoader: Ha(async ({ requests: n4, customDataProxyFetch: i }) => {
        let { transaction: o4, otelParentCtx: s5 } = n4[0], a3 = n4.map((p3) => p3.protocolQuery), l5 = this.client._tracingHelper.getTraceParent(s5), u3 = n4.some((p3) => jo(p3.protocolQuery.action));
        return (await this.client._engine.requestBatch(a3, { traceparent: l5, transaction: Rg(o4), containsWrite: u3, customDataProxyFetch: i })).map((p3, d3) => {
          if (p3 instanceof Error)
            return p3;
          try {
            return this.mapQueryEngineResult(n4[d3], p3);
          } catch (f) {
            return f;
          }
        });
      }), singleLoader: async (n4) => {
        let i = n4.transaction?.kind === "itx" ? ou(n4.transaction) : undefined, o4 = await this.client._engine.request(n4.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: i, isWrite: jo(n4.protocolQuery.action), customDataProxyFetch: n4.customDataProxyFetch });
        return this.mapQueryEngineResult(n4, o4);
      }, batchBy: (n4) => n4.transaction?.id ? `transaction-${n4.transaction.id}` : nu(n4.protocolQuery), batchOrder(n4, i) {
        return n4.transaction?.kind === "batch" && i.transaction?.kind === "batch" ? n4.transaction.index - i.transaction.index : 0;
      } });
    }
    async request(t4) {
      try {
        return await this.dataloader.request(t4);
      } catch (r2) {
        let { clientMethod: n4, callsite: i, transaction: o4, args: s5, modelName: a3 } = t4;
        this.handleAndLogRequestError({ error: r2, clientMethod: n4, callsite: i, transaction: o4, args: s5, modelName: a3 });
      }
    }
    mapQueryEngineResult({ dataPath: t4, unpacker: r2 }, n4) {
      let i = n4?.data, o4 = n4?.elapsed, s5 = this.unpack(i, t4, r2);
      return process.env.PRISMA_CLIENT_GET_TIME ? { data: s5, elapsed: o4 } : s5;
    }
    handleAndLogRequestError(t4) {
      try {
        this.handleRequestError(t4);
      } catch (r2) {
        throw this.logEmitter && this.logEmitter.emit("error", { message: r2.message, target: t4.clientMethod, timestamp: new Date }), r2;
      }
    }
    handleRequestError({ error: t4, clientMethod: r2, callsite: n4, transaction: i, args: o4, modelName: s5 }) {
      if (Ag(t4), Mg(t4, i) || t4 instanceof Ve)
        throw t4;
      if (t4 instanceof H3 && Sg(t4)) {
        let l5 = su(t4.meta);
        ri({ args: o4, errors: [l5], callsite: n4, errorFormat: this.client._errorFormat, originalMethod: r2, clientVersion: this.client._clientVersion });
      }
      let a3 = t4.message;
      if (n4 && (a3 = Kt({ callsite: n4, originalMethod: r2, isPanic: t4.isPanic, showColors: this.client._errorFormat === "pretty", message: a3 })), a3 = this.sanitizeMessage(a3), t4.code) {
        let l5 = s5 ? { modelName: s5, ...t4.meta } : t4.meta;
        throw new H3(a3, { code: t4.code, clientVersion: this.client._clientVersion, meta: l5, batchRequestIdx: t4.batchRequestIdx });
      } else {
        if (t4.isPanic)
          throw new be(a3, this.client._clientVersion);
        if (t4 instanceof W)
          throw new W(a3, { clientVersion: this.client._clientVersion, batchRequestIdx: t4.batchRequestIdx });
        if (t4 instanceof O)
          throw new O(a3, this.client._clientVersion);
        if (t4 instanceof be)
          throw new be(a3, this.client._clientVersion);
      }
      throw t4.clientVersion = this.client._clientVersion, t4;
    }
    sanitizeMessage(t4) {
      return this.client._errorFormat && this.client._errorFormat !== "pretty" ? (0, iu.default)(t4) : t4;
    }
    unpack(t4, r2, n4) {
      if (!t4 || (t4.data && (t4 = t4.data), !t4))
        return t4;
      let i = Object.values(t4)[0], o4 = r2.filter((a3) => a3 !== "select" && a3 !== "include"), s5 = oi(co(i, o4));
      return n4 ? n4(s5) : s5;
    }
    get [Symbol.toStringTag]() {
      return "RequestHandler";
    }
  };
  var au = "5.9.1";
  var lu = au;
  var fu = D(Do());
  var U = class extends Error {
    constructor(t4) {
      super(t4 + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientConstructorValidationError";
    }
  };
  v3(U, "PrismaClientConstructorValidationError");
  var pu = ["datasources", "datasourceUrl", "errorFormat", "adapter", "log", "__internal"];
  var du = ["pretty", "colorless", "minimal"];
  var mu = ["info", "query", "warn", "error"];
  var Dg = { datasources: (e4, { datasourceNames: t4 }) => {
    if (e4) {
      if (typeof e4 != "object" || Array.isArray(e4))
        throw new U(`Invalid value ${JSON.stringify(e4)} for "datasources" provided to PrismaClient constructor`);
      for (let [r2, n4] of Object.entries(e4)) {
        if (!t4.includes(r2)) {
          let i = Wt(r2, t4) || ` Available datasources: ${t4.join(", ")}`;
          throw new U(`Unknown datasource ${r2} provided to PrismaClient constructor.${i}`);
        }
        if (typeof n4 != "object" || Array.isArray(n4))
          throw new U(`Invalid value ${JSON.stringify(e4)} for datasource "${r2}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
        if (n4 && typeof n4 == "object")
          for (let [i, o4] of Object.entries(n4)) {
            if (i !== "url")
              throw new U(`Invalid value ${JSON.stringify(e4)} for datasource "${r2}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            if (typeof o4 != "string")
              throw new U(`Invalid value ${JSON.stringify(o4)} for datasource "${r2}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
      }
    }
  }, adapter: (e4, t4) => {
    if (e4 === null)
      return;
    if (e4 === undefined)
      throw new U('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');
    if (!Yn(t4).includes("driverAdapters"))
      throw new U('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');
    if (nr() === "binary")
      throw new U('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.');
  }, datasourceUrl: (e4) => {
    if (typeof e4 < "u" && typeof e4 != "string")
      throw new U(`Invalid value ${JSON.stringify(e4)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
  }, errorFormat: (e4) => {
    if (e4) {
      if (typeof e4 != "string")
        throw new U(`Invalid value ${JSON.stringify(e4)} for "errorFormat" provided to PrismaClient constructor.`);
      if (!du.includes(e4)) {
        let t4 = Wt(e4, du);
        throw new U(`Invalid errorFormat ${e4} provided to PrismaClient constructor.${t4}`);
      }
    }
  }, log: (e4) => {
    if (!e4)
      return;
    if (!Array.isArray(e4))
      throw new U(`Invalid value ${JSON.stringify(e4)} for "log" provided to PrismaClient constructor.`);
    function t4(r2) {
      if (typeof r2 == "string" && !mu.includes(r2)) {
        let n4 = Wt(r2, mu);
        throw new U(`Invalid log level "${r2}" provided to PrismaClient constructor.${n4}`);
      }
    }
    for (let r2 of e4) {
      t4(r2);
      let n4 = { level: t4, emit: (i) => {
        let o4 = ["stdout", "event"];
        if (!o4.includes(i)) {
          let s5 = Wt(i, o4);
          throw new U(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s5}`);
        }
      } };
      if (r2 && typeof r2 == "object")
        for (let [i, o4] of Object.entries(r2))
          if (n4[i])
            n4[i](o4);
          else
            throw new U(`Invalid property ${i} for "log" provided to PrismaClient constructor`);
    }
  }, __internal: (e4) => {
    if (!e4)
      return;
    let t4 = ["debug", "engine", "configOverride"];
    if (typeof e4 != "object")
      throw new U(`Invalid value ${JSON.stringify(e4)} for "__internal" to PrismaClient constructor`);
    for (let [r2] of Object.entries(e4))
      if (!t4.includes(r2)) {
        let n4 = Wt(r2, t4);
        throw new U(`Invalid property ${JSON.stringify(r2)} for "__internal" provided to PrismaClient constructor.${n4}`);
      }
  } };
  var lt = $("prisma:client");
  typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
  var Fg = { requestArgsToMiddlewareArgs: (e4) => e4, middlewareArgsToRequestArgs: (e4) => e4 };
  var Og = Symbol.for("prisma.client.transaction.id");
  var Ng = { id: 0, nextId() {
    return ++this.id;
  } };
  var $g = new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
  /*! Bundled license information:
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.4.3
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  */
});

// ../sisventa/prisma/client/index.js
var require_client = __commonJS((exports) => {
  var __dirname = "/home/joel/Documentos/proyectos-javascript/JugueteriaApi/sisventa/prisma/client";
  Object.defineProperty(exports, "__esModule", { value: true });
  var {
    PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
    PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
    PrismaClientRustPanicError: PrismaClientRustPanicError2,
    PrismaClientInitializationError: PrismaClientInitializationError2,
    PrismaClientValidationError: PrismaClientValidationError2,
    NotFoundError: NotFoundError2,
    getPrismaClient: getPrismaClient2,
    sqltag: sqltag2,
    empty: empty2,
    join: join3,
    raw: raw2,
    Decimal: Decimal2,
    Debug: Debug2,
    objectEnumValues: objectEnumValues2,
    makeStrictEnum: makeStrictEnum2,
    Extensions: Extensions2,
    warnOnce: warnOnce2,
    defineDmmfProperty: defineDmmfProperty2,
    Public: Public2,
    detectRuntime: detectRuntime2
  } = require_library();
  var Prisma = {};
  exports.Prisma = Prisma;
  exports.$Enums = {};
  Prisma.prismaVersion = {
    client: "5.9.1",
    engine: "23fdc5965b1e05fc54e5f26ed3de66776b93de64"
  };
  Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
  Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
  Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
  Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
  Prisma.PrismaClientValidationError = PrismaClientValidationError2;
  Prisma.NotFoundError = NotFoundError2;
  Prisma.Decimal = Decimal2;
  Prisma.sql = sqltag2;
  Prisma.empty = empty2;
  Prisma.join = join3;
  Prisma.raw = raw2;
  Prisma.validator = Public2.validator;
  Prisma.getExtensionContext = Extensions2.getExtensionContext;
  Prisma.defineExtension = Extensions2.defineExtension;
  Prisma.DbNull = objectEnumValues2.instances.DbNull;
  Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
  Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
  Prisma.NullTypes = {
    DbNull: objectEnumValues2.classes.DbNull,
    JsonNull: objectEnumValues2.classes.JsonNull,
    AnyNull: objectEnumValues2.classes.AnyNull
  };
  var path = import.meta.require("path");
  exports.Prisma.TransactionIsolationLevel = makeStrictEnum2({
    ReadUncommitted: "ReadUncommitted",
    ReadCommitted: "ReadCommitted",
    RepeatableRead: "RepeatableRead",
    Serializable: "Serializable"
  });
  exports.Prisma.UserScalarFieldEnum = {
    id: "id",
    email: "email",
    name: "name",
    password: "password",
    role: "role",
    picture: "picture",
    createdAt: "createdAt",
    updateAt: "updateAt"
  };
  exports.Prisma.TokenScalarFieldEnum = {
    id: "id",
    userId: "userId",
    ip: "ip",
    token: "token",
    createdAt: "createdAt"
  };
  exports.Prisma.PostScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    published: "published",
    title: "title",
    authorId: "authorId"
  };
  exports.Prisma.ClienteScalarFieldEnum = {
    id: "id",
    nombre: "nombre",
    apellido: "apellido",
    celular: "celular",
    correo: "correo",
    direccion: "direccion"
  };
  exports.Prisma.SortOrder = {
    asc: "asc",
    desc: "desc"
  };
  exports.Prisma.NullsOrder = {
    first: "first",
    last: "last"
  };
  exports.Role = exports.$Enums.Role = {
    admin: "admin",
    vendedor: "vendedor",
    bodega: "bodega"
  };
  exports.Prisma.ModelName = {
    User: "User",
    Token: "Token",
    Post: "Post",
    Cliente: "Cliente"
  };
  var config2 = {
    generator: {
      name: "client",
      provider: {
        fromEnvVar: null,
        value: "prisma-client-js"
      },
      output: {
        value: "/home/joel/Documentos/proyectos-javascript/JugueteriaApi/sisventa/prisma/client",
        fromEnvVar: null
      },
      config: {
        engineType: "library"
      },
      binaryTargets: [
        {
          fromEnvVar: null,
          value: "debian-openssl-3.0.x",
          native: true
        }
      ],
      previewFeatures: [],
      isCustomOutput: true
    },
    relativeEnvPaths: {
      rootEnvPath: null,
      schemaEnvPath: "../../.env"
    },
    relativePath: "..",
    clientVersion: "5.9.1",
    engineVersion: "23fdc5965b1e05fc54e5f26ed3de66776b93de64",
    datasourceNames: [
      "db"
    ],
    activeProvider: "mysql",
    inlineDatasources: {
      db: {
        url: {
          fromEnvVar: "DATABASE_URL",
          value: null
        }
      }
    },
    inlineSchema: "Ly8gVGhpcyBpcyB5b3VyIFByaXNtYSBzY2hlbWEgZmlsZSwKLy8gbGVhcm4gbW9yZSBhYm91dCBpdCBpbiB0aGUgZG9jczogaHR0cHM6Ly9wcmlzLmx5L2QvcHJpc21hLXNjaGVtYQoKZ2VuZXJhdG9yIGNsaWVudCB7CiAgcHJvdmlkZXIgPSAicHJpc21hLWNsaWVudC1qcyIKICBvdXRwdXQgPSAiLi9jbGllbnQiCn0KCmRhdGFzb3VyY2UgZGIgewogIHByb3ZpZGVyID0gIm15c3FsIgogIHVybCAgICAgID0gZW52KCJEQVRBQkFTRV9VUkwiKQp9Cgptb2RlbCBVc2VyIHsKICBpZCBTdHJpbmcgQGlkIEBkZWZhdWx0KHV1aWQoKSkKICBlbWFpbCBTdHJpbmcgQHVuaXF1ZQogIG5hbWUgU3RyaW5nCiAgcGFzc3dvcmQgU3RyaW5nCiAgcm9sZSBSb2xlIEBkZWZhdWx0KHZlbmRlZG9yKQogIHBpY3R1cmUgU3RyaW5nCiAgY3JlYXRlZEF0IERhdGVUaW1lIEBkZWZhdWx0KG5vdygpKQogIHVwZGF0ZUF0IERhdGVUaW1lIEB1cGRhdGVkQXQKICBwb3N0cyBQb3N0W10KICB0b2tlbiBUb2tlbltdCn0KCm1vZGVsIFRva2VuIHsKICBpZCBTdHJpbmcgQGlkIEBkZWZhdWx0KHV1aWQoKSkKICB1c2VySWQgU3RyaW5nCiAgdXNlciBVc2VyIEByZWxhdGlvbihmaWVsZHM6IFt1c2VySWRdLHJlZmVyZW5jZXM6IFtpZF0pCiAgaXAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNSkKICB0b2tlbiBTdHJpbmcgQGRiLlRleHQKICBjcmVhdGVkQXQgRGF0ZVRpbWUgQGRlZmF1bHQobm93KCkpCn0KCm1vZGVsIFBvc3QgewogIGlkIFN0cmluZyBAaWQgQGRlZmF1bHQodXVpZCgpKQogIGNyZWF0ZWRBdCBEYXRlVGltZSBAZGVmYXVsdChub3coKSkKICB1cGRhdGVkQXQgRGF0ZVRpbWUgQHVwZGF0ZWRBdAogIHB1Ymxpc2hlZCBCb29sZWFuIEBkZWZhdWx0KGZhbHNlKQogIHRpdGxlIFN0cmluZyBAZGIuVmFyQ2hhcigyNTUpCiAgYXV0aG9ySWQgU3RyaW5nPwogIC8vUmVsYWNpb24KICBhdXRob3IgVXNlcj8gQHJlbGF0aW9uKGZpZWxkczogW2F1dGhvcklkXSwgcmVmZXJlbmNlczogW2lkXSkKfQoKbW9kZWwgQ2xpZW50ZSB7CiAgaWQgU3RyaW5nIEBpZCBAZGVmYXVsdCh1dWlkKCkpCiAgbm9tYnJlIFN0cmluZwogIGFwZWxsaWRvIFN0cmluZz8KICBjZWx1bGFyIFN0cmluZz8KICBjb3JyZW8gU3RyaW5nPwogIGRpcmVjY2lvbiBTdHJpbmc/Cn0KCmVudW0gUm9sZSB7CiAgYWRtaW4KICB2ZW5kZWRvcgogIGJvZGVnYQp9",
    inlineSchemaHash: "2ad52c3efe3889f68766aab9144df9e1bb043bb67f5a59879824854803e21790"
  };
  var fs2 = import.meta.require("fs");
  config2.dirname = __dirname;
  if (!fs2.existsSync(path.join(__dirname, "schema.prisma"))) {
    const alternativePaths = [
      "prisma/client",
      "client"
    ];
    const alternativePath = alternativePaths.find((altPath) => {
      return fs2.existsSync(path.join(process.cwd(), altPath, "schema.prisma"));
    }) ?? alternativePaths[0];
    config2.dirname = path.join(process.cwd(), alternativePath);
    config2.isBundled = true;
  }
  config2.runtimeDataModel = JSON.parse("{\"models\":{\"User\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"default\":{\"name\":\"uuid\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"email\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"password\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"role\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Role\",\"default\":\"vendedor\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"picture\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updateAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true},{\"name\":\"posts\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Post\",\"relationName\":\"PostToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"token\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Token\",\"relationName\":\"TokenToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Token\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"default\":{\"name\":\"uuid\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"relationName\":\"TokenToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"ip\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"token\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Post\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"default\":{\"name\":\"uuid\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true},{\"name\":\"published\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"title\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"authorId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"author\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"relationName\":\"PostToUser\",\"relationFromFields\":[\"authorId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Cliente\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"default\":{\"name\":\"uuid\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"nombre\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"apellido\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"celular\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"correo\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"direccion\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false}},\"enums\":{\"Role\":{\"values\":[{\"name\":\"admin\",\"dbName\":null},{\"name\":\"vendedor\",\"dbName\":null},{\"name\":\"bodega\",\"dbName\":null}],\"dbName\":null}},\"types\":{}}");
  defineDmmfProperty2(exports.Prisma, config2.runtimeDataModel);
  config2.getQueryEngineWasmModule = undefined;
  var { warnEnvConflicts: warnEnvConflicts2 } = require_library();
  warnEnvConflicts2({
    rootEnvPath: config2.relativeEnvPaths.rootEnvPath && path.resolve(config2.dirname, config2.relativeEnvPaths.rootEnvPath),
    schemaEnvPath: config2.relativeEnvPaths.schemaEnvPath && path.resolve(config2.dirname, config2.relativeEnvPaths.schemaEnvPath)
  });
  var PrismaClient = getPrismaClient2(config2);
  exports.PrismaClient = PrismaClient;
  Object.assign(exports, Prisma);
  path.join(__dirname, "libquery_engine-debian-openssl-3.0.x.so.node");
  path.join(process.cwd(), "prisma/client/libquery_engine-debian-openssl-3.0.x.so.node");
  path.join(__dirname, "schema.prisma");
  path.join(process.cwd(), "prisma/client/schema.prisma");
});

// node_modules/@sinclair/typebox/build/import/value/guard/guard.mjs
function IsAsyncIterator(value) {
  return IsObject(value) && Symbol.asyncIterator in value;
}
function IsIterator(value) {
  return IsObject(value) && Symbol.iterator in value;
}
function IsTypedArray(value) {
  return ArrayBuffer.isView(value);
}
function IsPromise(value) {
  return value instanceof Promise;
}
function IsUint8Array(value) {
  return value instanceof Uint8Array;
}
function IsDate(value) {
  return value instanceof Date && Number.isFinite(value.getTime());
}
function HasPropertyKey(value, key) {
  return key in value;
}
function IsPlainObject(value) {
  return IsObject(value) && IsFunction(value.constructor) && value.constructor.name === "Object";
}
function IsObject(value) {
  return value !== null && typeof value === "object";
}
function IsArray(value) {
  return Array.isArray(value) && !ArrayBuffer.isView(value);
}
function IsUndefined(value) {
  return value === undefined;
}
function IsNull(value) {
  return value === null;
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return IsNumber(value) && Number.isInteger(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsString(value) {
  return typeof value === "string";
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
}
// node_modules/@sinclair/typebox/build/import/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    const isNumber = IsNumber(value);
    return TypeSystemPolicy2.AllowNaN ? isNumber : isNumber && Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));
// node_modules/@sinclair/typebox/build/import/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => {
    {
      return Set2;
    }
  },
  Has: () => {
    {
      return Has;
    }
  },
  Get: () => {
    {
      return Get;
    }
  },
  Entries: () => {
    {
      return Entries;
    }
  },
  Delete: () => {
    {
      return Delete;
    }
  },
  Clear: () => {
    {
      return Clear;
    }
  }
});
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format) {
  return map.delete(format);
}
function Has(format) {
  return map.has(format);
}
function Set2(format, func) {
  map.set(format, func);
}
function Get(format) {
  return map.get(format);
}
var map = new Map;
// node_modules/@sinclair/typebox/build/import/type/registry/type.mjs
var exports_type = {};
__export(exports_type, {
  Set: () => {
    {
      return Set3;
    }
  },
  Has: () => {
    {
      return Has2;
    }
  },
  Get: () => {
    {
      return Get2;
    }
  },
  Entries: () => {
    {
      return Entries2;
    }
  },
  Delete: () => {
    {
      return Delete2;
    }
  },
  Clear: () => {
    {
      return Clear2;
    }
  }
});
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
var map2 = new Map;
// node_modules/@sinclair/typebox/build/import/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");
// node_modules/@sinclair/typebox/build/import/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return {
    ...options,
    [Kind]: options[Kind] ?? "Unsafe"
  };
}
// node_modules/@sinclair/typebox/build/import/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/import/system/system.mjs
class TypeSystemDuplicateTypeKind extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate type kind '${kind}' detected`);
  }
}

class TypeSystemDuplicateFormat extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate string format '${kind}' detected`);
  }
}
var TypeSystem;
(function(TypeSystem2) {
  function Type(kind, check) {
    if (exports_type.Has(kind))
      throw new TypeSystemDuplicateTypeKind(kind);
    exports_type.Set(kind, check);
    return (options = {}) => Unsafe({ ...options, [Kind]: kind });
  }
  TypeSystem2.Type = Type;
  function Format(format, check) {
    if (exports_format.Has(format))
      throw new TypeSystemDuplicateFormat(format);
    exports_format.Set(format, check);
    return format;
  }
  TypeSystem2.Format = Format;
})(TypeSystem || (TypeSystem = {}));
// node_modules/@sinclair/typebox/build/import/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return {
    [Kind]: "MappedResult",
    properties
  };
}
// node_modules/@sinclair/typebox/build/import/type/clone/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  CloneType: () => {
    {
      return CloneType;
    }
  },
  CloneRest: () => {
    {
      return CloneRest;
    }
  }
});

// node_modules/@sinclair/typebox/build/import/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => {
    {
      return IsUndefined2;
    }
  },
  IsUint8Array: () => {
    {
      return IsUint8Array2;
    }
  },
  IsSymbol: () => {
    {
      return IsSymbol2;
    }
  },
  IsString: () => {
    {
      return IsString2;
    }
  },
  IsRegExp: () => {
    {
      return IsRegExp;
    }
  },
  IsObject: () => {
    {
      return IsObject2;
    }
  },
  IsNumber: () => {
    {
      return IsNumber2;
    }
  },
  IsNull: () => {
    {
      return IsNull2;
    }
  },
  IsIterator: () => {
    {
      return IsIterator2;
    }
  },
  IsFunction: () => {
    {
      return IsFunction2;
    }
  },
  IsDate: () => {
    {
      return IsDate2;
    }
  },
  IsBoolean: () => {
    {
      return IsBoolean2;
    }
  },
  IsBigInt: () => {
    {
      return IsBigInt2;
    }
  },
  IsAsyncIterator: () => {
    {
      return IsAsyncIterator2;
    }
  },
  IsArray: () => {
    {
      return IsArray2;
    }
  }
});
function IsAsyncIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.asyncIterator in value;
}
function IsArray2(value) {
  return Array.isArray(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsDate2(value) {
  return value instanceof globalThis.Date;
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.iterator in value;
}
function IsNull2(value) {
  return value === null;
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsObject2(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString2(value) {
  return typeof value === "string";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined2(value) {
  return value === undefined;
}

// node_modules/@sinclair/typebox/build/import/type/clone/value.mjs
var ArrayType = function(value) {
  return value.map((value2) => Visit(value2));
};
var DateType = function(value) {
  return new Date(value.getTime());
};
var Uint8ArrayType = function(value) {
  return new Uint8Array(value);
};
var RegExpType = function(value) {
  return new RegExp(value.source, value.flags);
};
var ObjectType = function(value) {
  const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
  const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
  return { ...clonedProperties, ...clonedSymbols };
};
var Visit = function(value) {
  return IsArray2(value) ? ArrayType(value) : IsDate2(value) ? DateType(value) : IsUint8Array2(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject2(value) ? ObjectType(value) : value;
};
function Clone(value) {
  return Visit(value);
}

// node_modules/@sinclair/typebox/build/import/type/clone/type.mjs
function CloneRest(schemas) {
  return schemas.map((schema) => CloneType(schema));
}
function CloneType(schema, options = {}) {
  return { ...Clone(schema), ...options };
}

// node_modules/@sinclair/typebox/build/import/type/discard/discard.mjs
var DiscardKey = function(value2, key) {
  const { [key]: _, ...rest } = value2;
  return rest;
};
function Discard(value2, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value2);
}
// node_modules/@sinclair/typebox/build/import/type/array/array.mjs
function Array2(schema, options = {}) {
  return {
    ...options,
    [Kind]: "Array",
    type: "array",
    items: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/import/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "AsyncIterator",
    type: "AsyncIterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/import/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Constructor",
    type: "Constructor",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/import/type/function/function.mjs
function Function2(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Function",
    type: "Function",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/import/type/never/never.mjs
function Never(options = {}) {
  return {
    ...options,
    [Kind]: "Never",
    not: {}
  };
}
// node_modules/@sinclair/typebox/build/import/type/guard/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  TypeGuardUnknownTypeError: () => {
    {
      return TypeGuardUnknownTypeError;
    }
  },
  IsVoid: () => {
    {
      return IsVoid;
    }
  },
  IsUnsafe: () => {
    {
      return IsUnsafe;
    }
  },
  IsUnknown: () => {
    {
      return IsUnknown;
    }
  },
  IsUnionLiteral: () => {
    {
      return IsUnionLiteral;
    }
  },
  IsUnion: () => {
    {
      return IsUnion;
    }
  },
  IsUndefined: () => {
    {
      return IsUndefined3;
    }
  },
  IsUint8Array: () => {
    {
      return IsUint8Array3;
    }
  },
  IsTuple: () => {
    {
      return IsTuple;
    }
  },
  IsTransform: () => {
    {
      return IsTransform;
    }
  },
  IsThis: () => {
    {
      return IsThis;
    }
  },
  IsTemplateLiteral: () => {
    {
      return IsTemplateLiteral;
    }
  },
  IsSymbol: () => {
    {
      return IsSymbol3;
    }
  },
  IsString: () => {
    {
      return IsString3;
    }
  },
  IsSchema: () => {
    {
      return IsSchema;
    }
  },
  IsRegExp: () => {
    {
      return IsRegExp2;
    }
  },
  IsRef: () => {
    {
      return IsRef;
    }
  },
  IsRecursive: () => {
    {
      return IsRecursive;
    }
  },
  IsRecord: () => {
    {
      return IsRecord;
    }
  },
  IsReadonly: () => {
    {
      return IsReadonly;
    }
  },
  IsProperties: () => {
    {
      return IsProperties;
    }
  },
  IsPromise: () => {
    {
      return IsPromise2;
    }
  },
  IsOptional: () => {
    {
      return IsOptional;
    }
  },
  IsObject: () => {
    {
      return IsObject3;
    }
  },
  IsNumber: () => {
    {
      return IsNumber3;
    }
  },
  IsNull: () => {
    {
      return IsNull3;
    }
  },
  IsNot: () => {
    {
      return IsNot;
    }
  },
  IsNever: () => {
    {
      return IsNever;
    }
  },
  IsMappedResult: () => {
    {
      return IsMappedResult;
    }
  },
  IsMappedKey: () => {
    {
      return IsMappedKey;
    }
  },
  IsLiteralValue: () => {
    {
      return IsLiteralValue;
    }
  },
  IsLiteralString: () => {
    {
      return IsLiteralString;
    }
  },
  IsLiteralNumber: () => {
    {
      return IsLiteralNumber;
    }
  },
  IsLiteralBoolean: () => {
    {
      return IsLiteralBoolean;
    }
  },
  IsLiteral: () => {
    {
      return IsLiteral;
    }
  },
  IsKindOf: () => {
    {
      return IsKindOf;
    }
  },
  IsKind: () => {
    {
      return IsKind;
    }
  },
  IsIterator: () => {
    {
      return IsIterator3;
    }
  },
  IsIntersect: () => {
    {
      return IsIntersect;
    }
  },
  IsInteger: () => {
    {
      return IsInteger2;
    }
  },
  IsFunction: () => {
    {
      return IsFunction3;
    }
  },
  IsDate: () => {
    {
      return IsDate3;
    }
  },
  IsConstructor: () => {
    {
      return IsConstructor;
    }
  },
  IsBoolean: () => {
    {
      return IsBoolean3;
    }
  },
  IsBigInt: () => {
    {
      return IsBigInt3;
    }
  },
  IsAsyncIterator: () => {
    {
      return IsAsyncIterator3;
    }
  },
  IsArray: () => {
    {
      return IsArray3;
    }
  },
  IsAny: () => {
    {
      return IsAny;
    }
  }
});
var IsPattern = function(value2) {
  try {
    new RegExp(value2);
    return true;
  } catch {
    return false;
  }
};
var IsControlCharacterFree = function(value2) {
  if (!IsString2(value2))
    return false;
  for (let i = 0;i < value2.length; i++) {
    const code = value2.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
};
var IsAdditionalProperties = function(value2) {
  return IsOptionalBoolean(value2) || IsSchema(value2);
};
var IsOptionalBigInt = function(value2) {
  return IsUndefined2(value2) || IsBigInt2(value2);
};
var IsOptionalNumber = function(value2) {
  return IsUndefined2(value2) || IsNumber2(value2);
};
var IsOptionalBoolean = function(value2) {
  return IsUndefined2(value2) || IsBoolean2(value2);
};
var IsOptionalString = function(value2) {
  return IsUndefined2(value2) || IsString2(value2);
};
var IsOptionalPattern = function(value2) {
  return IsUndefined2(value2) || IsString2(value2) && IsControlCharacterFree(value2) && IsPattern(value2);
};
var IsOptionalFormat = function(value2) {
  return IsUndefined2(value2) || IsString2(value2) && IsControlCharacterFree(value2);
};
var IsOptionalSchema = function(value2) {
  return IsUndefined2(value2) || IsSchema(value2);
};
function IsReadonly(value2) {
  return IsObject2(value2) && value2[ReadonlyKind] === "Readonly";
}
function IsOptional(value2) {
  return IsObject2(value2) && value2[OptionalKind] === "Optional";
}
function IsAny(value2) {
  return IsKindOf(value2, "Any") && IsOptionalString(value2.$id);
}
function IsArray3(value2) {
  return IsKindOf(value2, "Array") && value2.type === "array" && IsOptionalString(value2.$id) && IsSchema(value2.items) && IsOptionalNumber(value2.minItems) && IsOptionalNumber(value2.maxItems) && IsOptionalBoolean(value2.uniqueItems) && IsOptionalSchema(value2.contains) && IsOptionalNumber(value2.minContains) && IsOptionalNumber(value2.maxContains);
}
function IsAsyncIterator3(value2) {
  return IsKindOf(value2, "AsyncIterator") && value2.type === "AsyncIterator" && IsOptionalString(value2.$id) && IsSchema(value2.items);
}
function IsBigInt3(value2) {
  return IsKindOf(value2, "BigInt") && value2.type === "bigint" && IsOptionalString(value2.$id) && IsOptionalBigInt(value2.exclusiveMaximum) && IsOptionalBigInt(value2.exclusiveMinimum) && IsOptionalBigInt(value2.maximum) && IsOptionalBigInt(value2.minimum) && IsOptionalBigInt(value2.multipleOf);
}
function IsBoolean3(value2) {
  return IsKindOf(value2, "Boolean") && value2.type === "boolean" && IsOptionalString(value2.$id);
}
function IsConstructor(value2) {
  return IsKindOf(value2, "Constructor") && value2.type === "Constructor" && IsOptionalString(value2.$id) && IsArray2(value2.parameters) && value2.parameters.every((schema) => IsSchema(schema)) && IsSchema(value2.returns);
}
function IsDate3(value2) {
  return IsKindOf(value2, "Date") && value2.type === "Date" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximumTimestamp) && IsOptionalNumber(value2.exclusiveMinimumTimestamp) && IsOptionalNumber(value2.maximumTimestamp) && IsOptionalNumber(value2.minimumTimestamp) && IsOptionalNumber(value2.multipleOfTimestamp);
}
function IsFunction3(value2) {
  return IsKindOf(value2, "Function") && value2.type === "Function" && IsOptionalString(value2.$id) && IsArray2(value2.parameters) && value2.parameters.every((schema) => IsSchema(schema)) && IsSchema(value2.returns);
}
function IsInteger2(value2) {
  return IsKindOf(value2, "Integer") && value2.type === "integer" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximum) && IsOptionalNumber(value2.exclusiveMinimum) && IsOptionalNumber(value2.maximum) && IsOptionalNumber(value2.minimum) && IsOptionalNumber(value2.multipleOf);
}
function IsProperties(value2) {
  return IsObject2(value2) && Object.entries(value2).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema(schema));
}
function IsIntersect(value2) {
  return IsKindOf(value2, "Intersect") && (IsString2(value2.type) && value2.type !== "object" ? false : true) && IsArray2(value2.allOf) && value2.allOf.every((schema) => IsSchema(schema) && !IsTransform(schema)) && IsOptionalString(value2.type) && (IsOptionalBoolean(value2.unevaluatedProperties) || IsOptionalSchema(value2.unevaluatedProperties)) && IsOptionalString(value2.$id);
}
function IsIterator3(value2) {
  return IsKindOf(value2, "Iterator") && value2.type === "Iterator" && IsOptionalString(value2.$id) && IsSchema(value2.items);
}
function IsKindOf(value2, kind) {
  return IsObject2(value2) && Kind in value2 && value2[Kind] === kind;
}
function IsLiteralString(value2) {
  return IsLiteral(value2) && IsString2(value2.const);
}
function IsLiteralNumber(value2) {
  return IsLiteral(value2) && IsNumber2(value2.const);
}
function IsLiteralBoolean(value2) {
  return IsLiteral(value2) && IsBoolean2(value2.const);
}
function IsLiteral(value2) {
  return IsKindOf(value2, "Literal") && IsOptionalString(value2.$id) && IsLiteralValue(value2.const);
}
function IsLiteralValue(value2) {
  return IsBoolean2(value2) || IsNumber2(value2) || IsString2(value2);
}
function IsMappedKey(value2) {
  return IsKindOf(value2, "MappedKey") && IsArray2(value2.keys) && value2.keys.every((key) => IsNumber2(key) || IsString2(key));
}
function IsMappedResult(value2) {
  return IsKindOf(value2, "MappedResult") && IsProperties(value2.properties);
}
function IsNever(value2) {
  return IsKindOf(value2, "Never") && IsObject2(value2.not) && Object.getOwnPropertyNames(value2.not).length === 0;
}
function IsNot(value2) {
  return IsKindOf(value2, "Not") && IsSchema(value2.not);
}
function IsNull3(value2) {
  return IsKindOf(value2, "Null") && value2.type === "null" && IsOptionalString(value2.$id);
}
function IsNumber3(value2) {
  return IsKindOf(value2, "Number") && value2.type === "number" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximum) && IsOptionalNumber(value2.exclusiveMinimum) && IsOptionalNumber(value2.maximum) && IsOptionalNumber(value2.minimum) && IsOptionalNumber(value2.multipleOf);
}
function IsObject3(value2) {
  return IsKindOf(value2, "Object") && value2.type === "object" && IsOptionalString(value2.$id) && IsProperties(value2.properties) && IsAdditionalProperties(value2.additionalProperties) && IsOptionalNumber(value2.minProperties) && IsOptionalNumber(value2.maxProperties);
}
function IsPromise2(value2) {
  return IsKindOf(value2, "Promise") && value2.type === "Promise" && IsOptionalString(value2.$id) && IsSchema(value2.item);
}
function IsRecord(value2) {
  return IsKindOf(value2, "Record") && value2.type === "object" && IsOptionalString(value2.$id) && IsAdditionalProperties(value2.additionalProperties) && IsObject2(value2.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject2(schema.patternProperties) && IsSchema(schema.patternProperties[keys[0]]);
  })(value2);
}
function IsRecursive(value2) {
  return IsObject2(value2) && Hint in value2 && value2[Hint] === "Recursive";
}
function IsRef(value2) {
  return IsKindOf(value2, "Ref") && IsOptionalString(value2.$id) && IsString2(value2.$ref);
}
function IsRegExp2(value2) {
  return IsKindOf(value2, "RegExp") && IsOptionalString(value2.$id) && IsString2(value2.source) && IsString2(value2.flags) && IsOptionalNumber(value2.maxLength) && IsOptionalNumber(value2.minLength);
}
function IsString3(value2) {
  return IsKindOf(value2, "String") && value2.type === "string" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.minLength) && IsOptionalNumber(value2.maxLength) && IsOptionalPattern(value2.pattern) && IsOptionalFormat(value2.format);
}
function IsSymbol3(value2) {
  return IsKindOf(value2, "Symbol") && value2.type === "symbol" && IsOptionalString(value2.$id);
}
function IsTemplateLiteral(value2) {
  return IsKindOf(value2, "TemplateLiteral") && value2.type === "string" && IsString2(value2.pattern) && value2.pattern[0] === "^" && value2.pattern[value2.pattern.length - 1] === "$";
}
function IsThis(value2) {
  return IsKindOf(value2, "This") && IsOptionalString(value2.$id) && IsString2(value2.$ref);
}
function IsTransform(value2) {
  return IsObject2(value2) && TransformKind in value2;
}
function IsTuple(value2) {
  return IsKindOf(value2, "Tuple") && value2.type === "array" && IsOptionalString(value2.$id) && IsNumber2(value2.minItems) && IsNumber2(value2.maxItems) && value2.minItems === value2.maxItems && (IsUndefined2(value2.items) && IsUndefined2(value2.additionalItems) && value2.minItems === 0 || IsArray2(value2.items) && value2.items.every((schema) => IsSchema(schema)));
}
function IsUndefined3(value2) {
  return IsKindOf(value2, "Undefined") && value2.type === "undefined" && IsOptionalString(value2.$id);
}
function IsUnionLiteral(value2) {
  return IsUnion(value2) && value2.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion(value2) {
  return IsKindOf(value2, "Union") && IsOptionalString(value2.$id) && IsObject2(value2) && IsArray2(value2.anyOf) && value2.anyOf.every((schema) => IsSchema(schema));
}
function IsUint8Array3(value2) {
  return IsKindOf(value2, "Uint8Array") && value2.type === "Uint8Array" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.minByteLength) && IsOptionalNumber(value2.maxByteLength);
}
function IsUnknown(value2) {
  return IsKindOf(value2, "Unknown") && IsOptionalString(value2.$id);
}
function IsUnsafe(value2) {
  return IsKindOf(value2, "Unsafe");
}
function IsVoid(value2) {
  return IsKindOf(value2, "Void") && value2.type === "void" && IsOptionalString(value2.$id);
}
function IsKind(value2) {
  return IsObject2(value2) && Kind in value2 && IsString2(value2[Kind]) && !KnownTypes.includes(value2[Kind]);
}
function IsSchema(value2) {
  return IsObject2(value2) && (IsAny(value2) || IsArray3(value2) || IsBoolean3(value2) || IsBigInt3(value2) || IsAsyncIterator3(value2) || IsConstructor(value2) || IsDate3(value2) || IsFunction3(value2) || IsInteger2(value2) || IsIntersect(value2) || IsIterator3(value2) || IsLiteral(value2) || IsMappedKey(value2) || IsMappedResult(value2) || IsNever(value2) || IsNot(value2) || IsNull3(value2) || IsNumber3(value2) || IsObject3(value2) || IsPromise2(value2) || IsRecord(value2) || IsRef(value2) || IsRegExp2(value2) || IsString3(value2) || IsSymbol3(value2) || IsTemplateLiteral(value2) || IsThis(value2) || IsTuple(value2) || IsUndefined3(value2) || IsUnion(value2) || IsUint8Array3(value2) || IsUnknown(value2) || IsUnsafe(value2) || IsVoid(value2) || IsKind(value2));
}

class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];

// node_modules/@sinclair/typebox/build/import/type/optional/optional.mjs
var RemoveOptional = function(schema) {
  return Discard(CloneType(schema), [OptionalKind]);
};
var AddOptional = function(schema) {
  return { ...CloneType(schema), [OptionalKind]: "Optional" };
};
var OptionalWithFlag = function(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
};
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/import/type/optional/optional-from-mapped-result.mjs
var FromProperties = function(P, F) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Optional(P[K2], F) };
  }, {});
};
var FromMappedResult = function(R, F) {
  return FromProperties(R.properties, F);
};
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/intersect/intersect-create.mjs
function IntersectCreate(T, options) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: CloneType(options.unevaluatedProperties) } : {};
  return options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: CloneRest(T) } : { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/import/type/intersect/intersect-evaluated.mjs
var IsIntersectOptional = function(T) {
  return T.every((L) => IsOptional(L));
};
var RemoveOptionalFromType = function(T) {
  return Discard(T, [OptionalKind]);
};
var RemoveOptionalFromRest = function(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType(L) : L);
};
var ResolveIntersect = function(T, options) {
  return IsIntersectOptional(T) ? Optional(IntersectCreate(RemoveOptionalFromRest(T), options)) : IntersectCreate(RemoveOptionalFromRest(T), options);
};
function IntersectEvaluated(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/intersect/intersect.mjs
function Intersect(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/union/union-create.mjs
function UnionCreate(T, options) {
  return { ...options, [Kind]: "Union", anyOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/import/type/union/union-evaluated.mjs
var IsUnionOptional = function(T) {
  return T.some((L) => IsOptional(L));
};
var RemoveOptionalFromRest2 = function(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType2(L) : L);
};
var RemoveOptionalFromType2 = function(T) {
  return Discard(T, [OptionalKind]);
};
var ResolveUnion = function(T, options) {
  return IsUnionOptional(T) ? Optional(UnionCreate(RemoveOptionalFromRest2(T), options)) : UnionCreate(RemoveOptionalFromRest2(T), options);
};
function UnionEvaluated(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : ResolveUnion(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/union/union.mjs
function Union(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : UnionCreate(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/parse.mjs
var IsNonEscaped = function(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
};
var IsOpenParen = function(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
};
var IsCloseParen = function(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
};
var IsSeparator = function(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
};
var IsGroup = function(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
};
var InGroup = function(pattern) {
  return pattern.slice(1, pattern.length - 1);
};
var IsPrecedenceOr = function(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
};
var IsPrecedenceAnd = function(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
};
var Or = function(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
};
var And = function(pattern) {
  function Group(value2, index) {
    if (!IsOpenParen(value2, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value2.length; scan++) {
      if (IsOpenParen(value2, scan))
        count += 1;
      if (IsCloseParen(value2, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
};
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: pattern };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

class TemplateLiteralParserError extends TypeBoxError {
}

// node_modules/@sinclair/typebox/build/import/type/template-literal/finite.mjs
var IsNumberExpression = function(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
};
var IsBooleanExpression = function(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
};
var IsStringExpression = function(expression) {
  return expression.type === "const" && expression.const === ".*";
};
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

class TemplateLiteralFiniteError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/generate.mjs
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

class TemplateLiteralGenerateError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/import/type/literal/literal.mjs
function Literal(value2, options = {}) {
  return {
    ...options,
    [Kind]: "Literal",
    const: value2,
    type: typeof value2
  };
}
// node_modules/@sinclair/typebox/build/import/type/boolean/boolean.mjs
function Boolean2(options = {}) {
  return {
    ...options,
    [Kind]: "Boolean",
    type: "boolean"
  };
}
// node_modules/@sinclair/typebox/build/import/type/bigint/bigint.mjs
function BigInt2(options = {}) {
  return {
    ...options,
    [Kind]: "BigInt",
    type: "bigint"
  };
}
// node_modules/@sinclair/typebox/build/import/type/number/number.mjs
function Number2(options = {}) {
  return {
    ...options,
    [Kind]: "Number",
    type: "number"
  };
}
// node_modules/@sinclair/typebox/build/import/type/string/string.mjs
function String2(options = {}) {
  return { ...options, [Kind]: "String", type: "string" };
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal3) => Literal(literal3.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}
// node_modules/@sinclair/typebox/build/import/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternBooleanExact = `^${PatternBoolean}\$`;
var PatternNumberExact = `^${PatternNumber}\$`;
var PatternStringExact = `^${PatternString}\$`;
// node_modules/@sinclair/typebox/build/import/type/template-literal/pattern.mjs
var Escape = function(value2) {
  return value2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
};
var Visit2 = function(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
};
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

class TemplateLiteralPatternError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options = {}) {
  const pattern2 = IsString2(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return { ...options, [Kind]: "TemplateLiteral", type: "string", pattern: pattern2 };
}
// node_modules/@sinclair/typebox/build/import/type/indexed/indexed-property-keys.mjs
var FromTemplateLiteral = function(T) {
  const R = TemplateLiteralGenerate(T);
  return R.map((S) => S.toString());
};
var FromUnion2 = function(T) {
  return T.reduce((Acc, L) => {
    return [...Acc, ...IndexPropertyKeys(L)];
  }, []);
};
var FromLiteral = function(T) {
  return [T.toString()];
};
function IndexPropertyKeys(T) {
  return [...new Set(IsTemplateLiteral(T) ? FromTemplateLiteral(T) : IsUnion(T) ? FromUnion2(T.anyOf) : IsLiteral(T) ? FromLiteral(T.const) : IsNumber3(T) ? ["[number]"] : IsInteger2(T) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/import/type/indexed/indexed-from-mapped-result.mjs
var FromProperties2 = function(T, P, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Index(T, IndexPropertyKeys(P[K2]), options) };
  }, {});
};
var FromMappedResult2 = function(T, R, options) {
  return FromProperties2(T, R.properties, options);
};
function IndexFromMappedResult(T, R, options) {
  const P = FromMappedResult2(T, R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/indexed/indexed.mjs
var FromRest = function(T, K) {
  return T.map((L) => IndexFromPropertyKey(L, K));
};
var FromIntersectRest = function(T) {
  return T.filter((L) => !IsNever(L));
};
var FromIntersect = function(T, K) {
  return IntersectEvaluated(FromIntersectRest(FromRest(T, K)));
};
var FromUnionRest = function(T) {
  return T;
};
var FromUnion3 = function(T, K) {
  return UnionEvaluated(FromUnionRest(FromRest(T, K)));
};
var FromTuple = function(T, K) {
  return K in T ? T[K] : K === "[number]" ? UnionEvaluated(T) : Never();
};
var FromArray = function(T, K) {
  return K === "[number]" ? T : Never();
};
var FromProperty = function(T, K) {
  return K in T ? T[K] : Never();
};
function IndexFromPropertyKey(T, K) {
  return IsIntersect(T) ? FromIntersect(T.allOf, K) : IsUnion(T) ? FromUnion3(T.anyOf, K) : IsTuple(T) ? FromTuple(T.items ?? [], K) : IsArray3(T) ? FromArray(T.items, K) : IsObject3(T) ? FromProperty(T.properties, K) : Never();
}
function IndexFromPropertyKeys(T, K) {
  return K.map((L) => IndexFromPropertyKey(T, L));
}
var FromSchema = function(T, K) {
  return UnionEvaluated(IndexFromPropertyKeys(T, K));
};
function Index(T, K, options = {}) {
  return IsMappedResult(K) ? CloneType(IndexFromMappedResult(T, K, options)) : IsMappedKey(K) ? CloneType(IndexFromMappedKey(T, K, options)) : IsSchema(K) ? CloneType(FromSchema(T, IndexPropertyKeys(K)), options) : CloneType(FromSchema(T, K), options);
}

// node_modules/@sinclair/typebox/build/import/type/indexed/indexed-from-mapped-key.mjs
var MappedIndexPropertyKey = function(T, K, options) {
  return { [K]: Index(T, [K], options) };
};
var MappedIndexPropertyKeys = function(T, K, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
  }, {});
};
var MappedIndexProperties = function(T, K, options) {
  return MappedIndexPropertyKeys(T, K.keys, options);
};
function IndexFromMappedKey(T, K, options) {
  const P = MappedIndexProperties(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/iterator/iterator.mjs
function Iterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "Iterator",
    type: "Iterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/import/type/object/object.mjs
function _Object(properties, options = {}) {
  const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
  const optionalKeys = propertyKeys.filter((key) => IsOptional(properties[key]));
  const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
  const clonedAdditionalProperties = IsSchema(options.additionalProperties) ? { additionalProperties: CloneType(options.additionalProperties) } : {};
  const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: CloneType(properties[key]) }), {});
  return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties };
}
var Object2 = _Object;
// node_modules/@sinclair/typebox/build/import/type/promise/promise.mjs
function Promise2(item, options = {}) {
  return {
    ...options,
    [Kind]: "Promise",
    type: "Promise",
    item: CloneType(item)
  };
}
// node_modules/@sinclair/typebox/build/import/type/readonly/readonly.mjs
var RemoveReadonly = function(schema) {
  return Discard(CloneType(schema), [ReadonlyKind]);
};
var AddReadonly = function(schema) {
  return { ...CloneType(schema), [ReadonlyKind]: "Readonly" };
};
var ReadonlyWithFlag = function(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
};
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/import/type/readonly/readonly-from-mapped-result.mjs
var FromProperties3 = function(K, F) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Readonly(K[K2], F) };
  }, {});
};
var FromMappedResult3 = function(R, F) {
  return FromProperties3(R.properties, F);
};
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult3(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/tuple/tuple.mjs
function Tuple(items, options = {}) {
  const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
  return items.length > 0 ? { ...options, [Kind]: "Tuple", type: "array", items: CloneRest(items), additionalItems, minItems, maxItems } : { ...options, [Kind]: "Tuple", type: "array", minItems, maxItems };
}
// node_modules/@sinclair/typebox/build/import/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
var SetIntersectManyResolve = function(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
};
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  return T.reduce((Acc, L) => [...Acc, ...L], []);
}
// node_modules/@sinclair/typebox/build/import/type/mapped/mapped.mjs
var FromMappedResult4 = function(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
};
var MappedKeyToKnownMappedResultProperties = function(K) {
  return { [K]: Literal(K) };
};
var MappedKeyToUnknownMappedResultProperties = function(P) {
  return P.reduce((Acc, L) => {
    return { ...Acc, [L]: Literal(L) };
  }, {});
};
var MappedKeyToMappedResultProperties = function(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
};
var FromMappedKey = function(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult4(K, R);
};
var FromRest2 = function(K, T) {
  return T.map((L) => FromSchemaType(K, L));
};
var FromProperties4 = function(K, T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K2) => {
    return { ...Acc, [K2]: FromSchemaType(K, T[K2]) };
  }, {});
};
var FromSchemaType = function(K, T) {
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult4(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items)) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items)) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf)) : IsUnion(T) ? Union(FromRest2(K, T.anyOf)) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? [])) : IsObject3(T) ? Object2(FromProperties4(K, T.properties)) : IsArray3(T) ? Array2(FromSchemaType(K, T.items)) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item)) : T;
};
function MappedFunctionReturnType(K, T, Acc = {}) {
  return K.reduce((Acc2, L) => {
    return { ...Acc2, [L]: FromSchemaType(L, T) };
  }, {});
}
function Mapped(key, map3, options = {}) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return CloneType(Object2(R), options);
}
// node_modules/@sinclair/typebox/build/import/type/keyof/keyof-property-keys.mjs
var FromRest3 = function(T) {
  return T.reduce((Acc, L) => {
    return [...Acc, KeyOfPropertyKeys(L)];
  }, []);
};
var FromIntersect2 = function(T) {
  const C = FromRest3(T);
  const R = SetUnionMany(C);
  return R;
};
var FromUnion4 = function(T) {
  const C = FromRest3(T);
  const R = SetIntersectMany(C);
  return R;
};
var FromTuple2 = function(T) {
  return T.map((_, I) => I.toString());
};
var FromArray2 = function(_) {
  return ["[number]"];
};
var FromProperties5 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T);
};
var FromPatternProperties = function(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
};
function KeyOfPropertyKeys(T) {
  return IsIntersect(T) ? FromIntersect2(T.allOf) : IsUnion(T) ? FromUnion4(T.anyOf) : IsTuple(T) ? FromTuple2(T.items ?? []) : IsArray3(T) ? FromArray2(T.items) : IsObject3(T) ? FromProperties5(T.properties) : IsRecord(T) ? FromPatternProperties(T.patternProperties) : [];
}
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern3 = keys.map((key) => `(${key})`);
  return `^(${pattern3.join("|")})\$`;
}
var includePatternProperties = false;

// node_modules/@sinclair/typebox/build/import/type/keyof/keyof.mjs
function KeyOfPropertyKeysToRest(T) {
  return T.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(T, options = {}) {
  if (IsMappedResult(T)) {
    return KeyOfFromMappedResult(T, options);
  } else {
    const K = KeyOfPropertyKeys(T);
    const S = KeyOfPropertyKeysToRest(K);
    const U = UnionEvaluated(S);
    return CloneType(U, options);
  }
}

// node_modules/@sinclair/typebox/build/import/type/keyof/keyof-from-mapped-result.mjs
var FromProperties6 = function(K, options) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: KeyOf(K[K2], options) };
  }, {});
};
var FromMappedResult5 = function(R, options) {
  return FromProperties6(R.properties, options);
};
function KeyOfFromMappedResult(R, options) {
  const P = FromMappedResult5(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/extends/extends-undefined.mjs
var Intersect2 = function(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
};
var Union2 = function(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
};
var Not = function(schema) {
  return !ExtendsUndefinedCheck(schema.not);
};
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/import/errors/function.mjs
function DefaultErrorFunction(error8) {
  switch (error8.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error8.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error8.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error8.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error8.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error8.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error8.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error8.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error8.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error8.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error8.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error8.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error8.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error8.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error8.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error8.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error8.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error8.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error8.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error8.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error8.schema.const === "string" ? `'${error8.schema.const}'` : error8.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error8.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error8.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error8.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error8.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error8.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error8.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error8.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error8.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error8.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error8.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error8.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error8.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error8.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error8.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error8.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error8.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
function GetErrorFunction() {
  return errorFunction;
}
var errorFunction = DefaultErrorFunction;

// node_modules/@sinclair/typebox/build/import/value/deref/deref.mjs
function Deref(schema, references) {
  const index = references.findIndex((target) => target.$id === schema.$ref);
  if (index === -1)
    throw new TypeDereferenceError(schema);
  return references[index];
}

class TypeDereferenceError extends TypeBoxError {
  schema;
  constructor(schema) {
    super(`Unable to dereference schema with \$id '${schema.$id}'`);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/import/value/hash/hash.mjs
function* NumberToBytes(value3) {
  const byteCount = value3 === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value3) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value3 >> 8 * (byteCount - 1 - i) & 255;
  }
}
var ArrayType2 = function(value3) {
  FNV1A64(ByteMarker.Array);
  for (const item of value3) {
    Visit3(item);
  }
};
var BooleanType = function(value3) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value3 ? 1 : 0);
};
var BigIntType = function(value3) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value3);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
};
var DateType2 = function(value3) {
  FNV1A64(ByteMarker.Date);
  Visit3(value3.getTime());
};
var NullType = function(value3) {
  FNV1A64(ByteMarker.Null);
};
var NumberType = function(value3) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value3);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
};
var ObjectType2 = function(value3) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.keys(value3).sort()) {
    Visit3(key);
    Visit3(value3[key]);
  }
};
var StringType = function(value3) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value3.length; i++) {
    for (const byte of NumberToBytes(value3.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
};
var SymbolType = function(value3) {
  FNV1A64(ByteMarker.Symbol);
  Visit3(value3.description);
};
var Uint8ArrayType2 = function(value3) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value3.length; i++) {
    FNV1A64(value3[i]);
  }
};
var UndefinedType = function(value3) {
  return FNV1A64(ByteMarker.Undefined);
};
var Visit3 = function(value3) {
  if (IsArray(value3))
    return ArrayType2(value3);
  if (IsBoolean(value3))
    return BooleanType(value3);
  if (IsBigInt(value3))
    return BigIntType(value3);
  if (IsDate(value3))
    return DateType2(value3);
  if (IsNull(value3))
    return NullType(value3);
  if (IsNumber(value3))
    return NumberType(value3);
  if (IsPlainObject(value3))
    return ObjectType2(value3);
  if (IsString(value3))
    return StringType(value3);
  if (IsSymbol(value3))
    return SymbolType(value3);
  if (IsUint8Array(value3))
    return Uint8ArrayType2(value3);
  if (IsUndefined(value3))
    return UndefinedType(value3);
  throw new ValueHashError(value3);
};
var FNV1A64 = function(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
};
function Hash(value3) {
  Accumulator = BigInt("14695981039346656037");
  Visit3(value3);
  return Accumulator;
}

class ValueHashError extends TypeBoxError {
  value;
  constructor(value3) {
    super(`Unable to hash value`);
    this.value = value3;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
// node_modules/@sinclair/typebox/build/import/errors/errors.mjs
var EscapeKey = function(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
};
var IsDefined = function(value3) {
  return value3 !== undefined;
};
var Create = function(errorType, schema, path, value3) {
  return { type: errorType, schema, path, value: value3, message: GetErrorFunction()({ errorType, path, schema, value: value3 }) };
};
function* FromAny(schema, references, path, value3) {
}
function* FromArray3(schema, references, path, value3) {
  if (!IsArray(value3)) {
    return yield Create(ValueErrorType.Array, schema, path, value3);
  }
  if (IsDefined(schema.minItems) && !(value3.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value3);
  }
  if (IsDefined(schema.maxItems) && !(value3.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value3);
  }
  for (let i = 0;i < value3.length; i++) {
    yield* Visit4(schema.items, references, `${path}/${i}`, value3[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value3) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value3);
  }
  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value3.reduce((acc, value4, index) => Visit4(containsSchema, references, `${path}${index}`, value4).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value3);
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value3);
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value3);
  }
}
function* FromAsyncIterator(schema, references, path, value3) {
  if (!IsAsyncIterator(value3))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value3);
}
function* FromBigInt(schema, references, path, value3) {
  if (!IsBigInt(value3))
    return yield Create(ValueErrorType.BigInt, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value3);
  }
}
function* FromBoolean(schema, references, path, value3) {
  if (!IsBoolean(value3))
    yield Create(ValueErrorType.Boolean, schema, path, value3);
}
function* FromConstructor(schema, references, path, value3) {
  yield* Visit4(schema.returns, references, path, value3.prototype);
}
function* FromDate(schema, references, path, value3) {
  if (!IsDate(value3))
    return yield Create(ValueErrorType.Date, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value3.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value3.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.maximumTimestamp) && !(value3.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.minimumTimestamp) && !(value3.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value3.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value3);
  }
}
function* FromFunction(schema, references, path, value3) {
  if (!IsFunction(value3))
    yield Create(ValueErrorType.Function, schema, path, value3);
}
function* FromInteger(schema, references, path, value3) {
  if (!IsInteger(value3))
    return yield Create(ValueErrorType.Integer, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value3);
  }
}
function* FromIntersect3(schema, references, path, value3) {
  for (const inner of schema.allOf) {
    const next = Visit4(inner, references, path, value3).next();
    if (!next.done) {
      yield Create(ValueErrorType.Intersect, schema, path, value3);
      yield next.value;
    }
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value3)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value3);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value3)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit4(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value3[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator(schema, references, path, value3) {
  if (!IsIterator(value3))
    yield Create(ValueErrorType.Iterator, schema, path, value3);
}
function* FromLiteral2(schema, references, path, value3) {
  if (!(value3 === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value3);
}
function* FromNever(schema, references, path, value3) {
  yield Create(ValueErrorType.Never, schema, path, value3);
}
function* FromNot(schema, references, path, value3) {
  if (Visit4(schema.not, references, path, value3).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value3);
}
function* FromNull(schema, references, path, value3) {
  if (!IsNull(value3))
    yield Create(ValueErrorType.Null, schema, path, value3);
}
function* FromNumber(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsNumberLike(value3))
    return yield Create(ValueErrorType.Number, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value3);
  }
}
function* FromObject(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsObjectLike(value3))
    return yield Create(ValueErrorType.Object, schema, path, value3);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value3);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value3);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value3);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value3[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value3[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value3[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value3)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value3, knownKey)) {
        yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value3[knownKey]);
      }
    }
  }
}
function* FromPromise(schema, references, path, value3) {
  if (!IsPromise(value3))
    yield Create(ValueErrorType.Promise, schema, path, value3);
}
function* FromRecord(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsRecordLike(value3))
    return yield Create(ValueErrorType.Object, schema, path, value3);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value3);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value3);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value3)) {
    if (regex.test(propertyKey))
      yield* Visit4(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value3)) {
      if (!regex.test(propertyKey))
        yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value3)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef(schema, references, path, value3) {
  yield* Visit4(Deref(schema, references), references, path, value3);
}
function* FromRegExp(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  if (IsDefined(schema.minLength) && !(value3.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value3);
  }
  if (IsDefined(schema.maxLength) && !(value3.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value3);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value3)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value3);
  }
}
function* FromString(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  if (IsDefined(schema.minLength) && !(value3.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value3);
  }
  if (IsDefined(schema.maxLength) && !(value3.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value3);
  }
  if (IsString(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value3)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value3);
    }
  }
  if (IsString(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value3);
    } else {
      const format = exports_format.Get(schema.format);
      if (!format(value3)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value3);
      }
    }
  }
}
function* FromSymbol(schema, references, path, value3) {
  if (!IsSymbol(value3))
    yield Create(ValueErrorType.Symbol, schema, path, value3);
}
function* FromTemplateLiteral2(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value3)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value3);
  }
}
function* FromThis(schema, references, path, value3) {
  yield* Visit4(Deref(schema, references), references, path, value3);
}
function* FromTuple3(schema, references, path, value3) {
  if (!IsArray(value3))
    return yield Create(ValueErrorType.Tuple, schema, path, value3);
  if (schema.items === undefined && !(value3.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value3);
  }
  if (!(value3.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value3);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit4(schema.items[i], references, `${path}/${i}`, value3[i]);
  }
}
function* FromUndefined(schema, references, path, value3) {
  if (!IsUndefined(value3))
    yield Create(ValueErrorType.Undefined, schema, path, value3);
}
function* FromUnion5(schema, references, path, value3) {
  let count = 0;
  for (const subschema of schema.anyOf) {
    const errors2 = [...Visit4(subschema, references, path, value3)];
    if (errors2.length === 0)
      return;
    count += errors2.length;
  }
  if (count > 0) {
    yield Create(ValueErrorType.Union, schema, path, value3);
  }
}
function* FromUint8Array(schema, references, path, value3) {
  if (!IsUint8Array(value3))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value3);
  if (IsDefined(schema.maxByteLength) && !(value3.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value3);
  }
  if (IsDefined(schema.minByteLength) && !(value3.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value3);
  }
}
function* FromUnknown(schema, references, path, value3) {
}
function* FromVoid(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsVoidLike(value3))
    yield Create(ValueErrorType.Void, schema, path, value3);
}
function* FromKind(schema, references, path, value3) {
  const check = exports_type.Get(schema[Kind]);
  if (!check(schema, value3))
    yield Create(ValueErrorType.Kind, schema, path, value3);
}
function* Visit4(schema, references, path, value3) {
  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny(schema_, references_, path, value3);
    case "Array":
      return yield* FromArray3(schema_, references_, path, value3);
    case "AsyncIterator":
      return yield* FromAsyncIterator(schema_, references_, path, value3);
    case "BigInt":
      return yield* FromBigInt(schema_, references_, path, value3);
    case "Boolean":
      return yield* FromBoolean(schema_, references_, path, value3);
    case "Constructor":
      return yield* FromConstructor(schema_, references_, path, value3);
    case "Date":
      return yield* FromDate(schema_, references_, path, value3);
    case "Function":
      return yield* FromFunction(schema_, references_, path, value3);
    case "Integer":
      return yield* FromInteger(schema_, references_, path, value3);
    case "Intersect":
      return yield* FromIntersect3(schema_, references_, path, value3);
    case "Iterator":
      return yield* FromIterator(schema_, references_, path, value3);
    case "Literal":
      return yield* FromLiteral2(schema_, references_, path, value3);
    case "Never":
      return yield* FromNever(schema_, references_, path, value3);
    case "Not":
      return yield* FromNot(schema_, references_, path, value3);
    case "Null":
      return yield* FromNull(schema_, references_, path, value3);
    case "Number":
      return yield* FromNumber(schema_, references_, path, value3);
    case "Object":
      return yield* FromObject(schema_, references_, path, value3);
    case "Promise":
      return yield* FromPromise(schema_, references_, path, value3);
    case "Record":
      return yield* FromRecord(schema_, references_, path, value3);
    case "Ref":
      return yield* FromRef(schema_, references_, path, value3);
    case "RegExp":
      return yield* FromRegExp(schema_, references_, path, value3);
    case "String":
      return yield* FromString(schema_, references_, path, value3);
    case "Symbol":
      return yield* FromSymbol(schema_, references_, path, value3);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral2(schema_, references_, path, value3);
    case "This":
      return yield* FromThis(schema_, references_, path, value3);
    case "Tuple":
      return yield* FromTuple3(schema_, references_, path, value3);
    case "Undefined":
      return yield* FromUndefined(schema_, references_, path, value3);
    case "Union":
      return yield* FromUnion5(schema_, references_, path, value3);
    case "Uint8Array":
      return yield* FromUint8Array(schema_, references_, path, value3);
    case "Unknown":
      return yield* FromUnknown(schema_, references_, path, value3);
    case "Void":
      return yield* FromVoid(schema_, references_, path, value3);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind(schema_, references_, path, value3);
  }
}
function Errors(...args) {
  const iterator3 = args.length === 3 ? Visit4(args[0], args[1], "", args[2]) : Visit4(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator3);
}
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  schema;
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class ValueErrorIterator {
  iterator;
  constructor(iterator3) {
    this.iterator = iterator3;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
// node_modules/@sinclair/typebox/build/import/type/any/any.mjs
function Any(options = {}) {
  return { ...options, [Kind]: "Any" };
}
// node_modules/@sinclair/typebox/build/import/type/unknown/unknown.mjs
function Unknown(options = {}) {
  return {
    ...options,
    [Kind]: "Unknown"
  };
}
// node_modules/@sinclair/typebox/build/import/type/extends/extends-check.mjs
var IntoBooleanResult = function(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
};
var Throw = function(message) {
  throw new ExtendsResolverError(message);
};
var IsStructuralRight = function(right) {
  return exports_type3.IsNever(right) || exports_type3.IsIntersect(right) || exports_type3.IsUnion(right) || exports_type3.IsUnknown(right) || exports_type3.IsAny(right);
};
var StructuralRight = function(left, right) {
  return exports_type3.IsNever(right) ? FromNeverRight(left, right) : exports_type3.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type3.IsUnion(right) ? FromUnionRight(left, right) : exports_type3.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type3.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
};
var FromAnyRight = function(left, right) {
  return ExtendsResult.True;
};
var FromAny2 = function(left, right) {
  return exports_type3.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type3.IsUnion(right) && right.anyOf.some((schema) => exports_type3.IsAny(schema) || exports_type3.IsUnknown(schema)) ? ExtendsResult.True : exports_type3.IsUnion(right) ? ExtendsResult.Union : exports_type3.IsUnknown(right) ? ExtendsResult.True : exports_type3.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
};
var FromArrayRight = function(left, right) {
  return exports_type3.IsUnknown(left) ? ExtendsResult.False : exports_type3.IsAny(left) ? ExtendsResult.Union : exports_type3.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromArray4 = function(left, right) {
  return exports_type3.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type3.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
};
var FromAsyncIterator2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type3.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
};
var FromBigInt2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromBooleanRight = function(left, right) {
  return exports_type3.IsLiteralBoolean(left) ? ExtendsResult.True : exports_type3.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromBoolean2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromConstructor2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : !exports_type3.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
};
var FromDate2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromFunction2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : !exports_type3.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
};
var FromIntegerRight = function(left, right) {
  return exports_type3.IsLiteral(left) && exports_value.IsNumber(left.const) ? ExtendsResult.True : exports_type3.IsNumber(left) || exports_type3.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromInteger2 = function(left, right) {
  return exports_type3.IsInteger(right) || exports_type3.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
};
var FromIntersectRight = function(left, right) {
  return right.allOf.every((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromIntersect4 = function(left, right) {
  return left.allOf.some((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromIterator2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type3.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
};
var FromLiteral3 = function(left, right) {
  return exports_type3.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsString(right) ? FromStringRight(left, right) : exports_type3.IsNumber(right) ? FromNumberRight(left, right) : exports_type3.IsInteger(right) ? FromIntegerRight(left, right) : exports_type3.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
};
var FromNeverRight = function(left, right) {
  return ExtendsResult.False;
};
var FromNever2 = function(left, right) {
  return ExtendsResult.True;
};
var UnwrapTNot = function(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type3.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
};
var FromNot2 = function(left, right) {
  return exports_type3.IsNot(left) ? Visit5(UnwrapTNot(left), right) : exports_type3.IsNot(right) ? Visit5(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
};
var FromNull2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromNumberRight = function(left, right) {
  return exports_type3.IsLiteralNumber(left) ? ExtendsResult.True : exports_type3.IsNumber(left) || exports_type3.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromNumber2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsInteger(right) || exports_type3.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
};
var IsObjectPropertyCount = function(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
};
var IsObjectStringLike = function(schema) {
  return IsObjectArrayLike(schema);
};
var IsObjectSymbolLike = function(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type3.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type3.IsString(schema.properties.description.anyOf[0]) && exports_type3.IsUndefined(schema.properties.description.anyOf[1]) || exports_type3.IsString(schema.properties.description.anyOf[1]) && exports_type3.IsUndefined(schema.properties.description.anyOf[0]));
};
var IsObjectNumberLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectBooleanLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectBigIntLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectDateLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectUint8ArrayLike = function(schema) {
  return IsObjectArrayLike(schema);
};
var IsObjectFunctionLike = function(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
};
var IsObjectConstructorLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectArrayLike = function(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
};
var IsObjectPromiseLike = function(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit5(schema.properties["then"], then)) === ExtendsResult.True;
};
var Property = function(left, right) {
  return Visit5(left, right) === ExtendsResult.False ? ExtendsResult.False : exports_type3.IsOptional(left) && !exports_type3.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
};
var FromObjectRight = function(left, right) {
  return exports_type3.IsUnknown(left) ? ExtendsResult.False : exports_type3.IsAny(left) ? ExtendsResult.Union : exports_type3.IsNever(left) || exports_type3.IsLiteralString(left) && IsObjectStringLike(right) || exports_type3.IsLiteralNumber(left) && IsObjectNumberLike(right) || exports_type3.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || exports_type3.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type3.IsBigInt(left) && IsObjectBigIntLike(right) || exports_type3.IsString(left) && IsObjectStringLike(right) || exports_type3.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type3.IsNumber(left) && IsObjectNumberLike(right) || exports_type3.IsInteger(left) && IsObjectNumberLike(right) || exports_type3.IsBoolean(left) && IsObjectBooleanLike(right) || exports_type3.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || exports_type3.IsDate(left) && IsObjectDateLike(right) || exports_type3.IsConstructor(left) && IsObjectConstructorLike(right) || exports_type3.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : exports_type3.IsRecord(left) && exports_type3.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type3.IsRecord(left) && exports_type3.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
};
var FromObject2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : !exports_type3.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type3.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type3.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
};
var FromPromise2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !exports_type3.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.item, right.item));
};
var RecordKey = function(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
};
var RecordValue = function(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
};
var FromRecordRight = function(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return exports_type3.IsLiteralString(left) && exports_type3.IsNumber(Key) && IntoBooleanResult(Visit5(left, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type3.IsUint8Array(left) && exports_type3.IsNumber(Key) ? Visit5(left, Value) : exports_type3.IsString(left) && exports_type3.IsNumber(Key) ? Visit5(left, Value) : exports_type3.IsArray(left) && exports_type3.IsNumber(Key) ? Visit5(left, Value) : exports_type3.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
};
var FromRecord2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : !exports_type3.IsRecord(right) ? ExtendsResult.False : Visit5(RecordValue(left), RecordValue(right));
};
var FromRegExp2 = function(left, right) {
  const L = exports_type3.IsRegExp(left) ? String2() : left;
  const R = exports_type3.IsRegExp(right) ? String2() : right;
  return Visit5(L, R);
};
var FromStringRight = function(left, right) {
  return exports_type3.IsLiteral(left) && exports_value.IsString(left.const) ? ExtendsResult.True : exports_type3.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromString2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromSymbol2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromTemplateLiteral3 = function(left, right) {
  return exports_type3.IsTemplateLiteral(left) ? Visit5(TemplateLiteralToUnion(left), right) : exports_type3.IsTemplateLiteral(right) ? Visit5(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
};
var IsArrayOfTuple = function(left, right) {
  return exports_type3.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit5(schema, right.items) === ExtendsResult.True);
};
var FromTupleRight = function(left, right) {
  return exports_type3.IsNever(left) ? ExtendsResult.True : exports_type3.IsUnknown(left) ? ExtendsResult.False : exports_type3.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
};
var FromTuple4 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : exports_type3.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !exports_type3.IsTuple(right) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) || !exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit5(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUint8Array2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUndefined2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsVoid(right) ? FromVoidRight(left, right) : exports_type3.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnionRight = function(left, right) {
  return right.anyOf.some((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnion6 = function(left, right) {
  return left.anyOf.every((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnknownRight = function(left, right) {
  return ExtendsResult.True;
};
var FromUnknown2 = function(left, right) {
  return exports_type3.IsNever(right) ? FromNeverRight(left, right) : exports_type3.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type3.IsUnion(right) ? FromUnionRight(left, right) : exports_type3.IsAny(right) ? FromAnyRight(left, right) : exports_type3.IsString(right) ? FromStringRight(left, right) : exports_type3.IsNumber(right) ? FromNumberRight(left, right) : exports_type3.IsInteger(right) ? FromIntegerRight(left, right) : exports_type3.IsBoolean(right) ? FromBooleanRight(left, right) : exports_type3.IsArray(right) ? FromArrayRight(left, right) : exports_type3.IsTuple(right) ? FromTupleRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromVoidRight = function(left, right) {
  return exports_type3.IsUndefined(left) ? ExtendsResult.True : exports_type3.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromVoid2 = function(left, right) {
  return exports_type3.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type3.IsUnion(right) ? FromUnionRight(left, right) : exports_type3.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type3.IsAny(right) ? FromAnyRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
};
var Visit5 = function(left, right) {
  return exports_type3.IsTemplateLiteral(left) || exports_type3.IsTemplateLiteral(right) ? FromTemplateLiteral3(left, right) : exports_type3.IsRegExp(left) || exports_type3.IsRegExp(right) ? FromRegExp2(left, right) : exports_type3.IsNot(left) || exports_type3.IsNot(right) ? FromNot2(left, right) : exports_type3.IsAny(left) ? FromAny2(left, right) : exports_type3.IsArray(left) ? FromArray4(left, right) : exports_type3.IsBigInt(left) ? FromBigInt2(left, right) : exports_type3.IsBoolean(left) ? FromBoolean2(left, right) : exports_type3.IsAsyncIterator(left) ? FromAsyncIterator2(left, right) : exports_type3.IsConstructor(left) ? FromConstructor2(left, right) : exports_type3.IsDate(left) ? FromDate2(left, right) : exports_type3.IsFunction(left) ? FromFunction2(left, right) : exports_type3.IsInteger(left) ? FromInteger2(left, right) : exports_type3.IsIntersect(left) ? FromIntersect4(left, right) : exports_type3.IsIterator(left) ? FromIterator2(left, right) : exports_type3.IsLiteral(left) ? FromLiteral3(left, right) : exports_type3.IsNever(left) ? FromNever2(left, right) : exports_type3.IsNull(left) ? FromNull2(left, right) : exports_type3.IsNumber(left) ? FromNumber2(left, right) : exports_type3.IsObject(left) ? FromObject2(left, right) : exports_type3.IsRecord(left) ? FromRecord2(left, right) : exports_type3.IsString(left) ? FromString2(left, right) : exports_type3.IsSymbol(left) ? FromSymbol2(left, right) : exports_type3.IsTuple(left) ? FromTuple4(left, right) : exports_type3.IsPromise(left) ? FromPromise2(left, right) : exports_type3.IsUint8Array(left) ? FromUint8Array2(left, right) : exports_type3.IsUndefined(left) ? FromUndefined2(left, right) : exports_type3.IsUnion(left) ? FromUnion6(left, right) : exports_type3.IsUnknown(left) ? FromUnknown2(left, right) : exports_type3.IsVoid(left) ? FromVoid2(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`);
};
function ExtendsCheck(left, right) {
  return Visit5(left, right);
}

class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
// node_modules/@sinclair/typebox/build/import/type/extends/extends-from-mapped-result.mjs
var FromProperties7 = function(P, Right, True, False, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Extends(P[K2], Right, True, False, options) };
  }, {});
};
var FromMappedResult6 = function(Left, Right, True, False, options) {
  return FromProperties7(Left.properties, Right, True, False, options);
};
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/extends/extends.mjs
var ExtendsResolve = function(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
};
function Extends(L, R, T, F, options = {}) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CloneType(ExtendsFromMappedKey(L, R, T, F, options)) : CloneType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/import/type/extends/extends-from-mapped-key.mjs
var FromPropertyKey = function(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, options)
  };
};
var FromPropertyKeys = function(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
};
var FromMappedKey2 = function(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
};
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/value/check/check.mjs
var IsAnyOrUnknown = function(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
};
var IsDefined2 = function(value3) {
  return value3 !== undefined;
};
var FromAny3 = function(schema, references, value3) {
  return true;
};
var FromArray5 = function(schema, references, value3) {
  if (!IsArray(value3))
    return false;
  if (IsDefined2(schema.minItems) && !(value3.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined2(schema.maxItems) && !(value3.length <= schema.maxItems)) {
    return false;
  }
  if (!value3.every((value4) => Visit6(schema.items, references, value4))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value3) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined2(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value3.reduce((acc, value4) => Visit6(containsSchema, references, value4) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
};
var FromAsyncIterator3 = function(schema, references, value3) {
  return IsAsyncIterator(value3);
};
var FromBigInt3 = function(schema, references, value3) {
  if (!IsBigInt(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
};
var FromBoolean3 = function(schema, references, value3) {
  return IsBoolean(value3);
};
var FromConstructor3 = function(schema, references, value3) {
  return Visit6(schema.returns, references, value3.prototype);
};
var FromDate3 = function(schema, references, value3) {
  if (!IsDate(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value3.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value3.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value3.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value3.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value3.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
};
var FromFunction3 = function(schema, references, value3) {
  return IsFunction(value3);
};
var FromInteger3 = function(schema, references, value3) {
  if (!IsInteger(value3)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
};
var FromIntersect5 = function(schema, references, value3) {
  const check1 = schema.allOf.every((schema2) => Visit6(schema2, references, value3));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value3).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value3).every((key) => keyCheck.test(key) || Visit6(schema.unevaluatedProperties, references, value3[key]));
    return check1 && check2;
  } else {
    return check1;
  }
};
var FromIterator3 = function(schema, references, value3) {
  return IsIterator(value3);
};
var FromLiteral4 = function(schema, references, value3) {
  return value3 === schema.const;
};
var FromNever3 = function(schema, references, value3) {
  return false;
};
var FromNot3 = function(schema, references, value3) {
  return !Visit6(schema.not, references, value3);
};
var FromNull3 = function(schema, references, value3) {
  return IsNull(value3);
};
var FromNumber3 = function(schema, references, value3) {
  if (!TypeSystemPolicy.IsNumberLike(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
};
var FromObject3 = function(schema, references, value3) {
  if (!TypeSystemPolicy.IsObjectLike(value3))
    return false;
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit6(property, references, value3[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value3)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value3, knownKey) && !Visit6(property, references, value3[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value3);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value3);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit6(schema.additionalProperties, references, value3[key]));
  } else {
    return true;
  }
};
var FromPromise3 = function(schema, references, value3) {
  return IsPromise(value3);
};
var FromRecord3 = function(schema, references, value3) {
  if (!TypeSystemPolicy.IsRecordLike(value3)) {
    return false;
  }
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value3).every(([key, value4]) => {
    return regex.test(key) ? Visit6(patternSchema, references, value4) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value3).every(([key, value4]) => {
    return !regex.test(key) ? Visit6(schema.additionalProperties, references, value4) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value3).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
};
var FromRef2 = function(schema, references, value3) {
  return Visit6(Deref(schema, references), references, value3);
};
var FromRegExp3 = function(schema, references, value3) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined2(schema.minLength)) {
    if (!(value3.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value3.length <= schema.maxLength))
      return false;
  }
  return regex.test(value3);
};
var FromString3 = function(schema, references, value3) {
  if (!IsString(value3)) {
    return false;
  }
  if (IsDefined2(schema.minLength)) {
    if (!(value3.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value3.length <= schema.maxLength))
      return false;
  }
  if (IsDefined2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value3))
      return false;
  }
  if (IsDefined2(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value3);
  }
  return true;
};
var FromSymbol3 = function(schema, references, value3) {
  return IsSymbol(value3);
};
var FromTemplateLiteral4 = function(schema, references, value3) {
  return IsString(value3) && new RegExp(schema.pattern).test(value3);
};
var FromThis2 = function(schema, references, value3) {
  return Visit6(Deref(schema, references), references, value3);
};
var FromTuple5 = function(schema, references, value3) {
  if (!IsArray(value3)) {
    return false;
  }
  if (schema.items === undefined && !(value3.length === 0)) {
    return false;
  }
  if (!(value3.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit6(schema.items[i], references, value3[i]))
      return false;
  }
  return true;
};
var FromUndefined3 = function(schema, references, value3) {
  return IsUndefined(value3);
};
var FromUnion7 = function(schema, references, value3) {
  return schema.anyOf.some((inner) => Visit6(inner, references, value3));
};
var FromUint8Array3 = function(schema, references, value3) {
  if (!IsUint8Array(value3)) {
    return false;
  }
  if (IsDefined2(schema.maxByteLength) && !(value3.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined2(schema.minByteLength) && !(value3.length >= schema.minByteLength)) {
    return false;
  }
  return true;
};
var FromUnknown3 = function(schema, references, value3) {
  return true;
};
var FromVoid3 = function(schema, references, value3) {
  return TypeSystemPolicy.IsVoidLike(value3);
};
var FromKind2 = function(schema, references, value3) {
  if (!exports_type.Has(schema[Kind]))
    return false;
  const func = exports_type.Get(schema[Kind]);
  return func(schema, value3);
};
var Visit6 = function(schema, references, value3) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny3(schema_, references_, value3);
    case "Array":
      return FromArray5(schema_, references_, value3);
    case "AsyncIterator":
      return FromAsyncIterator3(schema_, references_, value3);
    case "BigInt":
      return FromBigInt3(schema_, references_, value3);
    case "Boolean":
      return FromBoolean3(schema_, references_, value3);
    case "Constructor":
      return FromConstructor3(schema_, references_, value3);
    case "Date":
      return FromDate3(schema_, references_, value3);
    case "Function":
      return FromFunction3(schema_, references_, value3);
    case "Integer":
      return FromInteger3(schema_, references_, value3);
    case "Intersect":
      return FromIntersect5(schema_, references_, value3);
    case "Iterator":
      return FromIterator3(schema_, references_, value3);
    case "Literal":
      return FromLiteral4(schema_, references_, value3);
    case "Never":
      return FromNever3(schema_, references_, value3);
    case "Not":
      return FromNot3(schema_, references_, value3);
    case "Null":
      return FromNull3(schema_, references_, value3);
    case "Number":
      return FromNumber3(schema_, references_, value3);
    case "Object":
      return FromObject3(schema_, references_, value3);
    case "Promise":
      return FromPromise3(schema_, references_, value3);
    case "Record":
      return FromRecord3(schema_, references_, value3);
    case "Ref":
      return FromRef2(schema_, references_, value3);
    case "RegExp":
      return FromRegExp3(schema_, references_, value3);
    case "String":
      return FromString3(schema_, references_, value3);
    case "Symbol":
      return FromSymbol3(schema_, references_, value3);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value3);
    case "This":
      return FromThis2(schema_, references_, value3);
    case "Tuple":
      return FromTuple5(schema_, references_, value3);
    case "Undefined":
      return FromUndefined3(schema_, references_, value3);
    case "Union":
      return FromUnion7(schema_, references_, value3);
    case "Uint8Array":
      return FromUint8Array3(schema_, references_, value3);
    case "Unknown":
      return FromUnknown3(schema_, references_, value3);
    case "Void":
      return FromVoid3(schema_, references_, value3);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind2(schema_, references_, value3);
  }
};
function Check(...args) {
  return args.length === 3 ? Visit6(args[0], args[1], args[2]) : Visit6(args[0], [], args[1]);
}

class ValueCheckUnknownTypeError extends TypeBoxError {
  schema;
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/import/value/clone/clone.mjs
var ObjectType3 = function(value3) {
  const keys = [...Object.getOwnPropertyNames(value3), ...Object.getOwnPropertySymbols(value3)];
  return keys.reduce((acc, key) => ({ ...acc, [key]: Clone2(value3[key]) }), {});
};
var ArrayType3 = function(value3) {
  return value3.map((element) => Clone2(element));
};
var TypedArrayType = function(value3) {
  return value3.slice();
};
var DateType3 = function(value3) {
  return new Date(value3.toISOString());
};
var ValueType = function(value3) {
  return value3;
};
function Clone2(value3) {
  if (IsArray(value3))
    return ArrayType3(value3);
  if (IsDate(value3))
    return DateType3(value3);
  if (IsPlainObject(value3))
    return ObjectType3(value3);
  if (IsTypedArray(value3))
    return TypedArrayType(value3);
  if (IsValueType(value3))
    return ValueType(value3);
  throw new Error("ValueClone: Unable to clone value");
}
// node_modules/@sinclair/typebox/build/import/value/create/create.mjs
var FromDefault = function(value3) {
  return typeof value3 === "function" ? value3 : Clone2(value3);
};
var FromAny4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
};
var FromArray6 = function(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
};
var FromAsyncIterator4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {
    }();
  }
};
var FromBigInt4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
};
var FromBoolean4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
};
var FromConstructor4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value3 = Visit7(schema.returns, references);
    if (typeof value3 === "object" && !Array.isArray(value3)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value3)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
};
var FromDate4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
};
var FromFunction4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
};
var FromInteger4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
};
var FromIntersect6 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value3 = schema.allOf.reduce((acc, schema2) => {
      const next = Visit7(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value3))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value3;
  }
};
var FromIterator4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {
    }();
  }
};
var FromLiteral5 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
};
var FromNever4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
};
var FromNot4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
};
var FromNull4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
};
var FromNumber4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
};
var FromObject4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    return FromDefault(schema.default) || Object.entries(schema.properties).reduce((acc, [key, schema2]) => {
      return required.has(key) ? { ...acc, [key]: Visit7(schema2, references) } : { ...acc };
    }, {});
  }
};
var FromPromise4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
};
var FromRecord4 = function(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    return propertyKeys.reduce((acc, key) => {
      return { ...acc, [key]: Visit7(valueSchema, references) };
    }, {});
  } else {
    return {};
  }
};
var FromRef3 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
};
var FromRegExp4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
};
var FromString4 = function(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
};
var FromSymbol4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
};
var FromTemplateLiteral5 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
};
var FromThis3 = function(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
};
var FromTuple6 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit7(schema.items[index], references));
  }
};
var FromUndefined4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
};
var FromUnion8 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
};
var FromUint8Array4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
};
var FromUnknown4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
};
var FromVoid4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
};
var FromKind3 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
};
var Visit7 = function(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Array":
      return FromArray6(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor4(schema_, references_);
    case "Date":
      return FromDate4(schema_, references_);
    case "Function":
      return FromFunction4(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect6(schema_, references_);
    case "Iterator":
      return FromIterator4(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject4(schema_, references_);
    case "Promise":
      return FromPromise4(schema_, references_);
    case "Record":
      return FromRecord4(schema_, references_);
    case "Ref":
      return FromRef3(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral5(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple6(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion8(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
};
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}

class ValueCreateError extends TypeBoxError {
  schema;
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
// node_modules/@sinclair/typebox/build/import/value/cast/cast.mjs
var ScoreUnion = function(schema, references, value3) {
  if (schema[Kind] === "Object" && typeof value3 === "object" && !IsNull(value3)) {
    const object3 = schema;
    const keys = Object.getOwnPropertyNames(value3);
    const entries = Object.entries(object3.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal7 = schema2[Kind] === "Literal" && schema2.const === value3[key] ? max : 0;
      const checks = Check(schema2, references, value3[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal7 + checks + exists);
    }, 0);
  } else {
    return Check(schema, references, value3) ? 1 : 0;
  }
};
var SelectUnion = function(union9, references, value3) {
  let [select, best] = [union9.anyOf[0], 0];
  for (const schema of union9.anyOf) {
    const score = ScoreUnion(schema, references, value3);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
};
var CastUnion = function(union9, references, value3) {
  if ("default" in union9) {
    return typeof value3 === "function" ? union9.default : Clone2(union9.default);
  } else {
    const schema = SelectUnion(union9, references, value3);
    return Cast(schema, references, value3);
  }
};
var DefaultClone = function(schema, references, value3) {
  return Check(schema, references, value3) ? Clone2(value3) : Create2(schema, references);
};
var Default = function(schema, references, value3) {
  return Check(schema, references, value3) ? value3 : Create2(schema, references);
};
var FromArray7 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  const created = IsArray(value3) ? Clone2(value3) : Create2(schema, references);
  const minimum = IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value4) => Visit8(schema.items, references, value4));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
};
var FromConstructor5 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value3.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit8(property, references, value3.prototype[key]);
  }
  return result;
};
var FromIntersect7 = function(schema, references, value3) {
  const created = Create2(schema, references);
  const mapped9 = IsPlainObject(created) && IsPlainObject(value3) ? { ...created, ...value3 } : value3;
  return Check(schema, references, mapped9) ? mapped9 : Create2(schema, references);
};
var FromNever5 = function(schema, references, value3) {
  throw new ValueCastError(schema, "Never types cannot be cast");
};
var FromObject5 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return value3;
  if (value3 === null || typeof value3 !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value3[key] === undefined)
      continue;
    result[key] = Visit8(property, references, value3[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value3)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value3[propertyName]);
    }
  }
  return result;
};
var FromRecord5 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  if (value3 === null || typeof value3 !== "object" || Array.isArray(value3) || value3 instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value3)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
};
var FromRef4 = function(schema, references, value3) {
  return Visit8(Deref(schema, references), references, value3);
};
var FromThis4 = function(schema, references, value3) {
  return Visit8(Deref(schema, references), references, value3);
};
var FromTuple7 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  if (!IsArray(value3))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit8(schema2, references, value3[index]));
};
var FromUnion9 = function(schema, references, value3) {
  return Check(schema, references, value3) ? Clone2(value3) : CastUnion(schema, references, value3);
};
var Visit8 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray7(schema_, references_, value3);
    case "Constructor":
      return FromConstructor5(schema_, references_, value3);
    case "Intersect":
      return FromIntersect7(schema_, references_, value3);
    case "Never":
      return FromNever5(schema_, references_, value3);
    case "Object":
      return FromObject5(schema_, references_, value3);
    case "Record":
      return FromRecord5(schema_, references_, value3);
    case "Ref":
      return FromRef4(schema_, references_, value3);
    case "This":
      return FromThis4(schema_, references_, value3);
    case "Tuple":
      return FromTuple7(schema_, references_, value3);
    case "Union":
      return FromUnion9(schema_, references_, value3);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value3);
    default:
      return Default(schema_, references_, value3);
  }
};
function Cast(...args) {
  return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}

class ValueCastError extends TypeBoxError {
  schema;
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/import/value/clean/clean.mjs
var IsCheckable = function(schema) {
  return IsSchema(schema) && schema[Kind] !== "Unsafe";
};
var FromArray8 = function(schema, references, value3) {
  if (!IsArray(value3))
    return value3;
  return value3.map((value4) => Visit9(schema.items, references, value4));
};
var FromIntersect8 = function(schema, references, value3) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value3)));
  const composite = intersections.reduce((acc, value4) => IsObject(value4) ? { ...acc, ...value4 } : value4, {});
  if (!IsObject(value3) || !IsObject(composite) || !IsSchema(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value3)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value3[key])) {
      composite[key] = Visit9(unevaluatedProperties, references, value3[key]);
    }
  }
  return composite;
};
var FromObject6 = function(schema, references, value3) {
  if (!IsObject(value3) || IsArray(value3))
    return value3;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value3)) {
    if (key in schema.properties) {
      value3[key] = Visit9(schema.properties[key], references, value3[key]);
      continue;
    }
    if (IsSchema(additionalProperties) && Check(additionalProperties, references, value3[key])) {
      value3[key] = Visit9(additionalProperties, references, value3[key]);
      continue;
    }
    delete value3[key];
  }
  return value3;
};
var FromRecord6 = function(schema, references, value3) {
  if (!IsObject(value3))
    return value3;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.keys(value3);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value3[key] = Visit9(propertySchema, references, value3[key]);
      continue;
    }
    if (IsSchema(additionalProperties) && Check(additionalProperties, references, value3[key])) {
      value3[key] = Visit9(additionalProperties, references, value3[key]);
      continue;
    }
    delete value3[key];
  }
  return value3;
};
var FromRef5 = function(schema, references, value3) {
  return Visit9(Deref(schema, references), references, value3);
};
var FromThis5 = function(schema, references, value3) {
  return Visit9(Deref(schema, references), references, value3);
};
var FromTuple8 = function(schema, references, value3) {
  if (!IsArray(value3))
    return value3;
  if (IsUndefined(schema.items))
    return [];
  const length = Math.min(value3.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value3[i] = Visit9(schema.items[i], references, value3[i]);
  }
  return value3.length > length ? value3.slice(0, length) : value3;
};
var FromUnion10 = function(schema, references, value3) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, value3)) {
      return Visit9(inner, references, value3);
    }
  }
  return value3;
};
var Visit9 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray8(schema_, references_, value3);
    case "Intersect":
      return FromIntersect8(schema_, references_, value3);
    case "Object":
      return FromObject6(schema_, references_, value3);
    case "Record":
      return FromRecord6(schema_, references_, value3);
    case "Ref":
      return FromRef5(schema_, references_, value3);
    case "This":
      return FromThis5(schema_, references_, value3);
    case "Tuple":
      return FromTuple8(schema_, references_, value3);
    case "Union":
      return FromUnion10(schema_, references_, value3);
    default:
      return value3;
  }
};
function Clean(...args) {
  return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/import/type/composite/composite.mjs
var CompositeKeys = function(T) {
  return T.reduce((Acc, L) => {
    return SetDistinct([...Acc, ...KeyOfPropertyKeys(L)]);
  }, []);
};
var FilterNever = function(T) {
  return T.filter((L) => !IsNever(L));
};
var CompositeProperty = function(T, K) {
  return T.reduce((Acc, L) => {
    return FilterNever([...Acc, ...IndexFromPropertyKeys(L, [K])]);
  }, []);
};
var CompositeProperties = function(T, K) {
  return K.reduce((Acc, L) => {
    return { ...Acc, [L]: IntersectEvaluated(CompositeProperty(T, L)) };
  }, {});
};
function Composite(T, options = {}) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}
// node_modules/@sinclair/typebox/build/import/value/convert/convert.mjs
var IsStringNumeric = function(value3) {
  return IsString(value3) && !isNaN(value3) && !isNaN(parseFloat(value3));
};
var IsValueToString = function(value3) {
  return IsBigInt(value3) || IsBoolean(value3) || IsNumber(value3);
};
var IsValueTrue = function(value3) {
  return value3 === true || IsNumber(value3) && value3 === 1 || IsBigInt(value3) && value3 === BigInt("1") || IsString(value3) && (value3.toLowerCase() === "true" || value3 === "1");
};
var IsValueFalse = function(value3) {
  return value3 === false || IsNumber(value3) && (value3 === 0 || Object.is(value3, -0)) || IsBigInt(value3) && value3 === BigInt("0") || IsString(value3) && (value3.toLowerCase() === "false" || value3 === "0" || value3 === "-0");
};
var IsTimeStringWithTimeZone = function(value3) {
  return IsString(value3) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value3);
};
var IsTimeStringWithoutTimeZone = function(value3) {
  return IsString(value3) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value3);
};
var IsDateTimeStringWithTimeZone = function(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value3);
};
var IsDateTimeStringWithoutTimeZone = function(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value3);
};
var IsDateString = function(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value3);
};
var TryConvertLiteralString = function(value3, target) {
  const conversion = TryConvertString(value3);
  return conversion === target ? conversion : value3;
};
var TryConvertLiteralNumber = function(value3, target) {
  const conversion = TryConvertNumber(value3);
  return conversion === target ? conversion : value3;
};
var TryConvertLiteralBoolean = function(value3, target) {
  const conversion = TryConvertBoolean(value3);
  return conversion === target ? conversion : value3;
};
var TryConvertLiteral = function(schema, value3) {
  return IsString(schema.const) ? TryConvertLiteralString(value3, schema.const) : IsNumber(schema.const) ? TryConvertLiteralNumber(value3, schema.const) : IsBoolean(schema.const) ? TryConvertLiteralBoolean(value3, schema.const) : Clone2(value3);
};
var TryConvertBoolean = function(value3) {
  return IsValueTrue(value3) ? true : IsValueFalse(value3) ? false : value3;
};
var TryConvertBigInt = function(value3) {
  return IsStringNumeric(value3) ? BigInt(parseInt(value3)) : IsNumber(value3) ? BigInt(value3 | 0) : IsValueFalse(value3) ? BigInt(0) : IsValueTrue(value3) ? BigInt(1) : value3;
};
var TryConvertString = function(value3) {
  return IsValueToString(value3) ? value3.toString() : IsSymbol(value3) && value3.description !== undefined ? value3.description.toString() : value3;
};
var TryConvertNumber = function(value3) {
  return IsStringNumeric(value3) ? parseFloat(value3) : IsValueTrue(value3) ? 1 : IsValueFalse(value3) ? 0 : value3;
};
var TryConvertInteger = function(value3) {
  return IsStringNumeric(value3) ? parseInt(value3) : IsNumber(value3) ? value3 | 0 : IsValueTrue(value3) ? 1 : IsValueFalse(value3) ? 0 : value3;
};
var TryConvertNull = function(value3) {
  return IsString(value3) && value3.toLowerCase() === "null" ? null : value3;
};
var TryConvertUndefined = function(value3) {
  return IsString(value3) && value3 === "undefined" ? undefined : value3;
};
var TryConvertDate = function(value3) {
  return IsDate(value3) ? value3 : IsNumber(value3) ? new Date(value3) : IsValueTrue(value3) ? new Date(1) : IsValueFalse(value3) ? new Date(0) : IsStringNumeric(value3) ? new Date(parseInt(value3)) : IsTimeStringWithoutTimeZone(value3) ? new Date(`1970-01-01T${value3}.000Z`) : IsTimeStringWithTimeZone(value3) ? new Date(`1970-01-01T${value3}`) : IsDateTimeStringWithoutTimeZone(value3) ? new Date(`${value3}.000Z`) : IsDateTimeStringWithTimeZone(value3) ? new Date(value3) : IsDateString(value3) ? new Date(`${value3}T00:00:00.000Z`) : value3;
};
var Default2 = function(value3) {
  return value3;
};
var FromArray9 = function(schema, references, value3) {
  if (IsArray(value3)) {
    return value3.map((value4) => Visit10(schema.items, references, value4));
  }
  return value3;
};
var FromBigInt5 = function(schema, references, value3) {
  return TryConvertBigInt(value3);
};
var FromBoolean5 = function(schema, references, value3) {
  return TryConvertBoolean(value3);
};
var FromDate5 = function(schema, references, value3) {
  return TryConvertDate(value3);
};
var FromInteger5 = function(schema, references, value3) {
  return TryConvertInteger(value3);
};
var FromIntersect9 = function(schema, references, value3) {
  const allObjects = schema.allOf.every((schema2) => IsObject3(schema2));
  if (allObjects)
    return Visit10(Composite(schema.allOf), references, value3);
  return Visit10(schema.allOf[0], references, value3);
};
var FromLiteral6 = function(schema, references, value3) {
  return TryConvertLiteral(schema, value3);
};
var FromNull5 = function(schema, references, value3) {
  return TryConvertNull(value3);
};
var FromNumber5 = function(schema, references, value3) {
  return TryConvertNumber(value3);
};
var FromObject7 = function(schema, references, value3) {
  const isConvertable = IsObject(value3);
  if (!isConvertable)
    return value3;
  return Object.getOwnPropertyNames(schema.properties).reduce((value4, key) => {
    return !IsUndefined(value4[key]) ? { ...value4, [key]: Visit10(schema.properties[key], references, value4[key]) } : { ...value4 };
  }, value3);
};
var FromRecord7 = function(schema, references, value3) {
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value3)) {
    result[propKey] = Visit10(property, references, propValue);
  }
  return result;
};
var FromRef6 = function(schema, references, value3) {
  return Visit10(Deref(schema, references), references, value3);
};
var FromString5 = function(schema, references, value3) {
  return TryConvertString(value3);
};
var FromSymbol5 = function(schema, references, value3) {
  return IsString(value3) || IsNumber(value3) ? Symbol(value3) : value3;
};
var FromThis6 = function(schema, references, value3) {
  return Visit10(Deref(schema, references), references, value3);
};
var FromTuple9 = function(schema, references, value3) {
  const isConvertable = IsArray(value3) && !IsUndefined(schema.items);
  if (!isConvertable)
    return value3;
  return value3.map((value4, index) => {
    return index < schema.items.length ? Visit10(schema.items[index], references, value4) : value4;
  });
};
var FromUndefined5 = function(schema, references, value3) {
  return TryConvertUndefined(value3);
};
var FromUnion11 = function(schema, references, value3) {
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, value3);
    if (Check(subschema, references, converted)) {
      return converted;
    }
  }
  return value3;
};
var Visit10 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, value3);
    case "BigInt":
      return FromBigInt5(schema_, references_, value3);
    case "Boolean":
      return FromBoolean5(schema_, references_, value3);
    case "Date":
      return FromDate5(schema_, references_, value3);
    case "Integer":
      return FromInteger5(schema_, references_, value3);
    case "Intersect":
      return FromIntersect9(schema_, references_, value3);
    case "Literal":
      return FromLiteral6(schema_, references_, value3);
    case "Null":
      return FromNull5(schema_, references_, value3);
    case "Number":
      return FromNumber5(schema_, references_, value3);
    case "Object":
      return FromObject7(schema_, references_, value3);
    case "Record":
      return FromRecord7(schema_, references_, value3);
    case "Ref":
      return FromRef6(schema_, references_, value3);
    case "String":
      return FromString5(schema_, references_, value3);
    case "Symbol":
      return FromSymbol5(schema_, references_, value3);
    case "This":
      return FromThis6(schema_, references_, value3);
    case "Tuple":
      return FromTuple9(schema_, references_, value3);
    case "Undefined":
      return FromUndefined5(schema_, references_, value3);
    case "Union":
      return FromUnion11(schema_, references_, value3);
    default:
      return Default2(value3);
  }
};
function Convert(...args) {
  return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/import/value/default/default.mjs
var ValueOrDefault = function(schema, value3) {
  return value3 === undefined && "default" in schema ? Clone2(schema.default) : value3;
};
var IsCheckable2 = function(schema) {
  return IsSchema(schema) && schema[Kind] !== "Unsafe";
};
var IsDefaultSchema = function(value3) {
  return IsSchema(value3) && "default" in value3;
};
var FromArray10 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsArray(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit11(schema.items, references, defaulted[i]);
  }
  return defaulted;
};
var FromIntersect10 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit11(schema2, references, defaulted);
    return IsObject(next) ? { ...acc, ...next } : next;
  }, {});
};
var FromObject8 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    if (!IsDefaultSchema(schema.properties[key]))
      continue;
    defaulted[key] = Visit11(schema.properties[key], references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
};
var FromRecord8 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && IsDefaultSchema(propertySchema)))
      continue;
    defaulted[key] = Visit11(propertySchema, references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
};
var FromRef7 = function(schema, references, value3) {
  return Visit11(Deref(schema, references), references, ValueOrDefault(schema, value3));
};
var FromThis7 = function(schema, references, value3) {
  return Visit11(Deref(schema, references), references, value3);
};
var FromTuple10 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsArray(defaulted) || IsUndefined(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit11(items[i], references, defaulted[i]);
  }
  return defaulted;
};
var FromUnion12 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  for (const inner of schema.anyOf) {
    const result = Visit11(inner, references, defaulted);
    if (IsCheckable2(inner) && Check(inner, result)) {
      return result;
    }
  }
  return defaulted;
};
var Visit11 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray10(schema_, references_, value3);
    case "Intersect":
      return FromIntersect10(schema_, references_, value3);
    case "Object":
      return FromObject8(schema_, references_, value3);
    case "Record":
      return FromRecord8(schema_, references_, value3);
    case "Ref":
      return FromRef7(schema_, references_, value3);
    case "This":
      return FromThis7(schema_, references_, value3);
    case "Tuple":
      return FromTuple10(schema_, references_, value3);
    case "Union":
      return FromUnion12(schema_, references_, value3);
    default:
      return ValueOrDefault(schema_, value3);
  }
};
function Default3(...args) {
  return args.length === 3 ? Visit11(args[0], args[1], args[2]) : Visit11(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/import/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => {
    {
      return ValuePointerRootSetError;
    }
  },
  ValuePointerRootDeleteError: () => {
    {
      return ValuePointerRootDeleteError;
    }
  },
  Set: () => {
    {
      return Set4;
    }
  },
  Has: () => {
    {
      return Has3;
    }
  },
  Get: () => {
    {
      return Get3;
    }
  },
  Format: () => {
    {
      return Format;
    }
  },
  Delete: () => {
    {
      return Delete3;
    }
  }
});
var Escape2 = function(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
};
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value3, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value3, pointer, update);
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value3, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value3, pointer);
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value3, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value3, pointer) {
  if (pointer === "")
    return value3;
  let current = value3;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}

class ValuePointerRootSetError extends TypeBoxError {
  value;
  path;
  update;
  constructor(value3, path, update) {
    super("Cannot set root value");
    this.value = value3;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  value;
  path;
  constructor(value3, path) {
    super("Cannot delete root value");
    this.value = value3;
    this.path = path;
  }
}
// node_modules/@sinclair/typebox/build/import/value/delta/delta.mjs
var CreateUpdate = function(path, value3) {
  return { type: "update", path, value: value3 };
};
var CreateInsert = function(path, value3) {
  return { type: "insert", path, value: value3 };
};
var CreateDelete = function(path) {
  return { type: "delete", path };
};
function* ObjectType4(path, current, next) {
  if (!IsPlainObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
  const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
  for (const key of currentKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && nextKeys.includes(key))
      yield CreateUpdate(`${path}/${globalThis.String(key)}`, undefined);
  }
  for (const key of nextKeys) {
    if (IsUndefined(current[key]) || IsUndefined(next[key]))
      continue;
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    yield* Visit12(`${path}/${globalThis.String(key)}`, current[key], next[key]);
  }
  for (const key of nextKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(current[key]))
      yield CreateInsert(`${path}/${globalThis.String(key)}`, next[key]);
  }
  for (const key of currentKeys.reverse()) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && !nextKeys.includes(key))
      yield CreateDelete(`${path}/${globalThis.String(key)}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray(next))
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit12(path, current, next) {
  if (IsPlainObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDeltaError(current, "Unable to create diff edits for unknown value");
}
function Diff(current, next) {
  return [...Visit12("", current, next)];
}
var IsRootUpdate = function(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
};
var IsIdentity = function(edits) {
  return edits.length === 0;
};
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone8 = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone8, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone8, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone8, edit.path);
        break;
      }
    }
  }
  return clone8;
}
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDeltaError extends TypeBoxError {
  value;
  constructor(value3, message) {
    super(message);
    this.value = value3;
  }
}

class ValueDeltaSymbolError extends ValueDeltaError {
  value;
  constructor(value3) {
    super(value3, "Cannot diff objects with symbol keys");
    this.value = value3;
  }
}
// node_modules/@sinclair/typebox/build/import/value/equal/equal.mjs
var ObjectType5 = function(left, right) {
  if (!IsPlainObject(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
};
var DateType4 = function(left, right) {
  return IsDate(right) && left.getTime() === right.getTime();
};
var ArrayType5 = function(left, right) {
  if (!IsArray(right) || left.length !== right.length)
    return false;
  return left.every((value3, index) => Equal(value3, right[index]));
};
var TypedArrayType3 = function(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value3, index) => Equal(value3, right[index]));
};
var ValueType3 = function(left, right) {
  return left === right;
};
function Equal(left, right) {
  if (IsPlainObject(left))
    return ObjectType5(left, right);
  if (IsDate(left))
    return DateType4(left, right);
  if (IsTypedArray(left))
    return TypedArrayType3(left, right);
  if (IsArray(left))
    return ArrayType5(left, right);
  if (IsValueType(left))
    return ValueType3(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}
// node_modules/@sinclair/typebox/build/import/value/mutate/mutate.mjs
var ObjectType6 = function(root, path, current, next) {
  if (!IsPlainObject(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.keys(current);
    const nextKeys = Object.keys(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit13(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
};
var ArrayType6 = function(root, path, current, next) {
  if (!IsArray(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit13(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
};
var TypedArrayType4 = function(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next));
  }
};
var ValueType4 = function(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path, next);
};
var Visit13 = function(root, path, current, next) {
  if (IsArray(next))
    return ArrayType6(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType4(root, path, current, next);
  if (IsPlainObject(next))
    return ObjectType6(root, path, current, next);
  if (IsValueType(next))
    return ValueType4(root, path, current, next);
};
var IsNonMutableValue = function(value3) {
  return IsTypedArray(value3) || IsValueType(value3);
};
var IsMismatchedValue = function(current, next) {
  return IsPlainObject(current) && IsArray(next) || IsArray(current) && IsPlainObject(next);
};
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit13(current, "", current, next);
}

class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/import/value/transform/decode.mjs
var Default4 = function(schema, value3) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Decode(value3) : value3;
  } catch (error19) {
    throw new TransformDecodeError(schema, value3, error19);
  }
};
var FromArray11 = function(schema, references, value3) {
  return IsArray(value3) ? Default4(schema, value3.map((value4) => Visit14(schema.items, references, value4))) : Default4(schema, value3);
};
var FromIntersect11 = function(schema, references, value3) {
  if (!IsPlainObject(value3) || IsValueType(value3))
    return Default4(schema, value3);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in value4 ? { ...value4, [key]: Visit14(Index(schema, [key]), references, value4[key]) } : value4;
  }, value3);
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default4(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default4(unevaluatedProperties, value4[key]) } : value4;
  }, knownProperties);
  return Default4(schema, unknownProperties);
};
var FromNot5 = function(schema, references, value3) {
  return Default4(schema, Visit14(schema.not, references, value3));
};
var FromObject9 = function(schema, references, value3) {
  if (!IsPlainObject(value3))
    return Default4(schema, value3);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in value4 ? { ...value4, [key]: Visit14(schema.properties[key], references, value4[key]) } : value4;
  }, value3);
  if (!IsSchema(schema.additionalProperties)) {
    return Default4(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default4(additionalProperties, value4[key]) } : value4;
  }, knownProperties);
  return Default4(schema, unknownProperties);
};
var FromRecord9 = function(schema, references, value3) {
  if (!IsPlainObject(value3))
    return Default4(schema, value3);
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern3);
  const knownProperties = Object.getOwnPropertyNames(value3).reduce((value4, key) => {
    return knownKeys.test(key) ? { ...value4, [key]: Visit14(schema.patternProperties[pattern3], references, value4[key]) } : value4;
  }, value3);
  if (!IsSchema(schema.additionalProperties)) {
    return Default4(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = unknownKeys.reduce((value4, key) => {
    return !knownKeys.test(key) ? { ...value4, [key]: Default4(additionalProperties, value4[key]) } : value4;
  }, knownProperties);
  return Default4(schema, unknownProperties);
};
var FromRef8 = function(schema, references, value3) {
  const target = Deref(schema, references);
  return Default4(schema, Visit14(target, references, value3));
};
var FromThis8 = function(schema, references, value3) {
  const target = Deref(schema, references);
  return Default4(schema, Visit14(target, references, value3));
};
var FromTuple11 = function(schema, references, value3) {
  return IsArray(value3) && IsArray(schema.items) ? Default4(schema, schema.items.map((schema2, index) => Visit14(schema2, references, value3[index]))) : Default4(schema, value3);
};
var FromUnion13 = function(schema, references, value3) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value3))
      continue;
    const decoded = Visit14(subschema, references, value3);
    return Default4(schema, decoded);
  }
  return Default4(schema, value3);
};
var Visit14 = function(schema, references, value3) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, value3);
    case "Intersect":
      return FromIntersect11(schema_, references_, value3);
    case "Not":
      return FromNot5(schema_, references_, value3);
    case "Object":
      return FromObject9(schema_, references_, value3);
    case "Record":
      return FromRecord9(schema_, references_, value3);
    case "Ref":
      return FromRef8(schema_, references_, value3);
    case "Symbol":
      return Default4(schema_, value3);
    case "This":
      return FromThis8(schema_, references_, value3);
    case "Tuple":
      return FromTuple11(schema_, references_, value3);
    case "Union":
      return FromUnion13(schema_, references_, value3);
    default:
      return Default4(schema_, value3);
  }
};
function TransformDecode(schema, references, value3) {
  return Visit14(schema, references, value3);
}

class TransformDecodeCheckError extends TypeBoxError {
  schema;
  value;
  error;
  constructor(schema, value3, error19) {
    super(`Unable to decode due to invalid value`);
    this.schema = schema;
    this.value = value3;
    this.error = error19;
  }
}

class TransformDecodeError extends TypeBoxError {
  schema;
  value;
  constructor(schema, value3, error19) {
    super(`${error19 instanceof Error ? error19.message : "Unknown error"}`);
    this.schema = schema;
    this.value = value3;
  }
}
// node_modules/@sinclair/typebox/build/import/value/transform/encode.mjs
var Default5 = function(schema, value3) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Encode(value3) : value3;
  } catch (error20) {
    throw new TransformEncodeError(schema, value3, error20);
  }
};
var FromArray12 = function(schema, references, value3) {
  const defaulted = Default5(schema, value3);
  return IsArray(defaulted) ? defaulted.map((value4) => Visit15(schema.items, references, value4)) : defaulted;
};
var FromIntersect12 = function(schema, references, value3) {
  const defaulted = Default5(schema, value3);
  if (!IsPlainObject(value3) || IsValueType(value3))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in defaulted ? { ...value4, [key]: Visit15(Index(schema, [key]), references, value4[key]) } : value4;
  }, defaulted);
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default5(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  return unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default5(unevaluatedProperties, value4[key]) } : value4;
  }, knownProperties);
};
var FromNot6 = function(schema, references, value3) {
  return Default5(schema.not, Default5(schema, value3));
};
var FromObject10 = function(schema, references, value3) {
  const defaulted = Default5(schema, value3);
  if (!IsPlainObject(value3))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in value4 ? { ...value4, [key]: Visit15(schema.properties[key], references, value4[key]) } : value4;
  }, defaulted);
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  return unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default5(additionalProperties, value4[key]) } : value4;
  }, knownProperties);
};
var FromRecord10 = function(schema, references, value3) {
  const defaulted = Default5(schema, value3);
  if (!IsPlainObject(value3))
    return defaulted;
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern3);
  const knownProperties = Object.getOwnPropertyNames(value3).reduce((value4, key) => {
    return knownKeys.test(key) ? { ...value4, [key]: Visit15(schema.patternProperties[pattern3], references, value4[key]) } : value4;
  }, defaulted);
  if (!IsSchema(schema.additionalProperties)) {
    return Default5(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  return unknownKeys.reduce((value4, key) => {
    return !knownKeys.test(key) ? { ...value4, [key]: Default5(additionalProperties, value4[key]) } : value4;
  }, knownProperties);
};
var FromRef9 = function(schema, references, value3) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, value3);
  return Default5(schema, resolved);
};
var FromThis9 = function(schema, references, value3) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, value3);
  return Default5(schema, resolved);
};
var FromTuple12 = function(schema, references, value3) {
  const value1 = Default5(schema, value3);
  return IsArray(schema.items) ? schema.items.map((schema2, index) => Visit15(schema2, references, value1[index])) : [];
};
var FromUnion14 = function(schema, references, value3) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value3))
      continue;
    const value1 = Visit15(subschema, references, value3);
    return Default5(schema, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit15(subschema, references, value3);
    if (!Check(schema, references, value1))
      continue;
    return Default5(schema, value1);
  }
  return Default5(schema, value3);
};
var Visit15 = function(schema, references, value3) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, value3);
    case "Intersect":
      return FromIntersect12(schema_, references_, value3);
    case "Not":
      return FromNot6(schema_, references_, value3);
    case "Object":
      return FromObject10(schema_, references_, value3);
    case "Record":
      return FromRecord10(schema_, references_, value3);
    case "Ref":
      return FromRef9(schema_, references_, value3);
    case "This":
      return FromThis9(schema_, references_, value3);
    case "Tuple":
      return FromTuple12(schema_, references_, value3);
    case "Union":
      return FromUnion14(schema_, references_, value3);
    default:
      return Default5(schema_, value3);
  }
};
function TransformEncode(schema, references, value3) {
  return Visit15(schema, references, value3);
}

class TransformEncodeCheckError extends TypeBoxError {
  schema;
  value;
  error;
  constructor(schema, value3, error20) {
    super(`Unable to encode due to invalid value`);
    this.schema = schema;
    this.value = value3;
    this.error = error20;
  }
}

class TransformEncodeError extends TypeBoxError {
  schema;
  value;
  constructor(schema, value3, error20) {
    super(`${error20 instanceof Error ? error20.message : "Unknown error"}`);
    this.schema = schema;
    this.value = value3;
  }
}
// node_modules/@sinclair/typebox/build/import/value/transform/has.mjs
var FromArray13 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.items, references);
};
var FromAsyncIterator5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.items, references);
};
var FromConstructor6 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
};
var FromFunction5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
};
var FromIntersect13 = function(schema, references) {
  return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit16(schema2, references));
};
var FromIterator5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.items, references);
};
var FromNot7 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.not, references);
};
var FromObject11 = function(schema, references) {
  return IsTransform(schema) || Object.values(schema.properties).some((schema2) => Visit16(schema2, references)) || IsSchema(schema.additionalProperties) && Visit16(schema.additionalProperties, references);
};
var FromPromise5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.item, references);
};
var FromRecord11 = function(schema, references) {
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern3];
  return IsTransform(schema) || Visit16(property, references) || IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties);
};
var FromRef10 = function(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit16(Deref(schema, references), references);
};
var FromThis10 = function(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit16(Deref(schema, references), references);
};
var FromTuple13 = function(schema, references) {
  return IsTransform(schema) || !IsUndefined(schema.items) && schema.items.some((schema2) => Visit16(schema2, references));
};
var FromUnion15 = function(schema, references) {
  return IsTransform(schema) || schema.anyOf.some((schema2) => Visit16(schema2, references));
};
var Visit16 = function(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator5(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Function":
      return FromFunction5(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator5(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise5(schema_, references_);
    case "Record":
      return FromRecord11(schema_, references_);
    case "Ref":
      return FromRef10(schema_, references_);
    case "This":
      return FromThis10(schema_, references_);
    case "Tuple":
      return FromTuple13(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    default:
      return IsTransform(schema);
  }
};
function HasTransform(schema, references) {
  visited.clear();
  return Visit16(schema, references);
}
var visited = new Set;
// node_modules/@sinclair/typebox/build/import/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  Patch: () => {
    {
      return Patch2;
    }
  },
  Mutate: () => {
    {
      return Mutate2;
    }
  },
  Hash: () => {
    {
      return Hash2;
    }
  },
  Errors: () => {
    {
      return Errors2;
    }
  },
  Equal: () => {
    {
      return Equal2;
    }
  },
  Encode: () => {
    {
      return Encode;
    }
  },
  Diff: () => {
    {
      return Diff2;
    }
  },
  Default: () => {
    {
      return Default6;
    }
  },
  Decode: () => {
    {
      return Decode;
    }
  },
  Create: () => {
    {
      return Create3;
    }
  },
  Convert: () => {
    {
      return Convert2;
    }
  },
  Clone: () => {
    {
      return Clone3;
    }
  },
  Clean: () => {
    {
      return Clean2;
    }
  },
  Check: () => {
    {
      return Check2;
    }
  },
  Cast: () => {
    {
      return Cast2;
    }
  }
});
function Cast2(...args) {
  return Cast.apply(Cast, args);
}
function Create3(...args) {
  return Create2.apply(Create2, args);
}
function Check2(...args) {
  return Check.apply(Check, args);
}
function Clean2(...args) {
  return Clean.apply(Clean, args);
}
function Convert2(...args) {
  return Convert.apply(Convert, args);
}
function Clone3(value3) {
  return Clone2(value3);
}
function Decode(...args) {
  const [schema, references, value3] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check2(schema, references, value3))
    throw new TransformDecodeCheckError(schema, value3, Errors2(schema, references, value3).First());
  return TransformDecode(schema, references, value3);
}
function Default6(...args) {
  return Default3.apply(Default3, args);
}
function Encode(...args) {
  const [schema, references, value3] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = TransformEncode(schema, references, value3);
  if (!Check2(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, value3, Errors2(schema, references, value3).First());
  return encoded;
}
function Errors2(...args) {
  return Errors.apply(Errors, args);
}
function Equal2(left, right) {
  return Equal(left, right);
}
function Diff2(current, next) {
  return Diff(current, next);
}
function Hash2(value3) {
  return Hash(value3);
}
function Patch2(current, edits) {
  return Patch(current, edits);
}
function Mutate2(current, next) {
  Mutate(current, next);
}
// node_modules/@sinclair/typebox/build/import/type/awaited/awaited.mjs
var FromRest4 = function(T) {
  return T.map((L) => AwaitedResolve(L));
};
var FromIntersect14 = function(T) {
  return Intersect(FromRest4(T));
};
var FromUnion16 = function(T) {
  return Union(FromRest4(T));
};
var FromPromise6 = function(T) {
  return AwaitedResolve(T);
};
var AwaitedResolve = function(T) {
  return IsIntersect(T) ? FromIntersect14(T.allOf) : IsUnion(T) ? FromUnion16(T.anyOf) : IsPromise2(T) ? FromPromise6(T.item) : T;
};
function Awaited(T, options = {}) {
  return CloneType(AwaitedResolve(T), options);
}
// node_modules/@sinclair/typebox/build/import/type/date/date.mjs
function Date2(options = {}) {
  return {
    ...options,
    [Kind]: "Date",
    type: "Date"
  };
}
// node_modules/@sinclair/typebox/build/import/type/null/null.mjs
function Null(options = {}) {
  return {
    ...options,
    [Kind]: "Null",
    type: "null"
  };
}
// node_modules/@sinclair/typebox/build/import/type/symbol/symbol.mjs
function Symbol2(options) {
  return { ...options, [Kind]: "Symbol", type: "symbol" };
}
// node_modules/@sinclair/typebox/build/import/type/undefined/undefined.mjs
function Undefined(options = {}) {
  return { ...options, [Kind]: "Undefined", type: "undefined" };
}
// node_modules/@sinclair/typebox/build/import/type/uint8array/uint8array.mjs
function Uint8Array2(options = {}) {
  return { ...options, [Kind]: "Uint8Array", type: "Uint8Array" };
}
// node_modules/@sinclair/typebox/build/import/type/const/const.mjs
var FromArray14 = function(T) {
  return T.map((L) => FromValue(L, false));
};
var FromProperties8 = function(value4) {
  return globalThis.Object.getOwnPropertyNames(value4).reduce((acc, key) => {
    return { ...acc, [key]: Readonly(FromValue(value4[key], false)) };
  }, {});
};
var ConditionalReadonly = function(T, root) {
  return root === true ? T : Readonly(T);
};
var FromValue = function(value4, root) {
  return IsAsyncIterator2(value4) ? ConditionalReadonly(Any(), root) : IsIterator2(value4) ? ConditionalReadonly(Any(), root) : IsArray2(value4) ? Readonly(Tuple(FromArray14(value4))) : IsUint8Array2(value4) ? Uint8Array2() : IsDate2(value4) ? Date2() : IsObject2(value4) ? ConditionalReadonly(Object2(FromProperties8(value4)), root) : IsFunction2(value4) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined2(value4) ? Undefined() : IsNull2(value4) ? Null() : IsSymbol2(value4) ? Symbol2() : IsBigInt2(value4) ? BigInt2() : IsNumber2(value4) ? Literal(value4) : IsBoolean2(value4) ? Literal(value4) : IsString2(value4) ? Literal(value4) : Object2({});
};
function Const(T, options = {}) {
  return exports_type2.CloneType(FromValue(T, true), options);
}
// node_modules/@sinclair/typebox/build/import/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/import/type/deref/deref.mjs
var FromRest5 = function(schema, references) {
  return schema.map((schema2) => Deref2(schema2, references));
};
var FromProperties9 = function(properties, references) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((acc, key) => {
    return { ...acc, [key]: Deref2(properties[key], references) };
  }, {});
};
var FromConstructor7 = function(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
};
var FromFunction6 = function(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
};
var FromIntersect15 = function(schema, references) {
  schema.allOf = FromRest5(schema.allOf, references);
  return schema;
};
var FromUnion17 = function(schema, references) {
  schema.anyOf = FromRest5(schema.anyOf, references);
  return schema;
};
var FromTuple14 = function(schema, references) {
  if (IsUndefined2(schema.items))
    return schema;
  schema.items = FromRest5(schema.items, references);
  return schema;
};
var FromArray15 = function(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
};
var FromObject12 = function(schema, references) {
  schema.properties = FromProperties9(schema.properties, references);
  return schema;
};
var FromPromise7 = function(schema, references) {
  schema.item = Deref2(schema.item, references);
  return schema;
};
var FromAsyncIterator6 = function(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
};
var FromIterator6 = function(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
};
var FromRef11 = function(schema, references) {
  const target = references.find((remote) => remote.$id === schema.$ref);
  if (target === undefined)
    throw Error(`Unable to dereference schema with \$id ${schema.$ref}`);
  const discard8 = Discard(target, ["$id"]);
  return Deref2(discard8, references);
};
var DerefResolve = function(schema, references) {
  return IsConstructor(schema) ? FromConstructor7(schema, references) : IsFunction3(schema) ? FromFunction6(schema, references) : IsIntersect(schema) ? FromIntersect15(schema, references) : IsUnion(schema) ? FromUnion17(schema, references) : IsTuple(schema) ? FromTuple14(schema, references) : IsArray3(schema) ? FromArray15(schema, references) : IsObject3(schema) ? FromObject12(schema, references) : IsPromise2(schema) ? FromPromise7(schema, references) : IsAsyncIterator3(schema) ? FromAsyncIterator6(schema, references) : IsIterator3(schema) ? FromIterator6(schema, references) : IsRef(schema) ? FromRef11(schema, references) : schema;
};
function Deref2(schema, references) {
  return DerefResolve(CloneType(schema), CloneRest(references));
}
// node_modules/@sinclair/typebox/build/import/type/enum/enum.mjs
function Enum(item, options = {}) {
  if (IsUndefined2(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value6) => Literal(value6));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}
// node_modules/@sinclair/typebox/build/import/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/import/type/exclude/exclude.mjs
var ExcludeRest = function(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
};
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExcludeFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/@sinclair/typebox/build/import/type/exclude/exclude-from-mapped-result.mjs
var FromProperties10 = function(P, U) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Exclude(P[K2], U) };
  }, {});
};
var FromMappedResult7 = function(R, T) {
  return FromProperties10(R.properties, T);
};
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/import/type/extract/extract.mjs
var ExtractRest = function(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
};
function Extract(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExtractFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/@sinclair/typebox/build/import/type/extract/extract-from-mapped-result.mjs
var FromProperties11 = function(P, T) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Extract(P[K2], T) };
  }, {});
};
var FromMappedResult8 = function(R, T) {
  return FromProperties11(R.properties, T);
};
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/instance-type/instance-type.mjs
function InstanceType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/import/type/integer/integer.mjs
function Integer(options = {}) {
  return {
    ...options,
    [Kind]: "Integer",
    type: "integer"
  };
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/intrinsic-from-mapped-key.mjs
var MappedIntrinsicPropertyKey = function(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, options)
  };
};
var MappedIntrinsicPropertyKeys = function(K, M, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
};
var MappedIntrinsicProperties = function(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
};
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/intrinsic/intrinsic.mjs
var ApplyUncapitalize = function(value6) {
  const [first, rest] = [value6.slice(0, 1), value6.slice(1)];
  return [first.toLowerCase(), rest].join("");
};
var ApplyCapitalize = function(value6) {
  const [first, rest] = [value6.slice(0, 1), value6.slice(1)];
  return [first.toUpperCase(), rest].join("");
};
var ApplyUppercase = function(value6) {
  return value6.toUpperCase();
};
var ApplyLowercase = function(value6) {
  return value6.toLowerCase();
};
var FromTemplateLiteral6 = function(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite3 = IsTemplateLiteralExpressionFinite(expression);
  if (!finite3)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value6) => Literal(value6));
  const mapped12 = FromRest6(literals, mode);
  const union15 = Union(mapped12);
  return TemplateLiteral([union15], options);
};
var FromLiteralValue = function(value6, mode) {
  return typeof value6 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value6) : mode === "Capitalize" ? ApplyCapitalize(value6) : mode === "Uppercase" ? ApplyUppercase(value6) : mode === "Lowercase" ? ApplyLowercase(value6) : value6 : value6.toString();
};
var FromRest6 = function(T, M) {
  return T.map((L) => Intrinsic(L, M));
};
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral6(schema, mode, schema) : IsUnion(schema) ? Union(FromRest6(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : schema;
}

// node_modules/@sinclair/typebox/build/import/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}
// node_modules/@sinclair/typebox/build/import/type/not/not.mjs
function Not2(schema, options) {
  return {
    ...options,
    [Kind]: "Not",
    not: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/import/type/omit/omit-from-mapped-result.mjs
var FromProperties12 = function(P, K, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Omit(P[K2], K, options) };
  }, {});
};
var FromMappedResult9 = function(R, K, options) {
  return FromProperties12(R.properties, K, options);
};
function OmitFromMappedResult(R, K, options) {
  const P = FromMappedResult9(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/omit/omit.mjs
var FromIntersect16 = function(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
};
var FromUnion18 = function(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
};
var FromProperty2 = function(T, K) {
  const { [K]: _, ...R } = T;
  return R;
};
var FromProperties13 = function(T, K) {
  return K.reduce((T2, K2) => {
    return FromProperty2(T2, K2);
  }, T);
};
var OmitResolve = function(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect16(T.allOf, K)) : IsUnion(T) ? Union(FromUnion18(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties13(T.properties, K)) : Object2({});
};
function Omit(T, K, options = {}) {
  if (IsMappedKey(K))
    return OmitFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return OmitFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(OmitResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/import/type/omit/omit-from-mapped-key.mjs
var FromPropertyKey2 = function(T, K, options) {
  return {
    [K]: Omit(T, [K], options)
  };
};
var FromPropertyKeys2 = function(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(T, LK, options) };
  }, {});
};
var FromMappedKey3 = function(T, K, options) {
  return FromPropertyKeys2(T, K.keys, options);
};
function OmitFromMappedKey(T, K, options) {
  const P = FromMappedKey3(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/parameters/parameters.mjs
function Parameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/import/type/partial/partial.mjs
var FromRest7 = function(T) {
  return T.map((L) => PartialResolve(L));
};
var FromProperties14 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {
    return { ...Acc, [K]: Optional(T[K]) };
  }, {});
};
var PartialResolve = function(T) {
  return IsIntersect(T) ? Intersect(FromRest7(T.allOf)) : IsUnion(T) ? Union(FromRest7(T.anyOf)) : IsObject3(T) ? Object2(FromProperties14(T.properties)) : Object2({});
};
function Partial(T, options = {}) {
  if (IsMappedResult(T))
    return PartialFromMappedResult(T, options);
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PartialResolve(T), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/import/type/partial/partial-from-mapped-result.mjs
var FromProperties15 = function(K, options) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Partial(K[K2], options) };
  }, {});
};
var FromMappedResult10 = function(R, options) {
  return FromProperties15(R.properties, options);
};
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult10(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/pick/pick-from-mapped-result.mjs
var FromProperties16 = function(P, K, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Pick(P[K2], K, options) };
  }, {});
};
var FromMappedResult11 = function(R, K, options) {
  return FromProperties16(R.properties, K, options);
};
function PickFromMappedResult(R, K, options) {
  const P = FromMappedResult11(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/pick/pick.mjs
var FromIntersect17 = function(T, K) {
  return T.map((T2) => PickResolve(T2, K));
};
var FromUnion19 = function(T, K) {
  return T.map((T2) => PickResolve(T2, K));
};
var FromProperties17 = function(T, K) {
  return K.reduce((Acc, K2) => {
    return K2 in T ? { ...Acc, [K2]: T[K2] } : Acc;
  }, {});
};
var PickResolve = function(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect17(T.allOf, K)) : IsUnion(T) ? Union(FromUnion19(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties17(T.properties, K)) : Object2({});
};
function Pick(T, K, options = {}) {
  if (IsMappedKey(K))
    return PickFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return PickFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PickResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/import/type/pick/pick-from-mapped-key.mjs
var FromPropertyKey3 = function(T, K, options) {
  return {
    [K]: Pick(T, [K], options)
  };
};
var FromPropertyKeys3 = function(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey3(T, LK, options) };
  }, {});
};
var FromMappedKey4 = function(T, K, options) {
  return FromPropertyKeys3(T, K.keys, options);
};
function PickFromMappedKey(T, K, options) {
  const P = FromMappedKey4(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}
// node_modules/@sinclair/typebox/build/import/type/record/record.mjs
var RecordCreateFromPattern = function(pattern3, T, options) {
  return {
    ...options,
    [Kind]: "Record",
    type: "object",
    patternProperties: { [pattern3]: CloneType(T) }
  };
};
var RecordCreateFromKeys = function(K, T, options) {
  const P = K.reduce((Acc, K2) => ({ ...Acc, [K2]: CloneType(T) }), {});
  return Object2(P, { ...options, [Hint]: "Record" });
};
var FromTemplateLiteralKey = function(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
};
var FromUnionKey = function(K, T, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(K)), T, options);
};
var FromLiteralKey = function(K, T, options) {
  return RecordCreateFromKeys([K.toString()], T, options);
};
var FromRegExpKey = function(K, T, options) {
  return RecordCreateFromPattern(K.source, T, options);
};
var FromStringKey = function(K, T, options) {
  const pattern3 = IsUndefined2(K.pattern) ? PatternStringExact : K.pattern;
  return RecordCreateFromPattern(pattern3, T, options);
};
var FromIntegerKey = function(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
};
var FromNumberKey = function(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
};
function Record(K, T, options = {}) {
  return IsUnion(K) ? FromUnionKey(K.anyOf, T, options) : IsTemplateLiteral(K) ? FromTemplateLiteralKey(K, T, options) : IsLiteral(K) ? FromLiteralKey(K.const, T, options) : IsInteger2(K) ? FromIntegerKey(K, T, options) : IsNumber3(K) ? FromNumberKey(K, T, options) : IsRegExp2(K) ? FromRegExpKey(K, T, options) : IsString3(K) ? FromStringKey(K, T, options) : Never(options);
}
// node_modules/@sinclair/typebox/build/import/type/recursive/recursive.mjs
function Recursive(callback, options = {}) {
  if (IsUndefined2(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = callback({ [Kind]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType({ ...options, [Hint]: "Recursive", ...thisType });
}
var Ordinal = 0;
// node_modules/@sinclair/typebox/build/import/type/ref/ref.mjs
function Ref(unresolved, options = {}) {
  if (IsString2(unresolved))
    return { ...options, [Kind]: "Ref", $ref: unresolved };
  if (IsUndefined2(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind]: "Ref",
    $ref: unresolved.$id
  };
}
// node_modules/@sinclair/typebox/build/import/type/regexp/regexp.mjs
function RegExp2(unresolved, options = {}) {
  const expr = IsString2(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}
// node_modules/@sinclair/typebox/build/import/type/required/required.mjs
var FromRest8 = function(T) {
  return T.map((L) => RequiredResolve(L));
};
var FromProperties18 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {
    return { ...Acc, [K]: Discard(T[K], [OptionalKind]) };
  }, {});
};
var RequiredResolve = function(T) {
  return IsIntersect(T) ? Intersect(FromRest8(T.allOf)) : IsUnion(T) ? Union(FromRest8(T.anyOf)) : IsObject3(T) ? Object2(FromProperties18(T.properties)) : Object2({});
};
function Required(T, options = {}) {
  if (IsMappedResult(T)) {
    return RequiredFromMappedResult(T, options);
  } else {
    const D = Discard(T, [TransformKind, "$id", "required"]);
    const R = CloneType(RequiredResolve(T), options);
    return { ...D, ...R };
  }
}

// node_modules/@sinclair/typebox/build/import/type/required/required-from-mapped-result.mjs
var FromProperties19 = function(P, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Required(P[K2], options) };
  }, {});
};
var FromMappedResult12 = function(R, options) {
  return FromProperties19(R.properties, options);
};
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/rest/rest.mjs
var RestResolve = function(T) {
  return IsIntersect(T) ? [...T.allOf] : IsUnion(T) ? [...T.anyOf] : IsTuple(T) ? [...T.items ?? []] : [];
};
function Rest(T) {
  return CloneRest(RestResolve(T));
}
// node_modules/@sinclair/typebox/build/import/type/return-type/return-type.mjs
function ReturnType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/import/type/strict/strict.mjs
function Strict(schema) {
  return JSON.parse(JSON.stringify(schema));
}
// node_modules/@sinclair/typebox/build/import/type/transform/transform.mjs
function Transform(schema) {
  return new TransformDecodeBuilder(schema);
}

class TransformDecodeBuilder {
  schema;
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode2) {
    return new TransformEncodeBuilder(this.schema, decode2);
  }
}

class TransformEncodeBuilder {
  schema;
  decode;
  constructor(schema, decode2) {
    this.schema = schema;
    this.decode = decode2;
  }
  EncodeTransform(encode2, schema) {
    const Encode2 = (value10) => schema[TransformKind].Encode(encode2(value10));
    const Decode2 = (value10) => this.decode(schema[TransformKind].Decode(value10));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema, [TransformKind]: Codec };
  }
  EncodeSchema(encode2, schema) {
    const Codec = { Decode: this.decode, Encode: encode2 };
    return { ...schema, [TransformKind]: Codec };
  }
  Encode(encode2) {
    const schema = CloneType(this.schema);
    return IsTransform(schema) ? this.EncodeTransform(encode2, schema) : this.EncodeSchema(encode2, schema);
  }
}
// node_modules/@sinclair/typebox/build/import/type/void/void.mjs
function Void(options = {}) {
  return {
    ...options,
    [Kind]: "Void",
    type: "void"
  };
}
// node_modules/@sinclair/typebox/build/import/type/type/type.mjs
var exports_type4 = {};
__export(exports_type4, {
  Void: () => {
    {
      return Void;
    }
  },
  Uppercase: () => {
    {
      return Uppercase;
    }
  },
  Unsafe: () => {
    {
      return Unsafe;
    }
  },
  Unknown: () => {
    {
      return Unknown;
    }
  },
  Union: () => {
    {
      return Union;
    }
  },
  Undefined: () => {
    {
      return Undefined;
    }
  },
  Uncapitalize: () => {
    {
      return Uncapitalize;
    }
  },
  Uint8Array: () => {
    {
      return Uint8Array2;
    }
  },
  Tuple: () => {
    {
      return Tuple;
    }
  },
  Transform: () => {
    {
      return Transform;
    }
  },
  TemplateLiteral: () => {
    {
      return TemplateLiteral;
    }
  },
  Symbol: () => {
    {
      return Symbol2;
    }
  },
  String: () => {
    {
      return String2;
    }
  },
  Strict: () => {
    {
      return Strict;
    }
  },
  ReturnType: () => {
    {
      return ReturnType;
    }
  },
  Rest: () => {
    {
      return Rest;
    }
  },
  Required: () => {
    {
      return Required;
    }
  },
  RegExp: () => {
    {
      return RegExp2;
    }
  },
  Ref: () => {
    {
      return Ref;
    }
  },
  Recursive: () => {
    {
      return Recursive;
    }
  },
  Record: () => {
    {
      return Record;
    }
  },
  ReadonlyOptional: () => {
    {
      return ReadonlyOptional;
    }
  },
  Readonly: () => {
    {
      return Readonly;
    }
  },
  Promise: () => {
    {
      return Promise2;
    }
  },
  Pick: () => {
    {
      return Pick;
    }
  },
  Partial: () => {
    {
      return Partial;
    }
  },
  Parameters: () => {
    {
      return Parameters;
    }
  },
  Optional: () => {
    {
      return Optional;
    }
  },
  Omit: () => {
    {
      return Omit;
    }
  },
  Object: () => {
    {
      return Object2;
    }
  },
  Number: () => {
    {
      return Number2;
    }
  },
  Null: () => {
    {
      return Null;
    }
  },
  Not: () => {
    {
      return Not2;
    }
  },
  Never: () => {
    {
      return Never;
    }
  },
  Mapped: () => {
    {
      return Mapped;
    }
  },
  Lowercase: () => {
    {
      return Lowercase;
    }
  },
  Literal: () => {
    {
      return Literal;
    }
  },
  KeyOf: () => {
    {
      return KeyOf;
    }
  },
  Iterator: () => {
    {
      return Iterator;
    }
  },
  Intersect: () => {
    {
      return Intersect;
    }
  },
  Integer: () => {
    {
      return Integer;
    }
  },
  InstanceType: () => {
    {
      return InstanceType;
    }
  },
  Index: () => {
    {
      return Index;
    }
  },
  Function: () => {
    {
      return Function2;
    }
  },
  Extract: () => {
    {
      return Extract;
    }
  },
  Extends: () => {
    {
      return Extends;
    }
  },
  Exclude: () => {
    {
      return Exclude;
    }
  },
  Enum: () => {
    {
      return Enum;
    }
  },
  Deref: () => {
    {
      return Deref2;
    }
  },
  Date: () => {
    {
      return Date2;
    }
  },
  ConstructorParameters: () => {
    {
      return ConstructorParameters;
    }
  },
  Constructor: () => {
    {
      return Constructor;
    }
  },
  Const: () => {
    {
      return Const;
    }
  },
  Composite: () => {
    {
      return Composite;
    }
  },
  Capitalize: () => {
    {
      return Capitalize;
    }
  },
  Boolean: () => {
    {
      return Boolean2;
    }
  },
  BigInt: () => {
    {
      return BigInt2;
    }
  },
  Awaited: () => {
    {
      return Awaited;
    }
  },
  AsyncIterator: () => {
    {
      return AsyncIterator;
    }
  },
  Array: () => {
    {
      return Array2;
    }
  },
  Any: () => {
    {
      return Any;
    }
  }
});

// node_modules/@sinclair/typebox/build/import/type/type/index.mjs
var Type = exports_type4;
// node_modules/@sinclair/typebox/build/import/compiler/compiler.mjs
class TypeCheck {
  schema;
  references;
  checkFunc;
  code;
  hasTransform;
  constructor(schema, references, checkFunc, code) {
    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema, references);
  }
  Code() {
    return this.code;
  }
  Errors(value10) {
    return Errors(this.schema, this.references, value10);
  }
  Check(value10) {
    return this.checkFunc(value10);
  }
  Decode(value10) {
    if (!this.checkFunc(value10))
      throw new TransformDecodeCheckError(this.schema, value10, this.Errors(value10).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value10) : value10;
  }
  Encode(value10) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value10) : value10;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value10, this.Errors(value10).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value10) {
    if (value10.length === 0)
      return false;
    return Character.IsNumeric(value10.charCodeAt(0));
  }
  function IsAccessor(value10) {
    if (IsFirstCharacterNumeric(value10))
      return false;
    for (let i = 0;i < value10.length; i++) {
      const code = value10.charCodeAt(i);
      const check10 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check10)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object12, key) {
    return IsAccessor(key) ? `${object12}.${key}` : `${object12}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  schema;
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  schema;
  constructor(schema) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value10, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value10} ? ${expression} : true)` : `(${MemberExpression.Encode(value10, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value10) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value10} === 'object' && ${value10} !== null && !Array.isArray(${value10}))` : `(typeof ${value10} === 'object' && ${value10} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value10) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value10} === 'object' && ${value10} !== null && !Array.isArray(${value10}) && !(${value10} instanceof Date) && !(${value10} instanceof Uint8Array))` : `(typeof ${value10} === 'object' && ${value10} !== null && !(${value10} instanceof Date) && !(${value10} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value10) {
    return !TypeSystemPolicy.AllowNaN ? `(typeof ${value10} === 'number' && Number.isFinite(${value10}))` : `typeof ${value10} === 'number'`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value10) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value10} === undefined || ${value10} === null)` : `${value10} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema) {
    return schema[Kind] === "Any" || schema[Kind] === "Unknown";
  }
  function* FromAny5(schema, references, value10) {
    yield "true";
  }
  function* FromArray16(schema, references, value10) {
    yield `Array.isArray(${value10})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber(schema.maxItems))
      yield `${value10}.length <= ${schema.maxItems}`;
    if (IsNumber(schema.minItems))
      yield `${value10}.length >= ${schema.minItems}`;
    const elementExpression = CreateExpression(schema.items, references, "value");
    yield `${value10}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains)) {
      const containsSchema = IsSchema(schema.contains) ? schema.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
      const checkMaxContains = IsNumber(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check10 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check10}})(${value10})`;
    }
    if (schema.uniqueItems === true) {
      const check10 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check10} }`;
      yield `((${parameter}) => { ${block} )(${value10})`;
    }
  }
  function* FromAsyncIterator7(schema, references, value10) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value10})`;
  }
  function* FromBigInt6(schema, references, value10) {
    yield `(typeof ${value10} === 'bigint')`;
    if (IsBigInt(schema.exclusiveMaximum))
      yield `${value10} < BigInt(${schema.exclusiveMaximum})`;
    if (IsBigInt(schema.exclusiveMinimum))
      yield `${value10} > BigInt(${schema.exclusiveMinimum})`;
    if (IsBigInt(schema.maximum))
      yield `${value10} <= BigInt(${schema.maximum})`;
    if (IsBigInt(schema.minimum))
      yield `${value10} >= BigInt(${schema.minimum})`;
    if (IsBigInt(schema.multipleOf))
      yield `(${value10} % BigInt(${schema.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema, references, value10) {
    yield `(typeof ${value10} === 'boolean')`;
  }
  function* FromConstructor8(schema, references, value10) {
    yield* Visit17(schema.returns, references, `${value10}.prototype`);
  }
  function* FromDate6(schema, references, value10) {
    yield `(${value10} instanceof Date) && Number.isFinite(${value10}.getTime())`;
    if (IsNumber(schema.exclusiveMaximumTimestamp))
      yield `${value10}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
    if (IsNumber(schema.exclusiveMinimumTimestamp))
      yield `${value10}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
    if (IsNumber(schema.maximumTimestamp))
      yield `${value10}.getTime() <= ${schema.maximumTimestamp}`;
    if (IsNumber(schema.minimumTimestamp))
      yield `${value10}.getTime() >= ${schema.minimumTimestamp}`;
    if (IsNumber(schema.multipleOfTimestamp))
      yield `(${value10}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction7(schema, references, value10) {
    yield `(typeof ${value10} === 'function')`;
  }
  function* FromInteger6(schema, references, value10) {
    yield `(typeof ${value10} === 'number' && Number.isInteger(${value10}))`;
    if (IsNumber(schema.exclusiveMaximum))
      yield `${value10} < ${schema.exclusiveMaximum}`;
    if (IsNumber(schema.exclusiveMinimum))
      yield `${value10} > ${schema.exclusiveMinimum}`;
    if (IsNumber(schema.maximum))
      yield `${value10} <= ${schema.maximum}`;
    if (IsNumber(schema.minimum))
      yield `${value10} >= ${schema.minimum}`;
    if (IsNumber(schema.multipleOf))
      yield `(${value10} % ${schema.multipleOf}) === 0`;
  }
  function* FromIntersect18(schema, references, value10) {
    const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value10)).join(" && ");
    if (schema.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check22 = `Object.getOwnPropertyNames(${value10}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check22})`;
    } else if (IsSchema(schema.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check22 = `Object.getOwnPropertyNames(${value10}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value10}[key]`)})`;
      yield `(${check1} && ${check22})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator7(schema, references, value10) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value10})`;
  }
  function* FromLiteral7(schema, references, value10) {
    if (typeof schema.const === "number" || typeof schema.const === "boolean") {
      yield `(${value10} === ${schema.const})`;
    } else {
      yield `(${value10} === '${LiteralString.Escape(schema.const)}')`;
    }
  }
  function* FromNever6(schema, references, value10) {
    yield `false`;
  }
  function* FromNot8(schema, references, value10) {
    const expression = CreateExpression(schema.not, references, value10);
    yield `(!${expression})`;
  }
  function* FromNull6(schema, references, value10) {
    yield `(${value10} === null)`;
  }
  function* FromNumber6(schema, references, value10) {
    yield Policy.IsNumberLike(value10);
    if (IsNumber(schema.exclusiveMaximum))
      yield `${value10} < ${schema.exclusiveMaximum}`;
    if (IsNumber(schema.exclusiveMinimum))
      yield `${value10} > ${schema.exclusiveMinimum}`;
    if (IsNumber(schema.maximum))
      yield `${value10} <= ${schema.maximum}`;
    if (IsNumber(schema.minimum))
      yield `${value10} >= ${schema.minimum}`;
    if (IsNumber(schema.multipleOf))
      yield `(${value10} % ${schema.multipleOf}) === 0`;
  }
  function* FromObject13(schema, references, value10) {
    yield Policy.IsObjectLike(value10);
    if (IsNumber(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value10}).length >= ${schema.minProperties}`;
    if (IsNumber(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value10}).length <= ${schema.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value10, knownKey);
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value10})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value10, knownKey, expression);
      }
    }
    if (schema.additionalProperties === false) {
      if (schema.required && schema.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value10}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value10}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema.additionalProperties === "object") {
      const expression = CreateExpression(schema.additionalProperties, references, `${value10}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value10}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema, references, value10) {
    yield `(typeof value === 'object' && typeof ${value10}.then === 'function')`;
  }
  function* FromRecord12(schema, references, value10) {
    yield Policy.IsRecordLike(value10);
    if (IsNumber(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value10}).length >= ${schema.minProperties}`;
    if (IsNumber(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value10}).length <= ${schema.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check22 = IsSchema(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value10) : schema.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check22})`;
    yield `(Object.entries(${value10}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef12(schema, references, value10) {
    const target = Deref(schema, references);
    if (state.functions.has(schema.$ref))
      return yield `${CreateFunctionName(schema.$ref)}(${value10})`;
    yield* Visit17(target, references, value10);
  }
  function* FromRegExp5(schema, references, value10) {
    const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
    yield `(typeof ${value10} === 'string')`;
    if (IsNumber(schema.maxLength))
      yield `${value10}.length <= ${schema.maxLength}`;
    if (IsNumber(schema.minLength))
      yield `${value10}.length >= ${schema.minLength}`;
    yield `${variable}.test(${value10})`;
  }
  function* FromString6(schema, references, value10) {
    yield `(typeof ${value10} === 'string')`;
    if (IsNumber(schema.maxLength))
      yield `${value10}.length <= ${schema.maxLength}`;
    if (IsNumber(schema.minLength))
      yield `${value10}.length >= ${schema.minLength}`;
    if (schema.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value10})`;
    }
    if (schema.format !== undefined) {
      yield `format('${schema.format}', ${value10})`;
    }
  }
  function* FromSymbol6(schema, references, value10) {
    yield `(typeof ${value10} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema, references, value10) {
    yield `(typeof ${value10} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
    yield `${variable}.test(${value10})`;
  }
  function* FromThis11(schema, references, value10) {
    yield `${CreateFunctionName(schema.$ref)}(${value10})`;
  }
  function* FromTuple15(schema, references, value10) {
    yield `Array.isArray(${value10})`;
    if (schema.items === undefined)
      return yield `${value10}.length === 0`;
    yield `(${value10}.length === ${schema.maxItems})`;
    for (let i = 0;i < schema.items.length; i++) {
      const expression = CreateExpression(schema.items[i], references, `${value10}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema, references, value10) {
    yield `${value10} === undefined`;
  }
  function* FromUnion20(schema, references, value10) {
    const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value10));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema, references, value10) {
    yield `${value10} instanceof Uint8Array`;
    if (IsNumber(schema.maxByteLength))
      yield `(${value10}.length <= ${schema.maxByteLength})`;
    if (IsNumber(schema.minByteLength))
      yield `(${value10}.length >= ${schema.minByteLength})`;
  }
  function* FromUnknown5(schema, references, value10) {
    yield "true";
  }
  function* FromVoid5(schema, references, value10) {
    yield Policy.IsVoidLike(value10);
  }
  function* FromKind4(schema, references, value10) {
    const instance = state.instances.size;
    state.instances.set(instance, schema);
    yield `kind('${schema[Kind]}', ${instance}, ${value10})`;
  }
  function* Visit17(schema, references, value10, useHoisting = true) {
    const references_ = IsString(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (useHoisting && IsString(schema.$id)) {
      const functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value10})`;
      } else {
        const functionCode = CreateFunction(functionName, schema, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value10})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value10);
      case "Array":
        return yield* FromArray16(schema_, references_, value10);
      case "AsyncIterator":
        return yield* FromAsyncIterator7(schema_, references_, value10);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value10);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value10);
      case "Constructor":
        return yield* FromConstructor8(schema_, references_, value10);
      case "Date":
        return yield* FromDate6(schema_, references_, value10);
      case "Function":
        return yield* FromFunction7(schema_, references_, value10);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value10);
      case "Intersect":
        return yield* FromIntersect18(schema_, references_, value10);
      case "Iterator":
        return yield* FromIterator7(schema_, references_, value10);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value10);
      case "Never":
        return yield* FromNever6(schema_, references_, value10);
      case "Not":
        return yield* FromNot8(schema_, references_, value10);
      case "Null":
        return yield* FromNull6(schema_, references_, value10);
      case "Number":
        return yield* FromNumber6(schema_, references_, value10);
      case "Object":
        return yield* FromObject13(schema_, references_, value10);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value10);
      case "Record":
        return yield* FromRecord12(schema_, references_, value10);
      case "Ref":
        return yield* FromRef12(schema_, references_, value10);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value10);
      case "String":
        return yield* FromString6(schema_, references_, value10);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value10);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value10);
      case "This":
        return yield* FromThis11(schema_, references_, value10);
      case "Tuple":
        return yield* FromTuple15(schema_, references_, value10);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value10);
      case "Union":
        return yield* FromUnion20(schema_, references_, value10);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value10);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value10);
      case "Void":
        return yield* FromVoid5(schema_, references_, value10);
      default:
        if (!exports_type.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema);
        return yield* FromKind4(schema_, references_, value10);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema, references, value10, useHoisting = true) {
    return `(${[...Visit17(schema, references, value10, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema, references, value10, useHoisting = true) {
    const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema, references, value10, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\n}`;
  }
  function CreateParameter(name, type73) {
    const annotation = state.language === "typescript" ? `: ${type73}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type73) {
    return state.language === "typescript" ? `: ${type73}` : "";
  }
  function Build(schema, references, options) {
    const functionCode = CreateFunction("check", schema, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString(schema.$id) ? `return function check(${parameter})${returns} {\n  return ${CreateFunctionName(schema.$id)}(value)\n}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema, references, options] = args.length === 2 && IsArray(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema(schema))
      throw new TypeCompilerTypeGuardError(schema);
    for (const schema2 of references)
      if (!IsSchema(schema2))
        throw new TypeCompilerTypeGuardError(schema2);
    return Build(schema, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema, references = []) {
    const generatedCode = Code(schema, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value10) {
      if (!exports_type.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type.Get(kind);
      const schema2 = instances.get(instance);
      return checkFunc(schema2, value10);
    }
    function formatRegistryFunction(format, value10) {
      if (!exports_format.Has(format))
        return false;
      const checkFunc = exports_format.Get(format);
      return checkFunc(value10);
    }
    function hashFunction(value10) {
      return Hash(value10);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));
// node_modules/elysia/dist/bun/index.js
var X$ = Object.create;
var { defineProperty: z1, getPrototypeOf: W$, getOwnPropertyNames: J$ } = Object;
var Y$ = Object.prototype.hasOwnProperty;
var T0 = ($, Z, X) => {
  X = $ != null ? X$(W$($)) : {};
  const W = Z || !$ || !$.__esModule ? z1(X, "default", { value: $, enumerable: true }) : X;
  for (let J of J$($))
    if (!Y$.call(W, J))
      z1(W, J, { get: () => $[J], enumerable: true });
  return W;
};
var J0 = ($, Z) => () => (Z || $((Z = { exports: {} }).exports, Z), Z.exports);
var I1 = J0((m$, i0) => {
  var z0 = function() {
  }, B$ = function($, Z, X) {
    this.fn = $, this.context = Z, this.once = X || false;
  }, O1 = function($, Z, X, W, J) {
    if (typeof X !== "function")
      throw new TypeError("The listener must be a function");
    var Q = new B$(X, W || $, J), Y = f ? f + Z : Z;
    if (!$._events[Y])
      $._events[Y] = Q, $._eventsCount++;
    else if (!$._events[Y].fn)
      $._events[Y].push(Q);
    else
      $._events[Y] = [$._events[Y], Q];
    return $;
  }, E0 = function($, Z) {
    if (--$._eventsCount === 0)
      $._events = new z0;
    else
      delete $._events[Z];
  }, g = function() {
    this._events = new z0, this._eventsCount = 0;
  }, Q$ = Object.prototype.hasOwnProperty, f = "~";
  if (Object.create) {
    if (z0.prototype = Object.create(null), !new z0().__proto__)
      f = false;
  }
  g.prototype.eventNames = function $() {
    var Z = [], X, W;
    if (this._eventsCount === 0)
      return Z;
    for (W in X = this._events)
      if (Q$.call(X, W))
        Z.push(f ? W.slice(1) : W);
    if (Object.getOwnPropertySymbols)
      return Z.concat(Object.getOwnPropertySymbols(X));
    return Z;
  };
  g.prototype.listeners = function $(Z) {
    var X = f ? f + Z : Z, W = this._events[X];
    if (!W)
      return [];
    if (W.fn)
      return [W.fn];
    for (var J = 0, Q = W.length, Y = new Array(Q);J < Q; J++)
      Y[J] = W[J].fn;
    return Y;
  };
  g.prototype.listenerCount = function $(Z) {
    var X = f ? f + Z : Z, W = this._events[X];
    if (!W)
      return 0;
    if (W.fn)
      return 1;
    return W.length;
  };
  g.prototype.emit = function $(Z, X, W, J, Q, Y) {
    var _ = f ? f + Z : Z;
    if (!this._events[_])
      return false;
    var B = this._events[_], K = arguments.length, G, U;
    if (B.fn) {
      if (B.once)
        this.removeListener(Z, B.fn, undefined, true);
      switch (K) {
        case 1:
          return B.fn.call(B.context), true;
        case 2:
          return B.fn.call(B.context, X), true;
        case 3:
          return B.fn.call(B.context, X, W), true;
        case 4:
          return B.fn.call(B.context, X, W, J), true;
        case 5:
          return B.fn.call(B.context, X, W, J, Q), true;
        case 6:
          return B.fn.call(B.context, X, W, J, Q, Y), true;
      }
      for (U = 1, G = new Array(K - 1);U < K; U++)
        G[U - 1] = arguments[U];
      B.fn.apply(B.context, G);
    } else {
      var w = B.length, A;
      for (U = 0;U < w; U++) {
        if (B[U].once)
          this.removeListener(Z, B[U].fn, undefined, true);
        switch (K) {
          case 1:
            B[U].fn.call(B[U].context);
            break;
          case 2:
            B[U].fn.call(B[U].context, X);
            break;
          case 3:
            B[U].fn.call(B[U].context, X, W);
            break;
          case 4:
            B[U].fn.call(B[U].context, X, W, J);
            break;
          default:
            if (!G)
              for (A = 1, G = new Array(K - 1);A < K; A++)
                G[A - 1] = arguments[A];
            B[U].fn.apply(B[U].context, G);
        }
      }
    }
    return true;
  };
  g.prototype.on = function $(Z, X, W) {
    return O1(this, Z, X, W, false);
  };
  g.prototype.once = function $(Z, X, W) {
    return O1(this, Z, X, W, true);
  };
  g.prototype.removeListener = function $(Z, X, W, J) {
    var Q = f ? f + Z : Z;
    if (!this._events[Q])
      return this;
    if (!X)
      return E0(this, Q), this;
    var Y = this._events[Q];
    if (Y.fn) {
      if (Y.fn === X && (!J || Y.once) && (!W || Y.context === W))
        E0(this, Q);
    } else {
      for (var _ = 0, B = [], K = Y.length;_ < K; _++)
        if (Y[_].fn !== X || J && !Y[_].once || W && Y[_].context !== W)
          B.push(Y[_]);
      if (B.length)
        this._events[Q] = B.length === 1 ? B[0] : B;
      else
        E0(this, Q);
    }
    return this;
  };
  g.prototype.removeAllListeners = function $(Z) {
    var X;
    if (Z) {
      if (X = f ? f + Z : Z, this._events[X])
        E0(this, X);
    } else
      this._events = new z0, this._eventsCount = 0;
    return this;
  };
  g.prototype.off = g.prototype.removeListener;
  g.prototype.addListener = g.prototype.on;
  g.prefixed = f;
  g.EventEmitter = g;
  if (typeof i0 !== "undefined")
    i0.exports = g;
});
var X1 = J0((D6, H1) => {
  var P$ = function($) {
    var Z = $.indexOf("%");
    if (Z === -1)
      return $;
    var X = $.length, W = "", J = 0, Q = 0, Y = Z, _ = T1;
    while (Z > -1 && Z < X) {
      var B = E1($[Z + 1], 4), K = E1($[Z + 2], 0), G = B | K, U = Z1[G];
      if (_ = Z1[256 + _ + U], Q = Q << 6 | G & Z1[364 + U], _ === T1)
        W += $.slice(J, Y), W += Q <= 65535 ? String.fromCharCode(Q) : String.fromCharCode(55232 + (Q >> 10), 56320 + (Q & 1023)), Q = 0, J = Z + 3, Z = Y = $.indexOf("%", J);
      else if (_ === A$)
        return null;
      else {
        if (Z += 3, Z < X && $.charCodeAt(Z) === 37)
          continue;
        return null;
      }
    }
    return W + $.slice(J);
  }, E1 = function($, Z) {
    var X = w$[$];
    return X === undefined ? 255 : X << Z;
  }, T1 = 12, A$ = 0, Z1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7], w$ = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  H1.exports = P$;
});
var f1 = J0((G6, g1) => {
  var V$ = function($) {
    const Z = new x1;
    if (typeof $ !== "string")
      return Z;
    let X = $.length, W = "", J = "", Q = -1, Y = -1, _ = false, B = false, K = false, G = false, U = false, w = 0;
    for (let A = 0;A < X + 1; A++)
      if (w = A !== X ? $.charCodeAt(A) : 38, w === 38) {
        if (U = Y > Q, !U)
          Y = A;
        if (W = $.slice(Q + 1, Y), U || W.length > 0) {
          if (K)
            W = W.replace(L1, " ");
          if (_)
            W = b1(W) || W;
          if (U) {
            if (J = $.slice(Y + 1, A), G)
              J = J.replace(L1, " ");
            if (B)
              J = b1(J) || J;
          }
          const z = Z[W];
          if (z === undefined)
            Z[W] = J;
          else if (z.pop)
            z.push(J);
          else
            Z[W] = [z, J];
        }
        J = "", Q = A, Y = A, _ = false, B = false, K = false, G = false;
      } else if (w === 61)
        if (Y <= Q)
          Y = A;
        else
          B = true;
      else if (w === 43)
        if (Y > Q)
          G = true;
        else
          K = true;
      else if (w === 37)
        if (Y > Q)
          B = true;
        else
          _ = true;
    return Z;
  }, b1 = X1(), L1 = /\+/g, x1 = function() {
  };
  x1.prototype = Object.create(null);
  g1.exports = V$;
});
var v1 = J0((K6, y1) => {
  var C$ = function($) {
    const Z = $.length;
    if (Z === 0)
      return "";
    let X = "", W = 0, J = 0;
    $:
      for (;J < Z; J++) {
        let Q = $.charCodeAt(J);
        while (Q < 128) {
          if (R$[Q] !== 1) {
            if (W < J)
              X += $.slice(W, J);
            W = J + 1, X += i[Q];
          }
          if (++J === Z)
            break $;
          Q = $.charCodeAt(J);
        }
        if (W < J)
          X += $.slice(W, J);
        if (Q < 2048) {
          W = J + 1, X += i[192 | Q >> 6] + i[128 | Q & 63];
          continue;
        }
        if (Q < 55296 || Q >= 57344) {
          W = J + 1, X += i[224 | Q >> 12] + i[128 | Q >> 6 & 63] + i[128 | Q & 63];
          continue;
        }
        if (++J, J >= Z)
          throw new Error("URI malformed");
        const Y = $.charCodeAt(J) & 1023;
        W = J + 1, Q = 65536 + ((Q & 1023) << 10 | Y), X += i[240 | Q >> 18] + i[128 | Q >> 12 & 63] + i[128 | Q >> 6 & 63] + i[128 | Q & 63];
      }
    if (W === 0)
      return $;
    if (W < Z)
      return X + $.slice(W);
    return X;
  }, i = Array.from({ length: 256 }, ($, Z) => "%" + ((Z < 16 ? "0" : "") + Z.toString(16)).toUpperCase()), R$ = new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0]);
  y1.exports = { encodeString: C$ };
});
var u1 = J0((z6, k1) => {
  var m1 = function($) {
    const Z = typeof $;
    if (Z === "string")
      return W1($);
    else if (Z === "bigint")
      return $.toString();
    else if (Z === "boolean")
      return $ ? "true" : "false";
    else if (Z === "number" && Number.isFinite($))
      return $ < 1000000000000000000000 ? "" + $ : W1("" + $);
    return "";
  }, S$ = function($) {
    let Z = "";
    if ($ === null || typeof $ !== "object")
      return Z;
    const X = "&", W = Object.keys($), J = W.length;
    let Q = 0;
    for (let Y = 0;Y < J; Y++) {
      const _ = W[Y], B = $[_], K = W1(_) + "=";
      if (Y)
        Z += X;
      if (Array.isArray(B)) {
        Q = B.length;
        for (let G = 0;G < Q; G++) {
          if (G)
            Z += X;
          Z += K, Z += m1(B[G]);
        }
      } else
        Z += K, Z += m1(B);
    }
    return Z;
  }, { encodeString: W1 } = v1();
  k1.exports = S$;
});
var J1 = J0((U6, j0) => {
  var h1 = f1(), c1 = u1(), d1 = { parse: h1, stringify: c1 };
  j0.exports = d1;
  j0.exports.default = d1;
  j0.exports.parse = h1;
  j0.exports.stringify = c1;
});
var Y0 = ($, Z) => ({ part: $, store: null, inert: Z !== undefined ? new Map(Z.map((X) => [X.part.charCodeAt(0), X])) : null, params: null, wildcardStore: null });
var U1 = ($, Z) => ({ ...$, part: Z });
var M1 = ($) => ({ paramName: $, store: null, inert: null });

class o {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
  add($, Z, X) {
    if (typeof Z !== "string")
      throw new TypeError("Route path must be a string");
    if (Z === "")
      Z = "/";
    else if (Z[0] !== "/")
      Z = `/${Z}`;
    this.history.push([$, Z, X]);
    const W = Z[Z.length - 1] === "*";
    if (W)
      Z = Z.slice(0, -1);
    const J = Z.split(o.regex.static), Q = Z.match(o.regex.params) || [];
    if (J[J.length - 1] === "")
      J.pop();
    let Y;
    if (!this.root[$])
      Y = this.root[$] = Y0("/");
    else
      Y = this.root[$];
    let _ = 0;
    for (let B = 0;B < J.length; ++B) {
      let K = J[B];
      if (B > 0) {
        const G = Q[_++].slice(1);
        if (Y.params === null)
          Y.params = M1(G);
        else if (Y.params.paramName !== G)
          throw new Error(`Cannot create route "${Z}" with parameter "${G}" ` + "because a route already exists with a different parameter name " + `("${Y.params.paramName}") in the same location`);
        const U = Y.params;
        if (U.inert === null) {
          Y = U.inert = Y0(K);
          continue;
        }
        Y = U.inert;
      }
      for (let G = 0;; ) {
        if (G === K.length) {
          if (G < Y.part.length) {
            const U = U1(Y, Y.part.slice(G));
            Object.assign(Y, Y0(K, [U]));
          }
          break;
        }
        if (G === Y.part.length) {
          if (Y.inert === null)
            Y.inert = new Map;
          else if (Y.inert.has(K.charCodeAt(G))) {
            Y = Y.inert.get(K.charCodeAt(G)), K = K.slice(G), G = 0;
            continue;
          }
          const U = Y0(K.slice(G));
          Y.inert.set(K.charCodeAt(G), U), Y = U;
          break;
        }
        if (K[G] !== Y.part[G]) {
          const U = U1(Y, Y.part.slice(G)), w = Y0(K.slice(G));
          Object.assign(Y, Y0(Y.part.slice(0, G), [U, w])), Y = w;
          break;
        }
        ++G;
      }
    }
    if (_ < Q.length) {
      const B = Q[_].slice(1);
      if (Y.params === null)
        Y.params = M1(B);
      else if (Y.params.paramName !== B)
        throw new Error(`Cannot create route "${Z}" with parameter "${B}" ` + "because a route already exists with a different parameter name " + `("${Y.params.paramName}") in the same location`);
      if (Y.params.store === null)
        Y.params.store = X;
      return Y.params.store;
    }
    if (W) {
      if (Y.wildcardStore === null)
        Y.wildcardStore = X;
      return Y.wildcardStore;
    }
    if (Y.store === null)
      Y.store = X;
    return Y.store;
  }
  find($, Z) {
    const X = this.root[$];
    if (!X)
      return null;
    return p0(Z, Z.length, X, 0);
  }
}
var p0 = ($, Z, X, W) => {
  const J = X?.part, Q = W + J.length;
  if (J.length > 1) {
    if (Q > Z)
      return null;
    if (J.length < 15) {
      for (let Y = 1, _ = W + 1;Y < J.length; ++Y, ++_)
        if (J.charCodeAt(Y) !== $.charCodeAt(_))
          return null;
    } else if ($.substring(W, Q) !== J)
      return null;
  }
  if (Q === Z) {
    if (X.store !== null)
      return { store: X.store, params: {} };
    if (X.wildcardStore !== null)
      return { store: X.wildcardStore, params: { "*": "" } };
    return null;
  }
  if (X.inert !== null) {
    const Y = X.inert.get($.charCodeAt(Q));
    if (Y !== undefined) {
      const _ = p0($, Z, Y, Q);
      if (_ !== null)
        return _;
    }
  }
  if (X.params !== null) {
    const Y = X.params, _ = $.indexOf("/", Q);
    if (_ !== Q) {
      if (_ === -1 || _ >= Z) {
        if (Y.store !== null) {
          const B = {};
          return B[Y.paramName] = $.substring(Q, Z), { store: Y.store, params: B };
        }
      } else if (Y.inert !== null) {
        const B = p0($, Z, Y.inert, _);
        if (B !== null)
          return B.params[Y.paramName] = $.substring(Q, _), B;
      }
    }
  }
  if (X.wildcardStore !== null)
    return { store: X.wildcardStore, params: { "*": $.substring(Q, Z) } };
  return null;
};
var N1 = T0(I1(), 1);
var F1 = N1.default;
var H0 = () => {
  let $;
  return [new Promise((X) => {
    $ = X;
  }), $];
};
var t = () => {
  const [$, Z] = H0(), [X, W] = H0(), J = [], Q = [];
  return { signal: $, consume: (Y) => {
    switch (Y.type) {
      case "begin":
        if (Y.unit && J.length === 0)
          for (let _ = 0;_ < Y.unit; _++) {
            const [B, K] = H0(), [G, U] = H0();
            J.push(B), Q.push([(w) => {
              K({ children: [], end: G, name: w.name ?? "", skip: false, time: w.time });
            }, (w) => {
              U(w);
            }]);
          }
        Z({ children: J, end: X, name: Y.name ?? "", skip: false, time: Y.time });
        break;
      case "end":
        W(Y.time);
        break;
    }
  }, consumeChild(Y) {
    switch (Y.type) {
      case "begin":
        if (!Q[0])
          return;
        const [_] = Q[0];
        _({ children: [], end: X, name: Y.name ?? "", skip: false, time: Y.time });
        break;
      case "end":
        const B = Q.shift();
        if (!B)
          return;
        B[1](Y.time);
    }
  }, resolve() {
    Z({ children: [], end: new Promise((Y) => Y(0)), name: "", skip: true, time: 0 });
    for (let [Y, _] of Q)
      Y({ children: [], end: new Promise((B) => B(0)), name: "", skip: true, time: 0 }), _(0);
    W(0);
  } };
};
var j1 = ($, Z, X) => {
  return async function W(W) {
    if (W.event !== "request" || W.type !== "begin")
      return;
    const J = W.id, Q = $(), Y = t(), _ = t(), B = t(), K = t(), G = t(), U = t(), w = t(), A = t();
    Y.consume(W);
    const z = (P) => {
      if (P.id === J)
        switch (P.event) {
          case "request":
            Y.consume(P);
            break;
          case "request.unit":
            Y.consumeChild(P);
            break;
          case "parse":
            _.consume(P);
            break;
          case "parse.unit":
            _.consumeChild(P);
            break;
          case "transform":
            B.consume(P);
            break;
          case "transform.unit":
            B.consumeChild(P);
            break;
          case "beforeHandle":
            K.consume(P);
            break;
          case "beforeHandle.unit":
            K.consumeChild(P);
            break;
          case "handle":
            G.consume(P);
            break;
          case "afterHandle":
            U.consume(P);
            break;
          case "afterHandle.unit":
            U.consumeChild(P);
            break;
          case "error":
            w.consume(P);
            break;
          case "error.unit":
            w.consumeChild(P);
            break;
          case "response":
            if (P.type === "begin")
              Y.resolve(), _.resolve(), B.resolve(), K.resolve(), G.resolve(), U.resolve(), w.resolve();
            else
              Q.off("event", z);
            A.consume(P);
            break;
          case "response.unit":
            A.consumeChild(P);
            break;
          case "exit":
            Y.resolve(), _.resolve(), B.resolve(), K.resolve(), G.resolve(), U.resolve(), w.resolve();
            break;
        }
    };
    Q.on("event", z), await X({ id: J, context: W.ctx, set: W.ctx?.set, store: W.ctx?.store, time: W.time, request: Y.signal, parse: _.signal, transform: B.signal, beforeHandle: K.signal, handle: G.signal, afterHandle: U.signal, error: w.signal, response: A.signal }), Q.emit(`res${J}.${Z}`, undefined);
  };
};
var D$ = function($, Z) {
  if (typeof $ !== "string")
    throw new TypeError("argument str must be a string");
  var X = {}, W = Z || {}, J = W.decode || K$, Q = 0;
  while (Q < $.length) {
    var Y = $.indexOf("=", Q);
    if (Y === -1)
      break;
    var _ = $.indexOf(";", Q);
    if (_ === -1)
      _ = $.length;
    else if (_ < Y) {
      Q = $.lastIndexOf(";", Y - 1) + 1;
      continue;
    }
    var B = $.slice(Q, Y).trim();
    if (X[B] === undefined) {
      var K = $.slice(Y + 1, _).trim();
      if (K.charCodeAt(0) === 34)
        K = K.slice(1, -1);
      X[B] = M$(K, J);
    }
    Q = _ + 1;
  }
  return X;
};
var G$ = function($, Z, X) {
  var W = X || {}, J = W.encode || z$;
  if (typeof J !== "function")
    throw new TypeError("option encode is invalid");
  if (!b0.test($))
    throw new TypeError("argument name is invalid");
  var Q = J(Z);
  if (Q && !b0.test(Q))
    throw new TypeError("argument val is invalid");
  var Y = $ + "=" + Q;
  if (W.maxAge != null) {
    var _ = W.maxAge - 0;
    if (isNaN(_) || !isFinite(_))
      throw new TypeError("option maxAge is invalid");
    Y += "; Max-Age=" + Math.floor(_);
  }
  if (W.domain) {
    if (!b0.test(W.domain))
      throw new TypeError("option domain is invalid");
    Y += "; Domain=" + W.domain;
  }
  if (W.path) {
    if (!b0.test(W.path))
      throw new TypeError("option path is invalid");
    Y += "; Path=" + W.path;
  }
  if (W.expires) {
    var B = W.expires;
    if (!U$(B) || isNaN(B.valueOf()))
      throw new TypeError("option expires is invalid");
    Y += "; Expires=" + B.toUTCString();
  }
  if (W.httpOnly)
    Y += "; HttpOnly";
  if (W.secure)
    Y += "; Secure";
  if (W.partitioned)
    Y += "; Partitioned";
  if (W.priority) {
    var K = typeof W.priority === "string" ? W.priority.toLowerCase() : W.priority;
    switch (K) {
      case "low":
        Y += "; Priority=Low";
        break;
      case "medium":
        Y += "; Priority=Medium";
        break;
      case "high":
        Y += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (W.sameSite) {
    var G = typeof W.sameSite === "string" ? W.sameSite.toLowerCase() : W.sameSite;
    switch (G) {
      case true:
        Y += "; SameSite=Strict";
        break;
      case "lax":
        Y += "; SameSite=Lax";
        break;
      case "strict":
        Y += "; SameSite=Strict";
        break;
      case "none":
        Y += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return Y;
};
var K$ = function($) {
  return $.indexOf("%") !== -1 ? decodeURIComponent($) : $;
};
var z$ = function($) {
  return encodeURIComponent($);
};
var U$ = function($) {
  return _$.call($) === "[object Date]" || $ instanceof Date;
};
var M$ = function($, Z) {
  try {
    return Z($);
  } catch (X) {
    return $;
  }
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var L0 = D$;
var x0 = G$;
var _$ = Object.prototype.toString;
var b0 = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

class k {
  $;
  Z;
  name;
  setter;
  constructor($, Z = {}) {
    this._value = $;
    this.property = Z;
  }
  get() {
    return this._value;
  }
  get value() {
    return this._value;
  }
  set value($) {
    if (typeof $ === "object") {
      if (JSON.stringify(this.value) === JSON.stringify($))
        return;
    } else if (this.value === $)
      return;
    this._value = $, this.sync();
  }
  add($) {
    const Z = Object.assign(this.property, typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $);
    if ("value" in Z)
      this._value = Z.value, delete Z.value;
    return this.property = Z, this.sync();
  }
  set($) {
    const Z = typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $;
    if ("value" in Z)
      this._value = Z.value, delete Z.value;
    return this.property = Z, this.sync();
  }
  remove($) {
    if (this.value === undefined)
      return;
    this.set({ domain: $?.domain, expires: new Date(0), maxAge: 0, path: $?.path, sameSite: $?.sameSite, secure: $?.secure, value: "" });
  }
  get domain() {
    return this.property.domain;
  }
  set domain($) {
    if (this.property.domain === $)
      return;
    this.property.domain = $, this.sync();
  }
  get expires() {
    return this.property.expires;
  }
  set expires($) {
    if (this.property.expires?.getTime() === $?.getTime())
      return;
    this.property.expires = $, this.sync();
  }
  get httpOnly() {
    return this.property.httpOnly;
  }
  set httpOnly($) {
    if (this.property.domain === $)
      return;
    this.property.httpOnly = $, this.sync();
  }
  get maxAge() {
    return this.property.maxAge;
  }
  set maxAge($) {
    if (this.property.maxAge === $)
      return;
    this.property.maxAge = $, this.sync();
  }
  get path() {
    return this.property.path;
  }
  set path($) {
    if (this.property.path === $)
      return;
    this.property.path = $, this.sync();
  }
  get priority() {
    return this.property.priority;
  }
  set priority($) {
    if (this.property.priority === $)
      return;
    this.property.priority = $, this.sync();
  }
  get sameSite() {
    return this.property.sameSite;
  }
  set sameSite($) {
    if (this.property.sameSite === $)
      return;
    this.property.sameSite = $, this.sync();
  }
  get secure() {
    return this.property.secure;
  }
  set secure($) {
    if (this.property.secure === $)
      return;
    this.property.secure = $, this.sync();
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
  sync() {
    if (!this.name || !this.setter)
      return this;
    if (!this.setter.cookie)
      this.setter.cookie = { [this.name]: Object.assign(this.property, { value: this.toString() }) };
    else
      this.setter.cookie[this.name] = Object.assign(this.property, { value: this.toString() });
    return this;
  }
}
var A1 = ($, Z, X) => new Proxy($, { get(W, J) {
  if (J in W)
    return W[J];
  const Q = new k(undefined, X ? { ...X } : undefined);
  return Q.setter = Z, Q.name = J, Q;
}, set(W, J, Q) {
  if (!(Q instanceof k))
    return false;
  if (!Z.cookie)
    Z.cookie = {};
  return Q.setter = Z, Q.name = J, Q.sync(), W[J] = Q, true;
} });
var g0 = async ($, Z, { secret: X, sign: W, ...J } = {}) => {
  if (!Z)
    return A1({}, $, J);
  const Q = {}, Y = typeof X === "string";
  if (W && W !== true && !Array.isArray(W))
    W = [W];
  const _ = Object.keys(L0(Z));
  for (let B = 0;B < _.length; B++) {
    const K = _[B];
    let G = L0(Z)[K];
    if (W === true || W?.includes(K)) {
      if (!X)
        throw new Error("No secret is provided to cookie plugin");
      if (Y) {
        if (G = await l0(G, X), G === false)
          throw new U0(K);
      } else {
        let A = true;
        for (let z = 0;z < X.length; z++) {
          const P = await l0(G, X[z]);
          if (P !== false) {
            G = P, A = false;
            break;
          }
        }
        if (A)
          throw new U0(K);
      }
    }
    if (G === undefined)
      continue;
    const U = G.charCodeAt(0);
    if (U === 123 || U === 91)
      try {
        const A = new k(JSON.parse(G));
        A.setter = $, A.name = K, Q[K] = A;
        continue;
      } catch {
      }
    if (f0(G))
      G = +G;
    else if (G === "true")
      G = true;
    else if (G === "false")
      G = false;
    const w = new k(G, J);
    w.setter = $, w.name = K, Q[K] = w;
  }
  return A1(Q, $);
};
var M0 = "toJSON" in new Headers;
var u = ($) => {
  for (let Z in $)
    return true;
  return false;
};
var O0 = ($, Z) => {
  const X = $.size;
  if (X && Z && Z.status !== 206 && Z.status !== 304 && Z.status !== 412 && Z.status !== 416 || !Z && X) {
    if (Z) {
      if (Z.headers instanceof Headers) {
        if (M0)
          Z.headers = Z.headers.toJSON();
        else
          for (let [W, J] of Z.headers.entries())
            if (W in Z.headers)
              Z.headers[W] = J;
      }
      return new Response($, { status: Z.status, headers: Object.assign({ "accept-ranges": "bytes", "content-range": `bytes 0-${X - 1}/${X}` }, Z.headers) });
    }
    return new Response($, { headers: { "accept-ranges": "bytes", "content-range": `bytes 0-${X - 1}/${X}` } });
  }
  return new Response($);
};
var P1 = ($, Z) => {
  if (!$ || !Array.isArray(Z))
    return $;
  $.delete("Set-Cookie");
  for (let X = 0;X < Z.length; X++) {
    const W = Z[X].indexOf("=");
    $.append("Set-Cookie", `${Z[X].slice(0, W)}=${Z[X].slice(W + 1)}`);
  }
  return $;
};
var w1 = ($) => {
  if (!$ || typeof $ !== "object" || !u($))
    return;
  const Z = [];
  for (let [X, W] of Object.entries($)) {
    if (!X || !W)
      continue;
    if (Array.isArray(W.value))
      for (let J = 0;J < W.value.length; J++) {
        let Q = W.value[J];
        if (Q === undefined || Q === null)
          continue;
        if (typeof Q === "object")
          Q = JSON.stringify(Q);
        Z.push(x0(X, Q, W));
      }
    else {
      let J = W.value;
      if (J === undefined || J === null)
        continue;
      if (typeof J === "object")
        J = JSON.stringify(J);
      Z.push(x0(X, W.value, W));
    }
  }
  if (Z.length === 0)
    return;
  if (Z.length === 1)
    return Z[0];
  return Z;
};
var v = ($, Z) => {
  if ($?.[$.$passthrough])
    $ = $[$.$passthrough];
  if ($?.[c])
    Z.status = $[c], $ = $.response;
  if (u(Z.headers) || Z.status !== 200 || Z.redirect || Z.cookie) {
    if (typeof Z.status === "string")
      Z.status = I0[Z.status];
    if (Z.redirect) {
      if (Z.headers.Location = Z.redirect, !Z.status || Z.status < 300 || Z.status >= 400)
        Z.status = 302;
    }
    if (Z.cookie && u(Z.cookie))
      Z.headers["Set-Cookie"] = w1(Z.cookie);
    if (Z.headers["Set-Cookie"] && Array.isArray(Z.headers["Set-Cookie"]))
      Z.headers = P1(new Headers(Z.headers), Z.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
        return new Response($, Z);
      case "Blob":
        return O0($, Z);
      case "Object":
      case "Array":
        return Response.json($, Z);
      case "ReadableStream":
        if (!Z.headers["content-type"]?.startsWith("text/event-stream"))
          Z.headers["content-type"] = "text/event-stream; charset=utf-8";
        return new Response($, Z);
      case undefined:
        if (!$)
          return new Response("", Z);
        return Response.json($, Z);
      case "Response":
        const X = { ...Z.headers };
        if (M0)
          Z.headers = $.headers.toJSON();
        else
          for (let [J, Q] of $.headers.entries())
            if (J in Z.headers)
              Z.headers[J] = Q;
        for (let J in X)
          $.headers.append(J, X[J]);
        return $;
      case "Error":
        return h($, Z);
      case "Promise":
        return $.then((J) => v(J, Z));
      case "Function":
        return v($(), Z);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Z);
      case "Cookie":
        if ($ instanceof k)
          return new Response($.value, Z);
        return new Response($?.toString(), Z);
      default:
        if ($ instanceof Response) {
          const J = { ...Z.headers };
          if (M0)
            Z.headers = $.headers.toJSON();
          else
            for (let [Q, Y] of $.headers.entries())
              if (Q in Z.headers)
                Z.headers[Q] = Y;
          for (let Q in J)
            $.headers.append(Q, J[Q]);
          return $;
        }
        if ($ instanceof Promise)
          return $.then((J) => v(J, Z));
        if ($ instanceof Error)
          return h($, Z);
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123) {
          if (!Z.headers["Content-Type"])
            Z.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Z);
        }
        return new Response(W, Z);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
        return new Response($);
      case "Blob":
        return O0($, Z);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "ReadableStream":
        return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Error":
        return h($, Z);
      case "Promise":
        return $.then((W) => {
          const J = l(W);
          if (J !== undefined)
            return J;
          return new Response("");
        });
      case "Function":
        return l($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof k)
          return new Response($.value, Z);
        return new Response($?.toString(), Z);
      default:
        if ($ instanceof Response)
          return new Response($.body, { headers: { "Content-Type": "application/json" } });
        if ($ instanceof Promise)
          return $.then((W) => v(W, Z));
        if ($ instanceof Error)
          return h($, Z);
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(X);
    }
};
var y = ($, Z) => {
  if ($ === undefined || $ === null)
    return;
  if ($?.$passthrough)
    $ = $[$.$passthrough];
  if ($?.[c])
    Z.status = $[c], $ = $.response;
  if (u(Z.headers) || Z.status !== 200 || Z.redirect || Z.cookie) {
    if (typeof Z.status === "string")
      Z.status = I0[Z.status];
    if (Z.redirect) {
      if (Z.headers.Location = Z.redirect, !Z.status || Z.status < 300 || Z.status >= 400)
        Z.status = 302;
    }
    if (Z.cookie && u(Z.cookie))
      Z.headers["Set-Cookie"] = w1(Z.cookie);
    if (Z.headers["Set-Cookie"] && Array.isArray(Z.headers["Set-Cookie"]))
      Z.headers = P1(new Headers(Z.headers), Z.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
        return new Response($, Z);
      case "Blob":
        return O0($, Z);
      case "Object":
      case "Array":
        return Response.json($, Z);
      case "ReadableStream":
        if (!Z.headers["content-type"]?.startsWith("text/event-stream"))
          Z.headers["content-type"] = "text/event-stream; charset=utf-8";
        return new Response($, Z);
      case undefined:
        if (!$)
          return;
        return Response.json($, Z);
      case "Response":
        const X = Object.assign({}, Z.headers);
        if (M0)
          Z.headers = $.headers.toJSON();
        else
          for (let [J, Q] of $.headers.entries())
            if (!(J in Z.headers))
              Z.headers[J] = Q;
        for (let J in X)
          $.headers.append(J, X[J]);
        if ($.status !== Z.status)
          Z.status = $.status;
        return $;
      case "Promise":
        return $.then((J) => {
          const Q = y(J, Z);
          if (Q !== undefined)
            return Q;
          return;
        });
      case "Error":
        return h($, Z);
      case "Function":
        return y($(), Z);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Z);
      case "Cookie":
        if ($ instanceof k)
          return new Response($.value, Z);
        return new Response($?.toString(), Z);
      default:
        if ($ instanceof Response) {
          const J = { ...Z.headers };
          if (M0)
            Z.headers = $.headers.toJSON();
          else
            for (let [Q, Y] of $.headers.entries())
              if (Q in Z.headers)
                Z.headers[Q] = Y;
          for (let Q in J)
            $.headers.append(Q, J[Q]);
          return $;
        }
        if ($ instanceof Promise)
          return $.then((J) => y(J, Z));
        if ($ instanceof Error)
          return h($, Z);
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123) {
          if (!Z.headers["Content-Type"])
            Z.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Z);
        }
        return new Response(W, Z);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
        return new Response($);
      case "Blob":
        return O0($, Z);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "ReadableStream":
        return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Promise":
        return $.then((W) => {
          const J = y(W, Z);
          if (J !== undefined)
            return J;
          return;
        });
      case "Error":
        return h($, Z);
      case "Function":
        return l($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof k)
          return new Response($.value, Z);
        return new Response($?.toString(), Z);
      default:
        if ($ instanceof Response)
          return new Response($.body, { headers: { "Content-Type": "application/json" } });
        if ($ instanceof Promise)
          return $.then((W) => y(W, Z));
        if ($ instanceof Error)
          return h($, Z);
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(X);
    }
};
var l = ($) => {
  if ($?.$passthrough)
    $ = $[$.$passthrough];
  if ($?.[c])
    return v($.response, { status: $[c], headers: {} });
  switch ($?.constructor?.name) {
    case "String":
      return new Response($);
    case "Blob":
      return O0($);
    case "Object":
    case "Array":
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "ReadableStream":
      return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      return $;
    case "Error":
      return h($);
    case "Promise":
      return $.then(l);
    case "Function":
      return l($());
    case "Number":
    case "Boolean":
      return new Response($.toString());
    default:
      if ($ instanceof Response)
        return new Response($.body, { headers: { "Content-Type": "application/json" } });
      if ($ instanceof Promise)
        return $.then(l);
      if ($ instanceof Error)
        return h($);
      const Z = JSON.stringify($);
      if (Z.charCodeAt(0) === 123)
        return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      return new Response(Z);
  }
};
var h = ($, Z) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: Z?.status !== 200 ? Z?.status ?? 500 : 500, headers: Z?.headers });
var r0 = ($) => $ && typeof $ === "object" && !Array.isArray($);
var t0 = ($, Z) => {
  const X = new URL($);
  return X.pathname = Z, X.toString();
};
var O$ = ($) => typeof $ === "function" && /^\s*class\s+/.test($.toString()) || $.toString().startsWith("[object ") || u(Object.getPrototypeOf($));
var d = ($, Z, { skipKeys: X } = {}) => {
  if (r0($) && r0(Z))
    for (let [W, J] of Object.entries(Z)) {
      if (X?.includes(W))
        continue;
      if (!r0(J)) {
        $[W] = J;
        continue;
      }
      if (!(W in $)) {
        $[W] = J;
        continue;
      }
      if (O$(J)) {
        $[W] = J;
        continue;
      }
      $[W] = d($[W], J);
    }
  return $;
};
var R1 = ($, Z) => d($, Z, { skipKeys: ["properties"] });
var H = ($, Z) => {
  if (!$)
    return [];
  const X = [...Array.isArray($) ? $ : [$]], W = [];
  for (let J of X)
    if (J.$elysiaChecksum)
      W.push(J.$elysiaChecksum);
  for (let J of Array.isArray(Z) ? Z : [Z])
    if (!W.includes(J?.$elysiaChecksum))
      X.push(J);
  return X;
};
var I$ = ["start", "request", "parse", "transform", "resolve", "beforeHandle", "afterHandle", "onResponse", "mapResponse", "trace", "error", "stop", "body", "headers", "params", "query", "response", "type", "detail"];
var s = ($, Z) => {
  return { ...$, ...Z, body: Z?.body ?? $?.body, headers: Z?.headers ?? $?.headers, params: Z?.params ?? $?.params, query: Z?.query ?? $?.query, response: Z?.response ?? $?.response, type: $?.type || Z?.type, detail: d(Z?.detail ?? {}, $?.detail ?? {}), parse: H($?.parse ?? [], Z?.parse ?? []), transform: H($?.transform ?? [], Z?.transform ?? []), beforeHandle: H($?.beforeHandle ?? [], Z?.beforeHandle ?? []), afterHandle: H($?.afterHandle ?? [], Z?.afterHandle ?? []), onResponse: H($?.onResponse ?? [], Z?.onResponse ?? []), mapResponse: H($?.mapResponse ?? [], Z?.mapResponse ?? []), trace: H($?.trace ?? [], Z?.trace ?? []), error: H($?.error ?? [], Z?.error ?? []) };
};
var p = ($, { models: Z = {}, additionalProperties: X = false, dynamic: W = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Z))
    return;
  const J = typeof $ === "string" ? Z[$] : $;
  if (J.type === "object" && "additionalProperties" in J === false)
    J.additionalProperties = X;
  if (W)
    return { schema: J, references: "", checkFunc: () => {
    }, code: "", Check: (Q) => exports_value2.Check(J, Q), Errors: (Q) => exports_value2.Errors(J, Q), Code: () => "" };
  return TypeCompiler.Compile(J, Object.values(Z));
};
var s0 = ($, { models: Z = {}, additionalProperties: X = false, dynamic: W = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Z))
    return;
  const J = typeof $ === "string" ? Z[$] : $, Q = (_, B) => {
    if (W)
      return { schema: _, references: "", checkFunc: () => {
      }, code: "", Check: (K) => exports_value2.Check(_, K), Errors: (K) => exports_value2.Errors(_, K), Code: () => "" };
    return TypeCompiler.Compile(_, B);
  };
  if (Kind in J) {
    if ("additionalProperties" in J === false)
      J.additionalProperties = X;
    return { 200: Q(J, Object.values(Z)) };
  }
  const Y = {};
  return Object.keys(J).forEach((_) => {
    const B = J[+_];
    if (typeof B === "string") {
      if (B in Z) {
        const K = Z[B];
        K.type === "object" && "additionalProperties" in K, Y[+_] = Kind in K ? Q(K, Object.values(Z)) : K;
      }
      return;
    }
    if (B.type === "object" && "additionalProperties" in B === false)
      B.additionalProperties = X;
    Y[+_] = Kind in B ? Q(B, Object.values(Z)) : B;
  }), Y;
};
var N$ = typeof Bun !== "undefined";
var F$ = N$ && typeof Bun.hash === "function";
var N0 = ($) => {
  if (F$)
    return Bun.hash($);
  let Z = 9;
  for (let X = 0;X < $.length; )
    Z = Math.imul(Z ^ $.charCodeAt(X++), 387420489);
  return Z = Z ^ Z >>> 9;
};
var v0 = ($, Z, X) => {
  const W = (J) => {
    if (X && !J.$elysiaChecksum)
      J.$elysiaChecksum = X;
    return J;
  };
  return { ...$, ...Z, start: H($.start, ("start" in Z ? Z.start ?? [] : []).map(W)), request: H($.request, ("request" in Z ? Z.request ?? [] : []).map(W)), parse: H($.parse, "parse" in Z ? Z?.parse ?? [] : []).map(W), transform: H($.transform, (Z?.transform ?? []).map(W)), beforeHandle: H($.beforeHandle, (Z?.beforeHandle ?? []).map(W)), afterHandle: H($.afterHandle, (Z?.afterHandle ?? []).map(W)), mapResponse: H($.mapResponse, (Z?.mapResponse ?? []).map(W)), onResponse: H($.onResponse, (Z?.onResponse ?? []).map(W)), trace: $.trace, error: H($.error, (Z?.error ?? []).map(W)), stop: H($.stop, ("stop" in Z ? Z.stop ?? [] : []).map(W)) };
};
var C1 = ($, Z = true) => {
  if (!$)
    return $;
  if (typeof $ === "function") {
    if (Z)
      $.$elysiaHookType = "global";
    else
      $.$elysiaHookType = undefined;
    return $;
  }
  return $.map((X) => {
    if (Z)
      X.$elysiaHookType = "global";
    else
      X.$elysiaHookType = undefined;
    return X;
  });
};
var Q0 = ($) => {
  if (!$)
    return $;
  if (typeof $ === "function")
    return $.$elysiaHookType === "global" ? $ : undefined;
  return $.filter((Z) => Z.$elysiaHookType === "global");
};
var a0 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: Q0($?.parse), transform: Q0($?.transform), beforeHandle: Q0($?.beforeHandle), afterHandle: Q0($?.afterHandle), onResponse: Q0($?.onResponse), error: Q0($?.error) };
};
var I0 = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var B0 = async ($, Z) => {
  if (typeof $ !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (Z === null)
    throw new TypeError("Secret key must be provided.");
  const X = new TextEncoder, W = await crypto.subtle.importKey("raw", X.encode(Z), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), J = await crypto.subtle.sign("HMAC", W, X.encode($)), Q = Array.from(new Uint8Array(J)), Y = btoa(String.fromCharCode(...Q));
  return `${$}.${Y.replace(/=+$/, "")}`;
};
var l0 = async ($, Z) => {
  if (typeof $ !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (Z === null)
    throw new TypeError("Secret key must be provided.");
  const X = $.slice(0, $.lastIndexOf("."));
  return await B0(X, Z) === $ ? X : false;
};
var o0 = ($, Z, X = Z) => {
  for (let [W, J] of Object.entries(Z ?? {})) {
    if (I$.includes(W) || !(W in $))
      continue;
    if (typeof $[W] === "function")
      $[W](J);
    else if (typeof $[W] === "object")
      o0($[W], J, X);
  }
};
var f0 = ($) => $.trim().length !== 0 && !Number.isNaN(Number($));
var S1 = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var _0 = Symbol("ElysiaErrorCode");
var c = Symbol("ElysiaResponse");
var F0 = (S1?.NODE_ENV ?? S1?.ENV) === "production";
class m0 extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor($) {
    super($ ?? "INTERNAL_SERVER_ERROR");
  }
}

class e extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor($) {
    super($ ?? "NOT_FOUND");
  }
}
class U0 extends Error {
  $;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor($, Z) {
    super(Z ?? `"${$}" has invalid cookie signature`);
    this.key = $;
  }
}

class q extends Error {
  $;
  Z;
  X;
  code = "VALIDATION";
  status = 400;
  constructor($, Z, X) {
    const W = F0 ? undefined : ("Errors" in Z) ? Z.Errors(X).First() : exports_value2.Errors(Z, X).First(), J = W?.schema.error ? typeof W.schema.error === "function" ? W.schema.error($, Z, X) : W.schema.error : undefined, Q = W?.path?.slice(1) || "root";
    let Y = "";
    if (J)
      Y = typeof J === "object" ? JSON.stringify(J) : J + "";
    else if (F0)
      Y = JSON.stringify({ type: $, message: W?.message });
    else
      Y = JSON.stringify({ type: $, at: Q, message: W?.message, expected: exports_value2.Create(Z.schema), found: X, errors: [...Z.Errors(X)] }, null, 2);
    super(Y);
    this.type = $;
    this.validator = Z;
    this.value = X;
    Object.setPrototypeOf(this, q.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  static simplifyModel($) {
    const Z = "schema" in $ ? $.schema : $;
    try {
      return exports_value2.Create(Z);
    } catch {
      return Z;
    }
  }
  get model() {
    return q.simplifyModel(this.validator);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: $ });
  }
}
var $1 = { open($) {
  $.data.open?.($);
}, message($, Z) {
  $.data.message?.($, Z);
}, drain($) {
  $.data.drain?.($);
}, close($, Z, X) {
  $.data.close?.($, Z, X);
} };

class D0 {
  $;
  Z;
  validator;
  constructor($, Z) {
    this.raw = $;
    this.data = Z;
    if (this.validator = $.data.validator, $.data.id)
      this.id = $.data.id;
    else {
      const X = new Uint32Array(1);
      crypto.getRandomValues(X), this.id = X[0].toString();
    }
  }
  get id() {
    return this.raw.data.id;
  }
  set id($) {
    this.raw.data.id = $;
  }
  get publish() {
    return ($, Z = undefined, X) => {
      if (this.validator?.Check(Z) === false)
        throw new q("message", this.validator, Z);
      if (typeof Z === "object")
        Z = JSON.stringify(Z);
      return this.raw.publish($, Z, X), this;
    };
  }
  get send() {
    return ($) => {
      if (this.validator?.Check($) === false)
        throw new q("message", this.validator, $);
      if (Buffer.isBuffer($))
        return this.raw.send($), this;
      if (typeof $ === "object")
        $ = JSON.stringify($);
      return this.raw.send($), this;
    };
  }
  get subscribe() {
    return ($) => {
      return this.raw.subscribe($), this;
    };
  }
  get unsubscribe() {
    return ($) => {
      return this.raw.unsubscribe($), this;
    };
  }
  get cork() {
    return ($) => {
      return this.raw.cork($), this;
    };
  }
  get close() {
    return () => {
      return this.raw.close(), this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
}
var p1 = T0(J1(), 1);
var i1 = T0(X1(), 1);
var q$ = new Headers().toJSON;
var l1 = new RegExp(" (\\w+) = context", "g");
var n1 = { value: 0 };
var r1 = ({ hasTrace: $, hasTraceSet: Z = false, addFn: X, condition: W = {} }) => {
  if ($)
    return X("\nconst reporter = getReporter()\n"), (J, { name: Q, attribute: Y = "", unit: _ = 0 } = {}) => {
      const B = J.indexOf("."), K = B === -1;
      if (J !== "request" && J !== "response" && !W[K ? J : J.slice(0, B)])
        return () => {
          if (Z && J === "afterHandle")
            X("\nawait traceDone\n");
        };
      if (K)
        Q ||= J;
      else
        Q ||= "anonymous";
      X("\n" + `reporter.emit('event', {
					id,
					event: '${J}',
					type: 'begin',
					name: '${Q}',
					time: performance.now(),
					${K ? `unit: ${_},` : ""}
					${Y}
				})`.replace(/(\t| |\n)/g, "") + "\n");
      let G = false;
      return () => {
        if (G)
          return;
        if (G = true, X("\n" + `reporter.emit('event', {
							id,
							event: '${J}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + "\n"), Z && J === "afterHandle")
          X("\nawait traceDone\n");
      };
    };
  else
    return () => () => {
    };
};
var P0 = ($) => {
  const Z = $.indexOf(")");
  if ($.charCodeAt(Z + 2) === 61 && $.charCodeAt(Z + 5) !== 123)
    return true;
  return $.includes("return");
};
var T$ = ($, { injectResponse: Z = "" } = {}) => ({ composeValidation: (X, W = `c.${X}`) => $ ? `c.set.status = 400; throw new ValidationError(
'${X}',
${X},
${W}
)` : `c.set.status = 400; return new ValidationError(
	'${X}',
	${X},
	${W}
).toResponse(c.set.headers)`, composeResponseValidation: (X = "r") => {
  const W = $ ? `throw new ValidationError(
'response',
response[c.set.status],
${X}
)` : `return new ValidationError(
'response',
response[c.set.status],
${X}
).toResponse(c.set.headers)`;
  return `\n${Z}
		if(!(${X} instanceof Response) && response[c.set.status]?.Check(${X}) === false) {
	if(!(response instanceof Error))
		${W}
}\n`;
} });
var b = ($, Z) => {
  if (Z.startsWith("[object "))
    return false;
  if (Z = Z.trimStart(), Z = Z.replaceAll(/^async /g, ""), /^(\w+)\(/g.test(Z))
    Z = Z.slice(Z.indexOf("("));
  const X = Z.charCodeAt(0) === 40 || Z.startsWith("function") ? Z.slice(Z.indexOf("(") + 1, Z.indexOf(")")) : Z.slice(0, Z.indexOf("=") - 1);
  if (X === "")
    return false;
  const W = X.charCodeAt(0) === 123 ? X.indexOf("...") : -1;
  if (X.charCodeAt(0) === 123) {
    if (X.includes($))
      return true;
    if (W === -1)
      return false;
  }
  if (Z.match(new RegExp(`${X}(.${$}|\\["${$}"\\])`)))
    return true;
  const J = W !== -1 ? X.slice(W + 3, X.indexOf(" ", W + 3)) : undefined;
  if (Z.match(new RegExp(`${J}(.${$}|\\["${$}"\\])`)))
    return true;
  const Q = [X];
  if (J)
    Q.push(J);
  for (let _ of Z.matchAll(l1))
    Q.push(_[1]);
  const Y = new RegExp(`{.*?} = (${Q.join("|")})`, "g");
  for (let [_] of Z.matchAll(Y))
    if (_.includes(`{ ${$}`) || _.includes(`, ${$}`))
      return true;
  return false;
};
var w0 = ($) => {
  if ($ = $.trimStart(), $.startsWith("[object"))
    return false;
  if ($ = $.replaceAll(/^async /g, ""), /^(\w+)\(/g.test($))
    $ = $.slice($.indexOf("("));
  const Z = $.charCodeAt(0) === 40 || $.startsWith("function") ? $.slice($.indexOf("(") + 1, $.indexOf(")")) : $.slice(0, $.indexOf("=") - 1);
  if (Z === "")
    return false;
  const X = Z.charCodeAt(0) === 123 ? Z.indexOf("...") : -1, W = X !== -1 ? Z.slice(X + 3, Z.indexOf(" ", X + 3)) : undefined, J = [Z];
  if (W)
    J.push(W);
  for (let Y of $.matchAll(l1))
    J.push(Y[1]);
  for (let Y of J)
    if (new RegExp(`\\b\\w+\\([^)]*\\b${Y}\\b[^)]*\\)`).test($))
      return true;
  const Q = new RegExp(`{.*?} = (${J.join("|")})`, "g");
  for (let [Y] of $.matchAll(Q))
    if (new RegExp(`\\b\\w+\\([^)]*\\b${Y}\\b[^)]*\\)`).test($))
      return true;
  return false;
};
var G0 = Symbol.for("TypeBox.Kind");
var k0 = ($, Z) => {
  if (!Z)
    return;
  if (G0 in Z && Z[G0] === $)
    return true;
  if (Z.type === "object") {
    const X = Z.properties;
    for (let W of Object.keys(X)) {
      const J = X[W];
      if (J.type === "object") {
        if (k0($, J))
          return true;
      } else if (J.anyOf) {
        for (let Q = 0;Q < J.anyOf.length; Q++)
          if (k0($, J.anyOf[Q]))
            return true;
      }
      if (G0 in J && J[G0] === $)
        return true;
    }
    return false;
  }
  return Z.properties && G0 in Z.properties && Z.properties[G0] === $;
};
var $0 = ($, Z) => {
  if (!Z)
    return;
  if (Z.type === "object") {
    const X = Z.properties;
    if (!X)
      return false;
    for (let W of Object.keys(X)) {
      const J = X[W];
      if ($ in J)
        return true;
      if (J.type === "object") {
        if ($0($, J))
          return true;
      } else if (J.anyOf) {
        for (let Q = 0;Q < J.anyOf.length; Q++)
          if ($0($, J.anyOf[Q]))
            return true;
      }
    }
    return false;
  }
  return $ in Z;
};
var Y1 = Symbol.for("TypeBox.Transform");
var Z0 = ($) => {
  if (!$)
    return;
  if ($.type === "object" && $.properties) {
    const Z = $.properties;
    for (let X of Object.keys(Z)) {
      const W = Z[X];
      if (W.type === "object") {
        if (Z0(W))
          return true;
      } else if (W.anyOf) {
        for (let Q = 0;Q < W.anyOf.length; Q++)
          if (Z0(W.anyOf[Q]))
            return true;
      }
      if (Y1 in W)
        return true;
    }
    return false;
  }
  return Y1 in $ || $.properties && Y1 in $.properties;
};
var E$ = ($) => {
  if (!$)
    return;
  const Z = $?.schema;
  if (Z && "anyOf" in Z) {
    let X = false;
    const W = Z.anyOf[0].type;
    for (let J of Z.anyOf)
      if (J.type !== W) {
        X = true;
        break;
      }
    if (!X)
      return W;
  }
  return $.schema?.type;
};
var H$ = /(?:return|=>) \S+\(/g;
var L = ($) => {
  if ($.constructor.name === "AsyncFunction")
    return true;
  const Z = $.toString();
  if (Z.includes("=> response.clone("))
    return false;
  return !!Z.match(H$);
};
var b$ = ($) => {
  if (!$.includes("query: {") || $.includes("query,") || $.includes("query }"))
    return false;
  const Z = $.indexOf("query: {");
  return $ = $.slice(Z + 9), $ = $.slice(0, $.indexOf("}")), $.split(",").map((X) => {
    const W = X.indexOf(":");
    if (W === -1)
      return X.trim();
    return X.slice(0, W).trim();
  });
};
var t1 = ({ path: $, method: Z, hooks: X, validator: W, handler: J, handleError: Q, definitions: Y, schema: _, onRequest: B, config: K, getReporter: G, setHeader: U }) => {
  const w = K.forceErrorEncapsulation || X.error.length > 0 || typeof Bun === "undefined" || X.onResponse.length > 0 || !!X.trace.length, A = typeof J === "function", z = A ? "handler(c)" : "handler", P = X.onResponse.length ? `\n;(async () => {${X.onResponse.map((O, I) => `await res${I}(c)`).join(";")}})();\n` : "", M = X.trace.map((O) => O.toString());
  let N = false;
  if (A && w0(J.toString()))
    N = true;
  if (!N)
    for (let [O, I] of Object.entries(X)) {
      if (!Array.isArray(I) || !I.length || !["parse", "transform", "beforeHandle", "afterHandle", "onResponse"].includes(O))
        continue;
      for (let j of I) {
        if (typeof j !== "function")
          continue;
        if (w0(j.toString())) {
          N = true;
          break;
        }
      }
      if (N)
        break;
    }
  const F = { parse: M.some((O) => b("parse", O)), transform: M.some((O) => b("transform", O)), handle: M.some((O) => b("handle", O)), beforeHandle: M.some((O) => b("beforeHandle", O)), afterHandle: M.some((O) => b("afterHandle", O)), error: w || M.some((O) => b("error", O)) }, V = X.trace.length > 0;
  let D = "";
  const m = W || Z !== "GET" && Z !== "HEAD" ? [J, ...X.transform, ...X.beforeHandle, ...X.afterHandle, ...X.mapResponse].map((O) => typeof O === "function" ? O.toString() : `${O}`) : [], V0 = Z !== "GET" && Z !== "HEAD" && (N || X.type !== "none" && (!!W.body || !!X.type || m.some((O) => b("body", O)))), h0 = N || W.headers || m.some((O) => b("headers", O)) || U && Object.keys(U).length, R0 = N || !!W.cookie || m.some((O) => b("cookie", O)), x = W?.cookie?.schema;
  let r = "";
  if (x?.sign) {
    if (!x.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${Z}) ${$}.`);
    const O = !x.secrets ? undefined : typeof x.secrets === "string" ? x.secrets : x.secrets[0];
    if (r += `const _setCookie = c.set.cookie
		if(_setCookie) {`, x.sign === true)
      r += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${O}')
			}`;
    else
      for (let I of x.sign)
        r += `if(_setCookie['${I}']?.value) { c.set.cookie['${I}'].value = await signCookie(_setCookie['${I}'].value, '${O}') }\n`;
    r += "}\n";
  }
  const { composeValidation: X0, composeResponseValidation: C0 } = T$(w);
  if (h0)
    D += q$ ? "c.headers = c.request.headers.toJSON()\n" : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  if (R0) {
    const O = (j, C) => {
      const S = x?.[j] ?? C;
      if (!S)
        return typeof C === "string" ? `${j}: "${C}",` : `${j}: ${C},`;
      if (typeof S === "string")
        return `${j}: '${S}',`;
      if (S instanceof Date)
        return `${j}: new Date(${S.getTime()}),`;
      return `${j}: ${S},`;
    }, I = x ? `{
			secret: ${x.secrets !== undefined ? typeof x.secrets === "string" ? `'${x.secrets}'` : "[" + x.secrets.reduce((j, C) => j + `'${C}',`, "") + "]" : "undefined"},
			sign: ${x.sign === true ? true : x.sign !== undefined ? "[" + x.sign.reduce((j, C) => j + `'${C}',`, "") + "]" : "undefined"},
			${O("domain")}
			${O("expires")}
			${O("httpOnly")}
			${O("maxAge")}
			${O("path", "/")}
			${O("priority")}
			${O("sameSite")}
			${O("secure")}
		}` : "undefined";
    if (h0)
      D += `\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${I})\n`;
    else
      D += `\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${I})\n`;
  }
  if (N || W.query || m.some((O) => b("query", O))) {
    let O = [], I = false;
    if (W.query && W.query.schema.type === "object")
      O = Object.keys(W.query.schema.properties);
    else
      for (let j of m) {
        const C = b$(j);
        if (!C) {
          I = true;
          continue;
        }
        for (let S of C)
          if (O.indexOf(S) === -1)
            O.push(S);
      }
    if (!I && O.length)
      D += `
			let requestUrl = c.request.url.slice(c.qi + 1)
			if(requestUrl.includes('+')) requestUrl = requestUrl.replaceAll('+', ' ')

			if(c.qi !== -1) {	
				const url = decodeURIComponent(requestUrl)
				let memory = 0

				${O.map((j, C) => `
						memory = url.indexOf('${j}=')

						const a${C} = memory === -1 ? undefined : url.slice(memory = memory + ${j.length + 1}, (memory = url.indexOf('&', memory)) === -1 ? undefined : memory)`).join("\n")}

				c.query = {
					${O.map((j, C) => `${j}: a${C}`).join(", ")}
				}
			} else {
				c.query = {}
			}`;
    else
      D += "c.query = c.qi !== -1 ? parseQuery(decodeURIComponent(c.request.url.slice(c.qi + 1))) : {}";
  }
  const S0 = X.trace.map((O) => O.toString()).some((O) => b("set", O) || w0(O));
  N || X.trace.some((O) => b("set", O.toString()));
  const q0 = U && Object.keys(U).length || S0 || R0 || m.some((O) => b("set", O)) || B.some((O) => b("set", O.toString()));
  if (V)
    D += "\nconst id = c.$$requestId\n";
  const E = r1({ hasTrace: V, hasTraceSet: S0, condition: F, addFn: (O) => {
    D += O;
  } });
  if (D += w ? "\n try {\n" : "", S0) {
    D += "\nconst traceDone = Promise.all([";
    for (let O = 0;O < X.trace.length; O++)
      D += `new Promise(r => { reporter.once(\`res\${id}.${O}\`, r) }),`;
    D += "])\n";
  }
  const W0 = typeof J === "function" && L(J), c0 = R0 || V0 || S0 || W0 || !!X.mapResponse.length || X.parse.length > 0 || X.afterHandle.some(L) || X.beforeHandle.some(L) || X.transform.some(L), e1 = E("parse", { unit: X.parse.length });
  if (V0) {
    const O = E$(W?.body);
    if (X.type && !Array.isArray(X.type)) {
      if (X.type)
        switch (X.type) {
          case "json":
          case "application/json":
            D += "c.body = await c.request.json()\n";
            break;
          case "text":
          case "text/plain":
            D += "c.body = await c.request.text()\n";
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            D += "c.body = parseQuery(await c.request.text())\n";
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            D += "c.body = await c.request.arrayBuffer()\n";
            break;
          case "formdata":
          case "multipart/form-data":
            D += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}\n`;
            break;
        }
      if (X.parse.length)
        D += "}}";
    } else {
      const j = (() => {
        if (X.parse.length && O && !Array.isArray(X.type)) {
          const C = W?.body?.schema;
          switch (O) {
            case "object":
              if (k0("File", C) || k0("Files", C))
                return `c.body = {}

								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue

									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
              break;
            default:
              break;
          }
        }
      })();
      if (j)
        D += j;
      else {
        if (D += "\n", D += h0 ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", D += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n`, X.parse.length) {
          D += "let used = false\n";
          const C = E("parse", { unit: X.parse.length });
          for (let S = 0;S < X.parse.length; S++) {
            const d0 = E("parse.unit", { name: X.parse[S].name }), T = `bo${S}`;
            if (S !== 0)
              D += "if(!used) {\n";
            if (D += `let ${T} = parse[${S}](c, contentType)\n`, D += `if(${T} instanceof Promise) ${T} = await ${T}\n`, D += `if(${T} !== undefined) { c.body = ${T}; used = true }\n`, d0(), S !== 0)
              D += "}";
          }
          C();
        }
        if (X.parse.length)
          D += "if (!used)";
        D += `
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break

					case 'text/plain':
						c.body = await c.request.text()
						break

					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break

					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break

					case 'multipart/form-data':
						c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}

						break
					}\n`, D += "}\n";
      }
    }
    D += "\n";
  }
  if (e1(), X?.transform) {
    const O = E("transform", { unit: X.transform.length });
    for (let I = 0;I < X.transform.length; I++) {
      const j = X.transform[I], C = E("transform.unit", { name: j.name });
      if (j.$elysia === "derive")
        D += L(j) ? `Object.assign(c, await transform[${I}](c));` : `Object.assign(c, transform[${I}](c));`;
      else
        D += L(j) ? `await transform[${I}](c);` : `transform[${I}](c);`;
      C();
    }
    O();
  }
  if (W) {
    if (D += "\n", W.headers) {
      if ($0("default", W.headers.params))
        for (let [O, I] of Object.entries(exports_value2.Default(W.headers.schema, {}))) {
          const j = typeof I === "object" ? JSON.stringify(I) : `'${I}'`;
          if (j)
            D += `c.headers['${O}'] ??= ${j}\n`;
        }
      if (D += `if(headers.Check(c.headers) === false) {
				${X0("headers")}
			}`, Z0(W.headers.schema))
        D += "\nc.headers = headers.Decode(c.headers)\n";
    }
    if (W.params) {
      if ($0("default", W.params.schema))
        for (let [O, I] of Object.entries(exports_value2.Default(W.params.schema, {}))) {
          const j = typeof I === "object" ? JSON.stringify(I) : `'${I}'`;
          if (j)
            D += `c.params['${O}'] ??= ${j}\n`;
        }
      if (D += `if(params.Check(c.params) === false) {
				${X0("params")}
			}`, Z0(W.params.schema))
        D += "\nc.params = params.Decode(c.params)\n";
    }
    if (W.query) {
      if ($0("default", W.query.schema))
        for (let [O, I] of Object.entries(exports_value2.Default(W.query.schema, {}))) {
          const j = typeof I === "object" ? JSON.stringify(I) : `'${I}'`;
          if (j)
            D += `c.query['${O}'] ??= ${j}\n`;
        }
      if (D += `if(query.Check(c.query) === false) {
				${X0("query")}
			}`, Z0(W.query.schema))
        D += "\nc.query = query.Decode(Object.assign({}, c.query))\n";
    }
    if (W.body) {
      if ($0("default", W.body.schema))
        D += `if(body.Check(c.body) === false) {
    				c.body = Object.assign(${JSON.stringify(exports_value2.Default(W.body.schema, null) ?? {})}, c.body)

    				if(body.Check(c.query) === false) {
        				${X0("body")}
     			}
            }`;
      else
        D += `if(body.Check(c.body) === false) {
			${X0("body")}
		}`;
      if (Z0(W.body.schema))
        D += "\nc.body = body.Decode(c.body)\n";
    }
    if (u(W.cookie?.schema.properties ?? {})) {
      if (D += `const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value\n`, $0("default", W.cookie.schema))
        for (let [O, I] of Object.entries(exports_value2.Default(W.cookie.schema, {})))
          D += `cookieValue['${O}'] = ${typeof I === "object" ? JSON.stringify(I) : I}\n`;
      if (D += `if(cookie.Check(cookieValue) === false) {
				${X0("cookie", "cookieValue")}
			}`, Z0(W.cookie.schema))
        D += "\nc.cookie = params.Decode(c.cookie)\n";
    }
  }
  if (X?.beforeHandle) {
    const O = E("beforeHandle", { unit: X.beforeHandle.length });
    for (let I = 0;I < X.beforeHandle.length; I++) {
      const j = X.beforeHandle[I], C = E("beforeHandle.unit", { name: j.name }), S = P0(j.toString());
      if (j.$elysia === "resolve")
        D += L(j) ? `Object.assign(c, await beforeHandle[${I}](c));` : `Object.assign(c, beforeHandle[${I}](c));`;
      else if (!S)
        D += L(j) ? `await beforeHandle[${I}](c);\n` : `beforeHandle[${I}](c);\n`, C();
      else {
        D += L(j) ? `be = await beforeHandle[${I}](c);\n` : `be = beforeHandle[${I}](c);\n`, C(), D += "if(be !== undefined) {\n";
        const d0 = E("afterHandle", { unit: X.transform.length });
        if (X.afterHandle) {
          E("handle", { name: A ? J.name : undefined })();
          for (let T = 0;T < X.afterHandle.length; T++) {
            const $$ = P0(X.afterHandle[T].toString()), Z$ = E("afterHandle.unit", { name: X.afterHandle[T].name });
            if (D += "c.response = be\n", !$$)
              D += L(X.afterHandle[T]) ? `await afterHandle[${T}](c, be)\n` : `afterHandle[${T}](c, be)\n`;
            else
              D += L(X.afterHandle[T]) ? `af = await afterHandle[${T}](c)\n` : `af = afterHandle[${T}](c)\n`, D += "if(af !== undefined) { c.response = be = af }\n";
            Z$();
          }
        }
        if (d0(), W.response)
          D += C0("be");
        if (X.mapResponse.length) {
          D += "c.response = be";
          for (let T = 0;T < X.mapResponse.length; T++)
            D += `\nif(mr === undefined) {
							mr = onMapResponse[${T}](c)
							if(mr instanceof Promise) mr = await mr
							if(mr !== undefined) c.response = mr
						}\n`;
        }
        D += r, D += "return mapEarlyResponse(be, c.set)}\n";
      }
    }
    O();
  }
  if (X?.afterHandle.length) {
    const O = E("handle", { name: A ? J.name : undefined });
    if (X.afterHandle.length)
      D += W0 ? `let r = c.response = await ${z};\n` : `let r = c.response = ${z};\n`;
    else
      D += W0 ? `let r = await ${z};\n` : `let r = ${z};\n`;
    O();
    const I = E("afterHandle", { unit: X.afterHandle.length });
    for (let j = 0;j < X.afterHandle.length; j++) {
      const C = P0(X.afterHandle[j].toString()), S = E("afterHandle.unit", { name: X.afterHandle[j].name });
      if (!C)
        D += L(X.afterHandle[j]) ? `await afterHandle[${j}](c)\n` : `afterHandle[${j}](c)\n`, S();
      else if (D += L(X.afterHandle[j]) ? `af = await afterHandle[${j}](c)\n` : `af = afterHandle[${j}](c)\n`, S(), W.response)
        D += "if(af !== undefined) {", I(), D += C0("af"), D += "c.response = af }";
      else
        D += "if(af !== undefined) {", I(), D += "c.response = af}\n";
    }
    if (I(), D += "r = c.response\n", W.response)
      D += C0();
    if (D += r, X.mapResponse.length)
      for (let j = 0;j < X.mapResponse.length; j++)
        D += `\nmr = onMapResponse[${j}](c)
				if(mr instanceof Promise) mr = await mr
				if(mr !== undefined) c.response = mr\n`;
    if (q0)
      D += "return mapResponse(r, c.set)\n";
    else
      D += "return mapCompactResponse(r)\n";
  } else {
    const O = E("handle", { name: A ? J.name : undefined });
    if (W.response || X.mapResponse.length) {
      if (D += W0 ? `let r = await ${z};\n` : `let r = ${z};\n`, O(), W.response)
        D += C0();
      if (E("afterHandle")(), X.mapResponse.length) {
        D += "c.response = r";
        for (let I = 0;I < X.mapResponse.length; I++)
          D += `\nif(mr === undefined) { 
						mr = onMapResponse[${I}](c)
						if(mr instanceof Promise) mr = await mr
    					if(mr !== undefined) r = c.response = mr
					}\n`;
      }
      if (D += r, J instanceof Response)
        D += `return ${z}.clone()\n`;
      else if (q0)
        D += "return mapResponse(r, c.set)\n";
      else
        D += "return mapCompactResponse(r)\n";
    } else if (F.handle || R0) {
      if (D += W0 ? `let r = await ${z};\n` : `let r = ${z};\n`, O(), E("afterHandle")(), X.mapResponse.length) {
        D += "c.response = r";
        for (let I = 0;I < X.mapResponse.length; I++)
          D += `\nif(mr === undefined) {
							mr = onMapResponse[${I}](c)
							if(mr instanceof Promise) mr = await mr
    						if(mr !== undefined) r = c.response = mr
						}\n`;
      }
      if (D += r, q0)
        D += "return mapResponse(r, c.set)\n";
      else
        D += "return mapCompactResponse(r)\n";
    } else {
      O();
      const I = W0 ? `await ${z}` : z;
      if (E("afterHandle")(), J instanceof Response)
        D += `return ${z}.clone()\n`;
      else if (q0)
        D += `return mapResponse(${I}, c.set)\n`;
      else
        D += `return mapCompactResponse(${I})\n`;
    }
  }
  if (w || P) {
    if (D += `
} catch(error) {`, !c0)
      D += "return (async () => {";
    D += `const set = c.set

		if (!set.status || set.status < 300) set.status = error?.status || 500
	`;
    const O = E("error", { unit: X.error.length });
    if (X.error.length) {
      D += `
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
			`;
      for (let I = 0;I < X.error.length; I++) {
        const j = `er${I}`, C = E("error.unit", { name: X.error[I].name });
        if (D += `\nlet ${j} = handleErrors[${I}](c)\n`, L(X.error[I]))
          D += `if (${j} instanceof Promise) ${j} = await ${j}\n`;
        C(), D += `${j} = mapEarlyResponse(${j}, set)\n`, D += `if (${j}) {`, D += `return ${j} }\n`;
      }
    }
    if (O(), D += "return handleError(c, error)\n\n", !c0)
      D += "})()";
    if (D += "}", P || V) {
      D += " finally { ";
      const I = E("response", { unit: X.onResponse.length });
      D += P, I(), D += "}";
    }
  }
  return D = `const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		getReporter,
		requestId,
		parseCookie,
		signCookie,
		decodeURIComponent
	} = hooks

	${X.onResponse.length ? `const ${X.onResponse.map((O, I) => `res${I} = onResponse[${I}]`).join(",")}` : ""}

	return ${c0 ? "async" : ""} function handle(c) {
		${X.beforeHandle.length ? "let be" : ""}
		${X.afterHandle.length ? "let af" : ""}
		${X.mapResponse.length ? "let mr" : ""}

		${_ && Y ? "c.schema = schema; c.defs = definitions;" : ""}
		${D}
	}`, Function("hooks", D)({ handler: J, hooks: X, validator: W, handleError: Q, utils: { mapResponse: v, mapCompactResponse: l, mapEarlyResponse: y, parseQuery: p1.parse }, error: { NotFoundError: e, ValidationError: q, InternalServerError: m0 }, schema: _, definitions: Y, ERROR_CODE: _0, getReporter: G, requestId: n1, parseCookie: g0, signCookie: B0, decodeURIComponent: i1.default });
};
var Q1 = ($) => {
  let Z = "", X = "";
  for (let z of Object.keys($.decorators))
    Z += `,${z}: app.decorators.${z}`;
  const { router: W, staticRouter: J } = $, Q = $.event.trace.length > 0, Y = `
	const route = router.find(request.method, path) ${W.root.ALL ? '?? router.find("ALL", path)' : ""}
	if (route === null)
		return ${$.event.error.length ? "app.handleError(ctx, notFound)" : $.event.request.length ? `new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})` : "error404.clone()"}

	ctx.params = route.params

	return route.store(ctx)`;
  let _ = "";
  for (let [z, { code: P, all: M }] of Object.entries(J.map))
    _ += `case '${z}':\nswitch(request.method) {\n${P}\n${M ?? "default: break map"}}\n\n`;
  const B = $.event.request.some(L);
  if (X += `const {
		app,
		app: { store, router, staticRouter, wsRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		getReporter,
		handleError
	} = data

	const notFound = new NotFoundError()

	${$.event.request.length ? "const onRequest = app.event.request" : ""}
	${J.variables}
	${$.event.error.length ? "" : `
	const error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });
	`}

	return ${B ? "async" : ""} function map(request) {\n`, $.event.request.length)
    X += "let re";
  const K = $.event.trace.map((z) => z.toString()), G = r1({ hasTrace: Q, hasTraceSet: $.event.trace.some((z) => {
    const P = z.toString();
    return b("set", P) || w0(P);
  }), condition: { request: K.some((z) => b("request", z) || w0(z)) }, addFn: (z) => {
    X += z;
  } });
  if ($.event.request.length) {
    X += `
			${Q ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					headers: ${Object.keys($.setHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
					status: 200
				}
				${Q ? ",$$requestId: +id" : ""}
				${Z}
			}
		`;
    const z = G("request", { attribute: "ctx", unit: $.event.request.length });
    X += "\n try {\n";
    for (let P = 0;P < $.event.request.length; P++) {
      const M = $.event.request[P], N = P0(M.toString()), F = L(M), V = G("request.unit", { name: $.event.request[P].name });
      if (N) {
        if (X += `re = mapEarlyResponse(
					${F ? "await" : ""} onRequest[${P}](ctx),
					ctx.set
				)\n`, V(), N)
          X += "if(re !== undefined) return re\n";
      } else
        X += `${F ? "await" : ""} onRequest[${P}](ctx)\n`, V();
    }
    X += `} catch (error) {
			return app.handleError(ctx, error)
		}`, z(), X += `
		const url = request.url
		const s = url.indexOf('/', 11)
		const qi = ctx.qi = url.indexOf('?', s + 1)
		const path = ctx.path = url.substring(s, qi === -1 ? undefined : qi)`;
  } else
    X += `
		const url = request.url
		const s = url.indexOf('/', 11)
		const qi = url.indexOf('?', s + 1)
		const path = url.substring(s, qi === -1 ? undefined : qi)
		${Q ? "const id = +requestId.value++" : ""}
		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: ${Object.keys($.setHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
				status: 200
			}
			${Q ? ",$$requestId: id" : ""}
			${Z}
		}`, G("request", { unit: $.event.request.length, attribute: K.some((z) => b("context", z)) || K.some((z) => b("store", z)) || K.some((z) => b("set", z)) ? "ctx" : "" })();
  const { wsPaths: U, wsRouter: w } = $;
  if (Object.keys(U).length || w.history.length) {
    X += `
			if(request.method === 'GET') {
				switch(path) {`;
    for (let [z, P] of Object.entries(U))
      X += `
					case '${z}':
						if(request.headers.get('upgrade') === 'websocket')
							return st${P}(ctx)

						break`;
    X += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							return route.store(ctx)
						}
					}

					break
			}
		}\n`;
  }
  X += `
		map: switch(path) {
			${_}

			default:
				break
		}

		${Y}
	}`;
  const A = B1($);
  return $.handleError = A, Function("data", X)({ app: $, mapEarlyResponse: y, NotFoundError: e, getReporter: () => $.reporter, requestId: n1, handleError: A });
};
var B1 = ($) => {
  let Z = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE,
		ELYSIA_RESPONSE
	} = inject

	return ${$.event.error.find(L) ? "async" : ""} function(context, error) {
		let r

		const { set } = context

		context.code = error.code
		context.error = error

		if(error[ELYSIA_RESPONSE]) {
			error.status = error[ELYSIA_RESPONSE]
			error.message = error.response
		}
`;
  for (let X = 0;X < $.event.error.length; X++) {
    const W = $.event.error[X], J = `${L(W) ? "await " : ""}onError[${X}](context)`;
    if (P0(W.toString()))
      Z += `r = ${J}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r[ELYSIA_RESPONSE]) {
					error.status = error[ELYSIA_RESPONSE]
					error.message = error.response
				}
		
				if(set.status === 200) set.status = error.status
				return mapResponse(r, set)
			}\n`;
    else
      Z += J + "\n";
  }
  return Z += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 400
		return new Response(
			error.message,
			{ headers: set.headers, status: set.status }
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)

		return mapResponse(error, set)
	}
}`, Function("inject", Z)({ app: $, mapResponse: v, ERROR_CODE: _0, ELYSIA_RESPONSE: c });
};
var u0 = T0(J1(), 1);
var _1 = ($) => async (Z) => {
  const X = { cookie: {}, status: 200, headers: {} };
  let W;
  if ($.decorators)
    W = $.decorators, W.request = Z, W.set = X, W.store = $.store;
  else
    W = { set: X, store: $.store, request: Z };
  const J = Z.url, Q = J.indexOf("/", 11), Y = J.indexOf("?", Q + 1), _ = Y === -1 ? J.substring(Q) : J.substring(Q, Y);
  try {
    for (let M = 0;M < $.event.request.length; M++) {
      const N = $.event.request[M];
      let F = N(W);
      if (F instanceof Promise)
        F = await F;
      if (F = y(F, X), F)
        return F;
    }
    const B = $.dynamicRouter.find(Z.method, _) ?? $.dynamicRouter.find("ALL", _);
    if (!B)
      throw new e;
    const { handle: K, hooks: G, validator: U, content: w } = B.store;
    let A;
    if (Z.method !== "GET" && Z.method !== "HEAD")
      if (w)
        switch (w) {
          case "application/json":
            A = await Z.json();
            break;
          case "text/plain":
            A = await Z.text();
            break;
          case "application/x-www-form-urlencoded":
            A = u0.parse(await Z.text());
            break;
          case "application/octet-stream":
            A = await Z.arrayBuffer();
            break;
          case "multipart/form-data":
            A = {};
            const M = await Z.formData();
            for (let N of M.keys()) {
              if (A[N])
                continue;
              const F = M.getAll(N);
              if (F.length === 1)
                A[N] = F[0];
              else
                A[N] = F;
            }
            break;
        }
      else {
        let M = Z.headers.get("content-type");
        if (M) {
          const N = M.indexOf(";");
          if (N !== -1)
            M = M.slice(0, N);
          for (let F = 0;F < G.parse.length; F++) {
            let V = G.parse[F](W, M);
            if (V instanceof Promise)
              V = await V;
            if (V) {
              A = V;
              break;
            }
          }
          if (A === undefined)
            switch (M) {
              case "application/json":
                A = await Z.json();
                break;
              case "text/plain":
                A = await Z.text();
                break;
              case "application/x-www-form-urlencoded":
                A = u0.parse(await Z.text());
                break;
              case "application/octet-stream":
                A = await Z.arrayBuffer();
                break;
              case "multipart/form-data":
                A = {};
                const F = await Z.formData();
                for (let V of F.keys()) {
                  if (A[V])
                    continue;
                  const D = F.getAll(V);
                  if (D.length === 1)
                    A[V] = D[0];
                  else
                    A[V] = D;
                }
                break;
            }
        }
      }
    W.body = A, W.params = B?.params || undefined, W.query = Y === -1 ? {} : u0.parse(J.substring(Y + 1)), W.headers = {};
    for (let [M, N] of Z.headers.entries())
      W.headers[M] = N;
    const z = U?.cookie?.schema;
    W.cookie = await g0(W.set, W.headers.cookie, z ? { secret: z.secrets !== undefined ? typeof z.secrets === "string" ? z.secrets : z.secrets.join(",") : undefined, sign: z.sign === true ? true : z.sign !== undefined ? typeof z.sign === "string" ? z.sign : z.sign.join(",") : undefined } : undefined);
    for (let M = 0;M < G.transform.length; M++) {
      const N = G.transform[M](W);
      if (G.transform[M].$elysia === "derive")
        if (N instanceof Promise)
          Object.assign(W, await N);
        else
          Object.assign(W, N);
      else if (N instanceof Promise)
        await N;
    }
    if (U) {
      if (U.headers) {
        const M = {};
        for (let N in Z.headers)
          M[N] = Z.headers.get(N);
        if (U.headers.Check(M) === false)
          throw new q("header", U.headers, M);
      }
      if (U.params?.Check(W.params) === false)
        throw new q("params", U.params, W.params);
      if (U.query?.Check(W.query) === false)
        throw new q("query", U.query, W.query);
      if (U.cookie) {
        const M = {};
        for (let [N, F] of Object.entries(W.cookie))
          M[N] = F.value;
        if (U.cookie?.Check(M) === false)
          throw new q("cookie", U.cookie, M);
      }
      if (U.body?.Check(A) === false)
        throw new q("body", U.body, A);
    }
    for (let M = 0;M < G.beforeHandle.length; M++) {
      let N = G.beforeHandle[M](W);
      if (N instanceof Promise)
        N = await N;
      if (N !== undefined) {
        W.response = N;
        for (let V = 0;V < G.afterHandle.length; V++) {
          let D = G.afterHandle[V](W);
          if (D instanceof Promise)
            D = await D;
          if (D)
            N = D;
        }
        const F = y(N, W.set);
        if (F)
          return F;
      }
    }
    let P = K(W);
    if (P instanceof Promise)
      P = await P;
    if (!G.afterHandle.length) {
      const M = U?.response?.[P.status];
      if (M?.Check(P) === false)
        throw new q("response", M, P);
    } else {
      W.response = P;
      for (let M = 0;M < G.afterHandle.length; M++) {
        let N = G.afterHandle[M](W);
        if (N instanceof Promise)
          N = await N;
        const F = y(N, W.set);
        if (F !== undefined) {
          const V = U?.response?.[P.status];
          if (V?.Check(F) === false)
            throw new q("response", V, F);
          return F;
        }
      }
    }
    if (W.set.cookie && z?.sign) {
      const M = !z.secrets ? undefined : typeof z.secrets === "string" ? z.secrets : z.secrets[0];
      if (z.sign === true)
        for (let [N, F] of Object.entries(W.set.cookie))
          W.set.cookie[N].value = await B0(F.value, "${secret}");
      else
        for (let N of z.sign) {
          if (!(N in z.properties))
            continue;
          if (W.set.cookie[N]?.value)
            W.set.cookie[N].value = await B0(W.set.cookie[N].value, M);
        }
    }
    return v(P, W.set);
  } catch (B) {
    if (B.status)
      X.status = B.status;
    return $.handleError(W, B);
  } finally {
    for (let B of $.event.onResponse)
      await B(W);
  }
};
var s1 = ($) => async (Z, X) => {
  const W = Object.assign(Z, { error: X, code: X.code });
  W.set = Z.set;
  for (let J = 0;J < $.event.error.length; J++) {
    let Q = $.event.error[J](W);
    if (Q instanceof Promise)
      Q = await Q;
    if (Q !== undefined && Q !== null)
      return v(Q, Z.set);
  }
  return new Response(typeof X.cause === "string" ? X.cause : X.message, { headers: Z.set.headers, status: X.status ?? 500 });
};
var R = Object.assign({}, Type);
try {
  TypeSystem.Format("email", ($) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test($)), TypeSystem.Format("uuid", ($) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test($)), TypeSystem.Format("date", ($) => !Number.isNaN(new Date($).getTime())), TypeSystem.Format("date-time", ($) => !Number.isNaN(new Date($).getTime()));
} catch {
}
var o1 = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var G1 = ($, Z) => {
  if (!(Z instanceof Blob))
    return false;
  if ($.minSize && Z.size < o1($.minSize))
    return false;
  if ($.maxSize && Z.size > o1($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!Z.type.startsWith($.extension))
        return false;
    } else {
      for (let X = 0;X < $.extension.length; X++)
        if (Z.type.startsWith($.extension[X]))
          return true;
      return false;
    }
  return true;
};
var L$ = TypeSystem.Type("Files", ($, Z) => {
  if (!Array.isArray(Z))
    return G1($, Z);
  if ($.minItems && Z.length < $.minItems)
    return false;
  if ($.maxItems && Z.length > $.maxItems)
    return false;
  for (let X = 0;X < Z.length; X++)
    if (!G1($, Z[X]))
      return false;
  return true;
});
exports_format.Set("numeric", ($) => !!$ && !isNaN(+$));
exports_format.Set("boolean", ($) => $ === "true" || $ === "false");
exports_format.Set("ObjectString", ($) => {
  let Z = $.charCodeAt(0);
  if (Z === 9 || Z === 10 || Z === 32)
    Z = $.trimStart().charCodeAt(0);
  if (Z !== 123 && Z !== 91)
    return false;
  try {
    return JSON.parse($), true;
  } catch {
    return false;
  }
});
var a = { Numeric: ($) => {
  const Z = Type.Number($);
  return R.Transform(R.Union([R.String({ format: "numeric", default: 0 }), R.Number($)], $)).Decode((X) => {
    const W = +X;
    if (isNaN(W))
      return X;
    if ($ && !exports_value2.Check(Z, W))
      throw new q("property", Z, W);
    return W;
  }).Encode((X) => X);
}, BooleanString: ($) => {
  const Z = Type.Boolean($);
  return R.Transform(R.Union([R.String({ format: "boolean", default: false }), R.Boolean($)], $)).Decode((X) => {
    if (typeof X === "string")
      return X === "true";
    if ($ && !exports_value2.Check(Z, X))
      throw new q("property", Z, X);
    return X;
  }).Encode((X) => X);
}, ObjectString: ($, Z) => R.Transform(R.Union([R.String({ format: "ObjectString", default: "" }), R.Object($, Z)], Z)).Decode((X) => {
  if (typeof X === "string")
    try {
      return JSON.parse(X);
    } catch {
      return X;
    }
  return X;
}).Encode((X) => JSON.stringify(X)), File: TypeSystem.Type("File", G1), Files: ($ = {}) => R.Transform(R.Union([L$($)])).Decode((Z) => {
  if (Array.isArray(Z))
    return Z;
  return [Z];
}).Encode((Z) => Z), Nullable: ($) => R.Union([R.Null(), $]), MaybeEmpty: ($) => R.Union([R.Null(), R.Undefined(), $]), Cookie: ($, Z) => R.Object($, Z) };
R.BooleanString = a.BooleanString;
R.ObjectString = a.ObjectString;
R.Numeric = a.Numeric;
R.File = ($ = {}) => a.File({ default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
R.Files = ($ = {}) => a.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });
R.Nullable = ($) => a.Nullable($);
R.MaybeEmpty = a.MaybeEmpty;
R.Cookie = a.Cookie;

class n {
  config;
  dependencies = {};
  store = {};
  decorators = {};
  definitions = { type: {}, error: {} };
  schema = {};
  macros = [];
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], mapResponse: [], onResponse: [], trace: [], error: [], stop: [] };
  reporter = new F1;
  server = null;
  getServer() {
    return this.server;
  }
  validator = null;
  router = new o;
  wsRouter = new o;
  routes = [];
  staticRouter = { handlers: [], variables: "", map: {}, all: "" };
  wsPaths = {};
  dynamicRouter = new o;
  lazyLoadModules = [];
  path = "";
  stack = undefined;
  constructor($) {
    if (this.config = { forceErrorEncapsulation: true, prefix: "", aot: true, strictPath: false, scoped: false, cookie: {}, analytic: false, ...$ || {}, seed: $?.seed === undefined ? "" : $?.seed }, $?.analytic && ($?.name || $?.seed !== undefined))
      this.stack = new Error().stack;
  }
  add($, Z, X, W, { allowMeta: J = false, skipPrefix: Q = false } = { allowMeta: false, skipPrefix: false }) {
    if (typeof Z === "string")
      Z = [Z];
    for (let Y of Z) {
      if (Y = Y === "" ? Y : Y.charCodeAt(0) === 47 ? Y : `/${Y}`, this.config.prefix && !Q && !this.config.scoped)
        Y = this.config.prefix + Y;
      if (W?.type)
        switch (W.type) {
          case "text":
            W.type = "text/plain";
            break;
          case "json":
            W.type = "application/json";
            break;
          case "formdata":
            W.type = "multipart/form-data";
            break;
          case "urlencoded":
            W.type = "application/x-www-form-urlencoded";
            break;
          case "arrayBuffer":
            W.type = "application/octet-stream";
            break;
          default:
            break;
        }
      const _ = this.definitions.type;
      let B = p(W?.cookie ?? this.validator?.cookie, { dynamic: !this.config.aot, models: _, additionalProperties: true });
      if (u(this.config.cookie ?? {}))
        if (B)
          B.schema = R1(B.schema, this.config.cookie ?? {});
        else
          B = p(R.Cookie({}, this.config.cookie), { dynamic: !this.config.aot, models: _, additionalProperties: true });
      const K = { body: p(W?.body ?? this.validator?.body, { dynamic: !this.config.aot, models: _ }), headers: p(W?.headers ?? this.validator?.headers, { dynamic: !this.config.aot, models: _, additionalProperties: true }), params: p(W?.params ?? this.validator?.params, { dynamic: !this.config.aot, models: _ }), query: p(W?.query ?? this.validator?.query, { dynamic: !this.config.aot, models: _ }), cookie: B, response: s0(W?.response ?? this.validator?.response, { dynamic: !this.config.aot, models: _ }) }, G = this.event, U = Y.endsWith("/") ? Y.slice(0, Y.length - 1) : Y + "/";
      if (this.macros.length) {
        const M = (F) => (V, D) => {
          if (typeof V === "function" || Array.isArray(V)) {
            if (!W[F])
              W[F] = [];
            if (typeof W[F] === "function")
              W[F] = [W[F]];
            if (Array.isArray(V))
              W[F] = W[F].concat(V);
            else
              W[F].push(V);
            return;
          }
          const { insert: m = "after", stack: V0 = "local" } = V;
          if (V0 === "global") {
            if (!Array.isArray(D))
              if (m === "before")
                G[F].unshift(D);
              else
                G[F].push(D);
            else if (m === "before")
              G[F] = D.concat(G[F]);
            else
              G[F] = G[F].concat(D);
            return;
          } else {
            if (!W[F])
              W[F] = [];
            if (typeof W[F] === "function")
              W[F] = [W[F]];
            if (!Array.isArray(D))
              if (m === "before")
                W[F].unshift(D);
              else
                W[F].push(D);
            else if (m === "before")
              W[F] = D.concat(W[F]);
            else
              W[F] = W[F].concat(D);
            return;
          }
        }, N = { events: { global: G, local: W }, onParse: M("parse"), onTransform: M("transform"), onBeforeHandle: M("beforeHandle"), onAfterHandle: M("afterHandle"), onResponse: M("onResponse"), onError: M("error") };
        for (let F of this.macros)
          o0(F(N), W);
      }
      const w = s(G, W), A = typeof X === "function";
      if (this.config.aot === false) {
        if (this.dynamicRouter.add($, Y, { validator: K, hooks: w, content: W?.type, handle: X }), this.config.strictPath === false)
          this.dynamicRouter.add($, U, { validator: K, hooks: w, content: W?.type, handle: X });
        this.routes.push({ method: $, path: Y, composed: null, handler: X, hooks: w });
        return;
      }
      const z = t1({ path: Y, method: $, hooks: w, validator: K, handler: X, handleError: this.handleError, onRequest: this.event.request, config: this.config, definitions: J ? this.definitions.type : undefined, schema: J ? this.schema : undefined, getReporter: () => this.reporter, setHeader: this.setHeaders });
      if (!A) {
        const M = Object.assign({ headers: {}, query: {}, params: {}, body: undefined, request: new Request(`http://localhost${Y}`), store: this.store, path: Y, set: { headers: this.setHeaders ?? {}, status: 200 } }, this.decorators);
        let N;
        for (let F of Object.values(w.request))
          try {
            const V = y(F(M), M.set);
            if (V !== undefined) {
              N = V;
              break;
            }
          } catch (V) {
            N = this.handleError(M, V);
            break;
          }
        if (N)
          z.response = N;
        else
          try {
            z.response = z(M);
          } catch (F) {
            z.response = this.handleError(M, F);
          }
      }
      const P = this.routes.findIndex((M) => M.path === Y && M.method === $);
      if (P !== -1)
        this.routes.splice(P, 1);
      if (this.routes.push({ method: $, path: Y, composed: z, handler: X, hooks: w }), $ === "$INTERNALWS") {
        const M = this.config.strictPath ? undefined : Y.endsWith("/") ? Y.slice(0, Y.length - 1) : Y + "/";
        if (Y.indexOf(":") === -1 && Y.indexOf("*") === -1) {
          const N = this.staticRouter.handlers.length;
          if (this.staticRouter.handlers.push(z), z.response instanceof Response)
            this.staticRouter.variables += `const st${N} = staticRouter.handlers[${N}].response\n`;
          else
            this.staticRouter.variables += `const st${N} = staticRouter.handlers[${N}]\n`;
          if (this.wsPaths[Y] = N, M)
            this.wsPaths[M] = N;
        } else if (this.wsRouter.add("ws", Y, z), M)
          this.wsRouter.add("ws", M, z);
        return;
      }
      if (Y.indexOf(":") === -1 && Y.indexOf("*") === -1) {
        const M = this.staticRouter.handlers.length;
        if (this.staticRouter.handlers.push(z), z.response instanceof Response)
          this.staticRouter.variables += `const st${M} = staticRouter.handlers[${M}].response\n`;
        else
          this.staticRouter.variables += `const st${M} = staticRouter.handlers[${M}]\n`;
        if (!this.staticRouter.map[Y])
          this.staticRouter.map[Y] = { code: "" };
        if ($ === "ALL")
          this.staticRouter.map[Y].all = `default: return st${M}(ctx)\n`;
        else if (z.response instanceof Response)
          this.staticRouter.map[Y].code = `case '${$}': return st${M}.clone()\n${this.staticRouter.map[Y].code}`;
        else
          this.staticRouter.map[Y].code = `case '${$}': return st${M}(ctx)\n${this.staticRouter.map[Y].code}`;
        if (!this.config.strictPath) {
          if (!this.staticRouter.map[U])
            this.staticRouter.map[U] = { code: "" };
          if ($ === "ALL")
            this.staticRouter.map[U].all = `default: return st${M}(ctx)\n`;
          else if (z.response instanceof Response)
            this.staticRouter.map[U].code = `case '${$}': return st${M}.clone()\n${this.staticRouter.map[U].code}`;
          else
            this.staticRouter.map[U].code = `case '${$}': return st${M}(ctx)\n${this.staticRouter.map[U].code}`;
        }
      } else if (this.router.add($, Y, z), !this.config.strictPath)
        this.router.add($, Y.endsWith("/") ? Y.slice(0, Y.length - 1) : Y + "/", z);
    }
  }
  setHeaders;
  headers($) {
    if (!$)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    return this.setHeaders = d(this.setHeaders, $), this;
  }
  onStart($) {
    return this.on("start", $), this;
  }
  onRequest($) {
    return this.on("request", $), this;
  }
  onParse($) {
    return this.on("parse", $), this;
  }
  onTransform($) {
    return this.on("transform", $), this;
  }
  resolve($) {
    return $.$elysia = "resolve", this.onBeforeHandle($);
  }
  onBeforeHandle($) {
    return this.on("beforeHandle", $), this;
  }
  onAfterHandle($) {
    return this.on("afterHandle", $), this;
  }
  mapResponse($) {
    return this.on("mapResponse", $), this;
  }
  onResponse($) {
    return this.on("response", $), this;
  }
  trace($) {
    return this.reporter.on("event", j1(() => this.reporter, this.event.trace.length, $)), this.on("trace", $), this;
  }
  error($, Z) {
    switch (typeof $) {
      case "string":
        return Z.prototype[_0] = $, this.definitions.error[$] = Z, this;
      case "function":
        return this.definitions.error = $(this.definitions.error), this;
    }
    for (let [X, W] of Object.entries($))
      W.prototype[_0] = X, this.definitions.error[X] = W;
    return this;
  }
  onError($) {
    return this.on("error", $), this;
  }
  onStop($) {
    return this.on("stop", $), this;
  }
  on($, Z) {
    for (let X of Array.isArray(Z) ? Z : [Z])
      switch (X = C1(X), $) {
        case "start":
          this.event.start.push(X);
          break;
        case "request":
          this.event.request.push(X);
          break;
        case "parse":
          this.event.parse.splice(this.event.parse.length - 1, 0, X);
          break;
        case "transform":
          this.event.transform.push(X);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(X);
          break;
        case "afterHandle":
          this.event.afterHandle.push(X);
          break;
        case "mapResponse":
          this.event.mapResponse.push(X);
          break;
        case "response":
          this.event.onResponse.push(X);
          break;
        case "trace":
          this.event.trace.push(X);
          break;
        case "error":
          this.event.error.push(X);
          break;
        case "stop":
          this.event.stop.push(X);
          break;
      }
    return this;
  }
  group($, Z, X) {
    const W = new n({ ...this.config || {}, prefix: "" });
    W.store = this.store, W.definitions = this.definitions, W.getServer = () => this.server;
    const J = typeof Z === "object", Q = (J ? X : Z)(W);
    if (this.decorators = d(this.decorators, W.decorators), Q.event.request.length)
      this.event.request = [...this.event.request || [], ...Q.event.request || []];
    if (Q.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse || [], ...Q.event.onResponse || []];
    return this.model(Q.definitions.type), Object.values(W.routes).forEach(({ method: Y, path: _, handler: B, hooks: K }) => {
      if (_ = (J ? "" : this.config.prefix) + $ + _, J) {
        const G = Z, U = K;
        this.add(Y, _, B, s(G, { ...U || {}, error: !U.error ? Q.event.error : Array.isArray(U.error) ? [...U.error || {}, ...Q.event.error || {}] : [U.error, ...Q.event.error || {}] }));
      } else
        this.add(Y, _, B, s(K, { error: Q.event.error }), { skipPrefix: true });
    }), this;
  }
  guard($, Z) {
    if (!Z)
      return this.event = v0(this.event, $), this.validator = { body: $.body, headers: $.headers, params: $.params, query: $.query, response: $.response }, this;
    const X = new n({ ...this.config || {}, prefix: "" });
    X.store = this.store, X.definitions = this.definitions;
    const W = Z(X);
    if (this.decorators = d(this.decorators, X.decorators), W.event.request.length)
      this.event.request = [...this.event.request || [], ...W.event.request || []];
    if (W.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse || [], ...W.event.onResponse || []];
    return this.model(W.definitions.type), Object.values(X.routes).forEach(({ method: J, path: Q, handler: Y, hooks: _ }) => {
      this.add(J, Q, Y, s($, { ..._ || {}, error: !_.error ? W.event.error : Array.isArray(_.error) ? [..._.error || {}, ...W.event.error || []] : [_.error, ...W.event.error || []] }));
    }), this;
  }
  use($) {
    if ($ instanceof Promise)
      return this.lazyLoadModules.push($.then((Z) => {
        if (typeof Z === "function")
          return Z(this);
        if (typeof Z.default === "function")
          return Z.default(this);
        return this._use(Z);
      }).then((Z) => Z.compile())), this;
    else
      return this._use($);
    return this;
  }
  _use($) {
    if (typeof $ === "function") {
      const J = $(this);
      if (J instanceof Promise)
        return this.lazyLoadModules.push(J.then((Q) => {
          if (Q instanceof n) {
            this.compile();
            for (let { method: Y, path: _, handler: B, hooks: K } of Object.values(Q.routes))
              this.add(Y, _, B, s(K, { error: Q.event.error }));
            return Q;
          }
          if (typeof Q === "function")
            return Q(this);
          if (typeof Q.default === "function")
            return Q.default(this);
          return this._use(Q);
        }).then((Q) => Q.compile())), this;
      return J;
    }
    const { name: Z, seed: X } = $.config;
    $.getServer = () => this.getServer(), this.headers($.setHeaders);
    const W = $.config.scoped;
    if (W) {
      if (Z) {
        if (!(Z in this.dependencies))
          this.dependencies[Z] = [];
        const Q = X !== undefined ? N0(Z + JSON.stringify(X)) : 0;
        if (this.dependencies[Z].some(({ checksum: Y }) => Q === Y))
          return this;
        this.dependencies[Z].push(!this.config?.analytic ? { name: $.config.name, seed: $.config.seed, checksum: Q, dependencies: $.dependencies } : { name: $.config.name, seed: $.config.seed, checksum: Q, dependencies: $.dependencies, stack: $.stack, routes: $.routes, decorators: $.decorators, store: $.store, type: $.definitions.type, error: $.definitions.error, derive: $.event.transform.filter((Y) => Y.$elysia === "derive").map((Y) => ({ fn: Y.toString(), stack: new Error().stack ?? "" })), resolve: $.event.transform.filter((Y) => Y.$elysia === "derive").map((Y) => ({ fn: Y.toString(), stack: new Error().stack ?? "" })) });
      }
      if ($.model(this.definitions.type), $.error(this.definitions.error), $.macros = [...this.macros || [], ...$.macros || []], $.onRequest((Q) => {
        Object.assign(Q, this.decorators), Object.assign(Q.store, this.store);
      }), $.event.trace = [...this.event.trace || [], ...$.event.trace || []], $.config.aot)
        $.compile();
      if (W && !$.config.prefix)
        console.warn("When using scoped plugins it is recommended to use a prefix, else routing may not work correctly for the second scoped instance");
      let J;
      if (W && $.config.prefix)
        J = this.mount($.config.prefix + "/", $.fetch);
      else
        J = this.mount($.fetch);
      return this.routes = this.routes.concat(J.routes), this;
    } else {
      $.reporter = this.reporter;
      for (let J of $.event.trace)
        this.trace(J);
      if (Z) {
        if (!(Z in this.dependencies))
          this.dependencies[Z] = [];
        const J = X !== undefined ? N0(Z + JSON.stringify(X)) : 0;
        if (!this.dependencies[Z].some(({ checksum: Y }) => J === Y))
          this.macros.push(...$.macros || []);
        const Q = [];
        for (let Y = 0;Y < this.macros.length; Y++) {
          const _ = this.macros[Y];
          if (Q.includes(_.$elysiaChecksum))
            this.macros.splice(Y, 1), Y--;
          Q.push(_.$elysiaChecksum);
        }
      }
    }
    this.decorate($.decorators), this.state($.store), this.model($.definitions.type), this.error($.definitions.error);
    for (let { method: J, path: Q, handler: Y, hooks: _ } of Object.values($.routes))
      this.add(J, Q, Y, s(_, { error: $.event.error }));
    if (!W)
      if (Z) {
        if (!(Z in this.dependencies))
          this.dependencies[Z] = [];
        const J = X !== undefined ? N0(Z + JSON.stringify(X)) : 0;
        if (this.dependencies[Z].some(({ checksum: Q }) => J === Q))
          return this;
        this.dependencies[Z].push(!this.config?.analytic ? { name: $.config.name, seed: $.config.seed, checksum: J, dependencies: $.dependencies } : { name: $.config.name, seed: $.config.seed, checksum: J, dependencies: $.dependencies, stack: $.stack, routes: $.routes, decorators: $.decorators, store: $.store, type: $.definitions.type, error: $.definitions.error, derive: $.event.transform.filter((Q) => Q?.$elysia === "derive").map((Q) => ({ fn: Q.toString(), stack: new Error().stack ?? "" })), resolve: $.event.transform.filter((Q) => Q?.$elysia === "resolve").map((Q) => ({ fn: Q.toString(), stack: new Error().stack ?? "" })) }), this.event = v0(this.event, a0($.event), J);
      } else
        this.event = v0(this.event, a0($.event));
    return this;
  }
  macro($) {
    return $.$elysiaChecksum = N0(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: $.toString() })), this.macros.push($), this;
  }
  mount($, Z) {
    if ($ instanceof n || typeof $ === "function" || $.length === 0 || $ === "/") {
      const J = typeof $ === "function" ? $ : $ instanceof n ? $.compile().fetch : Z instanceof n ? Z.compile().fetch : Z, Q = async ({ request: Y, path: _ }) => J(new Request(t0(Y.url, _ || "/"), Y));
      return this.all("/", Q, { type: "none" }), this.all("/*", Q, { type: "none" }), this;
    }
    const X = $.length;
    if (Z instanceof n)
      Z = Z.compile().fetch;
    const W = async ({ request: J, path: Q }) => Z(new Request(t0(J.url, Q.slice(X) || "/"), J));
    return this.all($, W, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), W, { type: "none" }), this;
  }
  get($, Z, X) {
    return this.add("GET", $, Z, X), this;
  }
  post($, Z, X) {
    return this.add("POST", $, Z, X), this;
  }
  put($, Z, X) {
    return this.add("PUT", $, Z, X), this;
  }
  patch($, Z, X) {
    return this.add("PATCH", $, Z, X), this;
  }
  delete($, Z, X) {
    return this.add("DELETE", $, Z, X), this;
  }
  options($, Z, X) {
    return this.add("OPTIONS", $, Z, X), this;
  }
  all($, Z, X) {
    return this.add("ALL", $, Z, X), this;
  }
  head($, Z, X) {
    return this.add("HEAD", $, Z, X), this;
  }
  connect($, Z, X) {
    return this.add("CONNECT", $, Z, X), this;
  }
  ws($, Z) {
    const X = Z.transformMessage ? Array.isArray(Z.transformMessage) ? Z.transformMessage : [Z.transformMessage] : undefined;
    let W = null;
    const J = p(Z?.body, { models: this.definitions.type }), Q = p(Z?.response, { models: this.definitions.type }), Y = (_) => {
      if (typeof _ === "string") {
        const B = _?.charCodeAt(0);
        if (B === 47 || B === 123)
          try {
            _ = JSON.parse(_);
          } catch {
          }
        else if (f0(_))
          _ = +_;
      }
      if (X?.length)
        for (let B = 0;B < X.length; B++) {
          const K = X[B](_);
          if (K !== undefined)
            _ = K;
        }
      return _;
    };
    return this.route("$INTERNALWS", $, (_) => {
      const { set: B, path: K, qi: G, headers: U, query: w, params: A } = _;
      if (W === null)
        W = this.getServer();
      if (W?.upgrade(_.request, { headers: typeof Z.upgrade === "function" ? Z.upgrade(_) : Z.upgrade, data: { validator: Q, open(z) {
        Z.open?.(new D0(z, _));
      }, message: (z, P) => {
        const M = Y(P);
        if (J?.Check(M) === false)
          return void z.send(new q("message", J, M).message);
        Z.message?.(new D0(z, _), M);
      }, drain(z) {
        Z.drain?.(new D0(z, _));
      }, close(z, P, M) {
        Z.close?.(new D0(z, _), P, M);
      } } }))
        return;
      return B.status = 400, "Expected a websocket connection";
    }, { beforeHandle: Z.beforeHandle, transform: Z.transform, headers: Z.headers, params: Z.params, query: Z.query }), this;
  }
  route($, Z, X, { config: W, ...J } = { config: { allowMeta: false } }) {
    return this.add($, Z, X, J, W), this;
  }
  state($, Z) {
    switch (typeof $) {
      case "object":
        return this.store = d(this.store, $), this;
      case "function":
        return this.store = $(this.store), this;
    }
    if (!($ in this.store))
      this.store[$] = Z;
    return this;
  }
  decorate($, Z) {
    switch (typeof $) {
      case "object":
        return this.decorators = d(this.decorators, $), this;
      case "function":
        return this.decorators = $(this.decorators), this;
    }
    if (!($ in this.decorators))
      this.decorators[$] = Z;
    return this;
  }
  derive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  model($, Z) {
    switch (typeof $) {
      case "object":
        return Object.entries($).forEach(([X, W]) => {
          if (!(X in this.definitions.type))
            this.definitions.type[X] = W;
        }), this;
      case "function":
        return this.definitions.type = $(this.definitions.type), this;
    }
    return this.definitions.type[$] = Z, this;
  }
  mapDerive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  affix($, Z, X) {
    if (X === "")
      return this;
    const W = ["_", "-", " "], J = (B) => B[0].toUpperCase() + B.slice(1), Q = $ === "prefix" ? (B, K) => W.includes(B.at(-1) ?? "") ? B + K : B + J(K) : W.includes(X.at(-1) ?? "") ? (B, K) => K + B : (B, K) => K + J(B), Y = (B) => {
      const K = {};
      switch (B) {
        case "decorator":
          for (let G in this.decorators)
            K[Q(X, G)] = this.decorators[G];
          this.decorators = K;
          break;
        case "state":
          for (let G in this.store)
            K[Q(X, G)] = this.store[G];
          this.store = K;
          break;
        case "model":
          for (let G in this.definitions.type)
            K[Q(X, G)] = this.definitions.type[G];
          this.definitions.type = K;
          break;
        case "error":
          for (let G in this.definitions.error)
            K[Q(X, G)] = this.definitions.error[G];
          this.definitions.error = K;
          break;
      }
    }, _ = Array.isArray(Z) ? Z : [Z];
    for (let B of _.some((K) => K === "all") ? ["decorator", "state", "model", "error"] : _)
      Y(B);
    return this;
  }
  prefix($, Z) {
    return this.affix("prefix", $, Z);
  }
  suffix($, Z) {
    return this.affix("suffix", $, Z);
  }
  compile() {
    if (this.fetch = this.config.aot ? Q1(this) : _1(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server || {}, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => {
    return (this.fetch = this.config.aot ? Q1(this) : _1(this))($);
  };
  handleError = async ($, Z) => (this.handleError = this.config.aot ? B1(this) : s1(this))($, Z);
  outerErrorHandler = ($) => new Response($.message || $.name || "Error", { status: $?.status ?? 500 });
  listen = ($, Z) => {
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (this.compile(), typeof $ === "string") {
      if ($ = +$.trim(), Number.isNaN($))
        throw new Error("Port must be a numeric value");
    }
    const X = this.fetch, W = typeof $ === "object" ? { development: !F0, reusePort: true, ...this.config.serve || {}, ...$ || {}, websocket: { ...this.config.websocket || {}, ...$1 || {} }, fetch: X, error: this.outerErrorHandler } : { development: !F0, reusePort: true, ...this.config.serve || {}, websocket: { ...this.config.websocket || {}, ...$1 || {} }, port: $, fetch: X, error: this.outerErrorHandler };
    if (this.server = Bun?.serve(W), this.event.start.length)
      for (let J = 0;J < this.event.start.length; J++)
        this.event.start[J](this);
    if (Z)
      Z(this.server);
    return process.on("beforeExit", () => {
      for (let J = 0;J < this.event.stop.length; J++)
        this.event.stop[J](this);
    }), Promise.all(this.lazyLoadModules).then(() => {
      Bun?.gc(false);
    }), this;
  };
  stop = async () => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server.stop(), this.event.stop.length)
      for (let $ = 0;$ < this.event.stop.length; $++)
        this.event.stop[$](this);
  };
  get modules() {
    return Promise.all(this.lazyLoadModules);
  }
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/value/guard/guard.mjs
function IsAsyncIterator4(value14) {
  return IsObject4(value14) && Symbol.asyncIterator in value14;
}
function IsIterator4(value14) {
  return IsObject4(value14) && Symbol.iterator in value14;
}
function IsTypedArray2(value14) {
  return ArrayBuffer.isView(value14);
}
function IsPromise3(value14) {
  return value14 instanceof Promise;
}
function IsUint8Array4(value14) {
  return value14 instanceof Uint8Array;
}
function IsDate4(value14) {
  return value14 instanceof Date && Number.isFinite(value14.getTime());
}
function HasPropertyKey2(value14, key) {
  return key in value14;
}
function IsPlainObject2(value14) {
  return IsObject4(value14) && IsFunction4(value14.constructor) && value14.constructor.name === "Object";
}
function IsObject4(value14) {
  return value14 !== null && typeof value14 === "object";
}
function IsArray4(value14) {
  return Array.isArray(value14) && !ArrayBuffer.isView(value14);
}
function IsUndefined4(value14) {
  return value14 === undefined;
}
function IsNull4(value14) {
  return value14 === null;
}
function IsBoolean4(value14) {
  return typeof value14 === "boolean";
}
function IsNumber4(value14) {
  return typeof value14 === "number";
}
function IsInteger3(value14) {
  return IsNumber4(value14) && Number.isInteger(value14);
}
function IsBigInt4(value14) {
  return typeof value14 === "bigint";
}
function IsString4(value14) {
  return typeof value14 === "string";
}
function IsFunction4(value14) {
  return typeof value14 === "function";
}
function IsSymbol4(value14) {
  return typeof value14 === "symbol";
}
function IsValueType2(value14) {
  return IsBigInt4(value14) || IsBoolean4(value14) || IsNull4(value14) || IsNumber4(value14) || IsString4(value14) || IsSymbol4(value14) || IsUndefined4(value14);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/system/policy.mjs
var TypeSystemPolicy2;
(function(TypeSystemPolicy3) {
  TypeSystemPolicy3.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy3.AllowArrayObject = false;
  TypeSystemPolicy3.AllowNaN = false;
  TypeSystemPolicy3.AllowNullVoid = false;
  function IsExactOptionalProperty(value14, key) {
    return TypeSystemPolicy3.ExactOptionalPropertyTypes ? key in value14 : value14[key] !== undefined;
  }
  TypeSystemPolicy3.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value14) {
    const isObject = IsObject4(value14);
    return TypeSystemPolicy3.AllowArrayObject ? isObject : isObject && !IsArray4(value14);
  }
  TypeSystemPolicy3.IsObjectLike = IsObjectLike;
  function IsRecordLike(value14) {
    return IsObjectLike(value14) && !(value14 instanceof Date) && !(value14 instanceof Uint8Array);
  }
  TypeSystemPolicy3.IsRecordLike = IsRecordLike;
  function IsNumberLike(value14) {
    const isNumber = IsNumber4(value14);
    return TypeSystemPolicy3.AllowNaN ? isNumber : isNumber && Number.isFinite(value14);
  }
  TypeSystemPolicy3.IsNumberLike = IsNumberLike;
  function IsVoidLike(value14) {
    const isUndefined = IsUndefined4(value14);
    return TypeSystemPolicy3.AllowNullVoid ? isUndefined || value14 === null : isUndefined;
  }
  TypeSystemPolicy3.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy2 || (TypeSystemPolicy2 = {}));
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/registry/format.mjs
var exports_format2 = {};
__export(exports_format2, {
  Set: () => {
    {
      return Set5;
    }
  },
  Has: () => {
    {
      return Has4;
    }
  },
  Get: () => {
    {
      return Get4;
    }
  },
  Entries: () => {
    {
      return Entries3;
    }
  },
  Delete: () => {
    {
      return Delete5;
    }
  },
  Clear: () => {
    {
      return Clear3;
    }
  }
});
function Entries3() {
  return new Map(map3);
}
function Clear3() {
  return map3.clear();
}
function Delete5(format) {
  return map3.delete(format);
}
function Has4(format) {
  return map3.has(format);
}
function Set5(format, func) {
  map3.set(format, func);
}
function Get4(format) {
  return map3.get(format);
}
var map3 = new Map;
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/registry/type.mjs
var exports_type5 = {};
__export(exports_type5, {
  Set: () => {
    {
      return Set6;
    }
  },
  Has: () => {
    {
      return Has5;
    }
  },
  Get: () => {
    {
      return Get5;
    }
  },
  Entries: () => {
    {
      return Entries4;
    }
  },
  Delete: () => {
    {
      return Delete6;
    }
  },
  Clear: () => {
    {
      return Clear4;
    }
  }
});
function Entries4() {
  return new Map(map4);
}
function Clear4() {
  return map4.clear();
}
function Delete6(kind) {
  return map4.delete(kind);
}
function Has5(kind) {
  return map4.has(kind);
}
function Set6(kind, func) {
  map4.set(kind, func);
}
function Get5(kind) {
  return map4.get(kind);
}
var map4 = new Map;
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/symbols/symbols.mjs
var TransformKind2 = Symbol.for("TypeBox.Transform");
var ReadonlyKind2 = Symbol.for("TypeBox.Readonly");
var OptionalKind2 = Symbol.for("TypeBox.Optional");
var Hint2 = Symbol.for("TypeBox.Hint");
var Kind2 = Symbol.for("TypeBox.Kind");
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/unsafe/unsafe.mjs
function Unsafe2(options = {}) {
  return {
    ...options,
    [Kind2]: options[Kind2] ?? "Unsafe"
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/error/error.mjs
class TypeBoxError2 extends Error {
  constructor(message) {
    super(message);
  }
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/system/system.mjs
class TypeSystemDuplicateTypeKind2 extends TypeBoxError2 {
  constructor(kind) {
    super(`Duplicate type kind '${kind}' detected`);
  }
}

class TypeSystemDuplicateFormat2 extends TypeBoxError2 {
  constructor(kind) {
    super(`Duplicate string format '${kind}' detected`);
  }
}
var TypeSystem2;
(function(TypeSystem3) {
  function Type2(kind, check10) {
    if (exports_type5.Has(kind))
      throw new TypeSystemDuplicateTypeKind2(kind);
    exports_type5.Set(kind, check10);
    return (options = {}) => Unsafe2({ ...options, [Kind2]: kind });
  }
  TypeSystem3.Type = Type2;
  function Format2(format, check10) {
    if (exports_format2.Has(format))
      throw new TypeSystemDuplicateFormat2(format);
    exports_format2.Set(format, check10);
    return format;
  }
  TypeSystem3.Format = Format2;
})(TypeSystem2 || (TypeSystem2 = {}));
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/mapped/mapped-result.mjs
function MappedResult2(properties) {
  return {
    [Kind2]: "MappedResult",
    properties
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/clone/type.mjs
var exports_type6 = {};
__export(exports_type6, {
  CloneType: () => {
    {
      return CloneType2;
    }
  },
  CloneRest: () => {
    {
      return CloneRest2;
    }
  }
});

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/guard/value.mjs
var exports_value4 = {};
__export(exports_value4, {
  IsUndefined: () => {
    {
      return IsUndefined5;
    }
  },
  IsUint8Array: () => {
    {
      return IsUint8Array5;
    }
  },
  IsSymbol: () => {
    {
      return IsSymbol5;
    }
  },
  IsString: () => {
    {
      return IsString5;
    }
  },
  IsRegExp: () => {
    {
      return IsRegExp3;
    }
  },
  IsObject: () => {
    {
      return IsObject5;
    }
  },
  IsNumber: () => {
    {
      return IsNumber5;
    }
  },
  IsNull: () => {
    {
      return IsNull5;
    }
  },
  IsIterator: () => {
    {
      return IsIterator5;
    }
  },
  IsFunction: () => {
    {
      return IsFunction5;
    }
  },
  IsDate: () => {
    {
      return IsDate5;
    }
  },
  IsBoolean: () => {
    {
      return IsBoolean5;
    }
  },
  IsBigInt: () => {
    {
      return IsBigInt5;
    }
  },
  IsAsyncIterator: () => {
    {
      return IsAsyncIterator5;
    }
  },
  IsArray: () => {
    {
      return IsArray5;
    }
  }
});
function IsAsyncIterator5(value14) {
  return IsObject5(value14) && !IsArray5(value14) && !IsUint8Array5(value14) && Symbol.asyncIterator in value14;
}
function IsArray5(value14) {
  return Array.isArray(value14);
}
function IsBigInt5(value14) {
  return typeof value14 === "bigint";
}
function IsBoolean5(value14) {
  return typeof value14 === "boolean";
}
function IsDate5(value14) {
  return value14 instanceof globalThis.Date;
}
function IsFunction5(value14) {
  return typeof value14 === "function";
}
function IsIterator5(value14) {
  return IsObject5(value14) && !IsArray5(value14) && !IsUint8Array5(value14) && Symbol.iterator in value14;
}
function IsNull5(value14) {
  return value14 === null;
}
function IsNumber5(value14) {
  return typeof value14 === "number";
}
function IsObject5(value14) {
  return typeof value14 === "object" && value14 !== null;
}
function IsRegExp3(value14) {
  return value14 instanceof globalThis.RegExp;
}
function IsString5(value14) {
  return typeof value14 === "string";
}
function IsSymbol5(value14) {
  return typeof value14 === "symbol";
}
function IsUint8Array5(value14) {
  return value14 instanceof globalThis.Uint8Array;
}
function IsUndefined5(value14) {
  return value14 === undefined;
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/clone/value.mjs
var ArrayType7 = function(value14) {
  return value14.map((value15) => Visit17(value15));
};
var DateType5 = function(value14) {
  return new Date(value14.getTime());
};
var Uint8ArrayType3 = function(value14) {
  return new Uint8Array(value14);
};
var RegExpType2 = function(value14) {
  return new RegExp(value14.source, value14.flags);
};
var ObjectType7 = function(value14) {
  const clonedProperties = Object.getOwnPropertyNames(value14).reduce((acc, key) => ({ ...acc, [key]: Visit17(value14[key]) }), {});
  const clonedSymbols = Object.getOwnPropertySymbols(value14).reduce((acc, key) => ({ ...acc, [key]: Visit17(value14[key]) }), {});
  return { ...clonedProperties, ...clonedSymbols };
};
var Visit17 = function(value14) {
  return IsArray5(value14) ? ArrayType7(value14) : IsDate5(value14) ? DateType5(value14) : IsUint8Array5(value14) ? Uint8ArrayType3(value14) : IsRegExp3(value14) ? RegExpType2(value14) : IsObject5(value14) ? ObjectType7(value14) : value14;
};
function Clone4(value14) {
  return Visit17(value14);
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/clone/type.mjs
function CloneRest2(schemas) {
  return schemas.map((schema) => CloneType2(schema));
}
function CloneType2(schema, options = {}) {
  return { ...Clone4(schema), ...options };
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/discard/discard.mjs
var DiscardKey2 = function(value15, key) {
  const { [key]: _, ...rest3 } = value15;
  return rest3;
};
function Discard2(value15, keys) {
  return keys.reduce((acc, key) => DiscardKey2(acc, key), value15);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/array/array.mjs
function Array3(schema, options = {}) {
  return {
    ...options,
    [Kind2]: "Array",
    type: "array",
    items: CloneType2(schema)
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/async-iterator/async-iterator.mjs
function AsyncIterator2(items, options = {}) {
  return {
    ...options,
    [Kind2]: "AsyncIterator",
    type: "AsyncIterator",
    items: CloneType2(items)
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/constructor/constructor.mjs
function Constructor2(parameters3, returns, options) {
  return {
    ...options,
    [Kind2]: "Constructor",
    type: "Constructor",
    parameters: CloneRest2(parameters3),
    returns: CloneType2(returns)
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/function/function.mjs
function Function3(parameters3, returns, options) {
  return {
    ...options,
    [Kind2]: "Function",
    type: "Function",
    parameters: CloneRest2(parameters3),
    returns: CloneType2(returns)
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/never/never.mjs
function Never2(options = {}) {
  return {
    ...options,
    [Kind2]: "Never",
    not: {}
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/guard/type.mjs
var exports_type7 = {};
__export(exports_type7, {
  TypeGuardUnknownTypeError: () => {
    {
      return TypeGuardUnknownTypeError2;
    }
  },
  IsVoid: () => {
    {
      return IsVoid2;
    }
  },
  IsUnsafe: () => {
    {
      return IsUnsafe2;
    }
  },
  IsUnknown: () => {
    {
      return IsUnknown2;
    }
  },
  IsUnionLiteral: () => {
    {
      return IsUnionLiteral2;
    }
  },
  IsUnion: () => {
    {
      return IsUnion2;
    }
  },
  IsUndefined: () => {
    {
      return IsUndefined6;
    }
  },
  IsUint8Array: () => {
    {
      return IsUint8Array6;
    }
  },
  IsTuple: () => {
    {
      return IsTuple2;
    }
  },
  IsTransform: () => {
    {
      return IsTransform2;
    }
  },
  IsThis: () => {
    {
      return IsThis2;
    }
  },
  IsTemplateLiteral: () => {
    {
      return IsTemplateLiteral2;
    }
  },
  IsSymbol: () => {
    {
      return IsSymbol6;
    }
  },
  IsString: () => {
    {
      return IsString6;
    }
  },
  IsSchema: () => {
    {
      return IsSchema2;
    }
  },
  IsRegExp: () => {
    {
      return IsRegExp4;
    }
  },
  IsRef: () => {
    {
      return IsRef2;
    }
  },
  IsRecursive: () => {
    {
      return IsRecursive2;
    }
  },
  IsRecord: () => {
    {
      return IsRecord2;
    }
  },
  IsReadonly: () => {
    {
      return IsReadonly2;
    }
  },
  IsProperties: () => {
    {
      return IsProperties2;
    }
  },
  IsPromise: () => {
    {
      return IsPromise4;
    }
  },
  IsOptional: () => {
    {
      return IsOptional2;
    }
  },
  IsObject: () => {
    {
      return IsObject6;
    }
  },
  IsNumber: () => {
    {
      return IsNumber6;
    }
  },
  IsNull: () => {
    {
      return IsNull6;
    }
  },
  IsNot: () => {
    {
      return IsNot2;
    }
  },
  IsNever: () => {
    {
      return IsNever2;
    }
  },
  IsMappedResult: () => {
    {
      return IsMappedResult2;
    }
  },
  IsMappedKey: () => {
    {
      return IsMappedKey2;
    }
  },
  IsLiteralValue: () => {
    {
      return IsLiteralValue2;
    }
  },
  IsLiteralString: () => {
    {
      return IsLiteralString2;
    }
  },
  IsLiteralNumber: () => {
    {
      return IsLiteralNumber2;
    }
  },
  IsLiteralBoolean: () => {
    {
      return IsLiteralBoolean2;
    }
  },
  IsLiteral: () => {
    {
      return IsLiteral2;
    }
  },
  IsKindOf: () => {
    {
      return IsKindOf2;
    }
  },
  IsKind: () => {
    {
      return IsKind2;
    }
  },
  IsIterator: () => {
    {
      return IsIterator6;
    }
  },
  IsIntersect: () => {
    {
      return IsIntersect2;
    }
  },
  IsInteger: () => {
    {
      return IsInteger4;
    }
  },
  IsFunction: () => {
    {
      return IsFunction6;
    }
  },
  IsDate: () => {
    {
      return IsDate6;
    }
  },
  IsConstructor: () => {
    {
      return IsConstructor2;
    }
  },
  IsBoolean: () => {
    {
      return IsBoolean6;
    }
  },
  IsBigInt: () => {
    {
      return IsBigInt6;
    }
  },
  IsAsyncIterator: () => {
    {
      return IsAsyncIterator6;
    }
  },
  IsArray: () => {
    {
      return IsArray6;
    }
  },
  IsAny: () => {
    {
      return IsAny2;
    }
  }
});
var IsPattern2 = function(value15) {
  try {
    new RegExp(value15);
    return true;
  } catch {
    return false;
  }
};
var IsControlCharacterFree2 = function(value15) {
  if (!IsString5(value15))
    return false;
  for (let i = 0;i < value15.length; i++) {
    const code = value15.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
};
var IsAdditionalProperties2 = function(value15) {
  return IsOptionalBoolean2(value15) || IsSchema2(value15);
};
var IsOptionalBigInt2 = function(value15) {
  return IsUndefined5(value15) || IsBigInt5(value15);
};
var IsOptionalNumber2 = function(value15) {
  return IsUndefined5(value15) || IsNumber5(value15);
};
var IsOptionalBoolean2 = function(value15) {
  return IsUndefined5(value15) || IsBoolean5(value15);
};
var IsOptionalString2 = function(value15) {
  return IsUndefined5(value15) || IsString5(value15);
};
var IsOptionalPattern2 = function(value15) {
  return IsUndefined5(value15) || IsString5(value15) && IsControlCharacterFree2(value15) && IsPattern2(value15);
};
var IsOptionalFormat2 = function(value15) {
  return IsUndefined5(value15) || IsString5(value15) && IsControlCharacterFree2(value15);
};
var IsOptionalSchema2 = function(value15) {
  return IsUndefined5(value15) || IsSchema2(value15);
};
function IsReadonly2(value15) {
  return IsObject5(value15) && value15[ReadonlyKind2] === "Readonly";
}
function IsOptional2(value15) {
  return IsObject5(value15) && value15[OptionalKind2] === "Optional";
}
function IsAny2(value15) {
  return IsKindOf2(value15, "Any") && IsOptionalString2(value15.$id);
}
function IsArray6(value15) {
  return IsKindOf2(value15, "Array") && value15.type === "array" && IsOptionalString2(value15.$id) && IsSchema2(value15.items) && IsOptionalNumber2(value15.minItems) && IsOptionalNumber2(value15.maxItems) && IsOptionalBoolean2(value15.uniqueItems) && IsOptionalSchema2(value15.contains) && IsOptionalNumber2(value15.minContains) && IsOptionalNumber2(value15.maxContains);
}
function IsAsyncIterator6(value15) {
  return IsKindOf2(value15, "AsyncIterator") && value15.type === "AsyncIterator" && IsOptionalString2(value15.$id) && IsSchema2(value15.items);
}
function IsBigInt6(value15) {
  return IsKindOf2(value15, "BigInt") && value15.type === "bigint" && IsOptionalString2(value15.$id) && IsOptionalBigInt2(value15.exclusiveMaximum) && IsOptionalBigInt2(value15.exclusiveMinimum) && IsOptionalBigInt2(value15.maximum) && IsOptionalBigInt2(value15.minimum) && IsOptionalBigInt2(value15.multipleOf);
}
function IsBoolean6(value15) {
  return IsKindOf2(value15, "Boolean") && value15.type === "boolean" && IsOptionalString2(value15.$id);
}
function IsConstructor2(value15) {
  return IsKindOf2(value15, "Constructor") && value15.type === "Constructor" && IsOptionalString2(value15.$id) && IsArray5(value15.parameters) && value15.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value15.returns);
}
function IsDate6(value15) {
  return IsKindOf2(value15, "Date") && value15.type === "Date" && IsOptionalString2(value15.$id) && IsOptionalNumber2(value15.exclusiveMaximumTimestamp) && IsOptionalNumber2(value15.exclusiveMinimumTimestamp) && IsOptionalNumber2(value15.maximumTimestamp) && IsOptionalNumber2(value15.minimumTimestamp) && IsOptionalNumber2(value15.multipleOfTimestamp);
}
function IsFunction6(value15) {
  return IsKindOf2(value15, "Function") && value15.type === "Function" && IsOptionalString2(value15.$id) && IsArray5(value15.parameters) && value15.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value15.returns);
}
function IsInteger4(value15) {
  return IsKindOf2(value15, "Integer") && value15.type === "integer" && IsOptionalString2(value15.$id) && IsOptionalNumber2(value15.exclusiveMaximum) && IsOptionalNumber2(value15.exclusiveMinimum) && IsOptionalNumber2(value15.maximum) && IsOptionalNumber2(value15.minimum) && IsOptionalNumber2(value15.multipleOf);
}
function IsProperties2(value15) {
  return IsObject5(value15) && Object.entries(value15).every(([key, schema]) => IsControlCharacterFree2(key) && IsSchema2(schema));
}
function IsIntersect2(value15) {
  return IsKindOf2(value15, "Intersect") && (IsString5(value15.type) && value15.type !== "object" ? false : true) && IsArray5(value15.allOf) && value15.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString2(value15.type) && (IsOptionalBoolean2(value15.unevaluatedProperties) || IsOptionalSchema2(value15.unevaluatedProperties)) && IsOptionalString2(value15.$id);
}
function IsIterator6(value15) {
  return IsKindOf2(value15, "Iterator") && value15.type === "Iterator" && IsOptionalString2(value15.$id) && IsSchema2(value15.items);
}
function IsKindOf2(value15, kind) {
  return IsObject5(value15) && Kind2 in value15 && value15[Kind2] === kind;
}
function IsLiteralString2(value15) {
  return IsLiteral2(value15) && IsString5(value15.const);
}
function IsLiteralNumber2(value15) {
  return IsLiteral2(value15) && IsNumber5(value15.const);
}
function IsLiteralBoolean2(value15) {
  return IsLiteral2(value15) && IsBoolean5(value15.const);
}
function IsLiteral2(value15) {
  return IsKindOf2(value15, "Literal") && IsOptionalString2(value15.$id) && IsLiteralValue2(value15.const);
}
function IsLiteralValue2(value15) {
  return IsBoolean5(value15) || IsNumber5(value15) || IsString5(value15);
}
function IsMappedKey2(value15) {
  return IsKindOf2(value15, "MappedKey") && IsArray5(value15.keys) && value15.keys.every((key) => IsNumber5(key) || IsString5(key));
}
function IsMappedResult2(value15) {
  return IsKindOf2(value15, "MappedResult") && IsProperties2(value15.properties);
}
function IsNever2(value15) {
  return IsKindOf2(value15, "Never") && IsObject5(value15.not) && Object.getOwnPropertyNames(value15.not).length === 0;
}
function IsNot2(value15) {
  return IsKindOf2(value15, "Not") && IsSchema2(value15.not);
}
function IsNull6(value15) {
  return IsKindOf2(value15, "Null") && value15.type === "null" && IsOptionalString2(value15.$id);
}
function IsNumber6(value15) {
  return IsKindOf2(value15, "Number") && value15.type === "number" && IsOptionalString2(value15.$id) && IsOptionalNumber2(value15.exclusiveMaximum) && IsOptionalNumber2(value15.exclusiveMinimum) && IsOptionalNumber2(value15.maximum) && IsOptionalNumber2(value15.minimum) && IsOptionalNumber2(value15.multipleOf);
}
function IsObject6(value15) {
  return IsKindOf2(value15, "Object") && value15.type === "object" && IsOptionalString2(value15.$id) && IsProperties2(value15.properties) && IsAdditionalProperties2(value15.additionalProperties) && IsOptionalNumber2(value15.minProperties) && IsOptionalNumber2(value15.maxProperties);
}
function IsPromise4(value15) {
  return IsKindOf2(value15, "Promise") && value15.type === "Promise" && IsOptionalString2(value15.$id) && IsSchema2(value15.item);
}
function IsRecord2(value15) {
  return IsKindOf2(value15, "Record") && value15.type === "object" && IsOptionalString2(value15.$id) && IsAdditionalProperties2(value15.additionalProperties) && IsObject5(value15.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern2(keys[0]) && IsObject5(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value15);
}
function IsRecursive2(value15) {
  return IsObject5(value15) && Hint2 in value15 && value15[Hint2] === "Recursive";
}
function IsRef2(value15) {
  return IsKindOf2(value15, "Ref") && IsOptionalString2(value15.$id) && IsString5(value15.$ref);
}
function IsRegExp4(value15) {
  return IsKindOf2(value15, "RegExp") && IsOptionalString2(value15.$id) && IsString5(value15.source) && IsString5(value15.flags) && IsOptionalNumber2(value15.maxLength) && IsOptionalNumber2(value15.minLength);
}
function IsString6(value15) {
  return IsKindOf2(value15, "String") && value15.type === "string" && IsOptionalString2(value15.$id) && IsOptionalNumber2(value15.minLength) && IsOptionalNumber2(value15.maxLength) && IsOptionalPattern2(value15.pattern) && IsOptionalFormat2(value15.format);
}
function IsSymbol6(value15) {
  return IsKindOf2(value15, "Symbol") && value15.type === "symbol" && IsOptionalString2(value15.$id);
}
function IsTemplateLiteral2(value15) {
  return IsKindOf2(value15, "TemplateLiteral") && value15.type === "string" && IsString5(value15.pattern) && value15.pattern[0] === "^" && value15.pattern[value15.pattern.length - 1] === "$";
}
function IsThis2(value15) {
  return IsKindOf2(value15, "This") && IsOptionalString2(value15.$id) && IsString5(value15.$ref);
}
function IsTransform2(value15) {
  return IsObject5(value15) && TransformKind2 in value15;
}
function IsTuple2(value15) {
  return IsKindOf2(value15, "Tuple") && value15.type === "array" && IsOptionalString2(value15.$id) && IsNumber5(value15.minItems) && IsNumber5(value15.maxItems) && value15.minItems === value15.maxItems && (IsUndefined5(value15.items) && IsUndefined5(value15.additionalItems) && value15.minItems === 0 || IsArray5(value15.items) && value15.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined6(value15) {
  return IsKindOf2(value15, "Undefined") && value15.type === "undefined" && IsOptionalString2(value15.$id);
}
function IsUnionLiteral2(value15) {
  return IsUnion2(value15) && value15.anyOf.every((schema) => IsLiteralString2(schema) || IsLiteralNumber2(schema));
}
function IsUnion2(value15) {
  return IsKindOf2(value15, "Union") && IsOptionalString2(value15.$id) && IsObject5(value15) && IsArray5(value15.anyOf) && value15.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array6(value15) {
  return IsKindOf2(value15, "Uint8Array") && value15.type === "Uint8Array" && IsOptionalString2(value15.$id) && IsOptionalNumber2(value15.minByteLength) && IsOptionalNumber2(value15.maxByteLength);
}
function IsUnknown2(value15) {
  return IsKindOf2(value15, "Unknown") && IsOptionalString2(value15.$id);
}
function IsUnsafe2(value15) {
  return IsKindOf2(value15, "Unsafe");
}
function IsVoid2(value15) {
  return IsKindOf2(value15, "Void") && value15.type === "void" && IsOptionalString2(value15.$id);
}
function IsKind2(value15) {
  return IsObject5(value15) && Kind2 in value15 && IsString5(value15[Kind2]) && !KnownTypes2.includes(value15[Kind2]);
}
function IsSchema2(value15) {
  return IsObject5(value15) && (IsAny2(value15) || IsArray6(value15) || IsBoolean6(value15) || IsBigInt6(value15) || IsAsyncIterator6(value15) || IsConstructor2(value15) || IsDate6(value15) || IsFunction6(value15) || IsInteger4(value15) || IsIntersect2(value15) || IsIterator6(value15) || IsLiteral2(value15) || IsMappedKey2(value15) || IsMappedResult2(value15) || IsNever2(value15) || IsNot2(value15) || IsNull6(value15) || IsNumber6(value15) || IsObject6(value15) || IsPromise4(value15) || IsRecord2(value15) || IsRef2(value15) || IsRegExp4(value15) || IsString6(value15) || IsSymbol6(value15) || IsTemplateLiteral2(value15) || IsThis2(value15) || IsTuple2(value15) || IsUndefined6(value15) || IsUnion2(value15) || IsUint8Array6(value15) || IsUnknown2(value15) || IsUnsafe2(value15) || IsVoid2(value15) || IsKind2(value15));
}

class TypeGuardUnknownTypeError2 extends TypeBoxError2 {
}
var KnownTypes2 = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/optional/optional.mjs
var RemoveOptional2 = function(schema) {
  return Discard2(CloneType2(schema), [OptionalKind2]);
};
var AddOptional2 = function(schema) {
  return { ...CloneType2(schema), [OptionalKind2]: "Optional" };
};
var OptionalWithFlag2 = function(schema, F) {
  return F === false ? RemoveOptional2(schema) : AddOptional2(schema);
};
function Optional2(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult2(schema) ? OptionalFromMappedResult2(schema, F) : OptionalWithFlag2(schema, F);
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/optional/optional-from-mapped-result.mjs
var FromProperties20 = function(P, F) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Optional2(P[K2], F) };
  }, {});
};
var FromMappedResult13 = function(R2, F) {
  return FromProperties20(R2.properties, F);
};
function OptionalFromMappedResult2(R2, F) {
  const P = FromMappedResult13(R2, F);
  return MappedResult2(P);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/intersect/intersect-create.mjs
function IntersectCreate2(T, options) {
  const allObjects = T.every((schema) => IsObject6(schema));
  const clonedUnevaluatedProperties = IsSchema2(options.unevaluatedProperties) ? { unevaluatedProperties: CloneType2(options.unevaluatedProperties) } : {};
  return options.unevaluatedProperties === false || IsSchema2(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [Kind2]: "Intersect", type: "object", allOf: CloneRest2(T) } : { ...options, ...clonedUnevaluatedProperties, [Kind2]: "Intersect", allOf: CloneRest2(T) };
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/intersect/intersect-evaluated.mjs
var IsIntersectOptional2 = function(T) {
  return T.every((L2) => IsOptional2(L2));
};
var RemoveOptionalFromType3 = function(T) {
  return Discard2(T, [OptionalKind2]);
};
var RemoveOptionalFromRest3 = function(T) {
  return T.map((L2) => IsOptional2(L2) ? RemoveOptionalFromType3(L2) : L2);
};
var ResolveIntersect2 = function(T, options) {
  return IsIntersectOptional2(T) ? Optional2(IntersectCreate2(RemoveOptionalFromRest3(T), options)) : IntersectCreate2(RemoveOptionalFromRest3(T), options);
};
function IntersectEvaluated2(T, options = {}) {
  if (T.length === 0)
    return Never2(options);
  if (T.length === 1)
    return CloneType2(T[0], options);
  if (T.some((schema) => IsTransform2(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect2(T, options);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/intersect/intersect.mjs
function Intersect3(T, options = {}) {
  if (T.length === 0)
    return Never2(options);
  if (T.length === 1)
    return CloneType2(T[0], options);
  if (T.some((schema) => IsTransform2(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate2(T, options);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/union/union-create.mjs
function UnionCreate2(T, options) {
  return { ...options, [Kind2]: "Union", anyOf: CloneRest2(T) };
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/union/union-evaluated.mjs
var IsUnionOptional2 = function(T) {
  return T.some((L2) => IsOptional2(L2));
};
var RemoveOptionalFromRest4 = function(T) {
  return T.map((L2) => IsOptional2(L2) ? RemoveOptionalFromType4(L2) : L2);
};
var RemoveOptionalFromType4 = function(T) {
  return Discard2(T, [OptionalKind2]);
};
var ResolveUnion2 = function(T, options) {
  return IsUnionOptional2(T) ? Optional2(UnionCreate2(RemoveOptionalFromRest4(T), options)) : UnionCreate2(RemoveOptionalFromRest4(T), options);
};
function UnionEvaluated2(T, options = {}) {
  return T.length === 0 ? Never2(options) : T.length === 1 ? CloneType2(T[0], options) : ResolveUnion2(T, options);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/union/union.mjs
function Union3(T, options = {}) {
  return T.length === 0 ? Never2(options) : T.length === 1 ? CloneType2(T[0], options) : UnionCreate2(T, options);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/template-literal/parse.mjs
var IsNonEscaped2 = function(pattern3, index, char) {
  return pattern3[index] === char && pattern3.charCodeAt(index - 1) !== 92;
};
var IsOpenParen2 = function(pattern3, index) {
  return IsNonEscaped2(pattern3, index, "(");
};
var IsCloseParen2 = function(pattern3, index) {
  return IsNonEscaped2(pattern3, index, ")");
};
var IsSeparator2 = function(pattern3, index) {
  return IsNonEscaped2(pattern3, index, "|");
};
var IsGroup2 = function(pattern3) {
  if (!(IsOpenParen2(pattern3, 0) && IsCloseParen2(pattern3, pattern3.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern3.length; index++) {
    if (IsOpenParen2(pattern3, index))
      count += 1;
    if (IsCloseParen2(pattern3, index))
      count -= 1;
    if (count === 0 && index !== pattern3.length - 1)
      return false;
  }
  return true;
};
var InGroup2 = function(pattern3) {
  return pattern3.slice(1, pattern3.length - 1);
};
var IsPrecedenceOr2 = function(pattern3) {
  let count = 0;
  for (let index = 0;index < pattern3.length; index++) {
    if (IsOpenParen2(pattern3, index))
      count += 1;
    if (IsCloseParen2(pattern3, index))
      count -= 1;
    if (IsSeparator2(pattern3, index) && count === 0)
      return true;
  }
  return false;
};
var IsPrecedenceAnd2 = function(pattern3) {
  for (let index = 0;index < pattern3.length; index++) {
    if (IsOpenParen2(pattern3, index))
      return true;
  }
  return false;
};
var Or2 = function(pattern3) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern3.length; index++) {
    if (IsOpenParen2(pattern3, index))
      count += 1;
    if (IsCloseParen2(pattern3, index))
      count -= 1;
    if (IsSeparator2(pattern3, index) && count === 0) {
      const range2 = pattern3.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse2(range2));
      start = index + 1;
    }
  }
  const range = pattern3.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse2(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
};
var And2 = function(pattern3) {
  function Group(value15, index) {
    if (!IsOpenParen2(value15, index))
      throw new TemplateLiteralParserError2(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value15.length; scan++) {
      if (IsOpenParen2(value15, scan))
        count += 1;
      if (IsCloseParen2(value15, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError2(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern4, index) {
    for (let scan = index;scan < pattern4.length; scan++) {
      if (IsOpenParen2(pattern4, scan))
        return [index, scan];
    }
    return [index, pattern4.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern3.length; index++) {
    if (IsOpenParen2(pattern3, index)) {
      const [start, end] = Group(pattern3, index);
      const range = pattern3.slice(start, end + 1);
      expressions.push(TemplateLiteralParse2(range));
      index = end;
    } else {
      const [start, end] = Range(pattern3, index);
      const range = pattern3.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse2(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
};
function TemplateLiteralParse2(pattern3) {
  return IsGroup2(pattern3) ? TemplateLiteralParse2(InGroup2(pattern3)) : IsPrecedenceOr2(pattern3) ? Or2(pattern3) : IsPrecedenceAnd2(pattern3) ? And2(pattern3) : { type: "const", const: pattern3 };
}
function TemplateLiteralParseExact2(pattern3) {
  return TemplateLiteralParse2(pattern3.slice(1, pattern3.length - 1));
}

class TemplateLiteralParserError2 extends TypeBoxError2 {
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/template-literal/finite.mjs
var IsNumberExpression2 = function(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
};
var IsBooleanExpression2 = function(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
};
var IsStringExpression2 = function(expression) {
  return expression.type === "const" && expression.const === ".*";
};
function IsTemplateLiteralExpressionFinite2(expression) {
  return IsNumberExpression2(expression) || IsStringExpression2(expression) ? false : IsBooleanExpression2(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite2(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite2(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError2(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite2(schema) {
  const expression = TemplateLiteralParseExact2(schema.pattern);
  return IsTemplateLiteralExpressionFinite2(expression);
}

class TemplateLiteralFiniteError2 extends TypeBoxError2 {
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/template-literal/generate.mjs
function* GenerateReduce2(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce2(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd2(expression) {
  return yield* GenerateReduce2(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate2(expr)]));
}
function* GenerateOr2(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate2(expr);
}
function* GenerateConst2(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate2(expression) {
  return expression.type === "and" ? yield* GenerateAnd2(expression) : expression.type === "or" ? yield* GenerateOr2(expression) : expression.type === "const" ? yield* GenerateConst2(expression) : (() => {
    throw new TemplateLiteralGenerateError2("Unknown expression");
  })();
}
function TemplateLiteralGenerate2(schema) {
  const expression = TemplateLiteralParseExact2(schema.pattern);
  return IsTemplateLiteralExpressionFinite2(expression) ? [...TemplateLiteralExpressionGenerate2(expression)] : [];
}

class TemplateLiteralGenerateError2 extends TypeBoxError2 {
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/literal/literal.mjs
function Literal2(value15, options = {}) {
  return {
    ...options,
    [Kind2]: "Literal",
    const: value15,
    type: typeof value15
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/boolean/boolean.mjs
function Boolean3(options = {}) {
  return {
    ...options,
    [Kind2]: "Boolean",
    type: "boolean"
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/bigint/bigint.mjs
function BigInt3(options = {}) {
  return {
    ...options,
    [Kind2]: "BigInt",
    type: "bigint"
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/number/number.mjs
function Number3(options = {}) {
  return {
    ...options,
    [Kind2]: "Number",
    type: "number"
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/string/string.mjs
function String3(options = {}) {
  return { ...options, [Kind2]: "String", type: "string" };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/template-literal/syntax.mjs
function* FromUnion20(syntax3) {
  const trim = syntax3.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean3() : trim === "number" ? yield Number3() : trim === "bigint" ? yield BigInt3() : trim === "string" ? yield String3() : yield (() => {
    const literals = trim.split("|").map((literal15) => Literal2(literal15.trim()));
    return literals.length === 0 ? Never2() : literals.length === 1 ? literals[0] : UnionEvaluated2(literals);
  })();
}
function* FromTerminal2(syntax3) {
  if (syntax3[1] !== "{") {
    const L2 = Literal2("$");
    const R2 = FromSyntax2(syntax3.slice(1));
    return yield* [L2, ...R2];
  }
  for (let i = 2;i < syntax3.length; i++) {
    if (syntax3[i] === "}") {
      const L2 = FromUnion20(syntax3.slice(2, i));
      const R2 = FromSyntax2(syntax3.slice(i + 1));
      return yield* [...L2, ...R2];
    }
  }
  yield Literal2(syntax3);
}
function* FromSyntax2(syntax3) {
  for (let i = 0;i < syntax3.length; i++) {
    if (syntax3[i] === "$") {
      const L2 = Literal2(syntax3.slice(0, i));
      const R2 = FromTerminal2(syntax3.slice(i));
      return yield* [L2, ...R2];
    }
  }
  yield Literal2(syntax3);
}
function TemplateLiteralSyntax2(syntax3) {
  return [...FromSyntax2(syntax3)];
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/patterns/patterns.mjs
var PatternBoolean2 = "(true|false)";
var PatternNumber2 = "(0|[1-9][0-9]*)";
var PatternString2 = "(.*)";
var PatternBooleanExact2 = `^${PatternBoolean2}\$`;
var PatternNumberExact2 = `^${PatternNumber2}\$`;
var PatternStringExact2 = `^${PatternString2}\$`;
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/template-literal/pattern.mjs
var Escape3 = function(value15) {
  return value15.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
};
var Visit18 = function(schema, acc) {
  return IsTemplateLiteral2(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion2(schema) ? `(${schema.anyOf.map((schema2) => Visit18(schema2, acc)).join("|")})` : IsNumber6(schema) ? `${acc}${PatternNumber2}` : IsInteger4(schema) ? `${acc}${PatternNumber2}` : IsBigInt6(schema) ? `${acc}${PatternNumber2}` : IsString6(schema) ? `${acc}${PatternString2}` : IsLiteral2(schema) ? `${acc}${Escape3(schema.const.toString())}` : IsBoolean6(schema) ? `${acc}${PatternBoolean2}` : (() => {
    throw new TemplateLiteralPatternError2(`Unexpected Kind '${schema[Kind2]}'`);
  })();
};
function TemplateLiteralPattern2(kinds) {
  return `^${kinds.map((schema) => Visit18(schema, "")).join("")}$`;
}

class TemplateLiteralPatternError2 extends TypeBoxError2 {
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/template-literal/union.mjs
function TemplateLiteralToUnion2(schema) {
  const R2 = TemplateLiteralGenerate2(schema);
  const L2 = R2.map((S) => Literal2(S));
  return UnionEvaluated2(L2);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/template-literal/template-literal.mjs
function TemplateLiteral2(unresolved, options = {}) {
  const pattern4 = IsString5(unresolved) ? TemplateLiteralPattern2(TemplateLiteralSyntax2(unresolved)) : TemplateLiteralPattern2(unresolved);
  return { ...options, [Kind2]: "TemplateLiteral", type: "string", pattern: pattern4 };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/indexed/indexed-property-keys.mjs
var FromTemplateLiteral7 = function(T) {
  const R2 = TemplateLiteralGenerate2(T);
  return R2.map((S) => S.toString());
};
var FromUnion21 = function(T) {
  return T.reduce((Acc, L2) => {
    return [...Acc, ...IndexPropertyKeys2(L2)];
  }, []);
};
var FromLiteral7 = function(T) {
  return [T.toString()];
};
function IndexPropertyKeys2(T) {
  return [...new Set(IsTemplateLiteral2(T) ? FromTemplateLiteral7(T) : IsUnion2(T) ? FromUnion21(T.anyOf) : IsLiteral2(T) ? FromLiteral7(T.const) : IsNumber6(T) ? ["[number]"] : IsInteger4(T) ? ["[number]"] : [])];
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/indexed/indexed-from-mapped-result.mjs
var FromProperties21 = function(T, P, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Index2(T, IndexPropertyKeys2(P[K2]), options) };
  }, {});
};
var FromMappedResult14 = function(T, R2, options) {
  return FromProperties21(T, R2.properties, options);
};
function IndexFromMappedResult2(T, R2, options) {
  const P = FromMappedResult14(T, R2, options);
  return MappedResult2(P);
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/indexed/indexed.mjs
var FromRest9 = function(T, K) {
  return T.map((L2) => IndexFromPropertyKey2(L2, K));
};
var FromIntersectRest2 = function(T) {
  return T.filter((L2) => !IsNever2(L2));
};
var FromIntersect18 = function(T, K) {
  return IntersectEvaluated2(FromIntersectRest2(FromRest9(T, K)));
};
var FromUnionRest2 = function(T) {
  return T;
};
var FromUnion22 = function(T, K) {
  return UnionEvaluated2(FromUnionRest2(FromRest9(T, K)));
};
var FromTuple15 = function(T, K) {
  return K in T ? T[K] : K === "[number]" ? UnionEvaluated2(T) : Never2();
};
var FromArray16 = function(T, K) {
  return K === "[number]" ? T : Never2();
};
var FromProperty3 = function(T, K) {
  return K in T ? T[K] : Never2();
};
function IndexFromPropertyKey2(T, K) {
  return IsIntersect2(T) ? FromIntersect18(T.allOf, K) : IsUnion2(T) ? FromUnion22(T.anyOf, K) : IsTuple2(T) ? FromTuple15(T.items ?? [], K) : IsArray6(T) ? FromArray16(T.items, K) : IsObject6(T) ? FromProperty3(T.properties, K) : Never2();
}
function IndexFromPropertyKeys2(T, K) {
  return K.map((L2) => IndexFromPropertyKey2(T, L2));
}
var FromSchema2 = function(T, K) {
  return UnionEvaluated2(IndexFromPropertyKeys2(T, K));
};
function Index2(T, K, options = {}) {
  return IsMappedResult2(K) ? CloneType2(IndexFromMappedResult2(T, K, options)) : IsMappedKey2(K) ? CloneType2(IndexFromMappedKey2(T, K, options)) : IsSchema2(K) ? CloneType2(FromSchema2(T, IndexPropertyKeys2(K)), options) : CloneType2(FromSchema2(T, K), options);
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/indexed/indexed-from-mapped-key.mjs
var MappedIndexPropertyKey2 = function(T, K, options) {
  return { [K]: Index2(T, [K], options) };
};
var MappedIndexPropertyKeys2 = function(T, K, options) {
  return K.reduce((Acc, L2) => {
    return { ...Acc, ...MappedIndexPropertyKey2(T, L2, options) };
  }, {});
};
var MappedIndexProperties2 = function(T, K, options) {
  return MappedIndexPropertyKeys2(T, K.keys, options);
};
function IndexFromMappedKey2(T, K, options) {
  const P = MappedIndexProperties2(T, K, options);
  return MappedResult2(P);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/iterator/iterator.mjs
function Iterator2(items, options = {}) {
  return {
    ...options,
    [Kind2]: "Iterator",
    type: "Iterator",
    items: CloneType2(items)
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/object/object.mjs
function _Object2(properties, options = {}) {
  const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
  const optionalKeys = propertyKeys.filter((key) => IsOptional2(properties[key]));
  const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
  const clonedAdditionalProperties = IsSchema2(options.additionalProperties) ? { additionalProperties: CloneType2(options.additionalProperties) } : {};
  const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: CloneType2(properties[key]) }), {});
  return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [Kind2]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [Kind2]: "Object", type: "object", properties: clonedProperties };
}
var Object3 = _Object2;
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/promise/promise.mjs
function Promise3(item, options = {}) {
  return {
    ...options,
    [Kind2]: "Promise",
    type: "Promise",
    item: CloneType2(item)
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/readonly/readonly.mjs
var RemoveReadonly2 = function(schema) {
  return Discard2(CloneType2(schema), [ReadonlyKind2]);
};
var AddReadonly2 = function(schema) {
  return { ...CloneType2(schema), [ReadonlyKind2]: "Readonly" };
};
var ReadonlyWithFlag2 = function(schema, F) {
  return F === false ? RemoveReadonly2(schema) : AddReadonly2(schema);
};
function Readonly2(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult2(schema) ? ReadonlyFromMappedResult2(schema, F) : ReadonlyWithFlag2(schema, F);
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/readonly/readonly-from-mapped-result.mjs
var FromProperties22 = function(K, F) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Readonly2(K[K2], F) };
  }, {});
};
var FromMappedResult15 = function(R2, F) {
  return FromProperties22(R2.properties, F);
};
function ReadonlyFromMappedResult2(R2, F) {
  const P = FromMappedResult15(R2, F);
  return MappedResult2(P);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/tuple/tuple.mjs
function Tuple2(items, options = {}) {
  const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
  return items.length > 0 ? { ...options, [Kind2]: "Tuple", type: "array", items: CloneRest2(items), additionalItems, minItems, maxItems } : { ...options, [Kind2]: "Tuple", type: "array", minItems, maxItems };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/sets/set.mjs
function SetIncludes2(T, S) {
  return T.includes(S);
}
function SetDistinct2(T) {
  return [...new Set(T)];
}
function SetIntersect2(T, S) {
  return T.filter((L2) => S.includes(L2));
}
var SetIntersectManyResolve2 = function(T, Init) {
  return T.reduce((Acc, L2) => {
    return SetIntersect2(Acc, L2);
  }, Init);
};
function SetIntersectMany2(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve2(T.slice(1), T[0]) : [];
}
function SetUnionMany2(T) {
  return T.reduce((Acc, L2) => [...Acc, ...L2], []);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/mapped/mapped.mjs
var FromMappedResult16 = function(K, P) {
  return K in P ? FromSchemaType2(K, P[K]) : MappedResult2(P);
};
var MappedKeyToKnownMappedResultProperties2 = function(K) {
  return { [K]: Literal2(K) };
};
var MappedKeyToUnknownMappedResultProperties2 = function(P) {
  return P.reduce((Acc, L2) => {
    return { ...Acc, [L2]: Literal2(L2) };
  }, {});
};
var MappedKeyToMappedResultProperties2 = function(K, P) {
  return SetIncludes2(P, K) ? MappedKeyToKnownMappedResultProperties2(K) : MappedKeyToUnknownMappedResultProperties2(P);
};
var FromMappedKey5 = function(K, P) {
  const R2 = MappedKeyToMappedResultProperties2(K, P);
  return FromMappedResult16(K, R2);
};
var FromRest10 = function(K, T) {
  return T.map((L2) => FromSchemaType2(K, L2));
};
var FromProperties23 = function(K, T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K2) => {
    return { ...Acc, [K2]: FromSchemaType2(K, T[K2]) };
  }, {});
};
var FromSchemaType2 = function(K, T) {
  return IsOptional2(T) ? Optional2(FromSchemaType2(K, Discard2(T, [OptionalKind2]))) : IsReadonly2(T) ? Readonly2(FromSchemaType2(K, Discard2(T, [ReadonlyKind2]))) : IsMappedResult2(T) ? FromMappedResult16(K, T.properties) : IsMappedKey2(T) ? FromMappedKey5(K, T.keys) : IsConstructor2(T) ? Constructor2(FromRest10(K, T.parameters), FromSchemaType2(K, T.returns)) : IsFunction6(T) ? Function3(FromRest10(K, T.parameters), FromSchemaType2(K, T.returns)) : IsAsyncIterator6(T) ? AsyncIterator2(FromSchemaType2(K, T.items)) : IsIterator6(T) ? Iterator2(FromSchemaType2(K, T.items)) : IsIntersect2(T) ? Intersect3(FromRest10(K, T.allOf)) : IsUnion2(T) ? Union3(FromRest10(K, T.anyOf)) : IsTuple2(T) ? Tuple2(FromRest10(K, T.items ?? [])) : IsObject6(T) ? Object3(FromProperties23(K, T.properties)) : IsArray6(T) ? Array3(FromSchemaType2(K, T.items)) : IsPromise4(T) ? Promise3(FromSchemaType2(K, T.item)) : T;
};
function MappedFunctionReturnType2(K, T, Acc = {}) {
  return K.reduce((Acc2, L2) => {
    return { ...Acc2, [L2]: FromSchemaType2(L2, T) };
  }, {});
}
function Mapped2(key, map5, options = {}) {
  const K = IsSchema2(key) ? IndexPropertyKeys2(key) : key;
  const RT = map5({ [Kind2]: "MappedKey", keys: K });
  const R2 = MappedFunctionReturnType2(K, RT);
  return CloneType2(Object3(R2), options);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/keyof/keyof-property-keys.mjs
var FromRest11 = function(T) {
  return T.reduce((Acc, L2) => {
    return [...Acc, KeyOfPropertyKeys2(L2)];
  }, []);
};
var FromIntersect19 = function(T) {
  const C = FromRest11(T);
  const R2 = SetUnionMany2(C);
  return R2;
};
var FromUnion23 = function(T) {
  const C = FromRest11(T);
  const R2 = SetIntersectMany2(C);
  return R2;
};
var FromTuple16 = function(T) {
  return T.map((_, I) => I.toString());
};
var FromArray17 = function(_) {
  return ["[number]"];
};
var FromProperties24 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T);
};
var FromPatternProperties2 = function(patternProperties) {
  if (!includePatternProperties2)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
};
function KeyOfPropertyKeys2(T) {
  return IsIntersect2(T) ? FromIntersect19(T.allOf) : IsUnion2(T) ? FromUnion23(T.anyOf) : IsTuple2(T) ? FromTuple16(T.items ?? []) : IsArray6(T) ? FromArray17(T.items) : IsObject6(T) ? FromProperties24(T.properties) : IsRecord2(T) ? FromPatternProperties2(T.patternProperties) : [];
}
function KeyOfPattern2(schema) {
  includePatternProperties2 = true;
  const keys = KeyOfPropertyKeys2(schema);
  includePatternProperties2 = false;
  const pattern5 = keys.map((key) => `(${key})`);
  return `^(${pattern5.join("|")})\$`;
}
var includePatternProperties2 = false;

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/keyof/keyof.mjs
function KeyOfPropertyKeysToRest2(T) {
  return T.map((L2) => L2 === "[number]" ? Number3() : Literal2(L2));
}
function KeyOf2(T, options = {}) {
  if (IsMappedResult2(T)) {
    return KeyOfFromMappedResult2(T, options);
  } else {
    const K = KeyOfPropertyKeys2(T);
    const S = KeyOfPropertyKeysToRest2(K);
    const U = UnionEvaluated2(S);
    return CloneType2(U, options);
  }
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/keyof/keyof-from-mapped-result.mjs
var FromProperties25 = function(K, options) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: KeyOf2(K[K2], options) };
  }, {});
};
var FromMappedResult17 = function(R2, options) {
  return FromProperties25(R2.properties, options);
};
function KeyOfFromMappedResult2(R2, options) {
  const P = FromMappedResult17(R2, options);
  return MappedResult2(P);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/extends/extends-undefined.mjs
var Intersect4 = function(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck2(schema2));
};
var Union4 = function(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck2(schema2));
};
var Not3 = function(schema) {
  return !ExtendsUndefinedCheck2(schema.not);
};
function ExtendsUndefinedCheck2(schema) {
  return schema[Kind2] === "Intersect" ? Intersect4(schema) : schema[Kind2] === "Union" ? Union4(schema) : schema[Kind2] === "Not" ? Not3(schema) : schema[Kind2] === "Undefined" ? true : false;
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/errors/function.mjs
function DefaultErrorFunction2(error28) {
  switch (error28.errorType) {
    case ValueErrorType2.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType2.ArrayMaxContains:
      return `Expected array to contain no more than ${error28.schema.maxContains} matching values`;
    case ValueErrorType2.ArrayMinContains:
      return `Expected array to contain at least ${error28.schema.minContains} matching values`;
    case ValueErrorType2.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error28.schema.maxItems}`;
    case ValueErrorType2.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error28.schema.minItems}`;
    case ValueErrorType2.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType2.Array:
      return "Expected array";
    case ValueErrorType2.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType2.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error28.schema.exclusiveMaximum}`;
    case ValueErrorType2.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error28.schema.exclusiveMinimum}`;
    case ValueErrorType2.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error28.schema.maximum}`;
    case ValueErrorType2.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error28.schema.minimum}`;
    case ValueErrorType2.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error28.schema.multipleOf}`;
    case ValueErrorType2.BigInt:
      return "Expected bigint";
    case ValueErrorType2.Boolean:
      return "Expected boolean";
    case ValueErrorType2.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error28.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType2.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error28.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType2.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error28.schema.minimumTimestamp}`;
    case ValueErrorType2.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error28.schema.maximumTimestamp}`;
    case ValueErrorType2.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error28.schema.multipleOfTimestamp}`;
    case ValueErrorType2.Date:
      return "Expected Date";
    case ValueErrorType2.Function:
      return "Expected function";
    case ValueErrorType2.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error28.schema.exclusiveMaximum}`;
    case ValueErrorType2.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error28.schema.exclusiveMinimum}`;
    case ValueErrorType2.IntegerMaximum:
      return `Expected integer to be less or equal to ${error28.schema.maximum}`;
    case ValueErrorType2.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error28.schema.minimum}`;
    case ValueErrorType2.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error28.schema.multipleOf}`;
    case ValueErrorType2.Integer:
      return "Expected integer";
    case ValueErrorType2.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType2.Intersect:
      return "Expected all values to match";
    case ValueErrorType2.Iterator:
      return "Expected Iterator";
    case ValueErrorType2.Literal:
      return `Expected ${typeof error28.schema.const === "string" ? `'${error28.schema.const}'` : error28.schema.const}`;
    case ValueErrorType2.Never:
      return "Never";
    case ValueErrorType2.Not:
      return "Value should not match";
    case ValueErrorType2.Null:
      return "Expected null";
    case ValueErrorType2.NumberExclusiveMaximum:
      return `Expected number to be less than ${error28.schema.exclusiveMaximum}`;
    case ValueErrorType2.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error28.schema.exclusiveMinimum}`;
    case ValueErrorType2.NumberMaximum:
      return `Expected number to be less or equal to ${error28.schema.maximum}`;
    case ValueErrorType2.NumberMinimum:
      return `Expected number to be greater or equal to ${error28.schema.minimum}`;
    case ValueErrorType2.NumberMultipleOf:
      return `Expected number to be a multiple of ${error28.schema.multipleOf}`;
    case ValueErrorType2.Number:
      return "Expected number";
    case ValueErrorType2.Object:
      return "Expected object";
    case ValueErrorType2.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType2.ObjectMaxProperties:
      return `Expected object to have no more than ${error28.schema.maxProperties} properties`;
    case ValueErrorType2.ObjectMinProperties:
      return `Expected object to have at least ${error28.schema.minProperties} properties`;
    case ValueErrorType2.ObjectRequiredProperty:
      return "Required property";
    case ValueErrorType2.Promise:
      return "Expected Promise";
    case ValueErrorType2.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType2.StringFormatUnknown:
      return `Unknown format '${error28.schema.format}'`;
    case ValueErrorType2.StringFormat:
      return `Expected string to match '${error28.schema.format}' format`;
    case ValueErrorType2.StringMaxLength:
      return `Expected string length less or equal to ${error28.schema.maxLength}`;
    case ValueErrorType2.StringMinLength:
      return `Expected string length greater or equal to ${error28.schema.minLength}`;
    case ValueErrorType2.StringPattern:
      return `Expected string to match '${error28.schema.pattern}'`;
    case ValueErrorType2.String:
      return "Expected string";
    case ValueErrorType2.Symbol:
      return "Expected symbol";
    case ValueErrorType2.TupleLength:
      return `Expected tuple to have ${error28.schema.maxItems || 0} elements`;
    case ValueErrorType2.Tuple:
      return "Expected tuple";
    case ValueErrorType2.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error28.schema.maxByteLength}`;
    case ValueErrorType2.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error28.schema.minByteLength}`;
    case ValueErrorType2.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType2.Undefined:
      return "Expected undefined";
    case ValueErrorType2.Union:
      return "Expected union value";
    case ValueErrorType2.Void:
      return "Expected void";
    case ValueErrorType2.Kind:
      return `Expected kind '${error28.schema[Kind2]}'`;
    default:
      return "Unknown error type";
  }
}
function GetErrorFunction2() {
  return errorFunction2;
}
var errorFunction2 = DefaultErrorFunction2;

// ../sisventa/node_modules/@sinclair/typebox/build/import/value/deref/deref.mjs
function Deref3(schema, references) {
  const index = references.findIndex((target) => target.$id === schema.$ref);
  if (index === -1)
    throw new TypeDereferenceError2(schema);
  return references[index];
}

class TypeDereferenceError2 extends TypeBoxError2 {
  schema;
  constructor(schema) {
    super(`Unable to dereference schema with \$id '${schema.$id}'`);
    this.schema = schema;
  }
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/value/hash/hash.mjs
function* NumberToBytes2(value16) {
  const byteCount = value16 === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value16) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value16 >> 8 * (byteCount - 1 - i) & 255;
  }
}
var ArrayType8 = function(value16) {
  FNV1A642(ByteMarker2.Array);
  for (const item of value16) {
    Visit19(item);
  }
};
var BooleanType2 = function(value16) {
  FNV1A642(ByteMarker2.Boolean);
  FNV1A642(value16 ? 1 : 0);
};
var BigIntType2 = function(value16) {
  FNV1A642(ByteMarker2.BigInt);
  F64In2.setBigInt64(0, value16);
  for (const byte of F64Out2) {
    FNV1A642(byte);
  }
};
var DateType6 = function(value16) {
  FNV1A642(ByteMarker2.Date);
  Visit19(value16.getTime());
};
var NullType2 = function(value16) {
  FNV1A642(ByteMarker2.Null);
};
var NumberType2 = function(value16) {
  FNV1A642(ByteMarker2.Number);
  F64In2.setFloat64(0, value16);
  for (const byte of F64Out2) {
    FNV1A642(byte);
  }
};
var ObjectType8 = function(value16) {
  FNV1A642(ByteMarker2.Object);
  for (const key of globalThis.Object.keys(value16).sort()) {
    Visit19(key);
    Visit19(value16[key]);
  }
};
var StringType2 = function(value16) {
  FNV1A642(ByteMarker2.String);
  for (let i = 0;i < value16.length; i++) {
    for (const byte of NumberToBytes2(value16.charCodeAt(i))) {
      FNV1A642(byte);
    }
  }
};
var SymbolType2 = function(value16) {
  FNV1A642(ByteMarker2.Symbol);
  Visit19(value16.description);
};
var Uint8ArrayType4 = function(value16) {
  FNV1A642(ByteMarker2.Uint8Array);
  for (let i = 0;i < value16.length; i++) {
    FNV1A642(value16[i]);
  }
};
var UndefinedType2 = function(value16) {
  return FNV1A642(ByteMarker2.Undefined);
};
var Visit19 = function(value16) {
  if (IsArray4(value16))
    return ArrayType8(value16);
  if (IsBoolean4(value16))
    return BooleanType2(value16);
  if (IsBigInt4(value16))
    return BigIntType2(value16);
  if (IsDate4(value16))
    return DateType6(value16);
  if (IsNull4(value16))
    return NullType2(value16);
  if (IsNumber4(value16))
    return NumberType2(value16);
  if (IsPlainObject2(value16))
    return ObjectType8(value16);
  if (IsString4(value16))
    return StringType2(value16);
  if (IsSymbol4(value16))
    return SymbolType2(value16);
  if (IsUint8Array4(value16))
    return Uint8ArrayType4(value16);
  if (IsUndefined4(value16))
    return UndefinedType2(value16);
  throw new ValueHashError2(value16);
};
var FNV1A642 = function(byte) {
  Accumulator2 = Accumulator2 ^ Bytes2[byte];
  Accumulator2 = Accumulator2 * Prime2 % Size2;
};
function Hash3(value16) {
  Accumulator2 = BigInt("14695981039346656037");
  Visit19(value16);
  return Accumulator2;
}

class ValueHashError2 extends TypeBoxError2 {
  value;
  constructor(value16) {
    super(`Unable to hash value`);
    this.value = value16;
  }
}
var ByteMarker2;
(function(ByteMarker3) {
  ByteMarker3[ByteMarker3["Undefined"] = 0] = "Undefined";
  ByteMarker3[ByteMarker3["Null"] = 1] = "Null";
  ByteMarker3[ByteMarker3["Boolean"] = 2] = "Boolean";
  ByteMarker3[ByteMarker3["Number"] = 3] = "Number";
  ByteMarker3[ByteMarker3["String"] = 4] = "String";
  ByteMarker3[ByteMarker3["Object"] = 5] = "Object";
  ByteMarker3[ByteMarker3["Array"] = 6] = "Array";
  ByteMarker3[ByteMarker3["Date"] = 7] = "Date";
  ByteMarker3[ByteMarker3["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker3[ByteMarker3["Symbol"] = 9] = "Symbol";
  ByteMarker3[ByteMarker3["BigInt"] = 10] = "BigInt";
})(ByteMarker2 || (ByteMarker2 = {}));
var Accumulator2 = BigInt("14695981039346656037");
var [Prime2, Size2] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
var Bytes2 = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F642 = new Float64Array(1);
var F64In2 = new DataView(F642.buffer);
var F64Out2 = new Uint8Array(F642.buffer);
// ../sisventa/node_modules/@sinclair/typebox/build/import/errors/errors.mjs
var EscapeKey2 = function(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
};
var IsDefined3 = function(value16) {
  return value16 !== undefined;
};
var Create4 = function(errorType, schema, path, value16) {
  return { type: errorType, schema, path, value: value16, message: GetErrorFunction2()({ errorType, path, schema, value: value16 }) };
};
function* FromAny5(schema, references, path, value16) {
}
function* FromArray18(schema, references, path, value16) {
  if (!IsArray4(value16)) {
    return yield Create4(ValueErrorType2.Array, schema, path, value16);
  }
  if (IsDefined3(schema.minItems) && !(value16.length >= schema.minItems)) {
    yield Create4(ValueErrorType2.ArrayMinItems, schema, path, value16);
  }
  if (IsDefined3(schema.maxItems) && !(value16.length <= schema.maxItems)) {
    yield Create4(ValueErrorType2.ArrayMaxItems, schema, path, value16);
  }
  for (let i = 0;i < value16.length; i++) {
    yield* Visit20(schema.items, references, `${path}/${i}`, value16[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set3 = new Set;
    for (const element of value16) {
      const hashed = Hash3(element);
      if (set3.has(hashed)) {
        return false;
      } else {
        set3.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create4(ValueErrorType2.ArrayUniqueItems, schema, path, value16);
  }
  if (!(IsDefined3(schema.contains) || IsDefined3(schema.minContains) || IsDefined3(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined3(schema.contains) ? schema.contains : Never2();
  const containsCount = value16.reduce((acc, value17, index) => Visit20(containsSchema, references, `${path}${index}`, value17).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create4(ValueErrorType2.ArrayContains, schema, path, value16);
  }
  if (IsNumber4(schema.minContains) && containsCount < schema.minContains) {
    yield Create4(ValueErrorType2.ArrayMinContains, schema, path, value16);
  }
  if (IsNumber4(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create4(ValueErrorType2.ArrayMaxContains, schema, path, value16);
  }
}
function* FromAsyncIterator7(schema, references, path, value16) {
  if (!IsAsyncIterator4(value16))
    yield Create4(ValueErrorType2.AsyncIterator, schema, path, value16);
}
function* FromBigInt6(schema, references, path, value16) {
  if (!IsBigInt4(value16))
    return yield Create4(ValueErrorType2.BigInt, schema, path, value16);
  if (IsDefined3(schema.exclusiveMaximum) && !(value16 < schema.exclusiveMaximum)) {
    yield Create4(ValueErrorType2.BigIntExclusiveMaximum, schema, path, value16);
  }
  if (IsDefined3(schema.exclusiveMinimum) && !(value16 > schema.exclusiveMinimum)) {
    yield Create4(ValueErrorType2.BigIntExclusiveMinimum, schema, path, value16);
  }
  if (IsDefined3(schema.maximum) && !(value16 <= schema.maximum)) {
    yield Create4(ValueErrorType2.BigIntMaximum, schema, path, value16);
  }
  if (IsDefined3(schema.minimum) && !(value16 >= schema.minimum)) {
    yield Create4(ValueErrorType2.BigIntMinimum, schema, path, value16);
  }
  if (IsDefined3(schema.multipleOf) && !(value16 % schema.multipleOf === BigInt(0))) {
    yield Create4(ValueErrorType2.BigIntMultipleOf, schema, path, value16);
  }
}
function* FromBoolean6(schema, references, path, value16) {
  if (!IsBoolean4(value16))
    yield Create4(ValueErrorType2.Boolean, schema, path, value16);
}
function* FromConstructor8(schema, references, path, value16) {
  yield* Visit20(schema.returns, references, path, value16.prototype);
}
function* FromDate6(schema, references, path, value16) {
  if (!IsDate4(value16))
    return yield Create4(ValueErrorType2.Date, schema, path, value16);
  if (IsDefined3(schema.exclusiveMaximumTimestamp) && !(value16.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create4(ValueErrorType2.DateExclusiveMaximumTimestamp, schema, path, value16);
  }
  if (IsDefined3(schema.exclusiveMinimumTimestamp) && !(value16.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create4(ValueErrorType2.DateExclusiveMinimumTimestamp, schema, path, value16);
  }
  if (IsDefined3(schema.maximumTimestamp) && !(value16.getTime() <= schema.maximumTimestamp)) {
    yield Create4(ValueErrorType2.DateMaximumTimestamp, schema, path, value16);
  }
  if (IsDefined3(schema.minimumTimestamp) && !(value16.getTime() >= schema.minimumTimestamp)) {
    yield Create4(ValueErrorType2.DateMinimumTimestamp, schema, path, value16);
  }
  if (IsDefined3(schema.multipleOfTimestamp) && !(value16.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create4(ValueErrorType2.DateMultipleOfTimestamp, schema, path, value16);
  }
}
function* FromFunction7(schema, references, path, value16) {
  if (!IsFunction4(value16))
    yield Create4(ValueErrorType2.Function, schema, path, value16);
}
function* FromInteger6(schema, references, path, value16) {
  if (!IsInteger3(value16))
    return yield Create4(ValueErrorType2.Integer, schema, path, value16);
  if (IsDefined3(schema.exclusiveMaximum) && !(value16 < schema.exclusiveMaximum)) {
    yield Create4(ValueErrorType2.IntegerExclusiveMaximum, schema, path, value16);
  }
  if (IsDefined3(schema.exclusiveMinimum) && !(value16 > schema.exclusiveMinimum)) {
    yield Create4(ValueErrorType2.IntegerExclusiveMinimum, schema, path, value16);
  }
  if (IsDefined3(schema.maximum) && !(value16 <= schema.maximum)) {
    yield Create4(ValueErrorType2.IntegerMaximum, schema, path, value16);
  }
  if (IsDefined3(schema.minimum) && !(value16 >= schema.minimum)) {
    yield Create4(ValueErrorType2.IntegerMinimum, schema, path, value16);
  }
  if (IsDefined3(schema.multipleOf) && !(value16 % schema.multipleOf === 0)) {
    yield Create4(ValueErrorType2.IntegerMultipleOf, schema, path, value16);
  }
}
function* FromIntersect20(schema, references, path, value16) {
  for (const inner of schema.allOf) {
    const next = Visit20(inner, references, path, value16).next();
    if (!next.done) {
      yield Create4(ValueErrorType2.Intersect, schema, path, value16);
      yield next.value;
    }
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern2(schema));
    for (const valueKey of Object.getOwnPropertyNames(value16)) {
      if (!keyCheck.test(valueKey)) {
        yield Create4(ValueErrorType2.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value16);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern2(schema));
    for (const valueKey of Object.getOwnPropertyNames(value16)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit20(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value16[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator7(schema, references, path, value16) {
  if (!IsIterator4(value16))
    yield Create4(ValueErrorType2.Iterator, schema, path, value16);
}
function* FromLiteral8(schema, references, path, value16) {
  if (!(value16 === schema.const))
    yield Create4(ValueErrorType2.Literal, schema, path, value16);
}
function* FromNever6(schema, references, path, value16) {
  yield Create4(ValueErrorType2.Never, schema, path, value16);
}
function* FromNot8(schema, references, path, value16) {
  if (Visit20(schema.not, references, path, value16).next().done === true)
    yield Create4(ValueErrorType2.Not, schema, path, value16);
}
function* FromNull6(schema, references, path, value16) {
  if (!IsNull4(value16))
    yield Create4(ValueErrorType2.Null, schema, path, value16);
}
function* FromNumber6(schema, references, path, value16) {
  if (!TypeSystemPolicy2.IsNumberLike(value16))
    return yield Create4(ValueErrorType2.Number, schema, path, value16);
  if (IsDefined3(schema.exclusiveMaximum) && !(value16 < schema.exclusiveMaximum)) {
    yield Create4(ValueErrorType2.NumberExclusiveMaximum, schema, path, value16);
  }
  if (IsDefined3(schema.exclusiveMinimum) && !(value16 > schema.exclusiveMinimum)) {
    yield Create4(ValueErrorType2.NumberExclusiveMinimum, schema, path, value16);
  }
  if (IsDefined3(schema.maximum) && !(value16 <= schema.maximum)) {
    yield Create4(ValueErrorType2.NumberMaximum, schema, path, value16);
  }
  if (IsDefined3(schema.minimum) && !(value16 >= schema.minimum)) {
    yield Create4(ValueErrorType2.NumberMinimum, schema, path, value16);
  }
  if (IsDefined3(schema.multipleOf) && !(value16 % schema.multipleOf === 0)) {
    yield Create4(ValueErrorType2.NumberMultipleOf, schema, path, value16);
  }
}
function* FromObject13(schema, references, path, value16) {
  if (!TypeSystemPolicy2.IsObjectLike(value16))
    return yield Create4(ValueErrorType2.Object, schema, path, value16);
  if (IsDefined3(schema.minProperties) && !(Object.getOwnPropertyNames(value16).length >= schema.minProperties)) {
    yield Create4(ValueErrorType2.ObjectMinProperties, schema, path, value16);
  }
  if (IsDefined3(schema.maxProperties) && !(Object.getOwnPropertyNames(value16).length <= schema.maxProperties)) {
    yield Create4(ValueErrorType2.ObjectMaxProperties, schema, path, value16);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value16);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create4(ValueErrorType2.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey2(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create4(ValueErrorType2.ObjectAdditionalProperties, schema, `${path}/${EscapeKey2(valueKey)}`, value16[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit20(schema.additionalProperties, references, `${path}/${EscapeKey2(valueKey)}`, value16[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit20(property, references, `${path}/${EscapeKey2(knownKey)}`, value16[knownKey]);
      if (ExtendsUndefinedCheck2(schema) && !(knownKey in value16)) {
        yield Create4(ValueErrorType2.ObjectRequiredProperty, property, `${path}/${EscapeKey2(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy2.IsExactOptionalProperty(value16, knownKey)) {
        yield* Visit20(property, references, `${path}/${EscapeKey2(knownKey)}`, value16[knownKey]);
      }
    }
  }
}
function* FromPromise8(schema, references, path, value16) {
  if (!IsPromise3(value16))
    yield Create4(ValueErrorType2.Promise, schema, path, value16);
}
function* FromRecord12(schema, references, path, value16) {
  if (!TypeSystemPolicy2.IsRecordLike(value16))
    return yield Create4(ValueErrorType2.Object, schema, path, value16);
  if (IsDefined3(schema.minProperties) && !(Object.getOwnPropertyNames(value16).length >= schema.minProperties)) {
    yield Create4(ValueErrorType2.ObjectMinProperties, schema, path, value16);
  }
  if (IsDefined3(schema.maxProperties) && !(Object.getOwnPropertyNames(value16).length <= schema.maxProperties)) {
    yield Create4(ValueErrorType2.ObjectMaxProperties, schema, path, value16);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value16)) {
    if (regex.test(propertyKey))
      yield* Visit20(patternSchema, references, `${path}/${EscapeKey2(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value16)) {
      if (!regex.test(propertyKey))
        yield* Visit20(schema.additionalProperties, references, `${path}/${EscapeKey2(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value16)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create4(ValueErrorType2.ObjectAdditionalProperties, schema, `${path}/${EscapeKey2(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef12(schema, references, path, value16) {
  yield* Visit20(Deref3(schema, references), references, path, value16);
}
function* FromRegExp5(schema, references, path, value16) {
  if (!IsString4(value16))
    return yield Create4(ValueErrorType2.String, schema, path, value16);
  if (IsDefined3(schema.minLength) && !(value16.length >= schema.minLength)) {
    yield Create4(ValueErrorType2.StringMinLength, schema, path, value16);
  }
  if (IsDefined3(schema.maxLength) && !(value16.length <= schema.maxLength)) {
    yield Create4(ValueErrorType2.StringMaxLength, schema, path, value16);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value16)) {
    return yield Create4(ValueErrorType2.RegExp, schema, path, value16);
  }
}
function* FromString6(schema, references, path, value16) {
  if (!IsString4(value16))
    return yield Create4(ValueErrorType2.String, schema, path, value16);
  if (IsDefined3(schema.minLength) && !(value16.length >= schema.minLength)) {
    yield Create4(ValueErrorType2.StringMinLength, schema, path, value16);
  }
  if (IsDefined3(schema.maxLength) && !(value16.length <= schema.maxLength)) {
    yield Create4(ValueErrorType2.StringMaxLength, schema, path, value16);
  }
  if (IsString4(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value16)) {
      yield Create4(ValueErrorType2.StringPattern, schema, path, value16);
    }
  }
  if (IsString4(schema.format)) {
    if (!exports_format2.Has(schema.format)) {
      yield Create4(ValueErrorType2.StringFormatUnknown, schema, path, value16);
    } else {
      const format = exports_format2.Get(schema.format);
      if (!format(value16)) {
        yield Create4(ValueErrorType2.StringFormat, schema, path, value16);
      }
    }
  }
}
function* FromSymbol6(schema, references, path, value16) {
  if (!IsSymbol4(value16))
    yield Create4(ValueErrorType2.Symbol, schema, path, value16);
}
function* FromTemplateLiteral8(schema, references, path, value16) {
  if (!IsString4(value16))
    return yield Create4(ValueErrorType2.String, schema, path, value16);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value16)) {
    yield Create4(ValueErrorType2.StringPattern, schema, path, value16);
  }
}
function* FromThis11(schema, references, path, value16) {
  yield* Visit20(Deref3(schema, references), references, path, value16);
}
function* FromTuple17(schema, references, path, value16) {
  if (!IsArray4(value16))
    return yield Create4(ValueErrorType2.Tuple, schema, path, value16);
  if (schema.items === undefined && !(value16.length === 0)) {
    return yield Create4(ValueErrorType2.TupleLength, schema, path, value16);
  }
  if (!(value16.length === schema.maxItems)) {
    return yield Create4(ValueErrorType2.TupleLength, schema, path, value16);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit20(schema.items[i], references, `${path}/${i}`, value16[i]);
  }
}
function* FromUndefined6(schema, references, path, value16) {
  if (!IsUndefined4(value16))
    yield Create4(ValueErrorType2.Undefined, schema, path, value16);
}
function* FromUnion24(schema, references, path, value16) {
  let count = 0;
  for (const subschema of schema.anyOf) {
    const errors5 = [...Visit20(subschema, references, path, value16)];
    if (errors5.length === 0)
      return;
    count += errors5.length;
  }
  if (count > 0) {
    yield Create4(ValueErrorType2.Union, schema, path, value16);
  }
}
function* FromUint8Array5(schema, references, path, value16) {
  if (!IsUint8Array4(value16))
    return yield Create4(ValueErrorType2.Uint8Array, schema, path, value16);
  if (IsDefined3(schema.maxByteLength) && !(value16.length <= schema.maxByteLength)) {
    yield Create4(ValueErrorType2.Uint8ArrayMaxByteLength, schema, path, value16);
  }
  if (IsDefined3(schema.minByteLength) && !(value16.length >= schema.minByteLength)) {
    yield Create4(ValueErrorType2.Uint8ArrayMinByteLength, schema, path, value16);
  }
}
function* FromUnknown5(schema, references, path, value16) {
}
function* FromVoid5(schema, references, path, value16) {
  if (!TypeSystemPolicy2.IsVoidLike(value16))
    yield Create4(ValueErrorType2.Void, schema, path, value16);
}
function* FromKind4(schema, references, path, value16) {
  const check10 = exports_type5.Get(schema[Kind2]);
  if (!check10(schema, value16))
    yield Create4(ValueErrorType2.Kind, schema, path, value16);
}
function* Visit20(schema, references, path, value16) {
  const references_ = IsDefined3(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind2]) {
    case "Any":
      return yield* FromAny5(schema_, references_, path, value16);
    case "Array":
      return yield* FromArray18(schema_, references_, path, value16);
    case "AsyncIterator":
      return yield* FromAsyncIterator7(schema_, references_, path, value16);
    case "BigInt":
      return yield* FromBigInt6(schema_, references_, path, value16);
    case "Boolean":
      return yield* FromBoolean6(schema_, references_, path, value16);
    case "Constructor":
      return yield* FromConstructor8(schema_, references_, path, value16);
    case "Date":
      return yield* FromDate6(schema_, references_, path, value16);
    case "Function":
      return yield* FromFunction7(schema_, references_, path, value16);
    case "Integer":
      return yield* FromInteger6(schema_, references_, path, value16);
    case "Intersect":
      return yield* FromIntersect20(schema_, references_, path, value16);
    case "Iterator":
      return yield* FromIterator7(schema_, references_, path, value16);
    case "Literal":
      return yield* FromLiteral8(schema_, references_, path, value16);
    case "Never":
      return yield* FromNever6(schema_, references_, path, value16);
    case "Not":
      return yield* FromNot8(schema_, references_, path, value16);
    case "Null":
      return yield* FromNull6(schema_, references_, path, value16);
    case "Number":
      return yield* FromNumber6(schema_, references_, path, value16);
    case "Object":
      return yield* FromObject13(schema_, references_, path, value16);
    case "Promise":
      return yield* FromPromise8(schema_, references_, path, value16);
    case "Record":
      return yield* FromRecord12(schema_, references_, path, value16);
    case "Ref":
      return yield* FromRef12(schema_, references_, path, value16);
    case "RegExp":
      return yield* FromRegExp5(schema_, references_, path, value16);
    case "String":
      return yield* FromString6(schema_, references_, path, value16);
    case "Symbol":
      return yield* FromSymbol6(schema_, references_, path, value16);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral8(schema_, references_, path, value16);
    case "This":
      return yield* FromThis11(schema_, references_, path, value16);
    case "Tuple":
      return yield* FromTuple17(schema_, references_, path, value16);
    case "Undefined":
      return yield* FromUndefined6(schema_, references_, path, value16);
    case "Union":
      return yield* FromUnion24(schema_, references_, path, value16);
    case "Uint8Array":
      return yield* FromUint8Array5(schema_, references_, path, value16);
    case "Unknown":
      return yield* FromUnknown5(schema_, references_, path, value16);
    case "Void":
      return yield* FromVoid5(schema_, references_, path, value16);
    default:
      if (!exports_type5.Has(schema_[Kind2]))
        throw new ValueErrorsUnknownTypeError2(schema);
      return yield* FromKind4(schema_, references_, path, value16);
  }
}
function Errors3(...args) {
  const iterator6 = args.length === 3 ? Visit20(args[0], args[1], "", args[2]) : Visit20(args[0], [], "", args[1]);
  return new ValueErrorIterator2(iterator6);
}
var ValueErrorType2;
(function(ValueErrorType3) {
  ValueErrorType3[ValueErrorType3["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType3[ValueErrorType3["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType3[ValueErrorType3["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType3[ValueErrorType3["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType3[ValueErrorType3["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType3[ValueErrorType3["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType3[ValueErrorType3["Array"] = 6] = "Array";
  ValueErrorType3[ValueErrorType3["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType3[ValueErrorType3["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType3[ValueErrorType3["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType3[ValueErrorType3["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType3[ValueErrorType3["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType3[ValueErrorType3["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType3[ValueErrorType3["BigInt"] = 13] = "BigInt";
  ValueErrorType3[ValueErrorType3["Boolean"] = 14] = "Boolean";
  ValueErrorType3[ValueErrorType3["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType3[ValueErrorType3["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType3[ValueErrorType3["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType3[ValueErrorType3["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType3[ValueErrorType3["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType3[ValueErrorType3["Date"] = 20] = "Date";
  ValueErrorType3[ValueErrorType3["Function"] = 21] = "Function";
  ValueErrorType3[ValueErrorType3["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType3[ValueErrorType3["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType3[ValueErrorType3["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType3[ValueErrorType3["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType3[ValueErrorType3["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType3[ValueErrorType3["Integer"] = 27] = "Integer";
  ValueErrorType3[ValueErrorType3["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType3[ValueErrorType3["Intersect"] = 29] = "Intersect";
  ValueErrorType3[ValueErrorType3["Iterator"] = 30] = "Iterator";
  ValueErrorType3[ValueErrorType3["Kind"] = 31] = "Kind";
  ValueErrorType3[ValueErrorType3["Literal"] = 32] = "Literal";
  ValueErrorType3[ValueErrorType3["Never"] = 33] = "Never";
  ValueErrorType3[ValueErrorType3["Not"] = 34] = "Not";
  ValueErrorType3[ValueErrorType3["Null"] = 35] = "Null";
  ValueErrorType3[ValueErrorType3["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType3[ValueErrorType3["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType3[ValueErrorType3["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType3[ValueErrorType3["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType3[ValueErrorType3["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType3[ValueErrorType3["Number"] = 41] = "Number";
  ValueErrorType3[ValueErrorType3["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType3[ValueErrorType3["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType3[ValueErrorType3["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType3[ValueErrorType3["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType3[ValueErrorType3["Object"] = 46] = "Object";
  ValueErrorType3[ValueErrorType3["Promise"] = 47] = "Promise";
  ValueErrorType3[ValueErrorType3["RegExp"] = 48] = "RegExp";
  ValueErrorType3[ValueErrorType3["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType3[ValueErrorType3["StringFormat"] = 50] = "StringFormat";
  ValueErrorType3[ValueErrorType3["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType3[ValueErrorType3["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType3[ValueErrorType3["StringPattern"] = 53] = "StringPattern";
  ValueErrorType3[ValueErrorType3["String"] = 54] = "String";
  ValueErrorType3[ValueErrorType3["Symbol"] = 55] = "Symbol";
  ValueErrorType3[ValueErrorType3["TupleLength"] = 56] = "TupleLength";
  ValueErrorType3[ValueErrorType3["Tuple"] = 57] = "Tuple";
  ValueErrorType3[ValueErrorType3["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType3[ValueErrorType3["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType3[ValueErrorType3["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType3[ValueErrorType3["Undefined"] = 61] = "Undefined";
  ValueErrorType3[ValueErrorType3["Union"] = 62] = "Union";
  ValueErrorType3[ValueErrorType3["Void"] = 63] = "Void";
})(ValueErrorType2 || (ValueErrorType2 = {}));

class ValueErrorsUnknownTypeError2 extends TypeBoxError2 {
  schema;
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class ValueErrorIterator2 {
  iterator;
  constructor(iterator6) {
    this.iterator = iterator6;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/any/any.mjs
function Any2(options = {}) {
  return { ...options, [Kind2]: "Any" };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/unknown/unknown.mjs
function Unknown2(options = {}) {
  return {
    ...options,
    [Kind2]: "Unknown"
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/extends/extends-check.mjs
var IntoBooleanResult2 = function(result) {
  return result === ExtendsResult2.False ? result : ExtendsResult2.True;
};
var Throw2 = function(message) {
  throw new ExtendsResolverError2(message);
};
var IsStructuralRight2 = function(right) {
  return exports_type7.IsNever(right) || exports_type7.IsIntersect(right) || exports_type7.IsUnion(right) || exports_type7.IsUnknown(right) || exports_type7.IsAny(right);
};
var StructuralRight2 = function(left, right) {
  return exports_type7.IsNever(right) ? FromNeverRight2(left, right) : exports_type7.IsIntersect(right) ? FromIntersectRight2(left, right) : exports_type7.IsUnion(right) ? FromUnionRight2(left, right) : exports_type7.IsUnknown(right) ? FromUnknownRight2(left, right) : exports_type7.IsAny(right) ? FromAnyRight2(left, right) : Throw2("StructuralRight");
};
var FromAnyRight2 = function(left, right) {
  return ExtendsResult2.True;
};
var FromAny6 = function(left, right) {
  return exports_type7.IsIntersect(right) ? FromIntersectRight2(left, right) : exports_type7.IsUnion(right) && right.anyOf.some((schema) => exports_type7.IsAny(schema) || exports_type7.IsUnknown(schema)) ? ExtendsResult2.True : exports_type7.IsUnion(right) ? ExtendsResult2.Union : exports_type7.IsUnknown(right) ? ExtendsResult2.True : exports_type7.IsAny(right) ? ExtendsResult2.True : ExtendsResult2.Union;
};
var FromArrayRight2 = function(left, right) {
  return exports_type7.IsUnknown(left) ? ExtendsResult2.False : exports_type7.IsAny(left) ? ExtendsResult2.Union : exports_type7.IsNever(left) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromArray19 = function(left, right) {
  return exports_type7.IsObject(right) && IsObjectArrayLike2(right) ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : !exports_type7.IsArray(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit21(left.items, right.items));
};
var FromAsyncIterator8 = function(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : !exports_type7.IsAsyncIterator(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit21(left.items, right.items));
};
var FromBigInt7 = function(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type7.IsObject(right) ? FromObjectRight2(left, right) : exports_type7.IsRecord(right) ? FromRecordRight2(left, right) : exports_type7.IsBigInt(right) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromBooleanRight2 = function(left, right) {
  return exports_type7.IsLiteralBoolean(left) ? ExtendsResult2.True : exports_type7.IsBoolean(left) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromBoolean7 = function(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type7.IsObject(right) ? FromObjectRight2(left, right) : exports_type7.IsRecord(right) ? FromRecordRight2(left, right) : exports_type7.IsBoolean(right) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromConstructor9 = function(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type7.IsObject(right) ? FromObjectRight2(left, right) : !exports_type7.IsConstructor(right) ? ExtendsResult2.False : left.parameters.length > right.parameters.length ? ExtendsResult2.False : !left.parameters.every((schema, index) => IntoBooleanResult2(Visit21(right.parameters[index], schema)) === ExtendsResult2.True) ? ExtendsResult2.False : IntoBooleanResult2(Visit21(left.returns, right.returns));
};
var FromDate7 = function(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type7.IsObject(right) ? FromObjectRight2(left, right) : exports_type7.IsRecord(right) ? FromRecordRight2(left, right) : exports_type7.IsDate(right) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromFunction8 = function(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type7.IsObject(right) ? FromObjectRight2(left, right) : !exports_type7.IsFunction(right) ? ExtendsResult2.False : left.parameters.length > right.parameters.length ? ExtendsResult2.False : !left.parameters.every((schema, index) => IntoBooleanResult2(Visit21(right.parameters[index], schema)) === ExtendsResult2.True) ? ExtendsResult2.False : IntoBooleanResult2(Visit21(left.returns, right.returns));
};
var FromIntegerRight2 = function(left, right) {
  return exports_type7.IsLiteral(left) && exports_value4.IsNumber(left.const) ? ExtendsResult2.True : exports_type7.IsNumber(left) || exports_type7.IsInteger(left) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromInteger7 = function(left, right) {
  return exports_type7.IsInteger(right) || exports_type7.IsNumber(right) ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type7.IsObject(right) ? FromObjectRight2(left, right) : exports_type7.IsRecord(right) ? FromRecordRight2(left, right) : ExtendsResult2.False;
};
var FromIntersectRight2 = function(left, right) {
  return right.allOf.every((schema) => Visit21(left, schema) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromIntersect21 = function(left, right) {
  return left.allOf.some((schema) => Visit21(schema, right) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromIterator8 = function(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : !exports_type7.IsIterator(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit21(left.items, right.items));
};
var FromLiteral9 = function(left, right) {
  return exports_type7.IsLiteral(right) && right.const === left.const ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type7.IsObject(right) ? FromObjectRight2(left, right) : exports_type7.IsRecord(right) ? FromRecordRight2(left, right) : exports_type7.IsString(right) ? FromStringRight2(left, right) : exports_type7.IsNumber(right) ? FromNumberRight2(left, right) : exports_type7.IsInteger(right) ? FromIntegerRight2(left, right) : exports_type7.IsBoolean(right) ? FromBooleanRight2(left, right) : ExtendsResult2.False;
};
var FromNeverRight2 = function(left, right) {
  return ExtendsResult2.False;
};
var FromNever7 = function(left, right) {
  return ExtendsResult2.True;
};
var UnwrapTNot2 = function(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type7.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown2();
};
var FromNot9 = function(left, right) {
  return exports_type7.IsNot(left) ? Visit21(UnwrapTNot2(left), right) : exports_type7.IsNot(right) ? Visit21(left, UnwrapTNot2(right)) : Throw2("Invalid fallthrough for Not");
};
var FromNull7 = function(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type7.IsObject(right) ? FromObjectRight2(left, right) : exports_type7.IsRecord(right) ? FromRecordRight2(left, right) : exports_type7.IsNull(right) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromNumberRight2 = function(left, right) {
  return exports_type7.IsLiteralNumber(left) ? ExtendsResult2.True : exports_type7.IsNumber(left) || exports_type7.IsInteger(left) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromNumber7 = function(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type7.IsObject(right) ? FromObjectRight2(left, right) : exports_type7.IsRecord(right) ? FromRecordRight2(left, right) : exports_type7.IsInteger(right) || exports_type7.IsNumber(right) ? ExtendsResult2.True : ExtendsResult2.False;
};
var IsObjectPropertyCount2 = function(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
};
var IsObjectStringLike2 = function(schema) {
  return IsObjectArrayLike2(schema);
};
var IsObjectSymbolLike2 = function(schema) {
  return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "description" in schema.properties && exports_type7.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type7.IsString(schema.properties.description.anyOf[0]) && exports_type7.IsUndefined(schema.properties.description.anyOf[1]) || exports_type7.IsString(schema.properties.description.anyOf[1]) && exports_type7.IsUndefined(schema.properties.description.anyOf[0]));
};
var IsObjectNumberLike2 = function(schema) {
  return IsObjectPropertyCount2(schema, 0);
};
var IsObjectBooleanLike2 = function(schema) {
  return IsObjectPropertyCount2(schema, 0);
};
var IsObjectBigIntLike2 = function(schema) {
  return IsObjectPropertyCount2(schema, 0);
};
var IsObjectDateLike2 = function(schema) {
  return IsObjectPropertyCount2(schema, 0);
};
var IsObjectUint8ArrayLike2 = function(schema) {
  return IsObjectArrayLike2(schema);
};
var IsObjectFunctionLike2 = function(schema) {
  const length = Number3();
  return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "length" in schema.properties && IntoBooleanResult2(Visit21(schema.properties["length"], length)) === ExtendsResult2.True;
};
var IsObjectConstructorLike2 = function(schema) {
  return IsObjectPropertyCount2(schema, 0);
};
var IsObjectArrayLike2 = function(schema) {
  const length = Number3();
  return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "length" in schema.properties && IntoBooleanResult2(Visit21(schema.properties["length"], length)) === ExtendsResult2.True;
};
var IsObjectPromiseLike2 = function(schema) {
  const then = Function3([Any2()], Any2());
  return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "then" in schema.properties && IntoBooleanResult2(Visit21(schema.properties["then"], then)) === ExtendsResult2.True;
};
var Property2 = function(left, right) {
  return Visit21(left, right) === ExtendsResult2.False ? ExtendsResult2.False : exports_type7.IsOptional(left) && !exports_type7.IsOptional(right) ? ExtendsResult2.False : ExtendsResult2.True;
};
var FromObjectRight2 = function(left, right) {
  return exports_type7.IsUnknown(left) ? ExtendsResult2.False : exports_type7.IsAny(left) ? ExtendsResult2.Union : exports_type7.IsNever(left) || exports_type7.IsLiteralString(left) && IsObjectStringLike2(right) || exports_type7.IsLiteralNumber(left) && IsObjectNumberLike2(right) || exports_type7.IsLiteralBoolean(left) && IsObjectBooleanLike2(right) || exports_type7.IsSymbol(left) && IsObjectSymbolLike2(right) || exports_type7.IsBigInt(left) && IsObjectBigIntLike2(right) || exports_type7.IsString(left) && IsObjectStringLike2(right) || exports_type7.IsSymbol(left) && IsObjectSymbolLike2(right) || exports_type7.IsNumber(left) && IsObjectNumberLike2(right) || exports_type7.IsInteger(left) && IsObjectNumberLike2(right) || exports_type7.IsBoolean(left) && IsObjectBooleanLike2(right) || exports_type7.IsUint8Array(left) && IsObjectUint8ArrayLike2(right) || exports_type7.IsDate(left) && IsObjectDateLike2(right) || exports_type7.IsConstructor(left) && IsObjectConstructorLike2(right) || exports_type7.IsFunction(left) && IsObjectFunctionLike2(right) ? ExtendsResult2.True : exports_type7.IsRecord(left) && exports_type7.IsString(RecordKey2(left)) ? (() => {
    return right[Hint2] === "Record" ? ExtendsResult2.True : ExtendsResult2.False;
  })() : exports_type7.IsRecord(left) && exports_type7.IsNumber(RecordKey2(left)) ? (() => {
    return IsObjectPropertyCount2(right, 0) ? ExtendsResult2.True : ExtendsResult2.False;
  })() : ExtendsResult2.False;
};
var FromObject14 = function(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type7.IsRecord(right) ? FromRecordRight2(left, right) : !exports_type7.IsObject(right) ? ExtendsResult2.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type7.IsOptional(right.properties[key])) {
        return ExtendsResult2.False;
      }
      if (exports_type7.IsOptional(right.properties[key])) {
        return ExtendsResult2.True;
      }
      if (Property2(left.properties[key], right.properties[key]) === ExtendsResult2.False) {
        return ExtendsResult2.False;
      }
    }
    return ExtendsResult2.True;
  })();
};
var FromPromise9 = function(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type7.IsObject(right) && IsObjectPromiseLike2(right) ? ExtendsResult2.True : !exports_type7.IsPromise(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit21(left.item, right.item));
};
var RecordKey2 = function(schema) {
  return PatternNumberExact2 in schema.patternProperties ? Number3() : (PatternStringExact2 in schema.patternProperties) ? String3() : Throw2("Unknown record key pattern");
};
var RecordValue2 = function(schema) {
  return PatternNumberExact2 in schema.patternProperties ? schema.patternProperties[PatternNumberExact2] : (PatternStringExact2 in schema.patternProperties) ? schema.patternProperties[PatternStringExact2] : Throw2("Unable to get record value schema");
};
var FromRecordRight2 = function(left, right) {
  const [Key, Value] = [RecordKey2(right), RecordValue2(right)];
  return exports_type7.IsLiteralString(left) && exports_type7.IsNumber(Key) && IntoBooleanResult2(Visit21(left, Value)) === ExtendsResult2.True ? ExtendsResult2.True : exports_type7.IsUint8Array(left) && exports_type7.IsNumber(Key) ? Visit21(left, Value) : exports_type7.IsString(left) && exports_type7.IsNumber(Key) ? Visit21(left, Value) : exports_type7.IsArray(left) && exports_type7.IsNumber(Key) ? Visit21(left, Value) : exports_type7.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property2(Value, left.properties[key]) === ExtendsResult2.False) {
        return ExtendsResult2.False;
      }
    }
    return ExtendsResult2.True;
  })() : ExtendsResult2.False;
};
var FromRecord13 = function(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type7.IsObject(right) ? FromObjectRight2(left, right) : !exports_type7.IsRecord(right) ? ExtendsResult2.False : Visit21(RecordValue2(left), RecordValue2(right));
};
var FromRegExp6 = function(left, right) {
  const L2 = exports_type7.IsRegExp(left) ? String3() : left;
  const R2 = exports_type7.IsRegExp(right) ? String3() : right;
  return Visit21(L2, R2);
};
var FromStringRight2 = function(left, right) {
  return exports_type7.IsLiteral(left) && exports_value4.IsString(left.const) ? ExtendsResult2.True : exports_type7.IsString(left) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromString7 = function(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type7.IsObject(right) ? FromObjectRight2(left, right) : exports_type7.IsRecord(right) ? FromRecordRight2(left, right) : exports_type7.IsString(right) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromSymbol7 = function(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type7.IsObject(right) ? FromObjectRight2(left, right) : exports_type7.IsRecord(right) ? FromRecordRight2(left, right) : exports_type7.IsSymbol(right) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromTemplateLiteral9 = function(left, right) {
  return exports_type7.IsTemplateLiteral(left) ? Visit21(TemplateLiteralToUnion2(left), right) : exports_type7.IsTemplateLiteral(right) ? Visit21(left, TemplateLiteralToUnion2(right)) : Throw2("Invalid fallthrough for TemplateLiteral");
};
var IsArrayOfTuple2 = function(left, right) {
  return exports_type7.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit21(schema, right.items) === ExtendsResult2.True);
};
var FromTupleRight2 = function(left, right) {
  return exports_type7.IsNever(left) ? ExtendsResult2.True : exports_type7.IsUnknown(left) ? ExtendsResult2.False : exports_type7.IsAny(left) ? ExtendsResult2.Union : ExtendsResult2.False;
};
var FromTuple18 = function(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type7.IsObject(right) && IsObjectArrayLike2(right) ? ExtendsResult2.True : exports_type7.IsArray(right) && IsArrayOfTuple2(left, right) ? ExtendsResult2.True : !exports_type7.IsTuple(right) ? ExtendsResult2.False : exports_value4.IsUndefined(left.items) && !exports_value4.IsUndefined(right.items) || !exports_value4.IsUndefined(left.items) && exports_value4.IsUndefined(right.items) ? ExtendsResult2.False : exports_value4.IsUndefined(left.items) && !exports_value4.IsUndefined(right.items) ? ExtendsResult2.True : left.items.every((schema, index) => Visit21(schema, right.items[index]) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromUint8Array6 = function(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type7.IsObject(right) ? FromObjectRight2(left, right) : exports_type7.IsRecord(right) ? FromRecordRight2(left, right) : exports_type7.IsUint8Array(right) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromUndefined7 = function(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type7.IsObject(right) ? FromObjectRight2(left, right) : exports_type7.IsRecord(right) ? FromRecordRight2(left, right) : exports_type7.IsVoid(right) ? FromVoidRight2(left, right) : exports_type7.IsUndefined(right) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromUnionRight2 = function(left, right) {
  return right.anyOf.some((schema) => Visit21(left, schema) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromUnion25 = function(left, right) {
  return left.anyOf.every((schema) => Visit21(schema, right) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromUnknownRight2 = function(left, right) {
  return ExtendsResult2.True;
};
var FromUnknown6 = function(left, right) {
  return exports_type7.IsNever(right) ? FromNeverRight2(left, right) : exports_type7.IsIntersect(right) ? FromIntersectRight2(left, right) : exports_type7.IsUnion(right) ? FromUnionRight2(left, right) : exports_type7.IsAny(right) ? FromAnyRight2(left, right) : exports_type7.IsString(right) ? FromStringRight2(left, right) : exports_type7.IsNumber(right) ? FromNumberRight2(left, right) : exports_type7.IsInteger(right) ? FromIntegerRight2(left, right) : exports_type7.IsBoolean(right) ? FromBooleanRight2(left, right) : exports_type7.IsArray(right) ? FromArrayRight2(left, right) : exports_type7.IsTuple(right) ? FromTupleRight2(left, right) : exports_type7.IsObject(right) ? FromObjectRight2(left, right) : exports_type7.IsUnknown(right) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromVoidRight2 = function(left, right) {
  return exports_type7.IsUndefined(left) ? ExtendsResult2.True : exports_type7.IsUndefined(left) ? ExtendsResult2.True : ExtendsResult2.False;
};
var FromVoid6 = function(left, right) {
  return exports_type7.IsIntersect(right) ? FromIntersectRight2(left, right) : exports_type7.IsUnion(right) ? FromUnionRight2(left, right) : exports_type7.IsUnknown(right) ? FromUnknownRight2(left, right) : exports_type7.IsAny(right) ? FromAnyRight2(left, right) : exports_type7.IsObject(right) ? FromObjectRight2(left, right) : exports_type7.IsVoid(right) ? ExtendsResult2.True : ExtendsResult2.False;
};
var Visit21 = function(left, right) {
  return exports_type7.IsTemplateLiteral(left) || exports_type7.IsTemplateLiteral(right) ? FromTemplateLiteral9(left, right) : exports_type7.IsRegExp(left) || exports_type7.IsRegExp(right) ? FromRegExp6(left, right) : exports_type7.IsNot(left) || exports_type7.IsNot(right) ? FromNot9(left, right) : exports_type7.IsAny(left) ? FromAny6(left, right) : exports_type7.IsArray(left) ? FromArray19(left, right) : exports_type7.IsBigInt(left) ? FromBigInt7(left, right) : exports_type7.IsBoolean(left) ? FromBoolean7(left, right) : exports_type7.IsAsyncIterator(left) ? FromAsyncIterator8(left, right) : exports_type7.IsConstructor(left) ? FromConstructor9(left, right) : exports_type7.IsDate(left) ? FromDate7(left, right) : exports_type7.IsFunction(left) ? FromFunction8(left, right) : exports_type7.IsInteger(left) ? FromInteger7(left, right) : exports_type7.IsIntersect(left) ? FromIntersect21(left, right) : exports_type7.IsIterator(left) ? FromIterator8(left, right) : exports_type7.IsLiteral(left) ? FromLiteral9(left, right) : exports_type7.IsNever(left) ? FromNever7(left, right) : exports_type7.IsNull(left) ? FromNull7(left, right) : exports_type7.IsNumber(left) ? FromNumber7(left, right) : exports_type7.IsObject(left) ? FromObject14(left, right) : exports_type7.IsRecord(left) ? FromRecord13(left, right) : exports_type7.IsString(left) ? FromString7(left, right) : exports_type7.IsSymbol(left) ? FromSymbol7(left, right) : exports_type7.IsTuple(left) ? FromTuple18(left, right) : exports_type7.IsPromise(left) ? FromPromise9(left, right) : exports_type7.IsUint8Array(left) ? FromUint8Array6(left, right) : exports_type7.IsUndefined(left) ? FromUndefined7(left, right) : exports_type7.IsUnion(left) ? FromUnion25(left, right) : exports_type7.IsUnknown(left) ? FromUnknown6(left, right) : exports_type7.IsVoid(left) ? FromVoid6(left, right) : Throw2(`Unknown left type operand '${left[Kind2]}'`);
};
function ExtendsCheck2(left, right) {
  return Visit21(left, right);
}

class ExtendsResolverError2 extends TypeBoxError2 {
}
var ExtendsResult2;
(function(ExtendsResult3) {
  ExtendsResult3[ExtendsResult3["Union"] = 0] = "Union";
  ExtendsResult3[ExtendsResult3["True"] = 1] = "True";
  ExtendsResult3[ExtendsResult3["False"] = 2] = "False";
})(ExtendsResult2 || (ExtendsResult2 = {}));
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/extends/extends-from-mapped-result.mjs
var FromProperties26 = function(P, Right, True, False, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Extends2(P[K2], Right, True, False, options) };
  }, {});
};
var FromMappedResult18 = function(Left, Right, True, False, options) {
  return FromProperties26(Left.properties, Right, True, False, options);
};
function ExtendsFromMappedResult2(Left, Right, True, False, options) {
  const P = FromMappedResult18(Left, Right, True, False, options);
  return MappedResult2(P);
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/extends/extends.mjs
var ExtendsResolve2 = function(left, right, trueType, falseType) {
  const R2 = ExtendsCheck2(left, right);
  return R2 === ExtendsResult2.Union ? Union3([trueType, falseType]) : R2 === ExtendsResult2.True ? trueType : falseType;
};
function Extends2(L2, R2, T, F, options = {}) {
  return IsMappedResult2(L2) ? ExtendsFromMappedResult2(L2, R2, T, F, options) : IsMappedKey2(L2) ? CloneType2(ExtendsFromMappedKey2(L2, R2, T, F, options)) : CloneType2(ExtendsResolve2(L2, R2, T, F), options);
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/extends/extends-from-mapped-key.mjs
var FromPropertyKey4 = function(K, U, L2, R2, options) {
  return {
    [K]: Extends2(Literal2(K), U, L2, R2, options)
  };
};
var FromPropertyKeys4 = function(K, U, L2, R2, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey4(LK, U, L2, R2, options) };
  }, {});
};
var FromMappedKey6 = function(K, U, L2, R2, options) {
  return FromPropertyKeys4(K.keys, U, L2, R2, options);
};
function ExtendsFromMappedKey2(T, U, L2, R2, options) {
  const P = FromMappedKey6(T, U, L2, R2, options);
  return MappedResult2(P);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/value/check/check.mjs
var IsAnyOrUnknown2 = function(schema) {
  return schema[Kind2] === "Any" || schema[Kind2] === "Unknown";
};
var IsDefined4 = function(value16) {
  return value16 !== undefined;
};
var FromAny7 = function(schema, references, value16) {
  return true;
};
var FromArray20 = function(schema, references, value16) {
  if (!IsArray4(value16))
    return false;
  if (IsDefined4(schema.minItems) && !(value16.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined4(schema.maxItems) && !(value16.length <= schema.maxItems)) {
    return false;
  }
  if (!value16.every((value17) => Visit22(schema.items, references, value17))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set3 = new Set;
    for (const element of value16) {
      const hashed = Hash3(element);
      if (set3.has(hashed)) {
        return false;
      } else {
        set3.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined4(schema.contains) || IsNumber4(schema.minContains) || IsNumber4(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined4(schema.contains) ? schema.contains : Never2();
  const containsCount = value16.reduce((acc, value17) => Visit22(containsSchema, references, value17) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber4(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber4(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
};
var FromAsyncIterator9 = function(schema, references, value16) {
  return IsAsyncIterator4(value16);
};
var FromBigInt8 = function(schema, references, value16) {
  if (!IsBigInt4(value16))
    return false;
  if (IsDefined4(schema.exclusiveMaximum) && !(value16 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined4(schema.exclusiveMinimum) && !(value16 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined4(schema.maximum) && !(value16 <= schema.maximum)) {
    return false;
  }
  if (IsDefined4(schema.minimum) && !(value16 >= schema.minimum)) {
    return false;
  }
  if (IsDefined4(schema.multipleOf) && !(value16 % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
};
var FromBoolean8 = function(schema, references, value16) {
  return IsBoolean4(value16);
};
var FromConstructor10 = function(schema, references, value16) {
  return Visit22(schema.returns, references, value16.prototype);
};
var FromDate8 = function(schema, references, value16) {
  if (!IsDate4(value16))
    return false;
  if (IsDefined4(schema.exclusiveMaximumTimestamp) && !(value16.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined4(schema.exclusiveMinimumTimestamp) && !(value16.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined4(schema.maximumTimestamp) && !(value16.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined4(schema.minimumTimestamp) && !(value16.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined4(schema.multipleOfTimestamp) && !(value16.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
};
var FromFunction9 = function(schema, references, value16) {
  return IsFunction4(value16);
};
var FromInteger8 = function(schema, references, value16) {
  if (!IsInteger3(value16)) {
    return false;
  }
  if (IsDefined4(schema.exclusiveMaximum) && !(value16 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined4(schema.exclusiveMinimum) && !(value16 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined4(schema.maximum) && !(value16 <= schema.maximum)) {
    return false;
  }
  if (IsDefined4(schema.minimum) && !(value16 >= schema.minimum)) {
    return false;
  }
  if (IsDefined4(schema.multipleOf) && !(value16 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
};
var FromIntersect22 = function(schema, references, value16) {
  const check1 = schema.allOf.every((schema2) => Visit22(schema2, references, value16));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern2(schema));
    const check22 = Object.getOwnPropertyNames(value16).every((key) => keyPattern.test(key));
    return check1 && check22;
  } else if (IsSchema2(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern2(schema));
    const check22 = Object.getOwnPropertyNames(value16).every((key) => keyCheck.test(key) || Visit22(schema.unevaluatedProperties, references, value16[key]));
    return check1 && check22;
  } else {
    return check1;
  }
};
var FromIterator9 = function(schema, references, value16) {
  return IsIterator4(value16);
};
var FromLiteral10 = function(schema, references, value16) {
  return value16 === schema.const;
};
var FromNever8 = function(schema, references, value16) {
  return false;
};
var FromNot10 = function(schema, references, value16) {
  return !Visit22(schema.not, references, value16);
};
var FromNull8 = function(schema, references, value16) {
  return IsNull4(value16);
};
var FromNumber8 = function(schema, references, value16) {
  if (!TypeSystemPolicy2.IsNumberLike(value16))
    return false;
  if (IsDefined4(schema.exclusiveMaximum) && !(value16 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined4(schema.exclusiveMinimum) && !(value16 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined4(schema.minimum) && !(value16 >= schema.minimum)) {
    return false;
  }
  if (IsDefined4(schema.maximum) && !(value16 <= schema.maximum)) {
    return false;
  }
  if (IsDefined4(schema.multipleOf) && !(value16 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
};
var FromObject15 = function(schema, references, value16) {
  if (!TypeSystemPolicy2.IsObjectLike(value16))
    return false;
  if (IsDefined4(schema.minProperties) && !(Object.getOwnPropertyNames(value16).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined4(schema.maxProperties) && !(Object.getOwnPropertyNames(value16).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit22(property, references, value16[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck2(property) || IsAnyOrUnknown2(property)) && !(knownKey in value16)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy2.IsExactOptionalProperty(value16, knownKey) && !Visit22(property, references, value16[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value16);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value16);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit22(schema.additionalProperties, references, value16[key]));
  } else {
    return true;
  }
};
var FromPromise10 = function(schema, references, value16) {
  return IsPromise3(value16);
};
var FromRecord14 = function(schema, references, value16) {
  if (!TypeSystemPolicy2.IsRecordLike(value16)) {
    return false;
  }
  if (IsDefined4(schema.minProperties) && !(Object.getOwnPropertyNames(value16).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined4(schema.maxProperties) && !(Object.getOwnPropertyNames(value16).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value16).every(([key, value17]) => {
    return regex.test(key) ? Visit22(patternSchema, references, value17) : true;
  });
  const check22 = typeof schema.additionalProperties === "object" ? Object.entries(value16).every(([key, value17]) => {
    return !regex.test(key) ? Visit22(schema.additionalProperties, references, value17) : true;
  }) : true;
  const check32 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value16).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check22 && check32;
};
var FromRef13 = function(schema, references, value16) {
  return Visit22(Deref3(schema, references), references, value16);
};
var FromRegExp7 = function(schema, references, value16) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined4(schema.minLength)) {
    if (!(value16.length >= schema.minLength))
      return false;
  }
  if (IsDefined4(schema.maxLength)) {
    if (!(value16.length <= schema.maxLength))
      return false;
  }
  return regex.test(value16);
};
var FromString8 = function(schema, references, value16) {
  if (!IsString4(value16)) {
    return false;
  }
  if (IsDefined4(schema.minLength)) {
    if (!(value16.length >= schema.minLength))
      return false;
  }
  if (IsDefined4(schema.maxLength)) {
    if (!(value16.length <= schema.maxLength))
      return false;
  }
  if (IsDefined4(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value16))
      return false;
  }
  if (IsDefined4(schema.format)) {
    if (!exports_format2.Has(schema.format))
      return false;
    const func = exports_format2.Get(schema.format);
    return func(value16);
  }
  return true;
};
var FromSymbol8 = function(schema, references, value16) {
  return IsSymbol4(value16);
};
var FromTemplateLiteral10 = function(schema, references, value16) {
  return IsString4(value16) && new RegExp(schema.pattern).test(value16);
};
var FromThis12 = function(schema, references, value16) {
  return Visit22(Deref3(schema, references), references, value16);
};
var FromTuple19 = function(schema, references, value16) {
  if (!IsArray4(value16)) {
    return false;
  }
  if (schema.items === undefined && !(value16.length === 0)) {
    return false;
  }
  if (!(value16.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit22(schema.items[i], references, value16[i]))
      return false;
  }
  return true;
};
var FromUndefined8 = function(schema, references, value16) {
  return IsUndefined4(value16);
};
var FromUnion26 = function(schema, references, value16) {
  return schema.anyOf.some((inner) => Visit22(inner, references, value16));
};
var FromUint8Array7 = function(schema, references, value16) {
  if (!IsUint8Array4(value16)) {
    return false;
  }
  if (IsDefined4(schema.maxByteLength) && !(value16.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined4(schema.minByteLength) && !(value16.length >= schema.minByteLength)) {
    return false;
  }
  return true;
};
var FromUnknown7 = function(schema, references, value16) {
  return true;
};
var FromVoid7 = function(schema, references, value16) {
  return TypeSystemPolicy2.IsVoidLike(value16);
};
var FromKind5 = function(schema, references, value16) {
  if (!exports_type5.Has(schema[Kind2]))
    return false;
  const func = exports_type5.Get(schema[Kind2]);
  return func(schema, value16);
};
var Visit22 = function(schema, references, value16) {
  const references_ = IsDefined4(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind2]) {
    case "Any":
      return FromAny7(schema_, references_, value16);
    case "Array":
      return FromArray20(schema_, references_, value16);
    case "AsyncIterator":
      return FromAsyncIterator9(schema_, references_, value16);
    case "BigInt":
      return FromBigInt8(schema_, references_, value16);
    case "Boolean":
      return FromBoolean8(schema_, references_, value16);
    case "Constructor":
      return FromConstructor10(schema_, references_, value16);
    case "Date":
      return FromDate8(schema_, references_, value16);
    case "Function":
      return FromFunction9(schema_, references_, value16);
    case "Integer":
      return FromInteger8(schema_, references_, value16);
    case "Intersect":
      return FromIntersect22(schema_, references_, value16);
    case "Iterator":
      return FromIterator9(schema_, references_, value16);
    case "Literal":
      return FromLiteral10(schema_, references_, value16);
    case "Never":
      return FromNever8(schema_, references_, value16);
    case "Not":
      return FromNot10(schema_, references_, value16);
    case "Null":
      return FromNull8(schema_, references_, value16);
    case "Number":
      return FromNumber8(schema_, references_, value16);
    case "Object":
      return FromObject15(schema_, references_, value16);
    case "Promise":
      return FromPromise10(schema_, references_, value16);
    case "Record":
      return FromRecord14(schema_, references_, value16);
    case "Ref":
      return FromRef13(schema_, references_, value16);
    case "RegExp":
      return FromRegExp7(schema_, references_, value16);
    case "String":
      return FromString8(schema_, references_, value16);
    case "Symbol":
      return FromSymbol8(schema_, references_, value16);
    case "TemplateLiteral":
      return FromTemplateLiteral10(schema_, references_, value16);
    case "This":
      return FromThis12(schema_, references_, value16);
    case "Tuple":
      return FromTuple19(schema_, references_, value16);
    case "Undefined":
      return FromUndefined8(schema_, references_, value16);
    case "Union":
      return FromUnion26(schema_, references_, value16);
    case "Uint8Array":
      return FromUint8Array7(schema_, references_, value16);
    case "Unknown":
      return FromUnknown7(schema_, references_, value16);
    case "Void":
      return FromVoid7(schema_, references_, value16);
    default:
      if (!exports_type5.Has(schema_[Kind2]))
        throw new ValueCheckUnknownTypeError2(schema_);
      return FromKind5(schema_, references_, value16);
  }
};
function Check3(...args) {
  return args.length === 3 ? Visit22(args[0], args[1], args[2]) : Visit22(args[0], [], args[1]);
}

class ValueCheckUnknownTypeError2 extends TypeBoxError2 {
  schema;
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/value/clone/clone.mjs
var ObjectType9 = function(value16) {
  const keys = [...Object.getOwnPropertyNames(value16), ...Object.getOwnPropertySymbols(value16)];
  return keys.reduce((acc, key) => ({ ...acc, [key]: Clone5(value16[key]) }), {});
};
var ArrayType9 = function(value16) {
  return value16.map((element) => Clone5(element));
};
var TypedArrayType5 = function(value16) {
  return value16.slice();
};
var DateType7 = function(value16) {
  return new Date(value16.toISOString());
};
var ValueType5 = function(value16) {
  return value16;
};
function Clone5(value16) {
  if (IsArray4(value16))
    return ArrayType9(value16);
  if (IsDate4(value16))
    return DateType7(value16);
  if (IsPlainObject2(value16))
    return ObjectType9(value16);
  if (IsTypedArray2(value16))
    return TypedArrayType5(value16);
  if (IsValueType2(value16))
    return ValueType5(value16);
  throw new Error("ValueClone: Unable to clone value");
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/value/create/create.mjs
var FromDefault2 = function(value16) {
  return typeof value16 === "function" ? value16 : Clone5(value16);
};
var FromAny8 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return {};
  }
};
var FromArray21 = function(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError2(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError2(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault2(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit23(schema.items, references);
    });
  } else {
    return [];
  }
};
var FromAsyncIterator10 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return async function* () {
    }();
  }
};
var FromBigInt9 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return BigInt(0);
  }
};
var FromBoolean9 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return false;
  }
};
var FromConstructor11 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    const value16 = Visit23(schema.returns, references);
    if (typeof value16 === "object" && !Array.isArray(value16)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value16)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
};
var FromDate9 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
};
var FromFunction10 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return () => Visit23(schema.returns, references);
  }
};
var FromInteger9 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
};
var FromIntersect23 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    const value16 = schema.allOf.reduce((acc, schema2) => {
      const next = Visit23(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check3(schema, references, value16))
      throw new ValueCreateError2(schema, "Intersect produced invalid value. Consider using a default value.");
    return value16;
  }
};
var FromIterator10 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return function* () {
    }();
  }
};
var FromLiteral11 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return schema.const;
  }
};
var FromNever9 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    throw new ValueCreateError2(schema, "Never types cannot be created. Consider using a default value.");
  }
};
var FromNot11 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    throw new ValueCreateError2(schema, "Not types must have a default value");
  }
};
var FromNull9 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return null;
  }
};
var FromNumber9 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
};
var FromObject16 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    const required4 = new Set(schema.required);
    return FromDefault2(schema.default) || Object.entries(schema.properties).reduce((acc, [key, schema2]) => {
      return required4.has(key) ? { ...acc, [key]: Visit23(schema2, references) } : { ...acc };
    }, {});
  }
};
var FromPromise11 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return Promise.resolve(Visit23(schema.item, references));
  }
};
var FromRecord15 = function(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else if (!(keyPattern === PatternStringExact2 || keyPattern === PatternNumberExact2)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    return propertyKeys.reduce((acc, key) => {
      return { ...acc, [key]: Visit23(valueSchema, references) };
    }, {});
  } else {
    return {};
  }
};
var FromRef14 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return Visit23(Deref3(schema, references), references);
  }
};
var FromRegExp8 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    throw new ValueCreateError2(schema, "RegExp types cannot be created. Consider using a default value.");
  }
};
var FromString9 = function(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError2(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault2(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError2(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault2(schema.default);
    }
  } else {
    if (HasPropertyKey2(schema, "default")) {
      return FromDefault2(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
};
var FromSymbol9 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
};
var FromTemplateLiteral11 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  }
  if (!IsTemplateLiteralFinite2(schema))
    throw new ValueCreateError2(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate2(schema);
  return generated[0];
};
var FromThis13 = function(schema, references) {
  if (recursiveDepth2++ > recursiveMaxDepth2)
    throw new ValueCreateError2(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return Visit23(Deref3(schema, references), references);
  }
};
var FromTuple20 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit23(schema.items[index], references));
  }
};
var FromUndefined9 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return;
  }
};
var FromUnion27 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit23(schema.anyOf[0], references);
  }
};
var FromUint8Array8 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
};
var FromUnknown8 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return {};
  }
};
var FromVoid8 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return;
  }
};
var FromKind6 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
};
var Visit23 = function(schema, references) {
  const references_ = IsString4(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind2]) {
    case "Any":
      return FromAny8(schema_, references_);
    case "Array":
      return FromArray21(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator10(schema_, references_);
    case "BigInt":
      return FromBigInt9(schema_, references_);
    case "Boolean":
      return FromBoolean9(schema_, references_);
    case "Constructor":
      return FromConstructor11(schema_, references_);
    case "Date":
      return FromDate9(schema_, references_);
    case "Function":
      return FromFunction10(schema_, references_);
    case "Integer":
      return FromInteger9(schema_, references_);
    case "Intersect":
      return FromIntersect23(schema_, references_);
    case "Iterator":
      return FromIterator10(schema_, references_);
    case "Literal":
      return FromLiteral11(schema_, references_);
    case "Never":
      return FromNever9(schema_, references_);
    case "Not":
      return FromNot11(schema_, references_);
    case "Null":
      return FromNull9(schema_, references_);
    case "Number":
      return FromNumber9(schema_, references_);
    case "Object":
      return FromObject16(schema_, references_);
    case "Promise":
      return FromPromise11(schema_, references_);
    case "Record":
      return FromRecord15(schema_, references_);
    case "Ref":
      return FromRef14(schema_, references_);
    case "RegExp":
      return FromRegExp8(schema_, references_);
    case "String":
      return FromString9(schema_, references_);
    case "Symbol":
      return FromSymbol9(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral11(schema_, references_);
    case "This":
      return FromThis13(schema_, references_);
    case "Tuple":
      return FromTuple20(schema_, references_);
    case "Undefined":
      return FromUndefined9(schema_, references_);
    case "Union":
      return FromUnion27(schema_, references_);
    case "Uint8Array":
      return FromUint8Array8(schema_, references_);
    case "Unknown":
      return FromUnknown8(schema_, references_);
    case "Void":
      return FromVoid8(schema_, references_);
    default:
      if (!exports_type5.Has(schema_[Kind2]))
        throw new ValueCreateError2(schema_, "Unknown type");
      return FromKind6(schema_, references_);
  }
};
function Create5(...args) {
  recursiveDepth2 = 0;
  return args.length === 2 ? Visit23(args[0], args[1]) : Visit23(args[0], []);
}

class ValueCreateError2 extends TypeBoxError2 {
  schema;
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
var recursiveMaxDepth2 = 512;
var recursiveDepth2 = 0;
// ../sisventa/node_modules/@sinclair/typebox/build/import/value/cast/cast.mjs
var ScoreUnion2 = function(schema, references, value16) {
  if (schema[Kind2] === "Object" && typeof value16 === "object" && !IsNull4(value16)) {
    const object14 = schema;
    const keys = Object.getOwnPropertyNames(value16);
    const entries = Object.entries(object14.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal19 = schema2[Kind2] === "Literal" && schema2.const === value16[key] ? max : 0;
      const checks = Check3(schema2, references, value16[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal19 + checks + exists);
    }, 0);
  } else {
    return Check3(schema, references, value16) ? 1 : 0;
  }
};
var SelectUnion2 = function(union29, references, value16) {
  let [select, best] = [union29.anyOf[0], 0];
  for (const schema of union29.anyOf) {
    const score = ScoreUnion2(schema, references, value16);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
};
var CastUnion2 = function(union29, references, value16) {
  if ("default" in union29) {
    return typeof value16 === "function" ? union29.default : Clone5(union29.default);
  } else {
    const schema = SelectUnion2(union29, references, value16);
    return Cast3(schema, references, value16);
  }
};
var DefaultClone2 = function(schema, references, value16) {
  return Check3(schema, references, value16) ? Clone5(value16) : Create5(schema, references);
};
var Default7 = function(schema, references, value16) {
  return Check3(schema, references, value16) ? value16 : Create5(schema, references);
};
var FromArray22 = function(schema, references, value16) {
  if (Check3(schema, references, value16))
    return Clone5(value16);
  const created = IsArray4(value16) ? Clone5(value16) : Create5(schema, references);
  const minimum = IsNumber4(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber4(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value17) => Visit24(schema.items, references, value17));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check3(schema, references, unique))
    throw new ValueCastError2(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
};
var FromConstructor12 = function(schema, references, value16) {
  if (Check3(schema, references, value16))
    return Create5(schema, references);
  const required4 = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required4.has(key) && value16.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit24(property, references, value16.prototype[key]);
  }
  return result;
};
var FromIntersect24 = function(schema, references, value16) {
  const created = Create5(schema, references);
  const mapped27 = IsPlainObject2(created) && IsPlainObject2(value16) ? { ...created, ...value16 } : value16;
  return Check3(schema, references, mapped27) ? mapped27 : Create5(schema, references);
};
var FromNever10 = function(schema, references, value16) {
  throw new ValueCastError2(schema, "Never types cannot be cast");
};
var FromObject17 = function(schema, references, value16) {
  if (Check3(schema, references, value16))
    return value16;
  if (value16 === null || typeof value16 !== "object")
    return Create5(schema, references);
  const required4 = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required4.has(key) && value16[key] === undefined)
      continue;
    result[key] = Visit24(property, references, value16[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value16)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit24(schema.additionalProperties, references, value16[propertyName]);
    }
  }
  return result;
};
var FromRecord16 = function(schema, references, value16) {
  if (Check3(schema, references, value16))
    return Clone5(value16);
  if (value16 === null || typeof value16 !== "object" || Array.isArray(value16) || value16 instanceof Date)
    return Create5(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value16)) {
    result[propKey] = Visit24(subschema, references, propValue);
  }
  return result;
};
var FromRef15 = function(schema, references, value16) {
  return Visit24(Deref3(schema, references), references, value16);
};
var FromThis14 = function(schema, references, value16) {
  return Visit24(Deref3(schema, references), references, value16);
};
var FromTuple21 = function(schema, references, value16) {
  if (Check3(schema, references, value16))
    return Clone5(value16);
  if (!IsArray4(value16))
    return Create5(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit24(schema2, references, value16[index]));
};
var FromUnion28 = function(schema, references, value16) {
  return Check3(schema, references, value16) ? Clone5(value16) : CastUnion2(schema, references, value16);
};
var Visit24 = function(schema, references, value16) {
  const references_ = IsString4(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind2]) {
    case "Array":
      return FromArray22(schema_, references_, value16);
    case "Constructor":
      return FromConstructor12(schema_, references_, value16);
    case "Intersect":
      return FromIntersect24(schema_, references_, value16);
    case "Never":
      return FromNever10(schema_, references_, value16);
    case "Object":
      return FromObject17(schema_, references_, value16);
    case "Record":
      return FromRecord16(schema_, references_, value16);
    case "Ref":
      return FromRef15(schema_, references_, value16);
    case "This":
      return FromThis14(schema_, references_, value16);
    case "Tuple":
      return FromTuple21(schema_, references_, value16);
    case "Union":
      return FromUnion28(schema_, references_, value16);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone2(schema, references, value16);
    default:
      return Default7(schema_, references_, value16);
  }
};
function Cast3(...args) {
  return args.length === 3 ? Visit24(args[0], args[1], args[2]) : Visit24(args[0], [], args[1]);
}

class ValueCastError2 extends TypeBoxError2 {
  schema;
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/value/clean/clean.mjs
var IsCheckable3 = function(schema) {
  return IsSchema2(schema) && schema[Kind2] !== "Unsafe";
};
var FromArray23 = function(schema, references, value16) {
  if (!IsArray4(value16))
    return value16;
  return value16.map((value17) => Visit25(schema.items, references, value17));
};
var FromIntersect25 = function(schema, references, value16) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit25(schema2, references, Clone5(value16)));
  const composite4 = intersections.reduce((acc, value17) => IsObject4(value17) ? { ...acc, ...value17 } : value17, {});
  if (!IsObject4(value16) || !IsObject4(composite4) || !IsSchema2(unevaluatedProperties))
    return composite4;
  const knownkeys = KeyOfPropertyKeys2(schema);
  for (const key of Object.getOwnPropertyNames(value16)) {
    if (knownkeys.includes(key))
      continue;
    if (Check3(unevaluatedProperties, references, value16[key])) {
      composite4[key] = Visit25(unevaluatedProperties, references, value16[key]);
    }
  }
  return composite4;
};
var FromObject18 = function(schema, references, value16) {
  if (!IsObject4(value16) || IsArray4(value16))
    return value16;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value16)) {
    if (key in schema.properties) {
      value16[key] = Visit25(schema.properties[key], references, value16[key]);
      continue;
    }
    if (IsSchema2(additionalProperties) && Check3(additionalProperties, references, value16[key])) {
      value16[key] = Visit25(additionalProperties, references, value16[key]);
      continue;
    }
    delete value16[key];
  }
  return value16;
};
var FromRecord17 = function(schema, references, value16) {
  if (!IsObject4(value16))
    return value16;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.keys(value16);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value16[key] = Visit25(propertySchema, references, value16[key]);
      continue;
    }
    if (IsSchema2(additionalProperties) && Check3(additionalProperties, references, value16[key])) {
      value16[key] = Visit25(additionalProperties, references, value16[key]);
      continue;
    }
    delete value16[key];
  }
  return value16;
};
var FromRef16 = function(schema, references, value16) {
  return Visit25(Deref3(schema, references), references, value16);
};
var FromThis15 = function(schema, references, value16) {
  return Visit25(Deref3(schema, references), references, value16);
};
var FromTuple22 = function(schema, references, value16) {
  if (!IsArray4(value16))
    return value16;
  if (IsUndefined4(schema.items))
    return [];
  const length = Math.min(value16.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value16[i] = Visit25(schema.items[i], references, value16[i]);
  }
  return value16.length > length ? value16.slice(0, length) : value16;
};
var FromUnion29 = function(schema, references, value16) {
  for (const inner of schema.anyOf) {
    if (IsCheckable3(inner) && Check3(inner, value16)) {
      return Visit25(inner, references, value16);
    }
  }
  return value16;
};
var Visit25 = function(schema, references, value16) {
  const references_ = IsString4(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind2]) {
    case "Array":
      return FromArray23(schema_, references_, value16);
    case "Intersect":
      return FromIntersect25(schema_, references_, value16);
    case "Object":
      return FromObject18(schema_, references_, value16);
    case "Record":
      return FromRecord17(schema_, references_, value16);
    case "Ref":
      return FromRef16(schema_, references_, value16);
    case "This":
      return FromThis15(schema_, references_, value16);
    case "Tuple":
      return FromTuple22(schema_, references_, value16);
    case "Union":
      return FromUnion29(schema_, references_, value16);
    default:
      return value16;
  }
};
function Clean3(...args) {
  return args.length === 3 ? Visit25(args[0], args[1], args[2]) : Visit25(args[0], [], args[1]);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/composite/composite.mjs
var CompositeKeys2 = function(T) {
  return T.reduce((Acc, L2) => {
    return SetDistinct2([...Acc, ...KeyOfPropertyKeys2(L2)]);
  }, []);
};
var FilterNever2 = function(T) {
  return T.filter((L2) => !IsNever2(L2));
};
var CompositeProperty2 = function(T, K) {
  return T.reduce((Acc, L2) => {
    return FilterNever2([...Acc, ...IndexFromPropertyKeys2(L2, [K])]);
  }, []);
};
var CompositeProperties2 = function(T, K) {
  return K.reduce((Acc, L2) => {
    return { ...Acc, [L2]: IntersectEvaluated2(CompositeProperty2(T, L2)) };
  }, {});
};
function Composite2(T, options = {}) {
  const K = CompositeKeys2(T);
  const P = CompositeProperties2(T, K);
  const R2 = Object3(P, options);
  return R2;
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/value/convert/convert.mjs
var IsStringNumeric2 = function(value16) {
  return IsString4(value16) && !isNaN(value16) && !isNaN(parseFloat(value16));
};
var IsValueToString2 = function(value16) {
  return IsBigInt4(value16) || IsBoolean4(value16) || IsNumber4(value16);
};
var IsValueTrue2 = function(value16) {
  return value16 === true || IsNumber4(value16) && value16 === 1 || IsBigInt4(value16) && value16 === BigInt("1") || IsString4(value16) && (value16.toLowerCase() === "true" || value16 === "1");
};
var IsValueFalse2 = function(value16) {
  return value16 === false || IsNumber4(value16) && (value16 === 0 || Object.is(value16, -0)) || IsBigInt4(value16) && value16 === BigInt("0") || IsString4(value16) && (value16.toLowerCase() === "false" || value16 === "0" || value16 === "-0");
};
var IsTimeStringWithTimeZone2 = function(value16) {
  return IsString4(value16) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value16);
};
var IsTimeStringWithoutTimeZone2 = function(value16) {
  return IsString4(value16) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value16);
};
var IsDateTimeStringWithTimeZone2 = function(value16) {
  return IsString4(value16) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value16);
};
var IsDateTimeStringWithoutTimeZone2 = function(value16) {
  return IsString4(value16) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value16);
};
var IsDateString2 = function(value16) {
  return IsString4(value16) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value16);
};
var TryConvertLiteralString2 = function(value16, target) {
  const conversion = TryConvertString2(value16);
  return conversion === target ? conversion : value16;
};
var TryConvertLiteralNumber2 = function(value16, target) {
  const conversion = TryConvertNumber2(value16);
  return conversion === target ? conversion : value16;
};
var TryConvertLiteralBoolean2 = function(value16, target) {
  const conversion = TryConvertBoolean2(value16);
  return conversion === target ? conversion : value16;
};
var TryConvertLiteral2 = function(schema, value16) {
  return IsString4(schema.const) ? TryConvertLiteralString2(value16, schema.const) : IsNumber4(schema.const) ? TryConvertLiteralNumber2(value16, schema.const) : IsBoolean4(schema.const) ? TryConvertLiteralBoolean2(value16, schema.const) : Clone5(value16);
};
var TryConvertBoolean2 = function(value16) {
  return IsValueTrue2(value16) ? true : IsValueFalse2(value16) ? false : value16;
};
var TryConvertBigInt2 = function(value16) {
  return IsStringNumeric2(value16) ? BigInt(parseInt(value16)) : IsNumber4(value16) ? BigInt(value16 | 0) : IsValueFalse2(value16) ? BigInt(0) : IsValueTrue2(value16) ? BigInt(1) : value16;
};
var TryConvertString2 = function(value16) {
  return IsValueToString2(value16) ? value16.toString() : IsSymbol4(value16) && value16.description !== undefined ? value16.description.toString() : value16;
};
var TryConvertNumber2 = function(value16) {
  return IsStringNumeric2(value16) ? parseFloat(value16) : IsValueTrue2(value16) ? 1 : IsValueFalse2(value16) ? 0 : value16;
};
var TryConvertInteger2 = function(value16) {
  return IsStringNumeric2(value16) ? parseInt(value16) : IsNumber4(value16) ? value16 | 0 : IsValueTrue2(value16) ? 1 : IsValueFalse2(value16) ? 0 : value16;
};
var TryConvertNull2 = function(value16) {
  return IsString4(value16) && value16.toLowerCase() === "null" ? null : value16;
};
var TryConvertUndefined2 = function(value16) {
  return IsString4(value16) && value16 === "undefined" ? undefined : value16;
};
var TryConvertDate2 = function(value16) {
  return IsDate4(value16) ? value16 : IsNumber4(value16) ? new Date(value16) : IsValueTrue2(value16) ? new Date(1) : IsValueFalse2(value16) ? new Date(0) : IsStringNumeric2(value16) ? new Date(parseInt(value16)) : IsTimeStringWithoutTimeZone2(value16) ? new Date(`1970-01-01T${value16}.000Z`) : IsTimeStringWithTimeZone2(value16) ? new Date(`1970-01-01T${value16}`) : IsDateTimeStringWithoutTimeZone2(value16) ? new Date(`${value16}.000Z`) : IsDateTimeStringWithTimeZone2(value16) ? new Date(value16) : IsDateString2(value16) ? new Date(`${value16}T00:00:00.000Z`) : value16;
};
var Default8 = function(value16) {
  return value16;
};
var FromArray24 = function(schema, references, value16) {
  if (IsArray4(value16)) {
    return value16.map((value17) => Visit26(schema.items, references, value17));
  }
  return value16;
};
var FromBigInt10 = function(schema, references, value16) {
  return TryConvertBigInt2(value16);
};
var FromBoolean10 = function(schema, references, value16) {
  return TryConvertBoolean2(value16);
};
var FromDate10 = function(schema, references, value16) {
  return TryConvertDate2(value16);
};
var FromInteger10 = function(schema, references, value16) {
  return TryConvertInteger2(value16);
};
var FromIntersect26 = function(schema, references, value16) {
  const allObjects = schema.allOf.every((schema2) => IsObject6(schema2));
  if (allObjects)
    return Visit26(Composite2(schema.allOf), references, value16);
  return Visit26(schema.allOf[0], references, value16);
};
var FromLiteral12 = function(schema, references, value16) {
  return TryConvertLiteral2(schema, value16);
};
var FromNull10 = function(schema, references, value16) {
  return TryConvertNull2(value16);
};
var FromNumber10 = function(schema, references, value16) {
  return TryConvertNumber2(value16);
};
var FromObject19 = function(schema, references, value16) {
  const isConvertable = IsObject4(value16);
  if (!isConvertable)
    return value16;
  return Object.getOwnPropertyNames(schema.properties).reduce((value17, key) => {
    return !IsUndefined4(value17[key]) ? { ...value17, [key]: Visit26(schema.properties[key], references, value17[key]) } : { ...value17 };
  }, value16);
};
var FromRecord18 = function(schema, references, value16) {
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value16)) {
    result[propKey] = Visit26(property, references, propValue);
  }
  return result;
};
var FromRef17 = function(schema, references, value16) {
  return Visit26(Deref3(schema, references), references, value16);
};
var FromString10 = function(schema, references, value16) {
  return TryConvertString2(value16);
};
var FromSymbol10 = function(schema, references, value16) {
  return IsString4(value16) || IsNumber4(value16) ? Symbol(value16) : value16;
};
var FromThis16 = function(schema, references, value16) {
  return Visit26(Deref3(schema, references), references, value16);
};
var FromTuple23 = function(schema, references, value16) {
  const isConvertable = IsArray4(value16) && !IsUndefined4(schema.items);
  if (!isConvertable)
    return value16;
  return value16.map((value17, index) => {
    return index < schema.items.length ? Visit26(schema.items[index], references, value17) : value17;
  });
};
var FromUndefined10 = function(schema, references, value16) {
  return TryConvertUndefined2(value16);
};
var FromUnion30 = function(schema, references, value16) {
  for (const subschema of schema.anyOf) {
    const converted = Visit26(subschema, references, value16);
    if (Check3(subschema, references, converted)) {
      return converted;
    }
  }
  return value16;
};
var Visit26 = function(schema, references, value16) {
  const references_ = IsString4(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind2]) {
    case "Array":
      return FromArray24(schema_, references_, value16);
    case "BigInt":
      return FromBigInt10(schema_, references_, value16);
    case "Boolean":
      return FromBoolean10(schema_, references_, value16);
    case "Date":
      return FromDate10(schema_, references_, value16);
    case "Integer":
      return FromInteger10(schema_, references_, value16);
    case "Intersect":
      return FromIntersect26(schema_, references_, value16);
    case "Literal":
      return FromLiteral12(schema_, references_, value16);
    case "Null":
      return FromNull10(schema_, references_, value16);
    case "Number":
      return FromNumber10(schema_, references_, value16);
    case "Object":
      return FromObject19(schema_, references_, value16);
    case "Record":
      return FromRecord18(schema_, references_, value16);
    case "Ref":
      return FromRef17(schema_, references_, value16);
    case "String":
      return FromString10(schema_, references_, value16);
    case "Symbol":
      return FromSymbol10(schema_, references_, value16);
    case "This":
      return FromThis16(schema_, references_, value16);
    case "Tuple":
      return FromTuple23(schema_, references_, value16);
    case "Undefined":
      return FromUndefined10(schema_, references_, value16);
    case "Union":
      return FromUnion30(schema_, references_, value16);
    default:
      return Default8(value16);
  }
};
function Convert3(...args) {
  return args.length === 3 ? Visit26(args[0], args[1], args[2]) : Visit26(args[0], [], args[1]);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/value/default/default.mjs
var ValueOrDefault2 = function(schema, value16) {
  return value16 === undefined && "default" in schema ? Clone5(schema.default) : value16;
};
var IsCheckable4 = function(schema) {
  return IsSchema2(schema) && schema[Kind2] !== "Unsafe";
};
var IsDefaultSchema2 = function(value16) {
  return IsSchema2(value16) && "default" in value16;
};
var FromArray25 = function(schema, references, value16) {
  const defaulted = ValueOrDefault2(schema, value16);
  if (!IsArray4(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit27(schema.items, references, defaulted[i]);
  }
  return defaulted;
};
var FromIntersect27 = function(schema, references, value16) {
  const defaulted = ValueOrDefault2(schema, value16);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit27(schema2, references, defaulted);
    return IsObject4(next) ? { ...acc, ...next } : next;
  }, {});
};
var FromObject20 = function(schema, references, value16) {
  const defaulted = ValueOrDefault2(schema, value16);
  if (!IsObject4(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    if (!IsDefaultSchema2(schema.properties[key]))
      continue;
    defaulted[key] = Visit27(schema.properties[key], references, defaulted[key]);
  }
  if (!IsDefaultSchema2(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit27(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
};
var FromRecord19 = function(schema, references, value16) {
  const defaulted = ValueOrDefault2(schema, value16);
  if (!IsObject4(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && IsDefaultSchema2(propertySchema)))
      continue;
    defaulted[key] = Visit27(propertySchema, references, defaulted[key]);
  }
  if (!IsDefaultSchema2(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit27(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
};
var FromRef18 = function(schema, references, value16) {
  return Visit27(Deref3(schema, references), references, ValueOrDefault2(schema, value16));
};
var FromThis17 = function(schema, references, value16) {
  return Visit27(Deref3(schema, references), references, value16);
};
var FromTuple24 = function(schema, references, value16) {
  const defaulted = ValueOrDefault2(schema, value16);
  if (!IsArray4(defaulted) || IsUndefined4(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit27(items[i], references, defaulted[i]);
  }
  return defaulted;
};
var FromUnion31 = function(schema, references, value16) {
  const defaulted = ValueOrDefault2(schema, value16);
  for (const inner of schema.anyOf) {
    const result = Visit27(inner, references, defaulted);
    if (IsCheckable4(inner) && Check3(inner, result)) {
      return result;
    }
  }
  return defaulted;
};
var Visit27 = function(schema, references, value16) {
  const references_ = IsString4(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind2]) {
    case "Array":
      return FromArray25(schema_, references_, value16);
    case "Intersect":
      return FromIntersect27(schema_, references_, value16);
    case "Object":
      return FromObject20(schema_, references_, value16);
    case "Record":
      return FromRecord19(schema_, references_, value16);
    case "Ref":
      return FromRef18(schema_, references_, value16);
    case "This":
      return FromThis17(schema_, references_, value16);
    case "Tuple":
      return FromTuple24(schema_, references_, value16);
    case "Union":
      return FromUnion31(schema_, references_, value16);
    default:
      return ValueOrDefault2(schema_, value16);
  }
};
function Default9(...args) {
  return args.length === 3 ? Visit27(args[0], args[1], args[2]) : Visit27(args[0], [], args[1]);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/value/pointer/pointer.mjs
var exports_pointer2 = {};
__export(exports_pointer2, {
  ValuePointerRootSetError: () => {
    {
      return ValuePointerRootSetError2;
    }
  },
  ValuePointerRootDeleteError: () => {
    {
      return ValuePointerRootDeleteError2;
    }
  },
  Set: () => {
    {
      return Set7;
    }
  },
  Has: () => {
    {
      return Has6;
    }
  },
  Get: () => {
    {
      return Get6;
    }
  },
  Format: () => {
    {
      return Format2;
    }
  },
  Delete: () => {
    {
      return Delete7;
    }
  }
});
var Escape4 = function(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
};
function* Format2(pointer3) {
  if (pointer3 === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer3.length; i++) {
    const char = pointer3.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape4(pointer3.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape4(pointer3.slice(start));
}
function Set7(value16, pointer3, update) {
  if (pointer3 === "")
    throw new ValuePointerRootSetError2(value16, pointer3, update);
  let [owner, next, key] = [null, value16, ""];
  for (const component of Format2(pointer3)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete7(value16, pointer3) {
  if (pointer3 === "")
    throw new ValuePointerRootDeleteError2(value16, pointer3);
  let [owner, next, key] = [null, value16, ""];
  for (const component of Format2(pointer3)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has6(value16, pointer3) {
  if (pointer3 === "")
    return true;
  let [owner, next, key] = [null, value16, ""];
  for (const component of Format2(pointer3)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get6(value16, pointer3) {
  if (pointer3 === "")
    return value16;
  let current = value16;
  for (const component of Format2(pointer3)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}

class ValuePointerRootSetError2 extends TypeBoxError2 {
  value;
  path;
  update;
  constructor(value16, path, update) {
    super("Cannot set root value");
    this.value = value16;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError2 extends TypeBoxError2 {
  value;
  path;
  constructor(value16, path) {
    super("Cannot delete root value");
    this.value = value16;
    this.path = path;
  }
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/value/delta/delta.mjs
var CreateUpdate2 = function(path, value16) {
  return { type: "update", path, value: value16 };
};
var CreateInsert2 = function(path, value16) {
  return { type: "insert", path, value: value16 };
};
var CreateDelete2 = function(path) {
  return { type: "delete", path };
};
function* ObjectType10(path, current, next) {
  if (!IsPlainObject2(next))
    return yield CreateUpdate2(path, next);
  const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
  const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
  for (const key of currentKeys) {
    if (IsSymbol4(key))
      throw new ValueDeltaSymbolError2(key);
    if (IsUndefined4(next[key]) && nextKeys.includes(key))
      yield CreateUpdate2(`${path}/${globalThis.String(key)}`, undefined);
  }
  for (const key of nextKeys) {
    if (IsUndefined4(current[key]) || IsUndefined4(next[key]))
      continue;
    if (IsSymbol4(key))
      throw new ValueDeltaSymbolError2(key);
    yield* Visit28(`${path}/${globalThis.String(key)}`, current[key], next[key]);
  }
  for (const key of nextKeys) {
    if (IsSymbol4(key))
      throw new ValueDeltaSymbolError2(key);
    if (IsUndefined4(current[key]))
      yield CreateInsert2(`${path}/${globalThis.String(key)}`, next[key]);
  }
  for (const key of currentKeys.reverse()) {
    if (IsSymbol4(key))
      throw new ValueDeltaSymbolError2(key);
    if (IsUndefined4(next[key]) && !nextKeys.includes(key))
      yield CreateDelete2(`${path}/${globalThis.String(key)}`);
  }
}
function* ArrayType10(path, current, next) {
  if (!IsArray4(next))
    return yield CreateUpdate2(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit28(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert2(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete2(`${path}/${i}`);
  }
}
function* TypedArrayType6(path, current, next) {
  if (!IsTypedArray2(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate2(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit28(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType6(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate2(path, next);
}
function* Visit28(path, current, next) {
  if (IsPlainObject2(current))
    return yield* ObjectType10(path, current, next);
  if (IsArray4(current))
    return yield* ArrayType10(path, current, next);
  if (IsTypedArray2(current))
    return yield* TypedArrayType6(path, current, next);
  if (IsValueType2(current))
    return yield* ValueType6(path, current, next);
  throw new ValueDeltaError2(current, "Unable to create diff edits for unknown value");
}
function Diff3(current, next) {
  return [...Visit28("", current, next)];
}
var IsRootUpdate2 = function(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
};
var IsIdentity2 = function(edits) {
  return edits.length === 0;
};
function Patch3(current, edits) {
  if (IsRootUpdate2(edits)) {
    return Clone5(edits[0].value);
  }
  if (IsIdentity2(edits)) {
    return Clone5(current);
  }
  const clone18 = Clone5(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer2.Set(clone18, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer2.Set(clone18, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer2.Delete(clone18, edit.path);
        break;
      }
    }
  }
  return clone18;
}
var Insert2 = Object3({
  type: Literal2("insert"),
  path: String3(),
  value: Unknown2()
});
var Update2 = Object3({
  type: Literal2("update"),
  path: String3(),
  value: Unknown2()
});
var Delete8 = Object3({
  type: Literal2("delete"),
  path: String3()
});
var Edit2 = Union3([Insert2, Update2, Delete8]);

class ValueDeltaError2 extends TypeBoxError2 {
  value;
  constructor(value16, message) {
    super(message);
    this.value = value16;
  }
}

class ValueDeltaSymbolError2 extends ValueDeltaError2 {
  value;
  constructor(value16) {
    super(value16, "Cannot diff objects with symbol keys");
    this.value = value16;
  }
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/value/equal/equal.mjs
var ObjectType11 = function(left, right) {
  if (!IsPlainObject2(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal3(left[key], right[key]));
};
var DateType8 = function(left, right) {
  return IsDate4(right) && left.getTime() === right.getTime();
};
var ArrayType11 = function(left, right) {
  if (!IsArray4(right) || left.length !== right.length)
    return false;
  return left.every((value16, index) => Equal3(value16, right[index]));
};
var TypedArrayType7 = function(left, right) {
  if (!IsTypedArray2(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value16, index) => Equal3(value16, right[index]));
};
var ValueType7 = function(left, right) {
  return left === right;
};
function Equal3(left, right) {
  if (IsPlainObject2(left))
    return ObjectType11(left, right);
  if (IsDate4(left))
    return DateType8(left, right);
  if (IsTypedArray2(left))
    return TypedArrayType7(left, right);
  if (IsArray4(left))
    return ArrayType11(left, right);
  if (IsValueType2(left))
    return ValueType7(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/value/mutate/mutate.mjs
var ObjectType12 = function(root, path, current, next) {
  if (!IsPlainObject2(current)) {
    exports_pointer2.Set(root, path, Clone5(next));
  } else {
    const currentKeys = Object.keys(current);
    const nextKeys = Object.keys(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit29(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
};
var ArrayType12 = function(root, path, current, next) {
  if (!IsArray4(current)) {
    exports_pointer2.Set(root, path, Clone5(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit29(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
};
var TypedArrayType8 = function(root, path, current, next) {
  if (IsTypedArray2(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer2.Set(root, path, Clone5(next));
  }
};
var ValueType8 = function(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer2.Set(root, path, next);
};
var Visit29 = function(root, path, current, next) {
  if (IsArray4(next))
    return ArrayType12(root, path, current, next);
  if (IsTypedArray2(next))
    return TypedArrayType8(root, path, current, next);
  if (IsPlainObject2(next))
    return ObjectType12(root, path, current, next);
  if (IsValueType2(next))
    return ValueType8(root, path, current, next);
};
var IsNonMutableValue2 = function(value16) {
  return IsTypedArray2(value16) || IsValueType2(value16);
};
var IsMismatchedValue2 = function(current, next) {
  return IsPlainObject2(current) && IsArray4(next) || IsArray4(current) && IsPlainObject2(next);
};
function Mutate3(current, next) {
  if (IsNonMutableValue2(current) || IsNonMutableValue2(next))
    throw new ValueMutateError2("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue2(current, next))
    throw new ValueMutateError2("Cannot assign due type mismatch of assignable values");
  Visit29(current, "", current, next);
}

class ValueMutateError2 extends TypeBoxError2 {
  constructor(message) {
    super(message);
  }
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/value/transform/decode.mjs
var Default10 = function(schema, value16) {
  try {
    return IsTransform2(schema) ? schema[TransformKind2].Decode(value16) : value16;
  } catch (error39) {
    throw new TransformDecodeError2(schema, value16, error39);
  }
};
var FromArray26 = function(schema, references, value16) {
  return IsArray4(value16) ? Default10(schema, value16.map((value17) => Visit30(schema.items, references, value17))) : Default10(schema, value16);
};
var FromIntersect28 = function(schema, references, value16) {
  if (!IsPlainObject2(value16) || IsValueType2(value16))
    return Default10(schema, value16);
  const knownKeys = KeyOfPropertyKeys2(schema);
  const knownProperties = knownKeys.reduce((value17, key) => {
    return key in value17 ? { ...value17, [key]: Visit30(Index2(schema, [key]), references, value17[key]) } : value17;
  }, value16);
  if (!IsTransform2(schema.unevaluatedProperties)) {
    return Default10(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = unknownKeys.reduce((value17, key) => {
    return !knownKeys.includes(key) ? { ...value17, [key]: Default10(unevaluatedProperties, value17[key]) } : value17;
  }, knownProperties);
  return Default10(schema, unknownProperties);
};
var FromNot12 = function(schema, references, value16) {
  return Default10(schema, Visit30(schema.not, references, value16));
};
var FromObject21 = function(schema, references, value16) {
  if (!IsPlainObject2(value16))
    return Default10(schema, value16);
  const knownKeys = KeyOfPropertyKeys2(schema);
  const knownProperties = knownKeys.reduce((value17, key) => {
    return key in value17 ? { ...value17, [key]: Visit30(schema.properties[key], references, value17[key]) } : value17;
  }, value16);
  if (!IsSchema2(schema.additionalProperties)) {
    return Default10(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = unknownKeys.reduce((value17, key) => {
    return !knownKeys.includes(key) ? { ...value17, [key]: Default10(additionalProperties, value17[key]) } : value17;
  }, knownProperties);
  return Default10(schema, unknownProperties);
};
var FromRecord20 = function(schema, references, value16) {
  if (!IsPlainObject2(value16))
    return Default10(schema, value16);
  const pattern5 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern5);
  const knownProperties = Object.getOwnPropertyNames(value16).reduce((value17, key) => {
    return knownKeys.test(key) ? { ...value17, [key]: Visit30(schema.patternProperties[pattern5], references, value17[key]) } : value17;
  }, value16);
  if (!IsSchema2(schema.additionalProperties)) {
    return Default10(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = unknownKeys.reduce((value17, key) => {
    return !knownKeys.test(key) ? { ...value17, [key]: Default10(additionalProperties, value17[key]) } : value17;
  }, knownProperties);
  return Default10(schema, unknownProperties);
};
var FromRef19 = function(schema, references, value16) {
  const target = Deref3(schema, references);
  return Default10(schema, Visit30(target, references, value16));
};
var FromThis18 = function(schema, references, value16) {
  const target = Deref3(schema, references);
  return Default10(schema, Visit30(target, references, value16));
};
var FromTuple25 = function(schema, references, value16) {
  return IsArray4(value16) && IsArray4(schema.items) ? Default10(schema, schema.items.map((schema2, index) => Visit30(schema2, references, value16[index]))) : Default10(schema, value16);
};
var FromUnion32 = function(schema, references, value16) {
  for (const subschema of schema.anyOf) {
    if (!Check3(subschema, references, value16))
      continue;
    const decoded = Visit30(subschema, references, value16);
    return Default10(schema, decoded);
  }
  return Default10(schema, value16);
};
var Visit30 = function(schema, references, value16) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind2]) {
    case "Array":
      return FromArray26(schema_, references_, value16);
    case "Intersect":
      return FromIntersect28(schema_, references_, value16);
    case "Not":
      return FromNot12(schema_, references_, value16);
    case "Object":
      return FromObject21(schema_, references_, value16);
    case "Record":
      return FromRecord20(schema_, references_, value16);
    case "Ref":
      return FromRef19(schema_, references_, value16);
    case "Symbol":
      return Default10(schema_, value16);
    case "This":
      return FromThis18(schema_, references_, value16);
    case "Tuple":
      return FromTuple25(schema_, references_, value16);
    case "Union":
      return FromUnion32(schema_, references_, value16);
    default:
      return Default10(schema_, value16);
  }
};
function TransformDecode2(schema, references, value16) {
  return Visit30(schema, references, value16);
}

class TransformDecodeCheckError2 extends TypeBoxError2 {
  schema;
  value;
  error;
  constructor(schema, value16, error39) {
    super(`Unable to decode due to invalid value`);
    this.schema = schema;
    this.value = value16;
    this.error = error39;
  }
}

class TransformDecodeError2 extends TypeBoxError2 {
  schema;
  value;
  constructor(schema, value16, error39) {
    super(`${error39 instanceof Error ? error39.message : "Unknown error"}`);
    this.schema = schema;
    this.value = value16;
  }
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/value/transform/encode.mjs
var Default11 = function(schema, value16) {
  try {
    return IsTransform2(schema) ? schema[TransformKind2].Encode(value16) : value16;
  } catch (error40) {
    throw new TransformEncodeError2(schema, value16, error40);
  }
};
var FromArray27 = function(schema, references, value16) {
  const defaulted = Default11(schema, value16);
  return IsArray4(defaulted) ? defaulted.map((value17) => Visit31(schema.items, references, value17)) : defaulted;
};
var FromIntersect29 = function(schema, references, value16) {
  const defaulted = Default11(schema, value16);
  if (!IsPlainObject2(value16) || IsValueType2(value16))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys2(schema);
  const knownProperties = knownKeys.reduce((value17, key) => {
    return key in defaulted ? { ...value17, [key]: Visit31(Index2(schema, [key]), references, value17[key]) } : value17;
  }, defaulted);
  if (!IsTransform2(schema.unevaluatedProperties)) {
    return Default11(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  return unknownKeys.reduce((value17, key) => {
    return !knownKeys.includes(key) ? { ...value17, [key]: Default11(unevaluatedProperties, value17[key]) } : value17;
  }, knownProperties);
};
var FromNot13 = function(schema, references, value16) {
  return Default11(schema.not, Default11(schema, value16));
};
var FromObject22 = function(schema, references, value16) {
  const defaulted = Default11(schema, value16);
  if (!IsPlainObject2(value16))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys2(schema);
  const knownProperties = knownKeys.reduce((value17, key) => {
    return key in value17 ? { ...value17, [key]: Visit31(schema.properties[key], references, value17[key]) } : value17;
  }, defaulted);
  if (!IsSchema2(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  return unknownKeys.reduce((value17, key) => {
    return !knownKeys.includes(key) ? { ...value17, [key]: Default11(additionalProperties, value17[key]) } : value17;
  }, knownProperties);
};
var FromRecord21 = function(schema, references, value16) {
  const defaulted = Default11(schema, value16);
  if (!IsPlainObject2(value16))
    return defaulted;
  const pattern5 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern5);
  const knownProperties = Object.getOwnPropertyNames(value16).reduce((value17, key) => {
    return knownKeys.test(key) ? { ...value17, [key]: Visit31(schema.patternProperties[pattern5], references, value17[key]) } : value17;
  }, defaulted);
  if (!IsSchema2(schema.additionalProperties)) {
    return Default11(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  return unknownKeys.reduce((value17, key) => {
    return !knownKeys.test(key) ? { ...value17, [key]: Default11(additionalProperties, value17[key]) } : value17;
  }, knownProperties);
};
var FromRef20 = function(schema, references, value16) {
  const target = Deref3(schema, references);
  const resolved = Visit31(target, references, value16);
  return Default11(schema, resolved);
};
var FromThis19 = function(schema, references, value16) {
  const target = Deref3(schema, references);
  const resolved = Visit31(target, references, value16);
  return Default11(schema, resolved);
};
var FromTuple26 = function(schema, references, value16) {
  const value1 = Default11(schema, value16);
  return IsArray4(schema.items) ? schema.items.map((schema2, index) => Visit31(schema2, references, value1[index])) : [];
};
var FromUnion33 = function(schema, references, value16) {
  for (const subschema of schema.anyOf) {
    if (!Check3(subschema, references, value16))
      continue;
    const value1 = Visit31(subschema, references, value16);
    return Default11(schema, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit31(subschema, references, value16);
    if (!Check3(schema, references, value1))
      continue;
    return Default11(schema, value1);
  }
  return Default11(schema, value16);
};
var Visit31 = function(schema, references, value16) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind2]) {
    case "Array":
      return FromArray27(schema_, references_, value16);
    case "Intersect":
      return FromIntersect29(schema_, references_, value16);
    case "Not":
      return FromNot13(schema_, references_, value16);
    case "Object":
      return FromObject22(schema_, references_, value16);
    case "Record":
      return FromRecord21(schema_, references_, value16);
    case "Ref":
      return FromRef20(schema_, references_, value16);
    case "This":
      return FromThis19(schema_, references_, value16);
    case "Tuple":
      return FromTuple26(schema_, references_, value16);
    case "Union":
      return FromUnion33(schema_, references_, value16);
    default:
      return Default11(schema_, value16);
  }
};
function TransformEncode2(schema, references, value16) {
  return Visit31(schema, references, value16);
}

class TransformEncodeCheckError2 extends TypeBoxError2 {
  schema;
  value;
  error;
  constructor(schema, value16, error40) {
    super(`Unable to encode due to invalid value`);
    this.schema = schema;
    this.value = value16;
    this.error = error40;
  }
}

class TransformEncodeError2 extends TypeBoxError2 {
  schema;
  value;
  constructor(schema, value16, error40) {
    super(`${error40 instanceof Error ? error40.message : "Unknown error"}`);
    this.schema = schema;
    this.value = value16;
  }
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/value/transform/has.mjs
var FromArray28 = function(schema, references) {
  return IsTransform2(schema) || Visit32(schema.items, references);
};
var FromAsyncIterator11 = function(schema, references) {
  return IsTransform2(schema) || Visit32(schema.items, references);
};
var FromConstructor13 = function(schema, references) {
  return IsTransform2(schema) || Visit32(schema.returns, references) || schema.parameters.some((schema2) => Visit32(schema2, references));
};
var FromFunction11 = function(schema, references) {
  return IsTransform2(schema) || Visit32(schema.returns, references) || schema.parameters.some((schema2) => Visit32(schema2, references));
};
var FromIntersect30 = function(schema, references) {
  return IsTransform2(schema) || IsTransform2(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit32(schema2, references));
};
var FromIterator11 = function(schema, references) {
  return IsTransform2(schema) || Visit32(schema.items, references);
};
var FromNot14 = function(schema, references) {
  return IsTransform2(schema) || Visit32(schema.not, references);
};
var FromObject23 = function(schema, references) {
  return IsTransform2(schema) || Object.values(schema.properties).some((schema2) => Visit32(schema2, references)) || IsSchema2(schema.additionalProperties) && Visit32(schema.additionalProperties, references);
};
var FromPromise12 = function(schema, references) {
  return IsTransform2(schema) || Visit32(schema.item, references);
};
var FromRecord22 = function(schema, references) {
  const pattern5 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern5];
  return IsTransform2(schema) || Visit32(property, references) || IsSchema2(schema.additionalProperties) && IsTransform2(schema.additionalProperties);
};
var FromRef21 = function(schema, references) {
  if (IsTransform2(schema))
    return true;
  return Visit32(Deref3(schema, references), references);
};
var FromThis20 = function(schema, references) {
  if (IsTransform2(schema))
    return true;
  return Visit32(Deref3(schema, references), references);
};
var FromTuple27 = function(schema, references) {
  return IsTransform2(schema) || !IsUndefined4(schema.items) && schema.items.some((schema2) => Visit32(schema2, references));
};
var FromUnion34 = function(schema, references) {
  return IsTransform2(schema) || schema.anyOf.some((schema2) => Visit32(schema2, references));
};
var Visit32 = function(schema, references) {
  const references_ = IsString4(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  if (schema.$id && visited2.has(schema.$id))
    return false;
  if (schema.$id)
    visited2.add(schema.$id);
  switch (schema[Kind2]) {
    case "Array":
      return FromArray28(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator11(schema_, references_);
    case "Constructor":
      return FromConstructor13(schema_, references_);
    case "Function":
      return FromFunction11(schema_, references_);
    case "Intersect":
      return FromIntersect30(schema_, references_);
    case "Iterator":
      return FromIterator11(schema_, references_);
    case "Not":
      return FromNot14(schema_, references_);
    case "Object":
      return FromObject23(schema_, references_);
    case "Promise":
      return FromPromise12(schema_, references_);
    case "Record":
      return FromRecord22(schema_, references_);
    case "Ref":
      return FromRef21(schema_, references_);
    case "This":
      return FromThis20(schema_, references_);
    case "Tuple":
      return FromTuple27(schema_, references_);
    case "Union":
      return FromUnion34(schema_, references_);
    default:
      return IsTransform2(schema);
  }
};
function HasTransform2(schema, references) {
  visited2.clear();
  return Visit32(schema, references);
}
var visited2 = new Set;
// ../sisventa/node_modules/@sinclair/typebox/build/import/value/value/value.mjs
var exports_value5 = {};
__export(exports_value5, {
  Patch: () => {
    {
      return Patch4;
    }
  },
  Mutate: () => {
    {
      return Mutate4;
    }
  },
  Hash: () => {
    {
      return Hash4;
    }
  },
  Errors: () => {
    {
      return Errors4;
    }
  },
  Equal: () => {
    {
      return Equal4;
    }
  },
  Encode: () => {
    {
      return Encode2;
    }
  },
  Diff: () => {
    {
      return Diff4;
    }
  },
  Default: () => {
    {
      return Default12;
    }
  },
  Decode: () => {
    {
      return Decode2;
    }
  },
  Create: () => {
    {
      return Create6;
    }
  },
  Convert: () => {
    {
      return Convert4;
    }
  },
  Clone: () => {
    {
      return Clone6;
    }
  },
  Clean: () => {
    {
      return Clean4;
    }
  },
  Check: () => {
    {
      return Check4;
    }
  },
  Cast: () => {
    {
      return Cast4;
    }
  }
});
function Cast4(...args) {
  return Cast3.apply(Cast3, args);
}
function Create6(...args) {
  return Create5.apply(Create5, args);
}
function Check4(...args) {
  return Check3.apply(Check3, args);
}
function Clean4(...args) {
  return Clean3.apply(Clean3, args);
}
function Convert4(...args) {
  return Convert3.apply(Convert3, args);
}
function Clone6(value16) {
  return Clone5(value16);
}
function Decode2(...args) {
  const [schema, references, value16] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check4(schema, references, value16))
    throw new TransformDecodeCheckError2(schema, value16, Errors4(schema, references, value16).First());
  return TransformDecode2(schema, references, value16);
}
function Default12(...args) {
  return Default9.apply(Default9, args);
}
function Encode2(...args) {
  const [schema, references, value16] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = TransformEncode2(schema, references, value16);
  if (!Check4(schema, references, encoded))
    throw new TransformEncodeCheckError2(schema, value16, Errors4(schema, references, value16).First());
  return encoded;
}
function Errors4(...args) {
  return Errors3.apply(Errors3, args);
}
function Equal4(left, right) {
  return Equal3(left, right);
}
function Diff4(current, next) {
  return Diff3(current, next);
}
function Hash4(value16) {
  return Hash3(value16);
}
function Patch4(current, edits) {
  return Patch3(current, edits);
}
function Mutate4(current, next) {
  Mutate3(current, next);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/awaited/awaited.mjs
var FromRest12 = function(T) {
  return T.map((L2) => AwaitedResolve2(L2));
};
var FromIntersect31 = function(T) {
  return Intersect3(FromRest12(T));
};
var FromUnion35 = function(T) {
  return Union3(FromRest12(T));
};
var FromPromise13 = function(T) {
  return AwaitedResolve2(T);
};
var AwaitedResolve2 = function(T) {
  return IsIntersect2(T) ? FromIntersect31(T.allOf) : IsUnion2(T) ? FromUnion35(T.anyOf) : IsPromise4(T) ? FromPromise13(T.item) : T;
};
function Awaited2(T, options = {}) {
  return CloneType2(AwaitedResolve2(T), options);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/date/date.mjs
function Date3(options = {}) {
  return {
    ...options,
    [Kind2]: "Date",
    type: "Date"
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/null/null.mjs
function Null2(options = {}) {
  return {
    ...options,
    [Kind2]: "Null",
    type: "null"
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/symbol/symbol.mjs
function Symbol3(options) {
  return { ...options, [Kind2]: "Symbol", type: "symbol" };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/undefined/undefined.mjs
function Undefined2(options = {}) {
  return { ...options, [Kind2]: "Undefined", type: "undefined" };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/uint8array/uint8array.mjs
function Uint8Array3(options = {}) {
  return { ...options, [Kind2]: "Uint8Array", type: "Uint8Array" };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/const/const.mjs
var FromArray29 = function(T) {
  return T.map((L2) => FromValue2(L2, false));
};
var FromProperties27 = function(value17) {
  return globalThis.Object.getOwnPropertyNames(value17).reduce((acc, key) => {
    return { ...acc, [key]: Readonly2(FromValue2(value17[key], false)) };
  }, {});
};
var ConditionalReadonly2 = function(T, root) {
  return root === true ? T : Readonly2(T);
};
var FromValue2 = function(value17, root) {
  return IsAsyncIterator5(value17) ? ConditionalReadonly2(Any2(), root) : IsIterator5(value17) ? ConditionalReadonly2(Any2(), root) : IsArray5(value17) ? Readonly2(Tuple2(FromArray29(value17))) : IsUint8Array5(value17) ? Uint8Array3() : IsDate5(value17) ? Date3() : IsObject5(value17) ? ConditionalReadonly2(Object3(FromProperties27(value17)), root) : IsFunction5(value17) ? ConditionalReadonly2(Function3([], Unknown2()), root) : IsUndefined5(value17) ? Undefined2() : IsNull5(value17) ? Null2() : IsSymbol5(value17) ? Symbol3() : IsBigInt5(value17) ? BigInt3() : IsNumber5(value17) ? Literal2(value17) : IsBoolean5(value17) ? Literal2(value17) : IsString5(value17) ? Literal2(value17) : Object3({});
};
function Const2(T, options = {}) {
  return exports_type6.CloneType(FromValue2(T, true), options);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters2(schema, options = {}) {
  return Tuple2(CloneRest2(schema.parameters), { ...options });
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/deref/deref.mjs
var FromRest13 = function(schema, references) {
  return schema.map((schema2) => Deref4(schema2, references));
};
var FromProperties28 = function(properties, references) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((acc, key) => {
    return { ...acc, [key]: Deref4(properties[key], references) };
  }, {});
};
var FromConstructor14 = function(schema, references) {
  schema.parameters = FromRest13(schema.parameters, references);
  schema.returns = Deref4(schema.returns, references);
  return schema;
};
var FromFunction12 = function(schema, references) {
  schema.parameters = FromRest13(schema.parameters, references);
  schema.returns = Deref4(schema.returns, references);
  return schema;
};
var FromIntersect32 = function(schema, references) {
  schema.allOf = FromRest13(schema.allOf, references);
  return schema;
};
var FromUnion36 = function(schema, references) {
  schema.anyOf = FromRest13(schema.anyOf, references);
  return schema;
};
var FromTuple28 = function(schema, references) {
  if (IsUndefined5(schema.items))
    return schema;
  schema.items = FromRest13(schema.items, references);
  return schema;
};
var FromArray30 = function(schema, references) {
  schema.items = Deref4(schema.items, references);
  return schema;
};
var FromObject24 = function(schema, references) {
  schema.properties = FromProperties28(schema.properties, references);
  return schema;
};
var FromPromise14 = function(schema, references) {
  schema.item = Deref4(schema.item, references);
  return schema;
};
var FromAsyncIterator12 = function(schema, references) {
  schema.items = Deref4(schema.items, references);
  return schema;
};
var FromIterator12 = function(schema, references) {
  schema.items = Deref4(schema.items, references);
  return schema;
};
var FromRef22 = function(schema, references) {
  const target = references.find((remote) => remote.$id === schema.$ref);
  if (target === undefined)
    throw Error(`Unable to dereference schema with \$id ${schema.$ref}`);
  const discard19 = Discard2(target, ["$id"]);
  return Deref4(discard19, references);
};
var DerefResolve2 = function(schema, references) {
  return IsConstructor2(schema) ? FromConstructor14(schema, references) : IsFunction6(schema) ? FromFunction12(schema, references) : IsIntersect2(schema) ? FromIntersect32(schema, references) : IsUnion2(schema) ? FromUnion36(schema, references) : IsTuple2(schema) ? FromTuple28(schema, references) : IsArray6(schema) ? FromArray30(schema, references) : IsObject6(schema) ? FromObject24(schema, references) : IsPromise4(schema) ? FromPromise14(schema, references) : IsAsyncIterator6(schema) ? FromAsyncIterator12(schema, references) : IsIterator6(schema) ? FromIterator12(schema, references) : IsRef2(schema) ? FromRef22(schema, references) : schema;
};
function Deref4(schema, references) {
  return DerefResolve2(CloneType2(schema), CloneRest2(references));
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/enum/enum.mjs
function Enum2(item, options = {}) {
  if (IsUndefined5(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value19) => Literal2(value19));
  return Union3(anyOf, { ...options, [Hint2]: "Enum" });
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral2(L2, R2) {
  return Exclude2(TemplateLiteralToUnion2(L2), R2);
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/exclude/exclude.mjs
var ExcludeRest2 = function(L2, R2) {
  const excluded = L2.filter((inner) => ExtendsCheck2(inner, R2) === ExtendsResult2.False);
  return excluded.length === 1 ? excluded[0] : Union3(excluded);
};
function Exclude2(L2, R2, options = {}) {
  if (IsTemplateLiteral2(L2))
    return CloneType2(ExcludeFromTemplateLiteral2(L2, R2), options);
  if (IsMappedResult2(L2))
    return CloneType2(ExcludeFromMappedResult2(L2, R2), options);
  return CloneType2(IsUnion2(L2) ? ExcludeRest2(L2.anyOf, R2) : ExtendsCheck2(L2, R2) !== ExtendsResult2.False ? Never2() : L2, options);
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/exclude/exclude-from-mapped-result.mjs
var FromProperties29 = function(P, U) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Exclude2(P[K2], U) };
  }, {});
};
var FromMappedResult19 = function(R2, T) {
  return FromProperties29(R2.properties, T);
};
function ExcludeFromMappedResult2(R2, T) {
  const P = FromMappedResult19(R2, T);
  return MappedResult2(P);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral2(L2, R2) {
  return Extract2(TemplateLiteralToUnion2(L2), R2);
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/extract/extract.mjs
var ExtractRest2 = function(L2, R2) {
  const extracted = L2.filter((inner) => ExtendsCheck2(inner, R2) !== ExtendsResult2.False);
  return extracted.length === 1 ? extracted[0] : Union3(extracted);
};
function Extract2(L2, R2, options = {}) {
  if (IsTemplateLiteral2(L2))
    return CloneType2(ExtractFromTemplateLiteral2(L2, R2), options);
  if (IsMappedResult2(L2))
    return CloneType2(ExtractFromMappedResult2(L2, R2), options);
  return CloneType2(IsUnion2(L2) ? ExtractRest2(L2.anyOf, R2) : ExtendsCheck2(L2, R2) !== ExtendsResult2.False ? L2 : Never2(), options);
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/extract/extract-from-mapped-result.mjs
var FromProperties30 = function(P, T) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Extract2(P[K2], T) };
  }, {});
};
var FromMappedResult20 = function(R2, T) {
  return FromProperties30(R2.properties, T);
};
function ExtractFromMappedResult2(R2, T) {
  const P = FromMappedResult20(R2, T);
  return MappedResult2(P);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/instance-type/instance-type.mjs
function InstanceType2(schema, options = {}) {
  return CloneType2(schema.returns, options);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/integer/integer.mjs
function Integer2(options = {}) {
  return {
    ...options,
    [Kind2]: "Integer",
    type: "integer"
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/intrinsic/intrinsic-from-mapped-key.mjs
var MappedIntrinsicPropertyKey2 = function(K, M, options) {
  return {
    [K]: Intrinsic2(Literal2(K), M, options)
  };
};
var MappedIntrinsicPropertyKeys2 = function(K, M, options) {
  return K.reduce((Acc, L2) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey2(L2, M, options) };
  }, {});
};
var MappedIntrinsicProperties2 = function(T, M, options) {
  return MappedIntrinsicPropertyKeys2(T["keys"], M, options);
};
function IntrinsicFromMappedKey2(T, M, options) {
  const P = MappedIntrinsicProperties2(T, M, options);
  return MappedResult2(P);
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/intrinsic/intrinsic.mjs
var ApplyUncapitalize2 = function(value19) {
  const [first, rest3] = [value19.slice(0, 1), value19.slice(1)];
  return [first.toLowerCase(), rest3].join("");
};
var ApplyCapitalize2 = function(value19) {
  const [first, rest3] = [value19.slice(0, 1), value19.slice(1)];
  return [first.toUpperCase(), rest3].join("");
};
var ApplyUppercase2 = function(value19) {
  return value19.toUpperCase();
};
var ApplyLowercase2 = function(value19) {
  return value19.toLowerCase();
};
var FromTemplateLiteral12 = function(schema, mode, options) {
  const expression = TemplateLiteralParseExact2(schema.pattern);
  const finite5 = IsTemplateLiteralExpressionFinite2(expression);
  if (!finite5)
    return { ...schema, pattern: FromLiteralValue2(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate2(expression)];
  const literals = strings.map((value19) => Literal2(value19));
  const mapped30 = FromRest14(literals, mode);
  const union35 = Union3(mapped30);
  return TemplateLiteral2([union35], options);
};
var FromLiteralValue2 = function(value19, mode) {
  return typeof value19 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize2(value19) : mode === "Capitalize" ? ApplyCapitalize2(value19) : mode === "Uppercase" ? ApplyUppercase2(value19) : mode === "Lowercase" ? ApplyLowercase2(value19) : value19 : value19.toString();
};
var FromRest14 = function(T, M) {
  return T.map((L2) => Intrinsic2(L2, M));
};
function Intrinsic2(schema, mode, options = {}) {
  return IsMappedKey2(schema) ? IntrinsicFromMappedKey2(schema, mode, options) : IsTemplateLiteral2(schema) ? FromTemplateLiteral12(schema, mode, schema) : IsUnion2(schema) ? Union3(FromRest14(schema.anyOf, mode), options) : IsLiteral2(schema) ? Literal2(FromLiteralValue2(schema.const, mode), options) : schema;
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/intrinsic/capitalize.mjs
function Capitalize2(T, options = {}) {
  return Intrinsic2(T, "Capitalize", options);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/intrinsic/lowercase.mjs
function Lowercase2(T, options = {}) {
  return Intrinsic2(T, "Lowercase", options);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/intrinsic/uncapitalize.mjs
function Uncapitalize2(T, options = {}) {
  return Intrinsic2(T, "Uncapitalize", options);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/intrinsic/uppercase.mjs
function Uppercase2(T, options = {}) {
  return Intrinsic2(T, "Uppercase", options);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/not/not.mjs
function Not4(schema, options) {
  return {
    ...options,
    [Kind2]: "Not",
    not: CloneType2(schema)
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/omit/omit-from-mapped-result.mjs
var FromProperties31 = function(P, K, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Omit2(P[K2], K, options) };
  }, {});
};
var FromMappedResult21 = function(R2, K, options) {
  return FromProperties31(R2.properties, K, options);
};
function OmitFromMappedResult2(R2, K, options) {
  const P = FromMappedResult21(R2, K, options);
  return MappedResult2(P);
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/omit/omit.mjs
var FromIntersect33 = function(T, K) {
  return T.map((T2) => OmitResolve2(T2, K));
};
var FromUnion37 = function(T, K) {
  return T.map((T2) => OmitResolve2(T2, K));
};
var FromProperty4 = function(T, K) {
  const { [K]: _, ...R2 } = T;
  return R2;
};
var FromProperties32 = function(T, K) {
  return K.reduce((T2, K2) => {
    return FromProperty4(T2, K2);
  }, T);
};
var OmitResolve2 = function(T, K) {
  return IsIntersect2(T) ? Intersect3(FromIntersect33(T.allOf, K)) : IsUnion2(T) ? Union3(FromUnion37(T.anyOf, K)) : IsObject6(T) ? Object3(FromProperties32(T.properties, K)) : Object3({});
};
function Omit2(T, K, options = {}) {
  if (IsMappedKey2(K))
    return OmitFromMappedKey2(T, K, options);
  if (IsMappedResult2(T))
    return OmitFromMappedResult2(T, K, options);
  const I = IsSchema2(K) ? IndexPropertyKeys2(K) : K;
  const D = Discard2(T, [TransformKind2, "$id", "required"]);
  const R2 = CloneType2(OmitResolve2(T, I), options);
  return { ...D, ...R2 };
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/omit/omit-from-mapped-key.mjs
var FromPropertyKey5 = function(T, K, options) {
  return {
    [K]: Omit2(T, [K], options)
  };
};
var FromPropertyKeys5 = function(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey5(T, LK, options) };
  }, {});
};
var FromMappedKey7 = function(T, K, options) {
  return FromPropertyKeys5(T, K.keys, options);
};
function OmitFromMappedKey2(T, K, options) {
  const P = FromMappedKey7(T, K, options);
  return MappedResult2(P);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/parameters/parameters.mjs
function Parameters2(schema, options = {}) {
  return Tuple2(CloneRest2(schema.parameters), { ...options });
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/partial/partial.mjs
var FromRest15 = function(T) {
  return T.map((L2) => PartialResolve2(L2));
};
var FromProperties33 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {
    return { ...Acc, [K]: Optional2(T[K]) };
  }, {});
};
var PartialResolve2 = function(T) {
  return IsIntersect2(T) ? Intersect3(FromRest15(T.allOf)) : IsUnion2(T) ? Union3(FromRest15(T.anyOf)) : IsObject6(T) ? Object3(FromProperties33(T.properties)) : Object3({});
};
function Partial2(T, options = {}) {
  if (IsMappedResult2(T))
    return PartialFromMappedResult2(T, options);
  const D = Discard2(T, [TransformKind2, "$id", "required"]);
  const R2 = CloneType2(PartialResolve2(T), options);
  return { ...D, ...R2 };
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/partial/partial-from-mapped-result.mjs
var FromProperties34 = function(K, options) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Partial2(K[K2], options) };
  }, {});
};
var FromMappedResult22 = function(R2, options) {
  return FromProperties34(R2.properties, options);
};
function PartialFromMappedResult2(R2, options) {
  const P = FromMappedResult22(R2, options);
  return MappedResult2(P);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/pick/pick-from-mapped-result.mjs
var FromProperties35 = function(P, K, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Pick2(P[K2], K, options) };
  }, {});
};
var FromMappedResult23 = function(R2, K, options) {
  return FromProperties35(R2.properties, K, options);
};
function PickFromMappedResult2(R2, K, options) {
  const P = FromMappedResult23(R2, K, options);
  return MappedResult2(P);
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/pick/pick.mjs
var FromIntersect34 = function(T, K) {
  return T.map((T2) => PickResolve2(T2, K));
};
var FromUnion38 = function(T, K) {
  return T.map((T2) => PickResolve2(T2, K));
};
var FromProperties36 = function(T, K) {
  return K.reduce((Acc, K2) => {
    return K2 in T ? { ...Acc, [K2]: T[K2] } : Acc;
  }, {});
};
var PickResolve2 = function(T, K) {
  return IsIntersect2(T) ? Intersect3(FromIntersect34(T.allOf, K)) : IsUnion2(T) ? Union3(FromUnion38(T.anyOf, K)) : IsObject6(T) ? Object3(FromProperties36(T.properties, K)) : Object3({});
};
function Pick2(T, K, options = {}) {
  if (IsMappedKey2(K))
    return PickFromMappedKey2(T, K, options);
  if (IsMappedResult2(T))
    return PickFromMappedResult2(T, K, options);
  const I = IsSchema2(K) ? IndexPropertyKeys2(K) : K;
  const D = Discard2(T, [TransformKind2, "$id", "required"]);
  const R2 = CloneType2(PickResolve2(T, I), options);
  return { ...D, ...R2 };
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/pick/pick-from-mapped-key.mjs
var FromPropertyKey6 = function(T, K, options) {
  return {
    [K]: Pick2(T, [K], options)
  };
};
var FromPropertyKeys6 = function(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey6(T, LK, options) };
  }, {});
};
var FromMappedKey8 = function(T, K, options) {
  return FromPropertyKeys6(T, K.keys, options);
};
function PickFromMappedKey2(T, K, options) {
  const P = FromMappedKey8(T, K, options);
  return MappedResult2(P);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional2(schema) {
  return Readonly2(Optional2(schema));
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/record/record.mjs
var RecordCreateFromPattern2 = function(pattern5, T, options) {
  return {
    ...options,
    [Kind2]: "Record",
    type: "object",
    patternProperties: { [pattern5]: CloneType2(T) }
  };
};
var RecordCreateFromKeys2 = function(K, T, options) {
  const P = K.reduce((Acc, K2) => ({ ...Acc, [K2]: CloneType2(T) }), {});
  return Object3(P, { ...options, [Hint2]: "Record" });
};
var FromTemplateLiteralKey2 = function(K, T, options) {
  return IsTemplateLiteralFinite2(K) ? RecordCreateFromKeys2(IndexPropertyKeys2(K), T, options) : RecordCreateFromPattern2(K.pattern, T, options);
};
var FromUnionKey2 = function(K, T, options) {
  return RecordCreateFromKeys2(IndexPropertyKeys2(Union3(K)), T, options);
};
var FromLiteralKey2 = function(K, T, options) {
  return RecordCreateFromKeys2([K.toString()], T, options);
};
var FromRegExpKey2 = function(K, T, options) {
  return RecordCreateFromPattern2(K.source, T, options);
};
var FromStringKey2 = function(K, T, options) {
  const pattern5 = IsUndefined5(K.pattern) ? PatternStringExact2 : K.pattern;
  return RecordCreateFromPattern2(pattern5, T, options);
};
var FromIntegerKey2 = function(_, T, options) {
  return RecordCreateFromPattern2(PatternNumberExact2, T, options);
};
var FromNumberKey2 = function(_, T, options) {
  return RecordCreateFromPattern2(PatternNumberExact2, T, options);
};
function Record2(K, T, options = {}) {
  return IsUnion2(K) ? FromUnionKey2(K.anyOf, T, options) : IsTemplateLiteral2(K) ? FromTemplateLiteralKey2(K, T, options) : IsLiteral2(K) ? FromLiteralKey2(K.const, T, options) : IsInteger4(K) ? FromIntegerKey2(K, T, options) : IsNumber6(K) ? FromNumberKey2(K, T, options) : IsRegExp4(K) ? FromRegExpKey2(K, T, options) : IsString6(K) ? FromStringKey2(K, T, options) : Never2(options);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/recursive/recursive.mjs
function Recursive2(callback, options = {}) {
  if (IsUndefined5(options.$id))
    options.$id = `T${Ordinal2++}`;
  const thisType = callback({ [Kind2]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType2({ ...options, [Hint2]: "Recursive", ...thisType });
}
var Ordinal2 = 0;
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/ref/ref.mjs
function Ref2(unresolved, options = {}) {
  if (IsString5(unresolved))
    return { ...options, [Kind2]: "Ref", $ref: unresolved };
  if (IsUndefined5(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind2]: "Ref",
    $ref: unresolved.$id
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/regexp/regexp.mjs
function RegExp3(unresolved, options = {}) {
  const expr = IsString5(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind2]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/required/required.mjs
var FromRest16 = function(T) {
  return T.map((L2) => RequiredResolve2(L2));
};
var FromProperties37 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {
    return { ...Acc, [K]: Discard2(T[K], [OptionalKind2]) };
  }, {});
};
var RequiredResolve2 = function(T) {
  return IsIntersect2(T) ? Intersect3(FromRest16(T.allOf)) : IsUnion2(T) ? Union3(FromRest16(T.anyOf)) : IsObject6(T) ? Object3(FromProperties37(T.properties)) : Object3({});
};
function Required2(T, options = {}) {
  if (IsMappedResult2(T)) {
    return RequiredFromMappedResult2(T, options);
  } else {
    const D = Discard2(T, [TransformKind2, "$id", "required"]);
    const R2 = CloneType2(RequiredResolve2(T), options);
    return { ...D, ...R2 };
  }
}

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/required/required-from-mapped-result.mjs
var FromProperties38 = function(P, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Required2(P[K2], options) };
  }, {});
};
var FromMappedResult24 = function(R2, options) {
  return FromProperties38(R2.properties, options);
};
function RequiredFromMappedResult2(R2, options) {
  const P = FromMappedResult24(R2, options);
  return MappedResult2(P);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/rest/rest.mjs
var RestResolve2 = function(T) {
  return IsIntersect2(T) ? [...T.allOf] : IsUnion2(T) ? [...T.anyOf] : IsTuple2(T) ? [...T.items ?? []] : [];
};
function Rest2(T) {
  return CloneRest2(RestResolve2(T));
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/return-type/return-type.mjs
function ReturnType2(schema, options = {}) {
  return CloneType2(schema.returns, options);
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/strict/strict.mjs
function Strict2(schema) {
  return JSON.parse(JSON.stringify(schema));
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/transform/transform.mjs
function Transform2(schema) {
  return new TransformDecodeBuilder2(schema);
}

class TransformDecodeBuilder2 {
  schema;
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode3) {
    return new TransformEncodeBuilder2(this.schema, decode3);
  }
}

class TransformEncodeBuilder2 {
  schema;
  decode;
  constructor(schema, decode3) {
    this.schema = schema;
    this.decode = decode3;
  }
  EncodeTransform(encode3, schema) {
    const Encode3 = (value23) => schema[TransformKind2].Encode(encode3(value23));
    const Decode3 = (value23) => this.decode(schema[TransformKind2].Decode(value23));
    const Codec = { Encode: Encode3, Decode: Decode3 };
    return { ...schema, [TransformKind2]: Codec };
  }
  EncodeSchema(encode3, schema) {
    const Codec = { Decode: this.decode, Encode: encode3 };
    return { ...schema, [TransformKind2]: Codec };
  }
  Encode(encode3) {
    const schema = CloneType2(this.schema);
    return IsTransform2(schema) ? this.EncodeTransform(encode3, schema) : this.EncodeSchema(encode3, schema);
  }
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/void/void.mjs
function Void2(options = {}) {
  return {
    ...options,
    [Kind2]: "Void",
    type: "void"
  };
}
// ../sisventa/node_modules/@sinclair/typebox/build/import/type/type/type.mjs
var exports_type8 = {};
__export(exports_type8, {
  Void: () => {
    {
      return Void2;
    }
  },
  Uppercase: () => {
    {
      return Uppercase2;
    }
  },
  Unsafe: () => {
    {
      return Unsafe2;
    }
  },
  Unknown: () => {
    {
      return Unknown2;
    }
  },
  Union: () => {
    {
      return Union3;
    }
  },
  Undefined: () => {
    {
      return Undefined2;
    }
  },
  Uncapitalize: () => {
    {
      return Uncapitalize2;
    }
  },
  Uint8Array: () => {
    {
      return Uint8Array3;
    }
  },
  Tuple: () => {
    {
      return Tuple2;
    }
  },
  Transform: () => {
    {
      return Transform2;
    }
  },
  TemplateLiteral: () => {
    {
      return TemplateLiteral2;
    }
  },
  Symbol: () => {
    {
      return Symbol3;
    }
  },
  String: () => {
    {
      return String3;
    }
  },
  Strict: () => {
    {
      return Strict2;
    }
  },
  ReturnType: () => {
    {
      return ReturnType2;
    }
  },
  Rest: () => {
    {
      return Rest2;
    }
  },
  Required: () => {
    {
      return Required2;
    }
  },
  RegExp: () => {
    {
      return RegExp3;
    }
  },
  Ref: () => {
    {
      return Ref2;
    }
  },
  Recursive: () => {
    {
      return Recursive2;
    }
  },
  Record: () => {
    {
      return Record2;
    }
  },
  ReadonlyOptional: () => {
    {
      return ReadonlyOptional2;
    }
  },
  Readonly: () => {
    {
      return Readonly2;
    }
  },
  Promise: () => {
    {
      return Promise3;
    }
  },
  Pick: () => {
    {
      return Pick2;
    }
  },
  Partial: () => {
    {
      return Partial2;
    }
  },
  Parameters: () => {
    {
      return Parameters2;
    }
  },
  Optional: () => {
    {
      return Optional2;
    }
  },
  Omit: () => {
    {
      return Omit2;
    }
  },
  Object: () => {
    {
      return Object3;
    }
  },
  Number: () => {
    {
      return Number3;
    }
  },
  Null: () => {
    {
      return Null2;
    }
  },
  Not: () => {
    {
      return Not4;
    }
  },
  Never: () => {
    {
      return Never2;
    }
  },
  Mapped: () => {
    {
      return Mapped2;
    }
  },
  Lowercase: () => {
    {
      return Lowercase2;
    }
  },
  Literal: () => {
    {
      return Literal2;
    }
  },
  KeyOf: () => {
    {
      return KeyOf2;
    }
  },
  Iterator: () => {
    {
      return Iterator2;
    }
  },
  Intersect: () => {
    {
      return Intersect3;
    }
  },
  Integer: () => {
    {
      return Integer2;
    }
  },
  InstanceType: () => {
    {
      return InstanceType2;
    }
  },
  Index: () => {
    {
      return Index2;
    }
  },
  Function: () => {
    {
      return Function3;
    }
  },
  Extract: () => {
    {
      return Extract2;
    }
  },
  Extends: () => {
    {
      return Extends2;
    }
  },
  Exclude: () => {
    {
      return Exclude2;
    }
  },
  Enum: () => {
    {
      return Enum2;
    }
  },
  Deref: () => {
    {
      return Deref4;
    }
  },
  Date: () => {
    {
      return Date3;
    }
  },
  ConstructorParameters: () => {
    {
      return ConstructorParameters2;
    }
  },
  Constructor: () => {
    {
      return Constructor2;
    }
  },
  Const: () => {
    {
      return Const2;
    }
  },
  Composite: () => {
    {
      return Composite2;
    }
  },
  Capitalize: () => {
    {
      return Capitalize2;
    }
  },
  Boolean: () => {
    {
      return Boolean3;
    }
  },
  BigInt: () => {
    {
      return BigInt3;
    }
  },
  Awaited: () => {
    {
      return Awaited2;
    }
  },
  AsyncIterator: () => {
    {
      return AsyncIterator2;
    }
  },
  Array: () => {
    {
      return Array3;
    }
  },
  Any: () => {
    {
      return Any2;
    }
  }
});

// ../sisventa/node_modules/@sinclair/typebox/build/import/type/type/index.mjs
var Type2 = exports_type8;
// ../sisventa/node_modules/@sinclair/typebox/build/import/compiler/compiler.mjs
class TypeCheck2 {
  schema;
  references;
  checkFunc;
  code;
  hasTransform;
  constructor(schema, references, checkFunc, code) {
    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform2(schema, references);
  }
  Code() {
    return this.code;
  }
  Errors(value23) {
    return Errors3(this.schema, this.references, value23);
  }
  Check(value23) {
    return this.checkFunc(value23);
  }
  Decode(value23) {
    if (!this.checkFunc(value23))
      throw new TransformDecodeCheckError2(this.schema, value23, this.Errors(value23).First());
    return this.hasTransform ? TransformDecode2(this.schema, this.references, value23) : value23;
  }
  Encode(value23) {
    const encoded = this.hasTransform ? TransformEncode2(this.schema, this.references, value23) : value23;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError2(this.schema, value23, this.Errors(value23).First());
    return encoded;
  }
}
var Character2;
(function(Character3) {
  function DollarSign(code) {
    return code === 36;
  }
  Character3.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character3.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character3.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character3.IsNumeric = IsNumeric;
})(Character2 || (Character2 = {}));
var MemberExpression2;
(function(MemberExpression3) {
  function IsFirstCharacterNumeric(value23) {
    if (value23.length === 0)
      return false;
    return Character2.IsNumeric(value23.charCodeAt(0));
  }
  function IsAccessor(value23) {
    if (IsFirstCharacterNumeric(value23))
      return false;
    for (let i = 0;i < value23.length; i++) {
      const code = value23.charCodeAt(i);
      const check19 = Character2.IsAlpha(code) || Character2.IsNumeric(code) || Character2.DollarSign(code) || Character2.IsUnderscore(code);
      if (!check19)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode3(object23, key) {
    return IsAccessor(key) ? `${object23}.${key}` : `${object23}['${EscapeHyphen(key)}']`;
  }
  MemberExpression3.Encode = Encode3;
})(MemberExpression2 || (MemberExpression2 = {}));
var Identifier2;
(function(Identifier3) {
  function Encode3($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character2.IsNumeric(code) || Character2.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier3.Encode = Encode3;
})(Identifier2 || (Identifier2 = {}));
var LiteralString2;
(function(LiteralString3) {
  function Escape5(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString3.Escape = Escape5;
})(LiteralString2 || (LiteralString2 = {}));

class TypeCompilerUnknownTypeError2 extends TypeBoxError2 {
  schema;
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class TypeCompilerTypeGuardError2 extends TypeBoxError2 {
  schema;
  constructor(schema) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema;
  }
}
var Policy2;
(function(Policy3) {
  function IsExactOptionalProperty(value23, key, expression) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? `('${key}' in ${value23} ? ${expression} : true)` : `(${MemberExpression2.Encode(value23, key)} !== undefined ? ${expression} : true)`;
  }
  Policy3.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value23) {
    return !TypeSystemPolicy2.AllowArrayObject ? `(typeof ${value23} === 'object' && ${value23} !== null && !Array.isArray(${value23}))` : `(typeof ${value23} === 'object' && ${value23} !== null)`;
  }
  Policy3.IsObjectLike = IsObjectLike;
  function IsRecordLike(value23) {
    return !TypeSystemPolicy2.AllowArrayObject ? `(typeof ${value23} === 'object' && ${value23} !== null && !Array.isArray(${value23}) && !(${value23} instanceof Date) && !(${value23} instanceof Uint8Array))` : `(typeof ${value23} === 'object' && ${value23} !== null && !(${value23} instanceof Date) && !(${value23} instanceof Uint8Array))`;
  }
  Policy3.IsRecordLike = IsRecordLike;
  function IsNumberLike(value23) {
    return !TypeSystemPolicy2.AllowNaN ? `(typeof ${value23} === 'number' && Number.isFinite(${value23}))` : `typeof ${value23} === 'number'`;
  }
  Policy3.IsNumberLike = IsNumberLike;
  function IsVoidLike(value23) {
    return TypeSystemPolicy2.AllowNullVoid ? `(${value23} === undefined || ${value23} === null)` : `${value23} === undefined`;
  }
  Policy3.IsVoidLike = IsVoidLike;
})(Policy2 || (Policy2 = {}));
var TypeCompiler2;
(function(TypeCompiler3) {
  function IsAnyOrUnknown3(schema) {
    return schema[Kind2] === "Any" || schema[Kind2] === "Unknown";
  }
  function* FromAny9(schema, references, value23) {
    yield "true";
  }
  function* FromArray31(schema, references, value23) {
    yield `Array.isArray(${value23})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber4(schema.maxItems))
      yield `${value23}.length <= ${schema.maxItems}`;
    if (IsNumber4(schema.minItems))
      yield `${value23}.length >= ${schema.minItems}`;
    const elementExpression = CreateExpression(schema.items, references, "value");
    yield `${value23}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema.contains) || IsNumber4(schema.minContains) || IsNumber4(schema.maxContains)) {
      const containsSchema = IsSchema2(schema.contains) ? schema.contains : Never2();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber4(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
      const checkMaxContains = IsNumber4(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check19 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check19}})(${value23})`;
    }
    if (schema.uniqueItems === true) {
      const check19 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check19} }`;
      yield `((${parameter}) => { ${block} )(${value23})`;
    }
  }
  function* FromAsyncIterator13(schema, references, value23) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value23})`;
  }
  function* FromBigInt11(schema, references, value23) {
    yield `(typeof ${value23} === 'bigint')`;
    if (IsBigInt4(schema.exclusiveMaximum))
      yield `${value23} < BigInt(${schema.exclusiveMaximum})`;
    if (IsBigInt4(schema.exclusiveMinimum))
      yield `${value23} > BigInt(${schema.exclusiveMinimum})`;
    if (IsBigInt4(schema.maximum))
      yield `${value23} <= BigInt(${schema.maximum})`;
    if (IsBigInt4(schema.minimum))
      yield `${value23} >= BigInt(${schema.minimum})`;
    if (IsBigInt4(schema.multipleOf))
      yield `(${value23} % BigInt(${schema.multipleOf})) === 0`;
  }
  function* FromBoolean11(schema, references, value23) {
    yield `(typeof ${value23} === 'boolean')`;
  }
  function* FromConstructor15(schema, references, value23) {
    yield* Visit33(schema.returns, references, `${value23}.prototype`);
  }
  function* FromDate11(schema, references, value23) {
    yield `(${value23} instanceof Date) && Number.isFinite(${value23}.getTime())`;
    if (IsNumber4(schema.exclusiveMaximumTimestamp))
      yield `${value23}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
    if (IsNumber4(schema.exclusiveMinimumTimestamp))
      yield `${value23}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
    if (IsNumber4(schema.maximumTimestamp))
      yield `${value23}.getTime() <= ${schema.maximumTimestamp}`;
    if (IsNumber4(schema.minimumTimestamp))
      yield `${value23}.getTime() >= ${schema.minimumTimestamp}`;
    if (IsNumber4(schema.multipleOfTimestamp))
      yield `(${value23}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction13(schema, references, value23) {
    yield `(typeof ${value23} === 'function')`;
  }
  function* FromInteger11(schema, references, value23) {
    yield `(typeof ${value23} === 'number' && Number.isInteger(${value23}))`;
    if (IsNumber4(schema.exclusiveMaximum))
      yield `${value23} < ${schema.exclusiveMaximum}`;
    if (IsNumber4(schema.exclusiveMinimum))
      yield `${value23} > ${schema.exclusiveMinimum}`;
    if (IsNumber4(schema.maximum))
      yield `${value23} <= ${schema.maximum}`;
    if (IsNumber4(schema.minimum))
      yield `${value23} >= ${schema.minimum}`;
    if (IsNumber4(schema.multipleOf))
      yield `(${value23} % ${schema.multipleOf}) === 0`;
  }
  function* FromIntersect35(schema, references, value23) {
    const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value23)).join(" && ");
    if (schema.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern2(schema))};`);
      const check22 = `Object.getOwnPropertyNames(${value23}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check22})`;
    } else if (IsSchema2(schema.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern2(schema))};`);
      const check22 = `Object.getOwnPropertyNames(${value23}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value23}[key]`)})`;
      yield `(${check1} && ${check22})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator13(schema, references, value23) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value23})`;
  }
  function* FromLiteral13(schema, references, value23) {
    if (typeof schema.const === "number" || typeof schema.const === "boolean") {
      yield `(${value23} === ${schema.const})`;
    } else {
      yield `(${value23} === '${LiteralString2.Escape(schema.const)}')`;
    }
  }
  function* FromNever11(schema, references, value23) {
    yield `false`;
  }
  function* FromNot15(schema, references, value23) {
    const expression = CreateExpression(schema.not, references, value23);
    yield `(!${expression})`;
  }
  function* FromNull11(schema, references, value23) {
    yield `(${value23} === null)`;
  }
  function* FromNumber11(schema, references, value23) {
    yield Policy2.IsNumberLike(value23);
    if (IsNumber4(schema.exclusiveMaximum))
      yield `${value23} < ${schema.exclusiveMaximum}`;
    if (IsNumber4(schema.exclusiveMinimum))
      yield `${value23} > ${schema.exclusiveMinimum}`;
    if (IsNumber4(schema.maximum))
      yield `${value23} <= ${schema.maximum}`;
    if (IsNumber4(schema.minimum))
      yield `${value23} >= ${schema.minimum}`;
    if (IsNumber4(schema.multipleOf))
      yield `(${value23} % ${schema.multipleOf}) === 0`;
  }
  function* FromObject25(schema, references, value23) {
    yield Policy2.IsObjectLike(value23);
    if (IsNumber4(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value23}).length >= ${schema.minProperties}`;
    if (IsNumber4(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value23}).length <= ${schema.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression2.Encode(value23, knownKey);
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit33(property, references, memberExpression);
        if (ExtendsUndefinedCheck2(property) || IsAnyOrUnknown3(property))
          yield `('${knownKey}' in ${value23})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy2.IsExactOptionalProperty(value23, knownKey, expression);
      }
    }
    if (schema.additionalProperties === false) {
      if (schema.required && schema.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value23}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value23}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema.additionalProperties === "object") {
      const expression = CreateExpression(schema.additionalProperties, references, `${value23}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value23}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise15(schema, references, value23) {
    yield `(typeof value === 'object' && typeof ${value23}.then === 'function')`;
  }
  function* FromRecord23(schema, references, value23) {
    yield Policy2.IsRecordLike(value23);
    if (IsNumber4(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value23}).length >= ${schema.minProperties}`;
    if (IsNumber4(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value23}).length <= ${schema.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check22 = IsSchema2(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value23) : schema.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check22})`;
    yield `(Object.entries(${value23}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef23(schema, references, value23) {
    const target = Deref3(schema, references);
    if (state.functions.has(schema.$ref))
      return yield `${CreateFunctionName(schema.$ref)}(${value23})`;
    yield* Visit33(target, references, value23);
  }
  function* FromRegExp9(schema, references, value23) {
    const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
    yield `(typeof ${value23} === 'string')`;
    if (IsNumber4(schema.maxLength))
      yield `${value23}.length <= ${schema.maxLength}`;
    if (IsNumber4(schema.minLength))
      yield `${value23}.length >= ${schema.minLength}`;
    yield `${variable}.test(${value23})`;
  }
  function* FromString11(schema, references, value23) {
    yield `(typeof ${value23} === 'string')`;
    if (IsNumber4(schema.maxLength))
      yield `${value23}.length <= ${schema.maxLength}`;
    if (IsNumber4(schema.minLength))
      yield `${value23}.length >= ${schema.minLength}`;
    if (schema.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value23})`;
    }
    if (schema.format !== undefined) {
      yield `format('${schema.format}', ${value23})`;
    }
  }
  function* FromSymbol11(schema, references, value23) {
    yield `(typeof ${value23} === 'symbol')`;
  }
  function* FromTemplateLiteral13(schema, references, value23) {
    yield `(typeof ${value23} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
    yield `${variable}.test(${value23})`;
  }
  function* FromThis21(schema, references, value23) {
    yield `${CreateFunctionName(schema.$ref)}(${value23})`;
  }
  function* FromTuple29(schema, references, value23) {
    yield `Array.isArray(${value23})`;
    if (schema.items === undefined)
      return yield `${value23}.length === 0`;
    yield `(${value23}.length === ${schema.maxItems})`;
    for (let i = 0;i < schema.items.length; i++) {
      const expression = CreateExpression(schema.items[i], references, `${value23}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined11(schema, references, value23) {
    yield `${value23} === undefined`;
  }
  function* FromUnion39(schema, references, value23) {
    const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value23));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array9(schema, references, value23) {
    yield `${value23} instanceof Uint8Array`;
    if (IsNumber4(schema.maxByteLength))
      yield `(${value23}.length <= ${schema.maxByteLength})`;
    if (IsNumber4(schema.minByteLength))
      yield `(${value23}.length >= ${schema.minByteLength})`;
  }
  function* FromUnknown9(schema, references, value23) {
    yield "true";
  }
  function* FromVoid9(schema, references, value23) {
    yield Policy2.IsVoidLike(value23);
  }
  function* FromKind7(schema, references, value23) {
    const instance = state.instances.size;
    state.instances.set(instance, schema);
    yield `kind('${schema[Kind2]}', ${instance}, ${value23})`;
  }
  function* Visit33(schema, references, value23, useHoisting = true) {
    const references_ = IsString4(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (useHoisting && IsString4(schema.$id)) {
      const functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value23})`;
      } else {
        const functionCode = CreateFunction(functionName, schema, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value23})`;
      }
    }
    switch (schema_[Kind2]) {
      case "Any":
        return yield* FromAny9(schema_, references_, value23);
      case "Array":
        return yield* FromArray31(schema_, references_, value23);
      case "AsyncIterator":
        return yield* FromAsyncIterator13(schema_, references_, value23);
      case "BigInt":
        return yield* FromBigInt11(schema_, references_, value23);
      case "Boolean":
        return yield* FromBoolean11(schema_, references_, value23);
      case "Constructor":
        return yield* FromConstructor15(schema_, references_, value23);
      case "Date":
        return yield* FromDate11(schema_, references_, value23);
      case "Function":
        return yield* FromFunction13(schema_, references_, value23);
      case "Integer":
        return yield* FromInteger11(schema_, references_, value23);
      case "Intersect":
        return yield* FromIntersect35(schema_, references_, value23);
      case "Iterator":
        return yield* FromIterator13(schema_, references_, value23);
      case "Literal":
        return yield* FromLiteral13(schema_, references_, value23);
      case "Never":
        return yield* FromNever11(schema_, references_, value23);
      case "Not":
        return yield* FromNot15(schema_, references_, value23);
      case "Null":
        return yield* FromNull11(schema_, references_, value23);
      case "Number":
        return yield* FromNumber11(schema_, references_, value23);
      case "Object":
        return yield* FromObject25(schema_, references_, value23);
      case "Promise":
        return yield* FromPromise15(schema_, references_, value23);
      case "Record":
        return yield* FromRecord23(schema_, references_, value23);
      case "Ref":
        return yield* FromRef23(schema_, references_, value23);
      case "RegExp":
        return yield* FromRegExp9(schema_, references_, value23);
      case "String":
        return yield* FromString11(schema_, references_, value23);
      case "Symbol":
        return yield* FromSymbol11(schema_, references_, value23);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral13(schema_, references_, value23);
      case "This":
        return yield* FromThis21(schema_, references_, value23);
      case "Tuple":
        return yield* FromTuple29(schema_, references_, value23);
      case "Undefined":
        return yield* FromUndefined11(schema_, references_, value23);
      case "Union":
        return yield* FromUnion39(schema_, references_, value23);
      case "Uint8Array":
        return yield* FromUint8Array9(schema_, references_, value23);
      case "Unknown":
        return yield* FromUnknown9(schema_, references_, value23);
      case "Void":
        return yield* FromVoid9(schema_, references_, value23);
      default:
        if (!exports_type5.Has(schema_[Kind2]))
          throw new TypeCompilerUnknownTypeError2(schema);
        return yield* FromKind7(schema_, references_, value23);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema, references, value23, useHoisting = true) {
    return `(${[...Visit33(schema, references, value23, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier2.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema, references, value23, useHoisting = true) {
    const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit33(schema, references, value23, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\n}`;
  }
  function CreateParameter(name, type145) {
    const annotation = state.language === "typescript" ? `: ${type145}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type145) {
    return state.language === "typescript" ? `: ${type145}` : "";
  }
  function Build(schema, references, options) {
    const functionCode = CreateFunction("check", schema, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString4(schema.$id) ? `return function check(${parameter})${returns} {\n  return ${CreateFunctionName(schema.$id)}(value)\n}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema, references, options] = args.length === 2 && IsArray4(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray4(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema))
      throw new TypeCompilerTypeGuardError2(schema);
    for (const schema2 of references)
      if (!IsSchema2(schema2))
        throw new TypeCompilerTypeGuardError2(schema2);
    return Build(schema, references, options);
  }
  TypeCompiler3.Code = Code;
  function Compile(schema, references = []) {
    const generatedCode = Code(schema, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value23) {
      if (!exports_type5.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type5.Get(kind);
      const schema2 = instances.get(instance);
      return checkFunc(schema2, value23);
    }
    function formatRegistryFunction(format, value23) {
      if (!exports_format2.Has(format))
        return false;
      const checkFunc = exports_format2.Get(format);
      return checkFunc(value23);
    }
    function hashFunction(value23) {
      return Hash3(value23);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck2(schema, references, checkFunction, generatedCode);
  }
  TypeCompiler3.Compile = Compile;
})(TypeCompiler2 || (TypeCompiler2 = {}));
// ../sisventa/node_modules/elysia/dist/bun/index.js
var X$2 = Object.create;
var { defineProperty: z12, getPrototypeOf: W$2, getOwnPropertyNames: J$2 } = Object;
var Y$2 = Object.prototype.hasOwnProperty;
var T02 = ($, Z, X) => {
  X = $ != null ? X$2(W$2($)) : {};
  const W = Z || !$ || !$.__esModule ? z12(X, "default", { value: $, enumerable: true }) : X;
  for (let J of J$2($))
    if (!Y$2.call(W, J))
      z12(W, J, { get: () => $[J], enumerable: true });
  return W;
};
var J02 = ($, Z) => () => (Z || $((Z = { exports: {} }).exports, Z), Z.exports);
var I12 = J02((m$, i0) => {
  var z0 = function() {
  }, B$ = function($, Z, X) {
    this.fn = $, this.context = Z, this.once = X || false;
  }, O1 = function($, Z, X, W, J) {
    if (typeof X !== "function")
      throw new TypeError("The listener must be a function");
    var Q = new B$(X, W || $, J), Y = f ? f + Z : Z;
    if (!$._events[Y])
      $._events[Y] = Q, $._eventsCount++;
    else if (!$._events[Y].fn)
      $._events[Y].push(Q);
    else
      $._events[Y] = [$._events[Y], Q];
    return $;
  }, E0 = function($, Z) {
    if (--$._eventsCount === 0)
      $._events = new z0;
    else
      delete $._events[Z];
  }, g = function() {
    this._events = new z0, this._eventsCount = 0;
  }, Q$ = Object.prototype.hasOwnProperty, f = "~";
  if (Object.create) {
    if (z0.prototype = Object.create(null), !new z0().__proto__)
      f = false;
  }
  g.prototype.eventNames = function $() {
    var Z = [], X, W;
    if (this._eventsCount === 0)
      return Z;
    for (W in X = this._events)
      if (Q$.call(X, W))
        Z.push(f ? W.slice(1) : W);
    if (Object.getOwnPropertySymbols)
      return Z.concat(Object.getOwnPropertySymbols(X));
    return Z;
  };
  g.prototype.listeners = function $(Z) {
    var X = f ? f + Z : Z, W = this._events[X];
    if (!W)
      return [];
    if (W.fn)
      return [W.fn];
    for (var J = 0, Q = W.length, Y = new Array(Q);J < Q; J++)
      Y[J] = W[J].fn;
    return Y;
  };
  g.prototype.listenerCount = function $(Z) {
    var X = f ? f + Z : Z, W = this._events[X];
    if (!W)
      return 0;
    if (W.fn)
      return 1;
    return W.length;
  };
  g.prototype.emit = function $(Z, X, W, J, Q, Y) {
    var _ = f ? f + Z : Z;
    if (!this._events[_])
      return false;
    var B = this._events[_], K = arguments.length, G, U;
    if (B.fn) {
      if (B.once)
        this.removeListener(Z, B.fn, undefined, true);
      switch (K) {
        case 1:
          return B.fn.call(B.context), true;
        case 2:
          return B.fn.call(B.context, X), true;
        case 3:
          return B.fn.call(B.context, X, W), true;
        case 4:
          return B.fn.call(B.context, X, W, J), true;
        case 5:
          return B.fn.call(B.context, X, W, J, Q), true;
        case 6:
          return B.fn.call(B.context, X, W, J, Q, Y), true;
      }
      for (U = 1, G = new Array(K - 1);U < K; U++)
        G[U - 1] = arguments[U];
      B.fn.apply(B.context, G);
    } else {
      var w = B.length, A;
      for (U = 0;U < w; U++) {
        if (B[U].once)
          this.removeListener(Z, B[U].fn, undefined, true);
        switch (K) {
          case 1:
            B[U].fn.call(B[U].context);
            break;
          case 2:
            B[U].fn.call(B[U].context, X);
            break;
          case 3:
            B[U].fn.call(B[U].context, X, W);
            break;
          case 4:
            B[U].fn.call(B[U].context, X, W, J);
            break;
          default:
            if (!G)
              for (A = 1, G = new Array(K - 1);A < K; A++)
                G[A - 1] = arguments[A];
            B[U].fn.apply(B[U].context, G);
        }
      }
    }
    return true;
  };
  g.prototype.on = function $(Z, X, W) {
    return O1(this, Z, X, W, false);
  };
  g.prototype.once = function $(Z, X, W) {
    return O1(this, Z, X, W, true);
  };
  g.prototype.removeListener = function $(Z, X, W, J) {
    var Q = f ? f + Z : Z;
    if (!this._events[Q])
      return this;
    if (!X)
      return E0(this, Q), this;
    var Y = this._events[Q];
    if (Y.fn) {
      if (Y.fn === X && (!J || Y.once) && (!W || Y.context === W))
        E0(this, Q);
    } else {
      for (var _ = 0, B = [], K = Y.length;_ < K; _++)
        if (Y[_].fn !== X || J && !Y[_].once || W && Y[_].context !== W)
          B.push(Y[_]);
      if (B.length)
        this._events[Q] = B.length === 1 ? B[0] : B;
      else
        E0(this, Q);
    }
    return this;
  };
  g.prototype.removeAllListeners = function $(Z) {
    var X;
    if (Z) {
      if (X = f ? f + Z : Z, this._events[X])
        E0(this, X);
    } else
      this._events = new z0, this._eventsCount = 0;
    return this;
  };
  g.prototype.off = g.prototype.removeListener;
  g.prototype.addListener = g.prototype.on;
  g.prefixed = f;
  g.EventEmitter = g;
  if (typeof i0 !== "undefined")
    i0.exports = g;
});
var X12 = J02((D6, H1) => {
  var P$ = function($) {
    var Z = $.indexOf("%");
    if (Z === -1)
      return $;
    var X = $.length, W = "", J = 0, Q = 0, Y = Z, _ = T1;
    while (Z > -1 && Z < X) {
      var B = E1($[Z + 1], 4), K = E1($[Z + 2], 0), G = B | K, U = Z1[G];
      if (_ = Z1[256 + _ + U], Q = Q << 6 | G & Z1[364 + U], _ === T1)
        W += $.slice(J, Y), W += Q <= 65535 ? String.fromCharCode(Q) : String.fromCharCode(55232 + (Q >> 10), 56320 + (Q & 1023)), Q = 0, J = Z + 3, Z = Y = $.indexOf("%", J);
      else if (_ === A$)
        return null;
      else {
        if (Z += 3, Z < X && $.charCodeAt(Z) === 37)
          continue;
        return null;
      }
    }
    return W + $.slice(J);
  }, E1 = function($, Z) {
    var X = w$[$];
    return X === undefined ? 255 : X << Z;
  }, T1 = 12, A$ = 0, Z1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7], w$ = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  H1.exports = P$;
});
var f12 = J02((G6, g1) => {
  var V$ = function($) {
    const Z = new x1;
    if (typeof $ !== "string")
      return Z;
    let X = $.length, W = "", J = "", Q = -1, Y = -1, _ = false, B = false, K = false, G = false, U = false, w = 0;
    for (let A = 0;A < X + 1; A++)
      if (w = A !== X ? $.charCodeAt(A) : 38, w === 38) {
        if (U = Y > Q, !U)
          Y = A;
        if (W = $.slice(Q + 1, Y), U || W.length > 0) {
          if (K)
            W = W.replace(L1, " ");
          if (_)
            W = b1(W) || W;
          if (U) {
            if (J = $.slice(Y + 1, A), G)
              J = J.replace(L1, " ");
            if (B)
              J = b1(J) || J;
          }
          const z = Z[W];
          if (z === undefined)
            Z[W] = J;
          else if (z.pop)
            z.push(J);
          else
            Z[W] = [z, J];
        }
        J = "", Q = A, Y = A, _ = false, B = false, K = false, G = false;
      } else if (w === 61)
        if (Y <= Q)
          Y = A;
        else
          B = true;
      else if (w === 43)
        if (Y > Q)
          G = true;
        else
          K = true;
      else if (w === 37)
        if (Y > Q)
          B = true;
        else
          _ = true;
    return Z;
  }, b1 = X12(), L1 = /\+/g, x1 = function() {
  };
  x1.prototype = Object.create(null);
  g1.exports = V$;
});
var v12 = J02((K6, y1) => {
  var C$ = function($) {
    const Z = $.length;
    if (Z === 0)
      return "";
    let X = "", W = 0, J = 0;
    $:
      for (;J < Z; J++) {
        let Q = $.charCodeAt(J);
        while (Q < 128) {
          if (R$[Q] !== 1) {
            if (W < J)
              X += $.slice(W, J);
            W = J + 1, X += i[Q];
          }
          if (++J === Z)
            break $;
          Q = $.charCodeAt(J);
        }
        if (W < J)
          X += $.slice(W, J);
        if (Q < 2048) {
          W = J + 1, X += i[192 | Q >> 6] + i[128 | Q & 63];
          continue;
        }
        if (Q < 55296 || Q >= 57344) {
          W = J + 1, X += i[224 | Q >> 12] + i[128 | Q >> 6 & 63] + i[128 | Q & 63];
          continue;
        }
        if (++J, J >= Z)
          throw new Error("URI malformed");
        const Y = $.charCodeAt(J) & 1023;
        W = J + 1, Q = 65536 + ((Q & 1023) << 10 | Y), X += i[240 | Q >> 18] + i[128 | Q >> 12 & 63] + i[128 | Q >> 6 & 63] + i[128 | Q & 63];
      }
    if (W === 0)
      return $;
    if (W < Z)
      return X + $.slice(W);
    return X;
  }, i = Array.from({ length: 256 }, ($, Z) => "%" + ((Z < 16 ? "0" : "") + Z.toString(16)).toUpperCase()), R$ = new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0]);
  y1.exports = { encodeString: C$ };
});
var u12 = J02((z6, k1) => {
  var m1 = function($) {
    const Z = typeof $;
    if (Z === "string")
      return W1($);
    else if (Z === "bigint")
      return $.toString();
    else if (Z === "boolean")
      return $ ? "true" : "false";
    else if (Z === "number" && Number.isFinite($))
      return $ < 1000000000000000000000 ? "" + $ : W1("" + $);
    return "";
  }, S$ = function($) {
    let Z = "";
    if ($ === null || typeof $ !== "object")
      return Z;
    const X = "&", W = Object.keys($), J = W.length;
    let Q = 0;
    for (let Y = 0;Y < J; Y++) {
      const _ = W[Y], B = $[_], K = W1(_) + "=";
      if (Y)
        Z += X;
      if (Array.isArray(B)) {
        Q = B.length;
        for (let G = 0;G < Q; G++) {
          if (G)
            Z += X;
          Z += K, Z += m1(B[G]);
        }
      } else
        Z += K, Z += m1(B);
    }
    return Z;
  }, { encodeString: W1 } = v12();
  k1.exports = S$;
});
var J12 = J02((U6, j0) => {
  var h1 = f12(), c1 = u12(), d1 = { parse: h1, stringify: c1 };
  j0.exports = d1;
  j0.exports.default = d1;
  j0.exports.parse = h1;
  j0.exports.stringify = c1;
});
var Y02 = ($, Z) => ({ part: $, store: null, inert: Z !== undefined ? new Map(Z.map((X) => [X.part.charCodeAt(0), X])) : null, params: null, wildcardStore: null });
var U12 = ($, Z) => ({ ...$, part: Z });
var M12 = ($) => ({ paramName: $, store: null, inert: null });

class o2 {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
  add($, Z, X) {
    if (typeof Z !== "string")
      throw new TypeError("Route path must be a string");
    if (Z === "")
      Z = "/";
    else if (Z[0] !== "/")
      Z = `/${Z}`;
    this.history.push([$, Z, X]);
    const W = Z[Z.length - 1] === "*";
    if (W)
      Z = Z.slice(0, -1);
    const J = Z.split(o2.regex.static), Q = Z.match(o2.regex.params) || [];
    if (J[J.length - 1] === "")
      J.pop();
    let Y;
    if (!this.root[$])
      Y = this.root[$] = Y02("/");
    else
      Y = this.root[$];
    let _ = 0;
    for (let B = 0;B < J.length; ++B) {
      let K = J[B];
      if (B > 0) {
        const G = Q[_++].slice(1);
        if (Y.params === null)
          Y.params = M12(G);
        else if (Y.params.paramName !== G)
          throw new Error(`Cannot create route "${Z}" with parameter "${G}" ` + "because a route already exists with a different parameter name " + `("${Y.params.paramName}") in the same location`);
        const U = Y.params;
        if (U.inert === null) {
          Y = U.inert = Y02(K);
          continue;
        }
        Y = U.inert;
      }
      for (let G = 0;; ) {
        if (G === K.length) {
          if (G < Y.part.length) {
            const U = U12(Y, Y.part.slice(G));
            Object.assign(Y, Y02(K, [U]));
          }
          break;
        }
        if (G === Y.part.length) {
          if (Y.inert === null)
            Y.inert = new Map;
          else if (Y.inert.has(K.charCodeAt(G))) {
            Y = Y.inert.get(K.charCodeAt(G)), K = K.slice(G), G = 0;
            continue;
          }
          const U = Y02(K.slice(G));
          Y.inert.set(K.charCodeAt(G), U), Y = U;
          break;
        }
        if (K[G] !== Y.part[G]) {
          const U = U12(Y, Y.part.slice(G)), w = Y02(K.slice(G));
          Object.assign(Y, Y02(Y.part.slice(0, G), [U, w])), Y = w;
          break;
        }
        ++G;
      }
    }
    if (_ < Q.length) {
      const B = Q[_].slice(1);
      if (Y.params === null)
        Y.params = M12(B);
      else if (Y.params.paramName !== B)
        throw new Error(`Cannot create route "${Z}" with parameter "${B}" ` + "because a route already exists with a different parameter name " + `("${Y.params.paramName}") in the same location`);
      if (Y.params.store === null)
        Y.params.store = X;
      return Y.params.store;
    }
    if (W) {
      if (Y.wildcardStore === null)
        Y.wildcardStore = X;
      return Y.wildcardStore;
    }
    if (Y.store === null)
      Y.store = X;
    return Y.store;
  }
  find($, Z) {
    const X = this.root[$];
    if (!X)
      return null;
    return p02(Z, Z.length, X, 0);
  }
}
var p02 = ($, Z, X, W) => {
  const J = X?.part, Q = W + J.length;
  if (J.length > 1) {
    if (Q > Z)
      return null;
    if (J.length < 15) {
      for (let Y = 1, _ = W + 1;Y < J.length; ++Y, ++_)
        if (J.charCodeAt(Y) !== $.charCodeAt(_))
          return null;
    } else if ($.substring(W, Q) !== J)
      return null;
  }
  if (Q === Z) {
    if (X.store !== null)
      return { store: X.store, params: {} };
    if (X.wildcardStore !== null)
      return { store: X.wildcardStore, params: { "*": "" } };
    return null;
  }
  if (X.inert !== null) {
    const Y = X.inert.get($.charCodeAt(Q));
    if (Y !== undefined) {
      const _ = p02($, Z, Y, Q);
      if (_ !== null)
        return _;
    }
  }
  if (X.params !== null) {
    const Y = X.params, _ = $.indexOf("/", Q);
    if (_ !== Q) {
      if (_ === -1 || _ >= Z) {
        if (Y.store !== null) {
          const B = {};
          return B[Y.paramName] = $.substring(Q, Z), { store: Y.store, params: B };
        }
      } else if (Y.inert !== null) {
        const B = p02($, Z, Y.inert, _);
        if (B !== null)
          return B.params[Y.paramName] = $.substring(Q, _), B;
      }
    }
  }
  if (X.wildcardStore !== null)
    return { store: X.wildcardStore, params: { "*": $.substring(Q, Z) } };
  return null;
};
var N12 = T02(I12(), 1);
var F12 = N12.default;
var H02 = () => {
  let $;
  return [new Promise((X) => {
    $ = X;
  }), $];
};
var t2 = () => {
  const [$, Z] = H02(), [X, W] = H02(), J = [], Q = [];
  return { signal: $, consume: (Y) => {
    switch (Y.type) {
      case "begin":
        if (Y.unit && J.length === 0)
          for (let _ = 0;_ < Y.unit; _++) {
            const [B, K] = H02(), [G, U] = H02();
            J.push(B), Q.push([(w) => {
              K({ children: [], end: G, name: w.name ?? "", skip: false, time: w.time });
            }, (w) => {
              U(w);
            }]);
          }
        Z({ children: J, end: X, name: Y.name ?? "", skip: false, time: Y.time });
        break;
      case "end":
        W(Y.time);
        break;
    }
  }, consumeChild(Y) {
    switch (Y.type) {
      case "begin":
        if (!Q[0])
          return;
        const [_] = Q[0];
        _({ children: [], end: X, name: Y.name ?? "", skip: false, time: Y.time });
        break;
      case "end":
        const B = Q.shift();
        if (!B)
          return;
        B[1](Y.time);
    }
  }, resolve() {
    Z({ children: [], end: new Promise((Y) => Y(0)), name: "", skip: true, time: 0 });
    for (let [Y, _] of Q)
      Y({ children: [], end: new Promise((B) => B(0)), name: "", skip: true, time: 0 }), _(0);
    W(0);
  } };
};
var j12 = ($, Z, X) => {
  return async function W(W) {
    if (W.event !== "request" || W.type !== "begin")
      return;
    const J = W.id, Q = $(), Y = t2(), _ = t2(), B = t2(), K = t2(), G = t2(), U = t2(), w = t2(), A = t2();
    Y.consume(W);
    const z = (P) => {
      if (P.id === J)
        switch (P.event) {
          case "request":
            Y.consume(P);
            break;
          case "request.unit":
            Y.consumeChild(P);
            break;
          case "parse":
            _.consume(P);
            break;
          case "parse.unit":
            _.consumeChild(P);
            break;
          case "transform":
            B.consume(P);
            break;
          case "transform.unit":
            B.consumeChild(P);
            break;
          case "beforeHandle":
            K.consume(P);
            break;
          case "beforeHandle.unit":
            K.consumeChild(P);
            break;
          case "handle":
            G.consume(P);
            break;
          case "afterHandle":
            U.consume(P);
            break;
          case "afterHandle.unit":
            U.consumeChild(P);
            break;
          case "error":
            w.consume(P);
            break;
          case "error.unit":
            w.consumeChild(P);
            break;
          case "response":
            if (P.type === "begin")
              Y.resolve(), _.resolve(), B.resolve(), K.resolve(), G.resolve(), U.resolve(), w.resolve();
            else
              Q.off("event", z);
            A.consume(P);
            break;
          case "response.unit":
            A.consumeChild(P);
            break;
          case "exit":
            Y.resolve(), _.resolve(), B.resolve(), K.resolve(), G.resolve(), U.resolve(), w.resolve();
            break;
        }
    };
    Q.on("event", z), await X({ id: J, context: W.ctx, set: W.ctx?.set, store: W.ctx?.store, time: W.time, request: Y.signal, parse: _.signal, transform: B.signal, beforeHandle: K.signal, handle: G.signal, afterHandle: U.signal, error: w.signal, response: A.signal }), Q.emit(`res${J}.${Z}`, undefined);
  };
};
var D$2 = function($, Z) {
  if (typeof $ !== "string")
    throw new TypeError("argument str must be a string");
  var X = {}, W = Z || {}, J = W.decode || K$2, Q = 0;
  while (Q < $.length) {
    var Y = $.indexOf("=", Q);
    if (Y === -1)
      break;
    var _ = $.indexOf(";", Q);
    if (_ === -1)
      _ = $.length;
    else if (_ < Y) {
      Q = $.lastIndexOf(";", Y - 1) + 1;
      continue;
    }
    var B = $.slice(Q, Y).trim();
    if (X[B] === undefined) {
      var K = $.slice(Y + 1, _).trim();
      if (K.charCodeAt(0) === 34)
        K = K.slice(1, -1);
      X[B] = M$2(K, J);
    }
    Q = _ + 1;
  }
  return X;
};
var G$2 = function($, Z, X) {
  var W = X || {}, J = W.encode || z$2;
  if (typeof J !== "function")
    throw new TypeError("option encode is invalid");
  if (!b02.test($))
    throw new TypeError("argument name is invalid");
  var Q = J(Z);
  if (Q && !b02.test(Q))
    throw new TypeError("argument val is invalid");
  var Y = $ + "=" + Q;
  if (W.maxAge != null) {
    var _ = W.maxAge - 0;
    if (isNaN(_) || !isFinite(_))
      throw new TypeError("option maxAge is invalid");
    Y += "; Max-Age=" + Math.floor(_);
  }
  if (W.domain) {
    if (!b02.test(W.domain))
      throw new TypeError("option domain is invalid");
    Y += "; Domain=" + W.domain;
  }
  if (W.path) {
    if (!b02.test(W.path))
      throw new TypeError("option path is invalid");
    Y += "; Path=" + W.path;
  }
  if (W.expires) {
    var B = W.expires;
    if (!U$2(B) || isNaN(B.valueOf()))
      throw new TypeError("option expires is invalid");
    Y += "; Expires=" + B.toUTCString();
  }
  if (W.httpOnly)
    Y += "; HttpOnly";
  if (W.secure)
    Y += "; Secure";
  if (W.partitioned)
    Y += "; Partitioned";
  if (W.priority) {
    var K = typeof W.priority === "string" ? W.priority.toLowerCase() : W.priority;
    switch (K) {
      case "low":
        Y += "; Priority=Low";
        break;
      case "medium":
        Y += "; Priority=Medium";
        break;
      case "high":
        Y += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (W.sameSite) {
    var G = typeof W.sameSite === "string" ? W.sameSite.toLowerCase() : W.sameSite;
    switch (G) {
      case true:
        Y += "; SameSite=Strict";
        break;
      case "lax":
        Y += "; SameSite=Lax";
        break;
      case "strict":
        Y += "; SameSite=Strict";
        break;
      case "none":
        Y += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return Y;
};
var K$2 = function($) {
  return $.indexOf("%") !== -1 ? decodeURIComponent($) : $;
};
var z$2 = function($) {
  return encodeURIComponent($);
};
var U$2 = function($) {
  return _$2.call($) === "[object Date]" || $ instanceof Date;
};
var M$2 = function($, Z) {
  try {
    return Z($);
  } catch (X) {
    return $;
  }
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var L02 = D$2;
var x02 = G$2;
var _$2 = Object.prototype.toString;
var b02 = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

class k2 {
  $;
  Z;
  name;
  setter;
  constructor($, Z = {}) {
    this._value = $;
    this.property = Z;
  }
  get() {
    return this._value;
  }
  get value() {
    return this._value;
  }
  set value($) {
    if (typeof $ === "object") {
      if (JSON.stringify(this.value) === JSON.stringify($))
        return;
    } else if (this.value === $)
      return;
    this._value = $, this.sync();
  }
  add($) {
    const Z = Object.assign(this.property, typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $);
    if ("value" in Z)
      this._value = Z.value, delete Z.value;
    return this.property = Z, this.sync();
  }
  set($) {
    const Z = typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $;
    if ("value" in Z)
      this._value = Z.value, delete Z.value;
    return this.property = Z, this.sync();
  }
  remove($) {
    if (this.value === undefined)
      return;
    this.set({ domain: $?.domain, expires: new Date(0), maxAge: 0, path: $?.path, sameSite: $?.sameSite, secure: $?.secure, value: "" });
  }
  get domain() {
    return this.property.domain;
  }
  set domain($) {
    if (this.property.domain === $)
      return;
    this.property.domain = $, this.sync();
  }
  get expires() {
    return this.property.expires;
  }
  set expires($) {
    if (this.property.expires?.getTime() === $?.getTime())
      return;
    this.property.expires = $, this.sync();
  }
  get httpOnly() {
    return this.property.httpOnly;
  }
  set httpOnly($) {
    if (this.property.domain === $)
      return;
    this.property.httpOnly = $, this.sync();
  }
  get maxAge() {
    return this.property.maxAge;
  }
  set maxAge($) {
    if (this.property.maxAge === $)
      return;
    this.property.maxAge = $, this.sync();
  }
  get path() {
    return this.property.path;
  }
  set path($) {
    if (this.property.path === $)
      return;
    this.property.path = $, this.sync();
  }
  get priority() {
    return this.property.priority;
  }
  set priority($) {
    if (this.property.priority === $)
      return;
    this.property.priority = $, this.sync();
  }
  get sameSite() {
    return this.property.sameSite;
  }
  set sameSite($) {
    if (this.property.sameSite === $)
      return;
    this.property.sameSite = $, this.sync();
  }
  get secure() {
    return this.property.secure;
  }
  set secure($) {
    if (this.property.secure === $)
      return;
    this.property.secure = $, this.sync();
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
  sync() {
    if (!this.name || !this.setter)
      return this;
    if (!this.setter.cookie)
      this.setter.cookie = { [this.name]: Object.assign(this.property, { value: this.toString() }) };
    else
      this.setter.cookie[this.name] = Object.assign(this.property, { value: this.toString() });
    return this;
  }
}
var A12 = ($, Z, X) => new Proxy($, { get(W, J) {
  if (J in W)
    return W[J];
  const Q = new k2(undefined, X ? { ...X } : undefined);
  return Q.setter = Z, Q.name = J, Q;
}, set(W, J, Q) {
  if (!(Q instanceof k2))
    return false;
  if (!Z.cookie)
    Z.cookie = {};
  return Q.setter = Z, Q.name = J, Q.sync(), W[J] = Q, true;
} });
var g02 = async ($, Z, { secret: X, sign: W, ...J } = {}) => {
  if (!Z)
    return A12({}, $, J);
  const Q = {}, Y = typeof X === "string";
  if (W && W !== true && !Array.isArray(W))
    W = [W];
  const _ = Object.keys(L02(Z));
  for (let B = 0;B < _.length; B++) {
    const K = _[B];
    let G = L02(Z)[K];
    if (W === true || W?.includes(K)) {
      if (!X)
        throw new Error("No secret is provided to cookie plugin");
      if (Y) {
        if (G = await l02(G, X), G === false)
          throw new U02(K);
      } else {
        let A = true;
        for (let z = 0;z < X.length; z++) {
          const P = await l02(G, X[z]);
          if (P !== false) {
            G = P, A = false;
            break;
          }
        }
        if (A)
          throw new U02(K);
      }
    }
    if (G === undefined)
      continue;
    const U = G.charCodeAt(0);
    if (U === 123 || U === 91)
      try {
        const A = new k2(JSON.parse(G));
        A.setter = $, A.name = K, Q[K] = A;
        continue;
      } catch {
      }
    if (f02(G))
      G = +G;
    else if (G === "true")
      G = true;
    else if (G === "false")
      G = false;
    const w = new k2(G, J);
    w.setter = $, w.name = K, Q[K] = w;
  }
  return A12(Q, $);
};
var M02 = "toJSON" in new Headers;
var u2 = ($) => {
  for (let Z in $)
    return true;
  return false;
};
var O02 = ($, Z) => {
  const X = $.size;
  if (X && Z && Z.status !== 206 && Z.status !== 304 && Z.status !== 412 && Z.status !== 416 || !Z && X) {
    if (Z) {
      if (Z.headers instanceof Headers) {
        if (M02)
          Z.headers = Z.headers.toJSON();
        else
          for (let [W, J] of Z.headers.entries())
            if (W in Z.headers)
              Z.headers[W] = J;
      }
      return new Response($, { status: Z.status, headers: Object.assign({ "accept-ranges": "bytes", "content-range": `bytes 0-${X - 1}/${X}` }, Z.headers) });
    }
    return new Response($, { headers: { "accept-ranges": "bytes", "content-range": `bytes 0-${X - 1}/${X}` } });
  }
  return new Response($);
};
var P12 = ($, Z) => {
  if (!$ || !Array.isArray(Z))
    return $;
  $.delete("Set-Cookie");
  for (let X = 0;X < Z.length; X++) {
    const W = Z[X].indexOf("=");
    $.append("Set-Cookie", `${Z[X].slice(0, W)}=${Z[X].slice(W + 1)}`);
  }
  return $;
};
var w12 = ($) => {
  if (!$ || typeof $ !== "object" || !u2($))
    return;
  const Z = [];
  for (let [X, W] of Object.entries($)) {
    if (!X || !W)
      continue;
    if (Array.isArray(W.value))
      for (let J = 0;J < W.value.length; J++) {
        let Q = W.value[J];
        if (Q === undefined || Q === null)
          continue;
        if (typeof Q === "object")
          Q = JSON.stringify(Q);
        Z.push(x02(X, Q, W));
      }
    else {
      let J = W.value;
      if (J === undefined || J === null)
        continue;
      if (typeof J === "object")
        J = JSON.stringify(J);
      Z.push(x02(X, W.value, W));
    }
  }
  if (Z.length === 0)
    return;
  if (Z.length === 1)
    return Z[0];
  return Z;
};
var v2 = ($, Z) => {
  if ($?.[$.$passthrough])
    $ = $[$.$passthrough];
  if ($?.[c2])
    Z.status = $[c2], $ = $.response;
  if (u2(Z.headers) || Z.status !== 200 || Z.redirect || Z.cookie) {
    if (typeof Z.status === "string")
      Z.status = I02[Z.status];
    if (Z.redirect) {
      if (Z.headers.Location = Z.redirect, !Z.status || Z.status < 300 || Z.status >= 400)
        Z.status = 302;
    }
    if (Z.cookie && u2(Z.cookie))
      Z.headers["Set-Cookie"] = w12(Z.cookie);
    if (Z.headers["Set-Cookie"] && Array.isArray(Z.headers["Set-Cookie"]))
      Z.headers = P12(new Headers(Z.headers), Z.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
        return new Response($, Z);
      case "Blob":
        return O02($, Z);
      case "Object":
      case "Array":
        return Response.json($, Z);
      case "ReadableStream":
        if (!Z.headers["content-type"]?.startsWith("text/event-stream"))
          Z.headers["content-type"] = "text/event-stream; charset=utf-8";
        return new Response($, Z);
      case undefined:
        if (!$)
          return new Response("", Z);
        return Response.json($, Z);
      case "Response":
        const X = { ...Z.headers };
        if (M02)
          Z.headers = $.headers.toJSON();
        else
          for (let [J, Q] of $.headers.entries())
            if (J in Z.headers)
              Z.headers[J] = Q;
        for (let J in X)
          $.headers.append(J, X[J]);
        return $;
      case "Error":
        return h2($, Z);
      case "Promise":
        return $.then((J) => v2(J, Z));
      case "Function":
        return v2($(), Z);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Z);
      case "Cookie":
        if ($ instanceof k2)
          return new Response($.value, Z);
        return new Response($?.toString(), Z);
      default:
        if ($ instanceof Response) {
          const J = { ...Z.headers };
          if (M02)
            Z.headers = $.headers.toJSON();
          else
            for (let [Q, Y] of $.headers.entries())
              if (Q in Z.headers)
                Z.headers[Q] = Y;
          for (let Q in J)
            $.headers.append(Q, J[Q]);
          return $;
        }
        if ($ instanceof Promise)
          return $.then((J) => v2(J, Z));
        if ($ instanceof Error)
          return h2($, Z);
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123) {
          if (!Z.headers["Content-Type"])
            Z.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Z);
        }
        return new Response(W, Z);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
        return new Response($);
      case "Blob":
        return O02($, Z);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "ReadableStream":
        return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Error":
        return h2($, Z);
      case "Promise":
        return $.then((W) => {
          const J = l2(W);
          if (J !== undefined)
            return J;
          return new Response("");
        });
      case "Function":
        return l2($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof k2)
          return new Response($.value, Z);
        return new Response($?.toString(), Z);
      default:
        if ($ instanceof Response)
          return new Response($.body, { headers: { "Content-Type": "application/json" } });
        if ($ instanceof Promise)
          return $.then((W) => v2(W, Z));
        if ($ instanceof Error)
          return h2($, Z);
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(X);
    }
};
var y2 = ($, Z) => {
  if ($ === undefined || $ === null)
    return;
  if ($?.$passthrough)
    $ = $[$.$passthrough];
  if ($?.[c2])
    Z.status = $[c2], $ = $.response;
  if (u2(Z.headers) || Z.status !== 200 || Z.redirect || Z.cookie) {
    if (typeof Z.status === "string")
      Z.status = I02[Z.status];
    if (Z.redirect) {
      if (Z.headers.Location = Z.redirect, !Z.status || Z.status < 300 || Z.status >= 400)
        Z.status = 302;
    }
    if (Z.cookie && u2(Z.cookie))
      Z.headers["Set-Cookie"] = w12(Z.cookie);
    if (Z.headers["Set-Cookie"] && Array.isArray(Z.headers["Set-Cookie"]))
      Z.headers = P12(new Headers(Z.headers), Z.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
        return new Response($, Z);
      case "Blob":
        return O02($, Z);
      case "Object":
      case "Array":
        return Response.json($, Z);
      case "ReadableStream":
        if (!Z.headers["content-type"]?.startsWith("text/event-stream"))
          Z.headers["content-type"] = "text/event-stream; charset=utf-8";
        return new Response($, Z);
      case undefined:
        if (!$)
          return;
        return Response.json($, Z);
      case "Response":
        const X = Object.assign({}, Z.headers);
        if (M02)
          Z.headers = $.headers.toJSON();
        else
          for (let [J, Q] of $.headers.entries())
            if (!(J in Z.headers))
              Z.headers[J] = Q;
        for (let J in X)
          $.headers.append(J, X[J]);
        if ($.status !== Z.status)
          Z.status = $.status;
        return $;
      case "Promise":
        return $.then((J) => {
          const Q = y2(J, Z);
          if (Q !== undefined)
            return Q;
          return;
        });
      case "Error":
        return h2($, Z);
      case "Function":
        return y2($(), Z);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Z);
      case "Cookie":
        if ($ instanceof k2)
          return new Response($.value, Z);
        return new Response($?.toString(), Z);
      default:
        if ($ instanceof Response) {
          const J = { ...Z.headers };
          if (M02)
            Z.headers = $.headers.toJSON();
          else
            for (let [Q, Y] of $.headers.entries())
              if (Q in Z.headers)
                Z.headers[Q] = Y;
          for (let Q in J)
            $.headers.append(Q, J[Q]);
          return $;
        }
        if ($ instanceof Promise)
          return $.then((J) => y2(J, Z));
        if ($ instanceof Error)
          return h2($, Z);
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123) {
          if (!Z.headers["Content-Type"])
            Z.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Z);
        }
        return new Response(W, Z);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
        return new Response($);
      case "Blob":
        return O02($, Z);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "ReadableStream":
        return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Promise":
        return $.then((W) => {
          const J = y2(W, Z);
          if (J !== undefined)
            return J;
          return;
        });
      case "Error":
        return h2($, Z);
      case "Function":
        return l2($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof k2)
          return new Response($.value, Z);
        return new Response($?.toString(), Z);
      default:
        if ($ instanceof Response)
          return new Response($.body, { headers: { "Content-Type": "application/json" } });
        if ($ instanceof Promise)
          return $.then((W) => y2(W, Z));
        if ($ instanceof Error)
          return h2($, Z);
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(X);
    }
};
var l2 = ($) => {
  if ($?.$passthrough)
    $ = $[$.$passthrough];
  if ($?.[c2])
    return v2($.response, { status: $[c2], headers: {} });
  switch ($?.constructor?.name) {
    case "String":
      return new Response($);
    case "Blob":
      return O02($);
    case "Object":
    case "Array":
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "ReadableStream":
      return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      return $;
    case "Error":
      return h2($);
    case "Promise":
      return $.then(l2);
    case "Function":
      return l2($());
    case "Number":
    case "Boolean":
      return new Response($.toString());
    default:
      if ($ instanceof Response)
        return new Response($.body, { headers: { "Content-Type": "application/json" } });
      if ($ instanceof Promise)
        return $.then(l2);
      if ($ instanceof Error)
        return h2($);
      const Z = JSON.stringify($);
      if (Z.charCodeAt(0) === 123)
        return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      return new Response(Z);
  }
};
var h2 = ($, Z) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: Z?.status !== 200 ? Z?.status ?? 500 : 500, headers: Z?.headers });
var r02 = ($) => $ && typeof $ === "object" && !Array.isArray($);
var t02 = ($, Z) => {
  const X = new URL($);
  return X.pathname = Z, X.toString();
};
var O$2 = ($) => typeof $ === "function" && /^\s*class\s+/.test($.toString()) || $.toString().startsWith("[object ") || u2(Object.getPrototypeOf($));
var d2 = ($, Z, { skipKeys: X } = {}) => {
  if (r02($) && r02(Z))
    for (let [W, J] of Object.entries(Z)) {
      if (X?.includes(W))
        continue;
      if (!r02(J)) {
        $[W] = J;
        continue;
      }
      if (!(W in $)) {
        $[W] = J;
        continue;
      }
      if (O$2(J)) {
        $[W] = J;
        continue;
      }
      $[W] = d2($[W], J);
    }
  return $;
};
var R12 = ($, Z) => d2($, Z, { skipKeys: ["properties"] });
var H2 = ($, Z) => {
  if (!$)
    return [];
  const X = [...Array.isArray($) ? $ : [$]], W = [];
  for (let J of X)
    if (J.$elysiaChecksum)
      W.push(J.$elysiaChecksum);
  for (let J of Array.isArray(Z) ? Z : [Z])
    if (!W.includes(J?.$elysiaChecksum))
      X.push(J);
  return X;
};
var I$2 = ["start", "request", "parse", "transform", "resolve", "beforeHandle", "afterHandle", "onResponse", "mapResponse", "trace", "error", "stop", "body", "headers", "params", "query", "response", "type", "detail"];
var s2 = ($, Z) => {
  return { ...$, ...Z, body: Z?.body ?? $?.body, headers: Z?.headers ?? $?.headers, params: Z?.params ?? $?.params, query: Z?.query ?? $?.query, response: Z?.response ?? $?.response, type: $?.type || Z?.type, detail: d2(Z?.detail ?? {}, $?.detail ?? {}), parse: H2($?.parse ?? [], Z?.parse ?? []), transform: H2($?.transform ?? [], Z?.transform ?? []), beforeHandle: H2($?.beforeHandle ?? [], Z?.beforeHandle ?? []), afterHandle: H2($?.afterHandle ?? [], Z?.afterHandle ?? []), onResponse: H2($?.onResponse ?? [], Z?.onResponse ?? []), mapResponse: H2($?.mapResponse ?? [], Z?.mapResponse ?? []), trace: H2($?.trace ?? [], Z?.trace ?? []), error: H2($?.error ?? [], Z?.error ?? []) };
};
var p2 = ($, { models: Z = {}, additionalProperties: X = false, dynamic: W = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Z))
    return;
  const J = typeof $ === "string" ? Z[$] : $;
  if (J.type === "object" && "additionalProperties" in J === false)
    J.additionalProperties = X;
  if (W)
    return { schema: J, references: "", checkFunc: () => {
    }, code: "", Check: (Q) => exports_value5.Check(J, Q), Errors: (Q) => exports_value5.Errors(J, Q), Code: () => "" };
  return TypeCompiler2.Compile(J, Object.values(Z));
};
var s02 = ($, { models: Z = {}, additionalProperties: X = false, dynamic: W = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Z))
    return;
  const J = typeof $ === "string" ? Z[$] : $, Q = (_, B) => {
    if (W)
      return { schema: _, references: "", checkFunc: () => {
      }, code: "", Check: (K) => exports_value5.Check(_, K), Errors: (K) => exports_value5.Errors(_, K), Code: () => "" };
    return TypeCompiler2.Compile(_, B);
  };
  if (Kind2 in J) {
    if ("additionalProperties" in J === false)
      J.additionalProperties = X;
    return { 200: Q(J, Object.values(Z)) };
  }
  const Y = {};
  return Object.keys(J).forEach((_) => {
    const B = J[+_];
    if (typeof B === "string") {
      if (B in Z) {
        const K = Z[B];
        K.type === "object" && "additionalProperties" in K, Y[+_] = Kind2 in K ? Q(K, Object.values(Z)) : K;
      }
      return;
    }
    if (B.type === "object" && "additionalProperties" in B === false)
      B.additionalProperties = X;
    Y[+_] = Kind2 in B ? Q(B, Object.values(Z)) : B;
  }), Y;
};
var N$2 = typeof Bun !== "undefined";
var F$2 = N$2 && typeof Bun.hash === "function";
var N02 = ($) => {
  if (F$2)
    return Bun.hash($);
  let Z = 9;
  for (let X = 0;X < $.length; )
    Z = Math.imul(Z ^ $.charCodeAt(X++), 387420489);
  return Z = Z ^ Z >>> 9;
};
var v02 = ($, Z, X) => {
  const W = (J) => {
    if (X && !J.$elysiaChecksum)
      J.$elysiaChecksum = X;
    return J;
  };
  return { ...$, ...Z, start: H2($.start, ("start" in Z ? Z.start ?? [] : []).map(W)), request: H2($.request, ("request" in Z ? Z.request ?? [] : []).map(W)), parse: H2($.parse, "parse" in Z ? Z?.parse ?? [] : []).map(W), transform: H2($.transform, (Z?.transform ?? []).map(W)), beforeHandle: H2($.beforeHandle, (Z?.beforeHandle ?? []).map(W)), afterHandle: H2($.afterHandle, (Z?.afterHandle ?? []).map(W)), mapResponse: H2($.mapResponse, (Z?.mapResponse ?? []).map(W)), onResponse: H2($.onResponse, (Z?.onResponse ?? []).map(W)), trace: $.trace, error: H2($.error, (Z?.error ?? []).map(W)), stop: H2($.stop, ("stop" in Z ? Z.stop ?? [] : []).map(W)) };
};
var C12 = ($, Z = true) => {
  if (!$)
    return $;
  if (typeof $ === "function") {
    if (Z)
      $.$elysiaHookType = "global";
    else
      $.$elysiaHookType = undefined;
    return $;
  }
  return $.map((X) => {
    if (Z)
      X.$elysiaHookType = "global";
    else
      X.$elysiaHookType = undefined;
    return X;
  });
};
var Q02 = ($) => {
  if (!$)
    return $;
  if (typeof $ === "function")
    return $.$elysiaHookType === "global" ? $ : undefined;
  return $.filter((Z) => Z.$elysiaHookType === "global");
};
var a02 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: Q02($?.parse), transform: Q02($?.transform), beforeHandle: Q02($?.beforeHandle), afterHandle: Q02($?.afterHandle), onResponse: Q02($?.onResponse), error: Q02($?.error) };
};
var I02 = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var B02 = async ($, Z) => {
  if (typeof $ !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (Z === null)
    throw new TypeError("Secret key must be provided.");
  const X = new TextEncoder, W = await crypto.subtle.importKey("raw", X.encode(Z), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), J = await crypto.subtle.sign("HMAC", W, X.encode($)), Q = Array.from(new Uint8Array(J)), Y = btoa(String.fromCharCode(...Q));
  return `${$}.${Y.replace(/=+$/, "")}`;
};
var l02 = async ($, Z) => {
  if (typeof $ !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (Z === null)
    throw new TypeError("Secret key must be provided.");
  const X = $.slice(0, $.lastIndexOf("."));
  return await B02(X, Z) === $ ? X : false;
};
var o02 = ($, Z, X = Z) => {
  for (let [W, J] of Object.entries(Z ?? {})) {
    if (I$2.includes(W) || !(W in $))
      continue;
    if (typeof $[W] === "function")
      $[W](J);
    else if (typeof $[W] === "object")
      o02($[W], J, X);
  }
};
var f02 = ($) => $.trim().length !== 0 && !Number.isNaN(Number($));
var S12 = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var _02 = Symbol("ElysiaErrorCode");
var c2 = Symbol("ElysiaResponse");
var F02 = (S12?.NODE_ENV ?? S12?.ENV) === "production";
class m02 extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor($) {
    super($ ?? "INTERNAL_SERVER_ERROR");
  }
}

class e2 extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor($) {
    super($ ?? "NOT_FOUND");
  }
}
class U02 extends Error {
  $;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor($, Z) {
    super(Z ?? `"${$}" has invalid cookie signature`);
    this.key = $;
  }
}

class q2 extends Error {
  $;
  Z;
  X;
  code = "VALIDATION";
  status = 400;
  constructor($, Z, X) {
    const W = F02 ? undefined : ("Errors" in Z) ? Z.Errors(X).First() : exports_value5.Errors(Z, X).First(), J = W?.schema.error ? typeof W.schema.error === "function" ? W.schema.error($, Z, X) : W.schema.error : undefined, Q = W?.path?.slice(1) || "root";
    let Y = "";
    if (J)
      Y = typeof J === "object" ? JSON.stringify(J) : J + "";
    else if (F02)
      Y = JSON.stringify({ type: $, message: W?.message });
    else
      Y = JSON.stringify({ type: $, at: Q, message: W?.message, expected: exports_value5.Create(Z.schema), found: X, errors: [...Z.Errors(X)] }, null, 2);
    super(Y);
    this.type = $;
    this.validator = Z;
    this.value = X;
    Object.setPrototypeOf(this, q2.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  static simplifyModel($) {
    const Z = "schema" in $ ? $.schema : $;
    try {
      return exports_value5.Create(Z);
    } catch {
      return Z;
    }
  }
  get model() {
    return q2.simplifyModel(this.validator);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: $ });
  }
}
var $12 = { open($) {
  $.data.open?.($);
}, message($, Z) {
  $.data.message?.($, Z);
}, drain($) {
  $.data.drain?.($);
}, close($, Z, X) {
  $.data.close?.($, Z, X);
} };

class D02 {
  $;
  Z;
  validator;
  constructor($, Z) {
    this.raw = $;
    this.data = Z;
    if (this.validator = $.data.validator, $.data.id)
      this.id = $.data.id;
    else {
      const X = new Uint32Array(1);
      crypto.getRandomValues(X), this.id = X[0].toString();
    }
  }
  get id() {
    return this.raw.data.id;
  }
  set id($) {
    this.raw.data.id = $;
  }
  get publish() {
    return ($, Z = undefined, X) => {
      if (this.validator?.Check(Z) === false)
        throw new q2("message", this.validator, Z);
      if (typeof Z === "object")
        Z = JSON.stringify(Z);
      return this.raw.publish($, Z, X), this;
    };
  }
  get send() {
    return ($) => {
      if (this.validator?.Check($) === false)
        throw new q2("message", this.validator, $);
      if (Buffer.isBuffer($))
        return this.raw.send($), this;
      if (typeof $ === "object")
        $ = JSON.stringify($);
      return this.raw.send($), this;
    };
  }
  get subscribe() {
    return ($) => {
      return this.raw.subscribe($), this;
    };
  }
  get unsubscribe() {
    return ($) => {
      return this.raw.unsubscribe($), this;
    };
  }
  get cork() {
    return ($) => {
      return this.raw.cork($), this;
    };
  }
  get close() {
    return () => {
      return this.raw.close(), this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
}
var p12 = T02(J12(), 1);
var i12 = T02(X12(), 1);
var q$2 = new Headers().toJSON;
var l12 = new RegExp(" (\\w+) = context", "g");
var n12 = { value: 0 };
var r12 = ({ hasTrace: $, hasTraceSet: Z = false, addFn: X, condition: W = {} }) => {
  if ($)
    return X("\nconst reporter = getReporter()\n"), (J, { name: Q, attribute: Y = "", unit: _ = 0 } = {}) => {
      const B = J.indexOf("."), K = B === -1;
      if (J !== "request" && J !== "response" && !W[K ? J : J.slice(0, B)])
        return () => {
          if (Z && J === "afterHandle")
            X("\nawait traceDone\n");
        };
      if (K)
        Q ||= J;
      else
        Q ||= "anonymous";
      X("\n" + `reporter.emit('event', {
					id,
					event: '${J}',
					type: 'begin',
					name: '${Q}',
					time: performance.now(),
					${K ? `unit: ${_},` : ""}
					${Y}
				})`.replace(/(\t| |\n)/g, "") + "\n");
      let G = false;
      return () => {
        if (G)
          return;
        if (G = true, X("\n" + `reporter.emit('event', {
							id,
							event: '${J}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + "\n"), Z && J === "afterHandle")
          X("\nawait traceDone\n");
      };
    };
  else
    return () => () => {
    };
};
var P02 = ($) => {
  const Z = $.indexOf(")");
  if ($.charCodeAt(Z + 2) === 61 && $.charCodeAt(Z + 5) !== 123)
    return true;
  return $.includes("return");
};
var T$2 = ($, { injectResponse: Z = "" } = {}) => ({ composeValidation: (X, W = `c.${X}`) => $ ? `c.set.status = 400; throw new ValidationError(
'${X}',
${X},
${W}
)` : `c.set.status = 400; return new ValidationError(
	'${X}',
	${X},
	${W}
).toResponse(c.set.headers)`, composeResponseValidation: (X = "r") => {
  const W = $ ? `throw new ValidationError(
'response',
response[c.set.status],
${X}
)` : `return new ValidationError(
'response',
response[c.set.status],
${X}
).toResponse(c.set.headers)`;
  return `\n${Z}
		if(!(${X} instanceof Response) && response[c.set.status]?.Check(${X}) === false) {
	if(!(response instanceof Error))
		${W}
}\n`;
} });
var b2 = ($, Z) => {
  if (Z.startsWith("[object "))
    return false;
  if (Z = Z.trimStart(), Z = Z.replaceAll(/^async /g, ""), /^(\w+)\(/g.test(Z))
    Z = Z.slice(Z.indexOf("("));
  const X = Z.charCodeAt(0) === 40 || Z.startsWith("function") ? Z.slice(Z.indexOf("(") + 1, Z.indexOf(")")) : Z.slice(0, Z.indexOf("=") - 1);
  if (X === "")
    return false;
  const W = X.charCodeAt(0) === 123 ? X.indexOf("...") : -1;
  if (X.charCodeAt(0) === 123) {
    if (X.includes($))
      return true;
    if (W === -1)
      return false;
  }
  if (Z.match(new RegExp(`${X}(.${$}|\\["${$}"\\])`)))
    return true;
  const J = W !== -1 ? X.slice(W + 3, X.indexOf(" ", W + 3)) : undefined;
  if (Z.match(new RegExp(`${J}(.${$}|\\["${$}"\\])`)))
    return true;
  const Q = [X];
  if (J)
    Q.push(J);
  for (let _ of Z.matchAll(l12))
    Q.push(_[1]);
  const Y = new RegExp(`{.*?} = (${Q.join("|")})`, "g");
  for (let [_] of Z.matchAll(Y))
    if (_.includes(`{ ${$}`) || _.includes(`, ${$}`))
      return true;
  return false;
};
var w02 = ($) => {
  if ($ = $.trimStart(), $.startsWith("[object"))
    return false;
  if ($ = $.replaceAll(/^async /g, ""), /^(\w+)\(/g.test($))
    $ = $.slice($.indexOf("("));
  const Z = $.charCodeAt(0) === 40 || $.startsWith("function") ? $.slice($.indexOf("(") + 1, $.indexOf(")")) : $.slice(0, $.indexOf("=") - 1);
  if (Z === "")
    return false;
  const X = Z.charCodeAt(0) === 123 ? Z.indexOf("...") : -1, W = X !== -1 ? Z.slice(X + 3, Z.indexOf(" ", X + 3)) : undefined, J = [Z];
  if (W)
    J.push(W);
  for (let Y of $.matchAll(l12))
    J.push(Y[1]);
  for (let Y of J)
    if (new RegExp(`\\b\\w+\\([^)]*\\b${Y}\\b[^)]*\\)`).test($))
      return true;
  const Q = new RegExp(`{.*?} = (${J.join("|")})`, "g");
  for (let [Y] of $.matchAll(Q))
    if (new RegExp(`\\b\\w+\\([^)]*\\b${Y}\\b[^)]*\\)`).test($))
      return true;
  return false;
};
var G02 = Symbol.for("TypeBox.Kind");
var k02 = ($, Z) => {
  if (!Z)
    return;
  if (G02 in Z && Z[G02] === $)
    return true;
  if (Z.type === "object") {
    const X = Z.properties;
    for (let W of Object.keys(X)) {
      const J = X[W];
      if (J.type === "object") {
        if (k02($, J))
          return true;
      } else if (J.anyOf) {
        for (let Q = 0;Q < J.anyOf.length; Q++)
          if (k02($, J.anyOf[Q]))
            return true;
      }
      if (G02 in J && J[G02] === $)
        return true;
    }
    return false;
  }
  return Z.properties && G02 in Z.properties && Z.properties[G02] === $;
};
var $02 = ($, Z) => {
  if (!Z)
    return;
  if (Z.type === "object") {
    const X = Z.properties;
    if (!X)
      return false;
    for (let W of Object.keys(X)) {
      const J = X[W];
      if ($ in J)
        return true;
      if (J.type === "object") {
        if ($02($, J))
          return true;
      } else if (J.anyOf) {
        for (let Q = 0;Q < J.anyOf.length; Q++)
          if ($02($, J.anyOf[Q]))
            return true;
      }
    }
    return false;
  }
  return $ in Z;
};
var Y12 = Symbol.for("TypeBox.Transform");
var Z02 = ($) => {
  if (!$)
    return;
  if ($.type === "object" && $.properties) {
    const Z = $.properties;
    for (let X of Object.keys(Z)) {
      const W = Z[X];
      if (W.type === "object") {
        if (Z02(W))
          return true;
      } else if (W.anyOf) {
        for (let Q = 0;Q < W.anyOf.length; Q++)
          if (Z02(W.anyOf[Q]))
            return true;
      }
      if (Y12 in W)
        return true;
    }
    return false;
  }
  return Y12 in $ || $.properties && Y12 in $.properties;
};
var E$2 = ($) => {
  if (!$)
    return;
  const Z = $?.schema;
  if (Z && "anyOf" in Z) {
    let X = false;
    const W = Z.anyOf[0].type;
    for (let J of Z.anyOf)
      if (J.type !== W) {
        X = true;
        break;
      }
    if (!X)
      return W;
  }
  return $.schema?.type;
};
var H$2 = /(?:return|=>) \S+\(/g;
var L2 = ($) => {
  if ($.constructor.name === "AsyncFunction")
    return true;
  const Z = $.toString();
  if (Z.includes("=> response.clone("))
    return false;
  return !!Z.match(H$2);
};
var b$2 = ($) => {
  if (!$.includes("query: {") || $.includes("query,") || $.includes("query }"))
    return false;
  const Z = $.indexOf("query: {");
  return $ = $.slice(Z + 9), $ = $.slice(0, $.indexOf("}")), $.split(",").map((X) => {
    const W = X.indexOf(":");
    if (W === -1)
      return X.trim();
    return X.slice(0, W).trim();
  });
};
var t12 = ({ path: $, method: Z, hooks: X, validator: W, handler: J, handleError: Q, definitions: Y, schema: _, onRequest: B, config: K, getReporter: G, setHeader: U }) => {
  const w = K.forceErrorEncapsulation || X.error.length > 0 || typeof Bun === "undefined" || X.onResponse.length > 0 || !!X.trace.length, A = typeof J === "function", z = A ? "handler(c)" : "handler", P = X.onResponse.length ? `\n;(async () => {${X.onResponse.map((O, I) => `await res${I}(c)`).join(";")}})();\n` : "", M = X.trace.map((O) => O.toString());
  let N = false;
  if (A && w02(J.toString()))
    N = true;
  if (!N)
    for (let [O, I] of Object.entries(X)) {
      if (!Array.isArray(I) || !I.length || !["parse", "transform", "beforeHandle", "afterHandle", "onResponse"].includes(O))
        continue;
      for (let j of I) {
        if (typeof j !== "function")
          continue;
        if (w02(j.toString())) {
          N = true;
          break;
        }
      }
      if (N)
        break;
    }
  const F = { parse: M.some((O) => b2("parse", O)), transform: M.some((O) => b2("transform", O)), handle: M.some((O) => b2("handle", O)), beforeHandle: M.some((O) => b2("beforeHandle", O)), afterHandle: M.some((O) => b2("afterHandle", O)), error: w || M.some((O) => b2("error", O)) }, V = X.trace.length > 0;
  let D = "";
  const m = W || Z !== "GET" && Z !== "HEAD" ? [J, ...X.transform, ...X.beforeHandle, ...X.afterHandle, ...X.mapResponse].map((O) => typeof O === "function" ? O.toString() : `${O}`) : [], V0 = Z !== "GET" && Z !== "HEAD" && (N || X.type !== "none" && (!!W.body || !!X.type || m.some((O) => b2("body", O)))), h0 = N || W.headers || m.some((O) => b2("headers", O)) || U && Object.keys(U).length, R0 = N || !!W.cookie || m.some((O) => b2("cookie", O)), x = W?.cookie?.schema;
  let r = "";
  if (x?.sign) {
    if (!x.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${Z}) ${$}.`);
    const O = !x.secrets ? undefined : typeof x.secrets === "string" ? x.secrets : x.secrets[0];
    if (r += `const _setCookie = c.set.cookie
		if(_setCookie) {`, x.sign === true)
      r += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${O}')
			}`;
    else
      for (let I of x.sign)
        r += `if(_setCookie['${I}']?.value) { c.set.cookie['${I}'].value = await signCookie(_setCookie['${I}'].value, '${O}') }\n`;
    r += "}\n";
  }
  const { composeValidation: X0, composeResponseValidation: C0 } = T$2(w);
  if (h0)
    D += q$2 ? "c.headers = c.request.headers.toJSON()\n" : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  if (R0) {
    const O = (j, C) => {
      const S = x?.[j] ?? C;
      if (!S)
        return typeof C === "string" ? `${j}: "${C}",` : `${j}: ${C},`;
      if (typeof S === "string")
        return `${j}: '${S}',`;
      if (S instanceof Date)
        return `${j}: new Date(${S.getTime()}),`;
      return `${j}: ${S},`;
    }, I = x ? `{
			secret: ${x.secrets !== undefined ? typeof x.secrets === "string" ? `'${x.secrets}'` : "[" + x.secrets.reduce((j, C) => j + `'${C}',`, "") + "]" : "undefined"},
			sign: ${x.sign === true ? true : x.sign !== undefined ? "[" + x.sign.reduce((j, C) => j + `'${C}',`, "") + "]" : "undefined"},
			${O("domain")}
			${O("expires")}
			${O("httpOnly")}
			${O("maxAge")}
			${O("path", "/")}
			${O("priority")}
			${O("sameSite")}
			${O("secure")}
		}` : "undefined";
    if (h0)
      D += `\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${I})\n`;
    else
      D += `\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${I})\n`;
  }
  if (N || W.query || m.some((O) => b2("query", O))) {
    let O = [], I = false;
    if (W.query && W.query.schema.type === "object")
      O = Object.keys(W.query.schema.properties);
    else
      for (let j of m) {
        const C = b$2(j);
        if (!C) {
          I = true;
          continue;
        }
        for (let S of C)
          if (O.indexOf(S) === -1)
            O.push(S);
      }
    if (!I && O.length)
      D += `
			let requestUrl = c.request.url.slice(c.qi + 1)
			if(requestUrl.includes('+')) requestUrl = requestUrl.replaceAll('+', ' ')

			if(c.qi !== -1) {	
				const url = decodeURIComponent(requestUrl)
				let memory = 0

				${O.map((j, C) => `
						memory = url.indexOf('${j}=')

						const a${C} = memory === -1 ? undefined : url.slice(memory = memory + ${j.length + 1}, (memory = url.indexOf('&', memory)) === -1 ? undefined : memory)`).join("\n")}

				c.query = {
					${O.map((j, C) => `${j}: a${C}`).join(", ")}
				}
			} else {
				c.query = {}
			}`;
    else
      D += "c.query = c.qi !== -1 ? parseQuery(decodeURIComponent(c.request.url.slice(c.qi + 1))) : {}";
  }
  const S0 = X.trace.map((O) => O.toString()).some((O) => b2("set", O) || w02(O));
  N || X.trace.some((O) => b2("set", O.toString()));
  const q0 = U && Object.keys(U).length || S0 || R0 || m.some((O) => b2("set", O)) || B.some((O) => b2("set", O.toString()));
  if (V)
    D += "\nconst id = c.$$requestId\n";
  const E = r12({ hasTrace: V, hasTraceSet: S0, condition: F, addFn: (O) => {
    D += O;
  } });
  if (D += w ? "\n try {\n" : "", S0) {
    D += "\nconst traceDone = Promise.all([";
    for (let O = 0;O < X.trace.length; O++)
      D += `new Promise(r => { reporter.once(\`res\${id}.${O}\`, r) }),`;
    D += "])\n";
  }
  const W0 = typeof J === "function" && L2(J), c0 = R0 || V0 || S0 || W0 || !!X.mapResponse.length || X.parse.length > 0 || X.afterHandle.some(L2) || X.beforeHandle.some(L2) || X.transform.some(L2), e1 = E("parse", { unit: X.parse.length });
  if (V0) {
    const O = E$2(W?.body);
    if (X.type && !Array.isArray(X.type)) {
      if (X.type)
        switch (X.type) {
          case "json":
          case "application/json":
            D += "c.body = await c.request.json()\n";
            break;
          case "text":
          case "text/plain":
            D += "c.body = await c.request.text()\n";
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            D += "c.body = parseQuery(await c.request.text())\n";
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            D += "c.body = await c.request.arrayBuffer()\n";
            break;
          case "formdata":
          case "multipart/form-data":
            D += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}\n`;
            break;
        }
      if (X.parse.length)
        D += "}}";
    } else {
      const j = (() => {
        if (X.parse.length && O && !Array.isArray(X.type)) {
          const C = W?.body?.schema;
          switch (O) {
            case "object":
              if (k02("File", C) || k02("Files", C))
                return `c.body = {}

								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue

									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
              break;
            default:
              break;
          }
        }
      })();
      if (j)
        D += j;
      else {
        if (D += "\n", D += h0 ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", D += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n`, X.parse.length) {
          D += "let used = false\n";
          const C = E("parse", { unit: X.parse.length });
          for (let S = 0;S < X.parse.length; S++) {
            const d0 = E("parse.unit", { name: X.parse[S].name }), T = `bo${S}`;
            if (S !== 0)
              D += "if(!used) {\n";
            if (D += `let ${T} = parse[${S}](c, contentType)\n`, D += `if(${T} instanceof Promise) ${T} = await ${T}\n`, D += `if(${T} !== undefined) { c.body = ${T}; used = true }\n`, d0(), S !== 0)
              D += "}";
          }
          C();
        }
        if (X.parse.length)
          D += "if (!used)";
        D += `
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break

					case 'text/plain':
						c.body = await c.request.text()
						break

					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break

					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break

					case 'multipart/form-data':
						c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}

						break
					}\n`, D += "}\n";
      }
    }
    D += "\n";
  }
  if (e1(), X?.transform) {
    const O = E("transform", { unit: X.transform.length });
    for (let I = 0;I < X.transform.length; I++) {
      const j = X.transform[I], C = E("transform.unit", { name: j.name });
      if (j.$elysia === "derive")
        D += L2(j) ? `Object.assign(c, await transform[${I}](c));` : `Object.assign(c, transform[${I}](c));`;
      else
        D += L2(j) ? `await transform[${I}](c);` : `transform[${I}](c);`;
      C();
    }
    O();
  }
  if (W) {
    if (D += "\n", W.headers) {
      if ($02("default", W.headers.params))
        for (let [O, I] of Object.entries(exports_value5.Default(W.headers.schema, {}))) {
          const j = typeof I === "object" ? JSON.stringify(I) : `'${I}'`;
          if (j)
            D += `c.headers['${O}'] ??= ${j}\n`;
        }
      if (D += `if(headers.Check(c.headers) === false) {
				${X0("headers")}
			}`, Z02(W.headers.schema))
        D += "\nc.headers = headers.Decode(c.headers)\n";
    }
    if (W.params) {
      if ($02("default", W.params.schema))
        for (let [O, I] of Object.entries(exports_value5.Default(W.params.schema, {}))) {
          const j = typeof I === "object" ? JSON.stringify(I) : `'${I}'`;
          if (j)
            D += `c.params['${O}'] ??= ${j}\n`;
        }
      if (D += `if(params.Check(c.params) === false) {
				${X0("params")}
			}`, Z02(W.params.schema))
        D += "\nc.params = params.Decode(c.params)\n";
    }
    if (W.query) {
      if ($02("default", W.query.schema))
        for (let [O, I] of Object.entries(exports_value5.Default(W.query.schema, {}))) {
          const j = typeof I === "object" ? JSON.stringify(I) : `'${I}'`;
          if (j)
            D += `c.query['${O}'] ??= ${j}\n`;
        }
      if (D += `if(query.Check(c.query) === false) {
				${X0("query")}
			}`, Z02(W.query.schema))
        D += "\nc.query = query.Decode(Object.assign({}, c.query))\n";
    }
    if (W.body) {
      if ($02("default", W.body.schema))
        D += `if(body.Check(c.body) === false) {
    				c.body = Object.assign(${JSON.stringify(exports_value5.Default(W.body.schema, null) ?? {})}, c.body)

    				if(body.Check(c.query) === false) {
        				${X0("body")}
     			}
            }`;
      else
        D += `if(body.Check(c.body) === false) {
			${X0("body")}
		}`;
      if (Z02(W.body.schema))
        D += "\nc.body = body.Decode(c.body)\n";
    }
    if (u2(W.cookie?.schema.properties ?? {})) {
      if (D += `const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value\n`, $02("default", W.cookie.schema))
        for (let [O, I] of Object.entries(exports_value5.Default(W.cookie.schema, {})))
          D += `cookieValue['${O}'] = ${typeof I === "object" ? JSON.stringify(I) : I}\n`;
      if (D += `if(cookie.Check(cookieValue) === false) {
				${X0("cookie", "cookieValue")}
			}`, Z02(W.cookie.schema))
        D += "\nc.cookie = params.Decode(c.cookie)\n";
    }
  }
  if (X?.beforeHandle) {
    const O = E("beforeHandle", { unit: X.beforeHandle.length });
    for (let I = 0;I < X.beforeHandle.length; I++) {
      const j = X.beforeHandle[I], C = E("beforeHandle.unit", { name: j.name }), S = P02(j.toString());
      if (j.$elysia === "resolve")
        D += L2(j) ? `Object.assign(c, await beforeHandle[${I}](c));` : `Object.assign(c, beforeHandle[${I}](c));`;
      else if (!S)
        D += L2(j) ? `await beforeHandle[${I}](c);\n` : `beforeHandle[${I}](c);\n`, C();
      else {
        D += L2(j) ? `be = await beforeHandle[${I}](c);\n` : `be = beforeHandle[${I}](c);\n`, C(), D += "if(be !== undefined) {\n";
        const d0 = E("afterHandle", { unit: X.transform.length });
        if (X.afterHandle) {
          E("handle", { name: A ? J.name : undefined })();
          for (let T = 0;T < X.afterHandle.length; T++) {
            const $$ = P02(X.afterHandle[T].toString()), Z$ = E("afterHandle.unit", { name: X.afterHandle[T].name });
            if (D += "c.response = be\n", !$$)
              D += L2(X.afterHandle[T]) ? `await afterHandle[${T}](c, be)\n` : `afterHandle[${T}](c, be)\n`;
            else
              D += L2(X.afterHandle[T]) ? `af = await afterHandle[${T}](c)\n` : `af = afterHandle[${T}](c)\n`, D += "if(af !== undefined) { c.response = be = af }\n";
            Z$();
          }
        }
        if (d0(), W.response)
          D += C0("be");
        if (X.mapResponse.length) {
          D += "c.response = be";
          for (let T = 0;T < X.mapResponse.length; T++)
            D += `\nif(mr === undefined) {
							mr = onMapResponse[${T}](c)
							if(mr instanceof Promise) mr = await mr
							if(mr !== undefined) c.response = mr
						}\n`;
        }
        D += r, D += "return mapEarlyResponse(be, c.set)}\n";
      }
    }
    O();
  }
  if (X?.afterHandle.length) {
    const O = E("handle", { name: A ? J.name : undefined });
    if (X.afterHandle.length)
      D += W0 ? `let r = c.response = await ${z};\n` : `let r = c.response = ${z};\n`;
    else
      D += W0 ? `let r = await ${z};\n` : `let r = ${z};\n`;
    O();
    const I = E("afterHandle", { unit: X.afterHandle.length });
    for (let j = 0;j < X.afterHandle.length; j++) {
      const C = P02(X.afterHandle[j].toString()), S = E("afterHandle.unit", { name: X.afterHandle[j].name });
      if (!C)
        D += L2(X.afterHandle[j]) ? `await afterHandle[${j}](c)\n` : `afterHandle[${j}](c)\n`, S();
      else if (D += L2(X.afterHandle[j]) ? `af = await afterHandle[${j}](c)\n` : `af = afterHandle[${j}](c)\n`, S(), W.response)
        D += "if(af !== undefined) {", I(), D += C0("af"), D += "c.response = af }";
      else
        D += "if(af !== undefined) {", I(), D += "c.response = af}\n";
    }
    if (I(), D += "r = c.response\n", W.response)
      D += C0();
    if (D += r, X.mapResponse.length)
      for (let j = 0;j < X.mapResponse.length; j++)
        D += `\nmr = onMapResponse[${j}](c)
				if(mr instanceof Promise) mr = await mr
				if(mr !== undefined) c.response = mr\n`;
    if (q0)
      D += "return mapResponse(r, c.set)\n";
    else
      D += "return mapCompactResponse(r)\n";
  } else {
    const O = E("handle", { name: A ? J.name : undefined });
    if (W.response || X.mapResponse.length) {
      if (D += W0 ? `let r = await ${z};\n` : `let r = ${z};\n`, O(), W.response)
        D += C0();
      if (E("afterHandle")(), X.mapResponse.length) {
        D += "c.response = r";
        for (let I = 0;I < X.mapResponse.length; I++)
          D += `\nif(mr === undefined) { 
						mr = onMapResponse[${I}](c)
						if(mr instanceof Promise) mr = await mr
    					if(mr !== undefined) r = c.response = mr
					}\n`;
      }
      if (D += r, J instanceof Response)
        D += `return ${z}.clone()\n`;
      else if (q0)
        D += "return mapResponse(r, c.set)\n";
      else
        D += "return mapCompactResponse(r)\n";
    } else if (F.handle || R0) {
      if (D += W0 ? `let r = await ${z};\n` : `let r = ${z};\n`, O(), E("afterHandle")(), X.mapResponse.length) {
        D += "c.response = r";
        for (let I = 0;I < X.mapResponse.length; I++)
          D += `\nif(mr === undefined) {
							mr = onMapResponse[${I}](c)
							if(mr instanceof Promise) mr = await mr
    						if(mr !== undefined) r = c.response = mr
						}\n`;
      }
      if (D += r, q0)
        D += "return mapResponse(r, c.set)\n";
      else
        D += "return mapCompactResponse(r)\n";
    } else {
      O();
      const I = W0 ? `await ${z}` : z;
      if (E("afterHandle")(), J instanceof Response)
        D += `return ${z}.clone()\n`;
      else if (q0)
        D += `return mapResponse(${I}, c.set)\n`;
      else
        D += `return mapCompactResponse(${I})\n`;
    }
  }
  if (w || P) {
    if (D += `
} catch(error) {`, !c0)
      D += "return (async () => {";
    D += `const set = c.set

		if (!set.status || set.status < 300) set.status = error?.status || 500
	`;
    const O = E("error", { unit: X.error.length });
    if (X.error.length) {
      D += `
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
			`;
      for (let I = 0;I < X.error.length; I++) {
        const j = `er${I}`, C = E("error.unit", { name: X.error[I].name });
        if (D += `\nlet ${j} = handleErrors[${I}](c)\n`, L2(X.error[I]))
          D += `if (${j} instanceof Promise) ${j} = await ${j}\n`;
        C(), D += `${j} = mapEarlyResponse(${j}, set)\n`, D += `if (${j}) {`, D += `return ${j} }\n`;
      }
    }
    if (O(), D += "return handleError(c, error)\n\n", !c0)
      D += "})()";
    if (D += "}", P || V) {
      D += " finally { ";
      const I = E("response", { unit: X.onResponse.length });
      D += P, I(), D += "}";
    }
  }
  return D = `const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		getReporter,
		requestId,
		parseCookie,
		signCookie,
		decodeURIComponent
	} = hooks

	${X.onResponse.length ? `const ${X.onResponse.map((O, I) => `res${I} = onResponse[${I}]`).join(",")}` : ""}

	return ${c0 ? "async" : ""} function handle(c) {
		${X.beforeHandle.length ? "let be" : ""}
		${X.afterHandle.length ? "let af" : ""}
		${X.mapResponse.length ? "let mr" : ""}

		${_ && Y ? "c.schema = schema; c.defs = definitions;" : ""}
		${D}
	}`, Function("hooks", D)({ handler: J, hooks: X, validator: W, handleError: Q, utils: { mapResponse: v2, mapCompactResponse: l2, mapEarlyResponse: y2, parseQuery: p12.parse }, error: { NotFoundError: e2, ValidationError: q2, InternalServerError: m02 }, schema: _, definitions: Y, ERROR_CODE: _02, getReporter: G, requestId: n12, parseCookie: g02, signCookie: B02, decodeURIComponent: i12.default });
};
var Q12 = ($) => {
  let Z = "", X = "";
  for (let z of Object.keys($.decorators))
    Z += `,${z}: app.decorators.${z}`;
  const { router: W, staticRouter: J } = $, Q = $.event.trace.length > 0, Y = `
	const route = router.find(request.method, path) ${W.root.ALL ? '?? router.find("ALL", path)' : ""}
	if (route === null)
		return ${$.event.error.length ? "app.handleError(ctx, notFound)" : $.event.request.length ? `new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})` : "error404.clone()"}

	ctx.params = route.params

	return route.store(ctx)`;
  let _ = "";
  for (let [z, { code: P, all: M }] of Object.entries(J.map))
    _ += `case '${z}':\nswitch(request.method) {\n${P}\n${M ?? "default: break map"}}\n\n`;
  const B = $.event.request.some(L2);
  if (X += `const {
		app,
		app: { store, router, staticRouter, wsRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		getReporter,
		handleError
	} = data

	const notFound = new NotFoundError()

	${$.event.request.length ? "const onRequest = app.event.request" : ""}
	${J.variables}
	${$.event.error.length ? "" : `
	const error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });
	`}

	return ${B ? "async" : ""} function map(request) {\n`, $.event.request.length)
    X += "let re";
  const K = $.event.trace.map((z) => z.toString()), G = r12({ hasTrace: Q, hasTraceSet: $.event.trace.some((z) => {
    const P = z.toString();
    return b2("set", P) || w02(P);
  }), condition: { request: K.some((z) => b2("request", z) || w02(z)) }, addFn: (z) => {
    X += z;
  } });
  if ($.event.request.length) {
    X += `
			${Q ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					headers: ${Object.keys($.setHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
					status: 200
				}
				${Q ? ",$$requestId: +id" : ""}
				${Z}
			}
		`;
    const z = G("request", { attribute: "ctx", unit: $.event.request.length });
    X += "\n try {\n";
    for (let P = 0;P < $.event.request.length; P++) {
      const M = $.event.request[P], N = P02(M.toString()), F = L2(M), V = G("request.unit", { name: $.event.request[P].name });
      if (N) {
        if (X += `re = mapEarlyResponse(
					${F ? "await" : ""} onRequest[${P}](ctx),
					ctx.set
				)\n`, V(), N)
          X += "if(re !== undefined) return re\n";
      } else
        X += `${F ? "await" : ""} onRequest[${P}](ctx)\n`, V();
    }
    X += `} catch (error) {
			return app.handleError(ctx, error)
		}`, z(), X += `
		const url = request.url
		const s = url.indexOf('/', 11)
		const qi = ctx.qi = url.indexOf('?', s + 1)
		const path = ctx.path = url.substring(s, qi === -1 ? undefined : qi)`;
  } else
    X += `
		const url = request.url
		const s = url.indexOf('/', 11)
		const qi = url.indexOf('?', s + 1)
		const path = url.substring(s, qi === -1 ? undefined : qi)
		${Q ? "const id = +requestId.value++" : ""}
		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: ${Object.keys($.setHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
				status: 200
			}
			${Q ? ",$$requestId: id" : ""}
			${Z}
		}`, G("request", { unit: $.event.request.length, attribute: K.some((z) => b2("context", z)) || K.some((z) => b2("store", z)) || K.some((z) => b2("set", z)) ? "ctx" : "" })();
  const { wsPaths: U, wsRouter: w } = $;
  if (Object.keys(U).length || w.history.length) {
    X += `
			if(request.method === 'GET') {
				switch(path) {`;
    for (let [z, P] of Object.entries(U))
      X += `
					case '${z}':
						if(request.headers.get('upgrade') === 'websocket')
							return st${P}(ctx)

						break`;
    X += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							return route.store(ctx)
						}
					}

					break
			}
		}\n`;
  }
  X += `
		map: switch(path) {
			${_}

			default:
				break
		}

		${Y}
	}`;
  const A = B12($);
  return $.handleError = A, Function("data", X)({ app: $, mapEarlyResponse: y2, NotFoundError: e2, getReporter: () => $.reporter, requestId: n12, handleError: A });
};
var B12 = ($) => {
  let Z = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE,
		ELYSIA_RESPONSE
	} = inject

	return ${$.event.error.find(L2) ? "async" : ""} function(context, error) {
		let r

		const { set } = context

		context.code = error.code
		context.error = error

		if(error[ELYSIA_RESPONSE]) {
			error.status = error[ELYSIA_RESPONSE]
			error.message = error.response
		}
`;
  for (let X = 0;X < $.event.error.length; X++) {
    const W = $.event.error[X], J = `${L2(W) ? "await " : ""}onError[${X}](context)`;
    if (P02(W.toString()))
      Z += `r = ${J}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r[ELYSIA_RESPONSE]) {
					error.status = error[ELYSIA_RESPONSE]
					error.message = error.response
				}
		
				if(set.status === 200) set.status = error.status
				return mapResponse(r, set)
			}\n`;
    else
      Z += J + "\n";
  }
  return Z += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 400
		return new Response(
			error.message,
			{ headers: set.headers, status: set.status }
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)

		return mapResponse(error, set)
	}
}`, Function("inject", Z)({ app: $, mapResponse: v2, ERROR_CODE: _02, ELYSIA_RESPONSE: c2 });
};
var u02 = T02(J12(), 1);
var _12 = ($) => async (Z) => {
  const X = { cookie: {}, status: 200, headers: {} };
  let W;
  if ($.decorators)
    W = $.decorators, W.request = Z, W.set = X, W.store = $.store;
  else
    W = { set: X, store: $.store, request: Z };
  const J = Z.url, Q = J.indexOf("/", 11), Y = J.indexOf("?", Q + 1), _ = Y === -1 ? J.substring(Q) : J.substring(Q, Y);
  try {
    for (let M = 0;M < $.event.request.length; M++) {
      const N = $.event.request[M];
      let F = N(W);
      if (F instanceof Promise)
        F = await F;
      if (F = y2(F, X), F)
        return F;
    }
    const B = $.dynamicRouter.find(Z.method, _) ?? $.dynamicRouter.find("ALL", _);
    if (!B)
      throw new e2;
    const { handle: K, hooks: G, validator: U, content: w } = B.store;
    let A;
    if (Z.method !== "GET" && Z.method !== "HEAD")
      if (w)
        switch (w) {
          case "application/json":
            A = await Z.json();
            break;
          case "text/plain":
            A = await Z.text();
            break;
          case "application/x-www-form-urlencoded":
            A = u02.parse(await Z.text());
            break;
          case "application/octet-stream":
            A = await Z.arrayBuffer();
            break;
          case "multipart/form-data":
            A = {};
            const M = await Z.formData();
            for (let N of M.keys()) {
              if (A[N])
                continue;
              const F = M.getAll(N);
              if (F.length === 1)
                A[N] = F[0];
              else
                A[N] = F;
            }
            break;
        }
      else {
        let M = Z.headers.get("content-type");
        if (M) {
          const N = M.indexOf(";");
          if (N !== -1)
            M = M.slice(0, N);
          for (let F = 0;F < G.parse.length; F++) {
            let V = G.parse[F](W, M);
            if (V instanceof Promise)
              V = await V;
            if (V) {
              A = V;
              break;
            }
          }
          if (A === undefined)
            switch (M) {
              case "application/json":
                A = await Z.json();
                break;
              case "text/plain":
                A = await Z.text();
                break;
              case "application/x-www-form-urlencoded":
                A = u02.parse(await Z.text());
                break;
              case "application/octet-stream":
                A = await Z.arrayBuffer();
                break;
              case "multipart/form-data":
                A = {};
                const F = await Z.formData();
                for (let V of F.keys()) {
                  if (A[V])
                    continue;
                  const D = F.getAll(V);
                  if (D.length === 1)
                    A[V] = D[0];
                  else
                    A[V] = D;
                }
                break;
            }
        }
      }
    W.body = A, W.params = B?.params || undefined, W.query = Y === -1 ? {} : u02.parse(J.substring(Y + 1)), W.headers = {};
    for (let [M, N] of Z.headers.entries())
      W.headers[M] = N;
    const z = U?.cookie?.schema;
    W.cookie = await g02(W.set, W.headers.cookie, z ? { secret: z.secrets !== undefined ? typeof z.secrets === "string" ? z.secrets : z.secrets.join(",") : undefined, sign: z.sign === true ? true : z.sign !== undefined ? typeof z.sign === "string" ? z.sign : z.sign.join(",") : undefined } : undefined);
    for (let M = 0;M < G.transform.length; M++) {
      const N = G.transform[M](W);
      if (G.transform[M].$elysia === "derive")
        if (N instanceof Promise)
          Object.assign(W, await N);
        else
          Object.assign(W, N);
      else if (N instanceof Promise)
        await N;
    }
    if (U) {
      if (U.headers) {
        const M = {};
        for (let N in Z.headers)
          M[N] = Z.headers.get(N);
        if (U.headers.Check(M) === false)
          throw new q2("header", U.headers, M);
      }
      if (U.params?.Check(W.params) === false)
        throw new q2("params", U.params, W.params);
      if (U.query?.Check(W.query) === false)
        throw new q2("query", U.query, W.query);
      if (U.cookie) {
        const M = {};
        for (let [N, F] of Object.entries(W.cookie))
          M[N] = F.value;
        if (U.cookie?.Check(M) === false)
          throw new q2("cookie", U.cookie, M);
      }
      if (U.body?.Check(A) === false)
        throw new q2("body", U.body, A);
    }
    for (let M = 0;M < G.beforeHandle.length; M++) {
      let N = G.beforeHandle[M](W);
      if (N instanceof Promise)
        N = await N;
      if (N !== undefined) {
        W.response = N;
        for (let V = 0;V < G.afterHandle.length; V++) {
          let D = G.afterHandle[V](W);
          if (D instanceof Promise)
            D = await D;
          if (D)
            N = D;
        }
        const F = y2(N, W.set);
        if (F)
          return F;
      }
    }
    let P = K(W);
    if (P instanceof Promise)
      P = await P;
    if (!G.afterHandle.length) {
      const M = U?.response?.[P.status];
      if (M?.Check(P) === false)
        throw new q2("response", M, P);
    } else {
      W.response = P;
      for (let M = 0;M < G.afterHandle.length; M++) {
        let N = G.afterHandle[M](W);
        if (N instanceof Promise)
          N = await N;
        const F = y2(N, W.set);
        if (F !== undefined) {
          const V = U?.response?.[P.status];
          if (V?.Check(F) === false)
            throw new q2("response", V, F);
          return F;
        }
      }
    }
    if (W.set.cookie && z?.sign) {
      const M = !z.secrets ? undefined : typeof z.secrets === "string" ? z.secrets : z.secrets[0];
      if (z.sign === true)
        for (let [N, F] of Object.entries(W.set.cookie))
          W.set.cookie[N].value = await B02(F.value, "${secret}");
      else
        for (let N of z.sign) {
          if (!(N in z.properties))
            continue;
          if (W.set.cookie[N]?.value)
            W.set.cookie[N].value = await B02(W.set.cookie[N].value, M);
        }
    }
    return v2(P, W.set);
  } catch (B) {
    if (B.status)
      X.status = B.status;
    return $.handleError(W, B);
  } finally {
    for (let B of $.event.onResponse)
      await B(W);
  }
};
var s12 = ($) => async (Z, X) => {
  const W = Object.assign(Z, { error: X, code: X.code });
  W.set = Z.set;
  for (let J = 0;J < $.event.error.length; J++) {
    let Q = $.event.error[J](W);
    if (Q instanceof Promise)
      Q = await Q;
    if (Q !== undefined && Q !== null)
      return v2(Q, Z.set);
  }
  return new Response(typeof X.cause === "string" ? X.cause : X.message, { headers: Z.set.headers, status: X.status ?? 500 });
};
var R2 = Object.assign({}, Type2);
try {
  TypeSystem2.Format("email", ($) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test($)), TypeSystem2.Format("uuid", ($) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test($)), TypeSystem2.Format("date", ($) => !Number.isNaN(new Date($).getTime())), TypeSystem2.Format("date-time", ($) => !Number.isNaN(new Date($).getTime()));
} catch {
}
var o12 = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var G12 = ($, Z) => {
  if (!(Z instanceof Blob))
    return false;
  if ($.minSize && Z.size < o12($.minSize))
    return false;
  if ($.maxSize && Z.size > o12($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!Z.type.startsWith($.extension))
        return false;
    } else {
      for (let X = 0;X < $.extension.length; X++)
        if (Z.type.startsWith($.extension[X]))
          return true;
      return false;
    }
  return true;
};
var L$2 = TypeSystem2.Type("Files", ($, Z) => {
  if (!Array.isArray(Z))
    return G12($, Z);
  if ($.minItems && Z.length < $.minItems)
    return false;
  if ($.maxItems && Z.length > $.maxItems)
    return false;
  for (let X = 0;X < Z.length; X++)
    if (!G12($, Z[X]))
      return false;
  return true;
});
exports_format2.Set("numeric", ($) => !!$ && !isNaN(+$));
exports_format2.Set("boolean", ($) => $ === "true" || $ === "false");
exports_format2.Set("ObjectString", ($) => {
  let Z = $.charCodeAt(0);
  if (Z === 9 || Z === 10 || Z === 32)
    Z = $.trimStart().charCodeAt(0);
  if (Z !== 123 && Z !== 91)
    return false;
  try {
    return JSON.parse($), true;
  } catch {
    return false;
  }
});
var a2 = { Numeric: ($) => {
  const Z = Type2.Number($);
  return R2.Transform(R2.Union([R2.String({ format: "numeric", default: 0 }), R2.Number($)], $)).Decode((X) => {
    const W = +X;
    if (isNaN(W))
      return X;
    if ($ && !exports_value5.Check(Z, W))
      throw new q2("property", Z, W);
    return W;
  }).Encode((X) => X);
}, BooleanString: ($) => {
  const Z = Type2.Boolean($);
  return R2.Transform(R2.Union([R2.String({ format: "boolean", default: false }), R2.Boolean($)], $)).Decode((X) => {
    if (typeof X === "string")
      return X === "true";
    if ($ && !exports_value5.Check(Z, X))
      throw new q2("property", Z, X);
    return X;
  }).Encode((X) => X);
}, ObjectString: ($, Z) => R2.Transform(R2.Union([R2.String({ format: "ObjectString", default: "" }), R2.Object($, Z)], Z)).Decode((X) => {
  if (typeof X === "string")
    try {
      return JSON.parse(X);
    } catch {
      return X;
    }
  return X;
}).Encode((X) => JSON.stringify(X)), File: TypeSystem2.Type("File", G12), Files: ($ = {}) => R2.Transform(R2.Union([L$2($)])).Decode((Z) => {
  if (Array.isArray(Z))
    return Z;
  return [Z];
}).Encode((Z) => Z), Nullable: ($) => R2.Union([R2.Null(), $]), MaybeEmpty: ($) => R2.Union([R2.Null(), R2.Undefined(), $]), Cookie: ($, Z) => R2.Object($, Z) };
R2.BooleanString = a2.BooleanString;
R2.ObjectString = a2.ObjectString;
R2.Numeric = a2.Numeric;
R2.File = ($ = {}) => a2.File({ default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
R2.Files = ($ = {}) => a2.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });
R2.Nullable = ($) => a2.Nullable($);
R2.MaybeEmpty = a2.MaybeEmpty;
R2.Cookie = a2.Cookie;

class n2 {
  config;
  dependencies = {};
  store = {};
  decorators = {};
  definitions = { type: {}, error: {} };
  schema = {};
  macros = [];
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], mapResponse: [], onResponse: [], trace: [], error: [], stop: [] };
  reporter = new F12;
  server = null;
  getServer() {
    return this.server;
  }
  validator = null;
  router = new o2;
  wsRouter = new o2;
  routes = [];
  staticRouter = { handlers: [], variables: "", map: {}, all: "" };
  wsPaths = {};
  dynamicRouter = new o2;
  lazyLoadModules = [];
  path = "";
  stack = undefined;
  constructor($) {
    if (this.config = { forceErrorEncapsulation: true, prefix: "", aot: true, strictPath: false, scoped: false, cookie: {}, analytic: false, ...$ || {}, seed: $?.seed === undefined ? "" : $?.seed }, $?.analytic && ($?.name || $?.seed !== undefined))
      this.stack = new Error().stack;
  }
  add($, Z, X, W, { allowMeta: J = false, skipPrefix: Q = false } = { allowMeta: false, skipPrefix: false }) {
    if (typeof Z === "string")
      Z = [Z];
    for (let Y of Z) {
      if (Y = Y === "" ? Y : Y.charCodeAt(0) === 47 ? Y : `/${Y}`, this.config.prefix && !Q && !this.config.scoped)
        Y = this.config.prefix + Y;
      if (W?.type)
        switch (W.type) {
          case "text":
            W.type = "text/plain";
            break;
          case "json":
            W.type = "application/json";
            break;
          case "formdata":
            W.type = "multipart/form-data";
            break;
          case "urlencoded":
            W.type = "application/x-www-form-urlencoded";
            break;
          case "arrayBuffer":
            W.type = "application/octet-stream";
            break;
          default:
            break;
        }
      const _ = this.definitions.type;
      let B = p2(W?.cookie ?? this.validator?.cookie, { dynamic: !this.config.aot, models: _, additionalProperties: true });
      if (u2(this.config.cookie ?? {}))
        if (B)
          B.schema = R12(B.schema, this.config.cookie ?? {});
        else
          B = p2(R2.Cookie({}, this.config.cookie), { dynamic: !this.config.aot, models: _, additionalProperties: true });
      const K = { body: p2(W?.body ?? this.validator?.body, { dynamic: !this.config.aot, models: _ }), headers: p2(W?.headers ?? this.validator?.headers, { dynamic: !this.config.aot, models: _, additionalProperties: true }), params: p2(W?.params ?? this.validator?.params, { dynamic: !this.config.aot, models: _ }), query: p2(W?.query ?? this.validator?.query, { dynamic: !this.config.aot, models: _ }), cookie: B, response: s02(W?.response ?? this.validator?.response, { dynamic: !this.config.aot, models: _ }) }, G = this.event, U = Y.endsWith("/") ? Y.slice(0, Y.length - 1) : Y + "/";
      if (this.macros.length) {
        const M = (F) => (V, D) => {
          if (typeof V === "function" || Array.isArray(V)) {
            if (!W[F])
              W[F] = [];
            if (typeof W[F] === "function")
              W[F] = [W[F]];
            if (Array.isArray(V))
              W[F] = W[F].concat(V);
            else
              W[F].push(V);
            return;
          }
          const { insert: m = "after", stack: V0 = "local" } = V;
          if (V0 === "global") {
            if (!Array.isArray(D))
              if (m === "before")
                G[F].unshift(D);
              else
                G[F].push(D);
            else if (m === "before")
              G[F] = D.concat(G[F]);
            else
              G[F] = G[F].concat(D);
            return;
          } else {
            if (!W[F])
              W[F] = [];
            if (typeof W[F] === "function")
              W[F] = [W[F]];
            if (!Array.isArray(D))
              if (m === "before")
                W[F].unshift(D);
              else
                W[F].push(D);
            else if (m === "before")
              W[F] = D.concat(W[F]);
            else
              W[F] = W[F].concat(D);
            return;
          }
        }, N = { events: { global: G, local: W }, onParse: M("parse"), onTransform: M("transform"), onBeforeHandle: M("beforeHandle"), onAfterHandle: M("afterHandle"), onResponse: M("onResponse"), onError: M("error") };
        for (let F of this.macros)
          o02(F(N), W);
      }
      const w = s2(G, W), A = typeof X === "function";
      if (this.config.aot === false) {
        if (this.dynamicRouter.add($, Y, { validator: K, hooks: w, content: W?.type, handle: X }), this.config.strictPath === false)
          this.dynamicRouter.add($, U, { validator: K, hooks: w, content: W?.type, handle: X });
        this.routes.push({ method: $, path: Y, composed: null, handler: X, hooks: w });
        return;
      }
      const z = t12({ path: Y, method: $, hooks: w, validator: K, handler: X, handleError: this.handleError, onRequest: this.event.request, config: this.config, definitions: J ? this.definitions.type : undefined, schema: J ? this.schema : undefined, getReporter: () => this.reporter, setHeader: this.setHeaders });
      if (!A) {
        const M = Object.assign({ headers: {}, query: {}, params: {}, body: undefined, request: new Request(`http://localhost${Y}`), store: this.store, path: Y, set: { headers: this.setHeaders ?? {}, status: 200 } }, this.decorators);
        let N;
        for (let F of Object.values(w.request))
          try {
            const V = y2(F(M), M.set);
            if (V !== undefined) {
              N = V;
              break;
            }
          } catch (V) {
            N = this.handleError(M, V);
            break;
          }
        if (N)
          z.response = N;
        else
          try {
            z.response = z(M);
          } catch (F) {
            z.response = this.handleError(M, F);
          }
      }
      const P = this.routes.findIndex((M) => M.path === Y && M.method === $);
      if (P !== -1)
        this.routes.splice(P, 1);
      if (this.routes.push({ method: $, path: Y, composed: z, handler: X, hooks: w }), $ === "$INTERNALWS") {
        const M = this.config.strictPath ? undefined : Y.endsWith("/") ? Y.slice(0, Y.length - 1) : Y + "/";
        if (Y.indexOf(":") === -1 && Y.indexOf("*") === -1) {
          const N = this.staticRouter.handlers.length;
          if (this.staticRouter.handlers.push(z), z.response instanceof Response)
            this.staticRouter.variables += `const st${N} = staticRouter.handlers[${N}].response\n`;
          else
            this.staticRouter.variables += `const st${N} = staticRouter.handlers[${N}]\n`;
          if (this.wsPaths[Y] = N, M)
            this.wsPaths[M] = N;
        } else if (this.wsRouter.add("ws", Y, z), M)
          this.wsRouter.add("ws", M, z);
        return;
      }
      if (Y.indexOf(":") === -1 && Y.indexOf("*") === -1) {
        const M = this.staticRouter.handlers.length;
        if (this.staticRouter.handlers.push(z), z.response instanceof Response)
          this.staticRouter.variables += `const st${M} = staticRouter.handlers[${M}].response\n`;
        else
          this.staticRouter.variables += `const st${M} = staticRouter.handlers[${M}]\n`;
        if (!this.staticRouter.map[Y])
          this.staticRouter.map[Y] = { code: "" };
        if ($ === "ALL")
          this.staticRouter.map[Y].all = `default: return st${M}(ctx)\n`;
        else if (z.response instanceof Response)
          this.staticRouter.map[Y].code = `case '${$}': return st${M}.clone()\n${this.staticRouter.map[Y].code}`;
        else
          this.staticRouter.map[Y].code = `case '${$}': return st${M}(ctx)\n${this.staticRouter.map[Y].code}`;
        if (!this.config.strictPath) {
          if (!this.staticRouter.map[U])
            this.staticRouter.map[U] = { code: "" };
          if ($ === "ALL")
            this.staticRouter.map[U].all = `default: return st${M}(ctx)\n`;
          else if (z.response instanceof Response)
            this.staticRouter.map[U].code = `case '${$}': return st${M}.clone()\n${this.staticRouter.map[U].code}`;
          else
            this.staticRouter.map[U].code = `case '${$}': return st${M}(ctx)\n${this.staticRouter.map[U].code}`;
        }
      } else if (this.router.add($, Y, z), !this.config.strictPath)
        this.router.add($, Y.endsWith("/") ? Y.slice(0, Y.length - 1) : Y + "/", z);
    }
  }
  setHeaders;
  headers($) {
    if (!$)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    return this.setHeaders = d2(this.setHeaders, $), this;
  }
  onStart($) {
    return this.on("start", $), this;
  }
  onRequest($) {
    return this.on("request", $), this;
  }
  onParse($) {
    return this.on("parse", $), this;
  }
  onTransform($) {
    return this.on("transform", $), this;
  }
  resolve($) {
    return $.$elysia = "resolve", this.onBeforeHandle($);
  }
  onBeforeHandle($) {
    return this.on("beforeHandle", $), this;
  }
  onAfterHandle($) {
    return this.on("afterHandle", $), this;
  }
  mapResponse($) {
    return this.on("mapResponse", $), this;
  }
  onResponse($) {
    return this.on("response", $), this;
  }
  trace($) {
    return this.reporter.on("event", j12(() => this.reporter, this.event.trace.length, $)), this.on("trace", $), this;
  }
  error($, Z) {
    switch (typeof $) {
      case "string":
        return Z.prototype[_02] = $, this.definitions.error[$] = Z, this;
      case "function":
        return this.definitions.error = $(this.definitions.error), this;
    }
    for (let [X, W] of Object.entries($))
      W.prototype[_02] = X, this.definitions.error[X] = W;
    return this;
  }
  onError($) {
    return this.on("error", $), this;
  }
  onStop($) {
    return this.on("stop", $), this;
  }
  on($, Z) {
    for (let X of Array.isArray(Z) ? Z : [Z])
      switch (X = C12(X), $) {
        case "start":
          this.event.start.push(X);
          break;
        case "request":
          this.event.request.push(X);
          break;
        case "parse":
          this.event.parse.splice(this.event.parse.length - 1, 0, X);
          break;
        case "transform":
          this.event.transform.push(X);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(X);
          break;
        case "afterHandle":
          this.event.afterHandle.push(X);
          break;
        case "mapResponse":
          this.event.mapResponse.push(X);
          break;
        case "response":
          this.event.onResponse.push(X);
          break;
        case "trace":
          this.event.trace.push(X);
          break;
        case "error":
          this.event.error.push(X);
          break;
        case "stop":
          this.event.stop.push(X);
          break;
      }
    return this;
  }
  group($, Z, X) {
    const W = new n2({ ...this.config || {}, prefix: "" });
    W.store = this.store, W.definitions = this.definitions, W.getServer = () => this.server;
    const J = typeof Z === "object", Q = (J ? X : Z)(W);
    if (this.decorators = d2(this.decorators, W.decorators), Q.event.request.length)
      this.event.request = [...this.event.request || [], ...Q.event.request || []];
    if (Q.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse || [], ...Q.event.onResponse || []];
    return this.model(Q.definitions.type), Object.values(W.routes).forEach(({ method: Y, path: _, handler: B, hooks: K }) => {
      if (_ = (J ? "" : this.config.prefix) + $ + _, J) {
        const G = Z, U = K;
        this.add(Y, _, B, s2(G, { ...U || {}, error: !U.error ? Q.event.error : Array.isArray(U.error) ? [...U.error || {}, ...Q.event.error || {}] : [U.error, ...Q.event.error || {}] }));
      } else
        this.add(Y, _, B, s2(K, { error: Q.event.error }), { skipPrefix: true });
    }), this;
  }
  guard($, Z) {
    if (!Z)
      return this.event = v02(this.event, $), this.validator = { body: $.body, headers: $.headers, params: $.params, query: $.query, response: $.response }, this;
    const X = new n2({ ...this.config || {}, prefix: "" });
    X.store = this.store, X.definitions = this.definitions;
    const W = Z(X);
    if (this.decorators = d2(this.decorators, X.decorators), W.event.request.length)
      this.event.request = [...this.event.request || [], ...W.event.request || []];
    if (W.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse || [], ...W.event.onResponse || []];
    return this.model(W.definitions.type), Object.values(X.routes).forEach(({ method: J, path: Q, handler: Y, hooks: _ }) => {
      this.add(J, Q, Y, s2($, { ..._ || {}, error: !_.error ? W.event.error : Array.isArray(_.error) ? [..._.error || {}, ...W.event.error || []] : [_.error, ...W.event.error || []] }));
    }), this;
  }
  use($) {
    if ($ instanceof Promise)
      return this.lazyLoadModules.push($.then((Z) => {
        if (typeof Z === "function")
          return Z(this);
        if (typeof Z.default === "function")
          return Z.default(this);
        return this._use(Z);
      }).then((Z) => Z.compile())), this;
    else
      return this._use($);
    return this;
  }
  _use($) {
    if (typeof $ === "function") {
      const J = $(this);
      if (J instanceof Promise)
        return this.lazyLoadModules.push(J.then((Q) => {
          if (Q instanceof n2) {
            this.compile();
            for (let { method: Y, path: _, handler: B, hooks: K } of Object.values(Q.routes))
              this.add(Y, _, B, s2(K, { error: Q.event.error }));
            return Q;
          }
          if (typeof Q === "function")
            return Q(this);
          if (typeof Q.default === "function")
            return Q.default(this);
          return this._use(Q);
        }).then((Q) => Q.compile())), this;
      return J;
    }
    const { name: Z, seed: X } = $.config;
    $.getServer = () => this.getServer(), this.headers($.setHeaders);
    const W = $.config.scoped;
    if (W) {
      if (Z) {
        if (!(Z in this.dependencies))
          this.dependencies[Z] = [];
        const Q = X !== undefined ? N02(Z + JSON.stringify(X)) : 0;
        if (this.dependencies[Z].some(({ checksum: Y }) => Q === Y))
          return this;
        this.dependencies[Z].push(!this.config?.analytic ? { name: $.config.name, seed: $.config.seed, checksum: Q, dependencies: $.dependencies } : { name: $.config.name, seed: $.config.seed, checksum: Q, dependencies: $.dependencies, stack: $.stack, routes: $.routes, decorators: $.decorators, store: $.store, type: $.definitions.type, error: $.definitions.error, derive: $.event.transform.filter((Y) => Y.$elysia === "derive").map((Y) => ({ fn: Y.toString(), stack: new Error().stack ?? "" })), resolve: $.event.transform.filter((Y) => Y.$elysia === "derive").map((Y) => ({ fn: Y.toString(), stack: new Error().stack ?? "" })) });
      }
      if ($.model(this.definitions.type), $.error(this.definitions.error), $.macros = [...this.macros || [], ...$.macros || []], $.onRequest((Q) => {
        Object.assign(Q, this.decorators), Object.assign(Q.store, this.store);
      }), $.event.trace = [...this.event.trace || [], ...$.event.trace || []], $.config.aot)
        $.compile();
      if (W && !$.config.prefix)
        console.warn("When using scoped plugins it is recommended to use a prefix, else routing may not work correctly for the second scoped instance");
      let J;
      if (W && $.config.prefix)
        J = this.mount($.config.prefix + "/", $.fetch);
      else
        J = this.mount($.fetch);
      return this.routes = this.routes.concat(J.routes), this;
    } else {
      $.reporter = this.reporter;
      for (let J of $.event.trace)
        this.trace(J);
      if (Z) {
        if (!(Z in this.dependencies))
          this.dependencies[Z] = [];
        const J = X !== undefined ? N02(Z + JSON.stringify(X)) : 0;
        if (!this.dependencies[Z].some(({ checksum: Y }) => J === Y))
          this.macros.push(...$.macros || []);
        const Q = [];
        for (let Y = 0;Y < this.macros.length; Y++) {
          const _ = this.macros[Y];
          if (Q.includes(_.$elysiaChecksum))
            this.macros.splice(Y, 1), Y--;
          Q.push(_.$elysiaChecksum);
        }
      }
    }
    this.decorate($.decorators), this.state($.store), this.model($.definitions.type), this.error($.definitions.error);
    for (let { method: J, path: Q, handler: Y, hooks: _ } of Object.values($.routes))
      this.add(J, Q, Y, s2(_, { error: $.event.error }));
    if (!W)
      if (Z) {
        if (!(Z in this.dependencies))
          this.dependencies[Z] = [];
        const J = X !== undefined ? N02(Z + JSON.stringify(X)) : 0;
        if (this.dependencies[Z].some(({ checksum: Q }) => J === Q))
          return this;
        this.dependencies[Z].push(!this.config?.analytic ? { name: $.config.name, seed: $.config.seed, checksum: J, dependencies: $.dependencies } : { name: $.config.name, seed: $.config.seed, checksum: J, dependencies: $.dependencies, stack: $.stack, routes: $.routes, decorators: $.decorators, store: $.store, type: $.definitions.type, error: $.definitions.error, derive: $.event.transform.filter((Q) => Q?.$elysia === "derive").map((Q) => ({ fn: Q.toString(), stack: new Error().stack ?? "" })), resolve: $.event.transform.filter((Q) => Q?.$elysia === "resolve").map((Q) => ({ fn: Q.toString(), stack: new Error().stack ?? "" })) }), this.event = v02(this.event, a02($.event), J);
      } else
        this.event = v02(this.event, a02($.event));
    return this;
  }
  macro($) {
    return $.$elysiaChecksum = N02(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: $.toString() })), this.macros.push($), this;
  }
  mount($, Z) {
    if ($ instanceof n2 || typeof $ === "function" || $.length === 0 || $ === "/") {
      const J = typeof $ === "function" ? $ : $ instanceof n2 ? $.compile().fetch : Z instanceof n2 ? Z.compile().fetch : Z, Q = async ({ request: Y, path: _ }) => J(new Request(t02(Y.url, _ || "/"), Y));
      return this.all("/", Q, { type: "none" }), this.all("/*", Q, { type: "none" }), this;
    }
    const X = $.length;
    if (Z instanceof n2)
      Z = Z.compile().fetch;
    const W = async ({ request: J, path: Q }) => Z(new Request(t02(J.url, Q.slice(X) || "/"), J));
    return this.all($, W, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), W, { type: "none" }), this;
  }
  get($, Z, X) {
    return this.add("GET", $, Z, X), this;
  }
  post($, Z, X) {
    return this.add("POST", $, Z, X), this;
  }
  put($, Z, X) {
    return this.add("PUT", $, Z, X), this;
  }
  patch($, Z, X) {
    return this.add("PATCH", $, Z, X), this;
  }
  delete($, Z, X) {
    return this.add("DELETE", $, Z, X), this;
  }
  options($, Z, X) {
    return this.add("OPTIONS", $, Z, X), this;
  }
  all($, Z, X) {
    return this.add("ALL", $, Z, X), this;
  }
  head($, Z, X) {
    return this.add("HEAD", $, Z, X), this;
  }
  connect($, Z, X) {
    return this.add("CONNECT", $, Z, X), this;
  }
  ws($, Z) {
    const X = Z.transformMessage ? Array.isArray(Z.transformMessage) ? Z.transformMessage : [Z.transformMessage] : undefined;
    let W = null;
    const J = p2(Z?.body, { models: this.definitions.type }), Q = p2(Z?.response, { models: this.definitions.type }), Y = (_) => {
      if (typeof _ === "string") {
        const B = _?.charCodeAt(0);
        if (B === 47 || B === 123)
          try {
            _ = JSON.parse(_);
          } catch {
          }
        else if (f02(_))
          _ = +_;
      }
      if (X?.length)
        for (let B = 0;B < X.length; B++) {
          const K = X[B](_);
          if (K !== undefined)
            _ = K;
        }
      return _;
    };
    return this.route("$INTERNALWS", $, (_) => {
      const { set: B, path: K, qi: G, headers: U, query: w, params: A } = _;
      if (W === null)
        W = this.getServer();
      if (W?.upgrade(_.request, { headers: typeof Z.upgrade === "function" ? Z.upgrade(_) : Z.upgrade, data: { validator: Q, open(z) {
        Z.open?.(new D02(z, _));
      }, message: (z, P) => {
        const M = Y(P);
        if (J?.Check(M) === false)
          return void z.send(new q2("message", J, M).message);
        Z.message?.(new D02(z, _), M);
      }, drain(z) {
        Z.drain?.(new D02(z, _));
      }, close(z, P, M) {
        Z.close?.(new D02(z, _), P, M);
      } } }))
        return;
      return B.status = 400, "Expected a websocket connection";
    }, { beforeHandle: Z.beforeHandle, transform: Z.transform, headers: Z.headers, params: Z.params, query: Z.query }), this;
  }
  route($, Z, X, { config: W, ...J } = { config: { allowMeta: false } }) {
    return this.add($, Z, X, J, W), this;
  }
  state($, Z) {
    switch (typeof $) {
      case "object":
        return this.store = d2(this.store, $), this;
      case "function":
        return this.store = $(this.store), this;
    }
    if (!($ in this.store))
      this.store[$] = Z;
    return this;
  }
  decorate($, Z) {
    switch (typeof $) {
      case "object":
        return this.decorators = d2(this.decorators, $), this;
      case "function":
        return this.decorators = $(this.decorators), this;
    }
    if (!($ in this.decorators))
      this.decorators[$] = Z;
    return this;
  }
  derive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  model($, Z) {
    switch (typeof $) {
      case "object":
        return Object.entries($).forEach(([X, W]) => {
          if (!(X in this.definitions.type))
            this.definitions.type[X] = W;
        }), this;
      case "function":
        return this.definitions.type = $(this.definitions.type), this;
    }
    return this.definitions.type[$] = Z, this;
  }
  mapDerive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  affix($, Z, X) {
    if (X === "")
      return this;
    const W = ["_", "-", " "], J = (B) => B[0].toUpperCase() + B.slice(1), Q = $ === "prefix" ? (B, K) => W.includes(B.at(-1) ?? "") ? B + K : B + J(K) : W.includes(X.at(-1) ?? "") ? (B, K) => K + B : (B, K) => K + J(B), Y = (B) => {
      const K = {};
      switch (B) {
        case "decorator":
          for (let G in this.decorators)
            K[Q(X, G)] = this.decorators[G];
          this.decorators = K;
          break;
        case "state":
          for (let G in this.store)
            K[Q(X, G)] = this.store[G];
          this.store = K;
          break;
        case "model":
          for (let G in this.definitions.type)
            K[Q(X, G)] = this.definitions.type[G];
          this.definitions.type = K;
          break;
        case "error":
          for (let G in this.definitions.error)
            K[Q(X, G)] = this.definitions.error[G];
          this.definitions.error = K;
          break;
      }
    }, _ = Array.isArray(Z) ? Z : [Z];
    for (let B of _.some((K) => K === "all") ? ["decorator", "state", "model", "error"] : _)
      Y(B);
    return this;
  }
  prefix($, Z) {
    return this.affix("prefix", $, Z);
  }
  suffix($, Z) {
    return this.affix("suffix", $, Z);
  }
  compile() {
    if (this.fetch = this.config.aot ? Q12(this) : _12(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server || {}, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => {
    return (this.fetch = this.config.aot ? Q12(this) : _12(this))($);
  };
  handleError = async ($, Z) => (this.handleError = this.config.aot ? B12(this) : s12(this))($, Z);
  outerErrorHandler = ($) => new Response($.message || $.name || "Error", { status: $?.status ?? 500 });
  listen = ($, Z) => {
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (this.compile(), typeof $ === "string") {
      if ($ = +$.trim(), Number.isNaN($))
        throw new Error("Port must be a numeric value");
    }
    const X = this.fetch, W = typeof $ === "object" ? { development: !F02, reusePort: true, ...this.config.serve || {}, ...$ || {}, websocket: { ...this.config.websocket || {}, ...$12 || {} }, fetch: X, error: this.outerErrorHandler } : { development: !F02, reusePort: true, ...this.config.serve || {}, websocket: { ...this.config.websocket || {}, ...$12 || {} }, port: $, fetch: X, error: this.outerErrorHandler };
    if (this.server = Bun?.serve(W), this.event.start.length)
      for (let J = 0;J < this.event.start.length; J++)
        this.event.start[J](this);
    if (Z)
      Z(this.server);
    return process.on("beforeExit", () => {
      for (let J = 0;J < this.event.stop.length; J++)
        this.event.stop[J](this);
    }), Promise.all(this.lazyLoadModules).then(() => {
      Bun?.gc(false);
    }), this;
  };
  stop = async () => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server.stop(), this.event.stop.length)
      for (let $ = 0;$ < this.event.stop.length; $++)
        this.event.stop[$](this);
  };
  get modules() {
    return Promise.all(this.lazyLoadModules);
  }
}

// ../sisventa/src/helpers/passwd.ts
var import_bcryptjs = __toESM(require_bcrypt(), 1);
var makePasswd = async (passwd) => {
  const salt = await import_bcryptjs.default.genSaltSync(10);
  return await import_bcryptjs.default.hashSync(passwd, salt);
};
var comparePasswd = async (passwd, hash11) => {
  return await import_bcryptjs.default.compareSync(passwd, hash11);
};

// ../sisventa/src/helpers/token.ts
var import_jsonwebtoken = __toESM(require_jsonwebtoken(), 1);
var makeToken = (data, expiresIn) => {
  const token = import_jsonwebtoken.default.sign(data, "018decf5-b523-71f4-98ac-dee2e5a4eb1a", {
    expiresIn
  });
  return token;
};
var verifyToken = async (token, db, option) => {
  try {
    if (option) {
      const f = await db.token.findFirst({
        where: {
          token
        }
      });
      if (!f)
        return false;
    }
    return import_jsonwebtoken.default.verify(token, "018decf5-b523-71f4-98ac-dee2e5a4eb1a");
  } catch (error41) {
    console.log(error41);
    return false;
  }
};

// ../sisventa/node_modules/@react-email/render/dist/index.mjs
init_server_node();

// ../sisventa/node_modules/domelementtype/lib/esm/index.js
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
var Root = ElementType.Root;
var Text = ElementType.Text;
var Directive = ElementType.Directive;
var Comment = ElementType.Comment;
var Script = ElementType.Script;
var Style = ElementType.Style;
var Tag = ElementType.Tag;
var CDATA = ElementType.CDATA;
var Doctype = ElementType.Doctype;

// ../sisventa/node_modules/domhandler/lib/esm/node.js
function isTag2(node) {
  return isTag(node);
}
function isCDATA(node) {
  return node.type === ElementType.CDATA;
}
function isText(node) {
  return node.type === ElementType.Text;
}
function isComment(node) {
  return node.type === ElementType.Comment;
}
function isDirective(node) {
  return node.type === ElementType.Directive;
}
function isDocument(node) {
  return node.type === ElementType.Root;
}
function cloneNode(node, recursive5 = false) {
  let result;
  if (isText(node)) {
    result = new Text2(node.data);
  } else if (isComment(node)) {
    result = new Comment2(node.data);
  } else if (isTag2(node)) {
    const children = recursive5 ? cloneChildren(node.children) : [];
    const clone21 = new Element(node.name, { ...node.attribs }, children);
    children.forEach((child) => child.parent = clone21);
    if (node.namespace != null) {
      clone21.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone21["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
    }
    if (node["x-attribsPrefix"]) {
      clone21["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
    }
    result = clone21;
  } else if (isCDATA(node)) {
    const children = recursive5 ? cloneChildren(node.children) : [];
    const clone21 = new CDATA2(children);
    children.forEach((child) => child.parent = clone21);
    result = clone21;
  } else if (isDocument(node)) {
    const children = recursive5 ? cloneChildren(node.children) : [];
    const clone21 = new Document(children);
    children.forEach((child) => child.parent = clone21);
    if (node["x-mode"]) {
      clone21["x-mode"] = node["x-mode"];
    }
    result = clone21;
  } else if (isDirective(node)) {
    const instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node.type}`);
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
var cloneChildren = function(childs) {
  const children = childs.map((child) => cloneNode(child, true));
  for (let i = 1;i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
};

class Node {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent) {
    this.parent = parent;
  }
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev) {
    this.prev = prev;
  }
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next) {
    this.next = next;
  }
  cloneNode(recursive5 = false) {
    return cloneNode(this, recursive5);
  }
}

class DataNode extends Node {
  constructor(data) {
    super();
    this.data = data;
  }
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data) {
    this.data = data;
  }
}

class Text2 extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
}

class Comment2 extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
}

class ProcessingInstruction extends DataNode {
  constructor(name, data) {
    super(data);
    this.name = name;
    this.type = ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
}

class NodeWithChildren extends Node {
  constructor(children) {
    super();
    this.children = children;
  }
  get firstChild() {
    var _a;
    return (_a = this.children[0]) !== null && _a !== undefined ? _a : null;
  }
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  get childNodes() {
    return this.children;
  }
  set childNodes(children) {
    this.children = children;
  }
}

class CDATA2 extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
}

class Document extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
}

class Element extends NodeWithChildren {
  constructor(name, attribs, children = [], type145 = name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag) {
    super(children);
    this.name = name;
    this.attribs = attribs;
    this.type = type145;
  }
  get nodeType() {
    return 1;
  }
  get tagName() {
    return this.name;
  }
  set tagName(name) {
    this.name = name;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name) => {
      var _a, _b;
      return {
        name,
        value: this.attribs[name],
        namespace: (_a = this["x-attribsNamespace"]) === null || _a === undefined ? undefined : _a[name],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === undefined ? undefined : _b[name]
      };
    });
  }
}

// ../sisventa/node_modules/domhandler/lib/esm/index.js
var defaultOpts = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};

class DomHandler {
  constructor(callback, options, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = undefined;
    }
    this.callback = callback !== null && callback !== undefined ? callback : null;
    this.options = options !== null && options !== undefined ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== undefined ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error41) {
    this.handleCallback(error41);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name, attribs) {
    const type145 = this.options.xmlMode ? ElementType.Tag : undefined;
    const element = new Element(name, attribs, undefined, type145);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node3 = new Text2(data);
      this.addNode(node3);
      this.lastNode = node3;
    }
  }
  oncomment(data) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }
    const node3 = new Comment2(data);
    this.addNode(node3);
    this.lastNode = node3;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text = new Text2("");
    const node3 = new CDATA2([text]);
    this.addNode(node3);
    text.parent = node3;
    this.lastNode = text;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name, data) {
    const node3 = new ProcessingInstruction(name, data);
    this.addNode(node3);
  }
  handleCallback(error41) {
    if (typeof this.callback === "function") {
      this.callback(error41, this.dom);
    } else if (error41) {
      throw error41;
    }
  }
  addNode(node3) {
    const parent = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent.children[parent.children.length - 1];
    if (this.options.withStartIndices) {
      node3.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node3.endIndex = this.parser.endIndex;
    }
    parent.children.push(node3);
    if (previousSibling) {
      node3.prev = previousSibling;
      previousSibling.next = node3;
    }
    node3.parent = parent;
    this.lastNode = null;
  }
}

// ../sisventa/node_modules/leac/lib/leac.mjs
var n3 = function(n4) {
  const o3 = [...n4.matchAll(e3)].map((e3) => e3.index || 0);
  o3.unshift(-1);
  const s4 = t3(o3, 0, o3.length);
  return (e3) => r(s4, e3);
};
var t3 = function(e3, n4, r) {
  if (r - n4 == 1)
    return { offset: e3[n4], index: n4 + 1 };
  const o3 = Math.ceil((n4 + r) / 2), s4 = t3(e3, n4, o3), l4 = t3(e3, o3, r);
  return { offset: s4.offset, low: s4, high: l4 };
};
var r = function(e3, n4) {
  return function(e4) {
    return Object.prototype.hasOwnProperty.call(e4, "index");
  }(e3) ? { line: e3.index, column: n4 - e3.offset } : r(e3.high.offset < n4 ? e3.high : e3.low, n4);
};
var o3 = function(e3, t4 = "", r2 = {}) {
  const o4 = typeof t4 != "string" ? t4 : r2, l4 = typeof t4 == "string" ? t4 : "", c3 = e3.map(s4), f = !!o4.lineNumbers;
  return function(e4, t5 = 0) {
    const r3 = f ? n3(e4) : () => ({ line: 0, column: 0 });
    let o5 = t5;
    const s4 = [];
    e:
      for (;o5 < e4.length; ) {
        let n4 = false;
        for (const t6 of c3) {
          t6.regex.lastIndex = o5;
          const c4 = t6.regex.exec(e4);
          if (c4 && c4[0].length > 0) {
            if (!t6.discard) {
              const e5 = r3(o5), n5 = typeof t6.replace == "string" ? c4[0].replace(new RegExp(t6.regex.source, t6.regex.flags), t6.replace) : c4[0];
              s4.push({ state: l4, name: t6.name, text: n5, offset: o5, len: c4[0].length, line: e5.line, column: e5.column });
            }
            if (o5 = t6.regex.lastIndex, n4 = true, t6.push) {
              const n5 = t6.push(e4, o5);
              s4.push(...n5.tokens), o5 = n5.offset;
            }
            if (t6.pop)
              break e;
            break;
          }
        }
        if (!n4)
          break;
      }
    return { tokens: s4, offset: o5, complete: e4.length <= o5 };
  };
};
var s4 = function(e3, n4) {
  return { ...e3, regex: l4(e3, n4) };
};
var l4 = function(e3, n4) {
  if (e3.name.length === 0)
    throw new Error(`Rule #${n4} has empty name, which is not allowed.`);
  if (function(e4) {
    return Object.prototype.hasOwnProperty.call(e4, "regex");
  }(e3))
    return function(e4) {
      if (e4.global)
        throw new Error(`Regular expression /${e4.source}/${e4.flags} contains the global flag, which is not allowed.`);
      return e4.sticky ? e4 : new RegExp(e4.source, e4.flags + "y");
    }(e3.regex);
  if (function(e4) {
    return Object.prototype.hasOwnProperty.call(e4, "str");
  }(e3)) {
    if (e3.str.length === 0)
      throw new Error(`Rule #${n4} ("${e3.name}") has empty "str" property, which is not allowed.`);
    return new RegExp(c3(e3.str), "y");
  }
  return new RegExp(c3(e3.name), "y");
};
var c3 = function(e3) {
  return e3.replace(/[-[\]{}()*+!<=:?./\\^$|#\s,]/g, "\\$&");
};
var e3 = /\n/g;

// ../sisventa/node_modules/peberminta/lib/core.mjs
var token = function(onToken, onEnd) {
  return (data, i) => {
    let position = i;
    let value27 = undefined;
    if (i < data.tokens.length) {
      value27 = onToken(data.tokens[i], data, i);
      if (value27 !== undefined) {
        position++;
      }
    } else {
      onEnd?.(data, i);
    }
    return value27 === undefined ? { matched: false } : {
      matched: true,
      position,
      value: value27
    };
  };
};
var mapInner = function(r2, f) {
  return r2.matched ? {
    matched: true,
    position: r2.position,
    value: f(r2.value, r2.position)
  } : r2;
};
var mapOuter = function(r2, f) {
  return r2.matched ? f(r2) : r2;
};
var map5 = function(p3, mapper) {
  return (data, i) => mapInner(p3(data, i), (v3, j) => mapper(v3, data, i, j));
};
var option = function(p3, def) {
  return (data, i) => {
    const r2 = p3(data, i);
    return r2.matched ? r2 : {
      matched: true,
      position: i,
      value: def
    };
  };
};
var choice = function(...ps) {
  return (data, i) => {
    for (const p3 of ps) {
      const result = p3(data, i);
      if (result.matched) {
        return result;
      }
    }
    return { matched: false };
  };
};
var otherwise = function(pa, pb) {
  return (data, i) => {
    const r13 = pa(data, i);
    return r13.matched ? r13 : pb(data, i);
  };
};
var takeWhile = function(p3, test) {
  return (data, i) => {
    const values = [];
    let success = true;
    do {
      const r2 = p3(data, i);
      if (r2.matched && test(r2.value, values.length + 1, data, i, r2.position)) {
        values.push(r2.value);
        i = r2.position;
      } else {
        success = false;
      }
    } while (success);
    return {
      matched: true,
      position: i,
      value: values
    };
  };
};
var many = function(p3) {
  return takeWhile(p3, () => true);
};
var many1 = function(p3) {
  return ab(p3, many(p3), (head, tail) => [head, ...tail]);
};
var ab = function(pa, pb, join2) {
  return (data, i) => mapOuter(pa(data, i), (ma) => mapInner(pb(data, ma.position), (vb, j) => join2(ma.value, vb, data, i, j)));
};
var left = function(pa, pb) {
  return ab(pa, pb, (va) => va);
};
var right = function(pa, pb) {
  return ab(pa, pb, (va, vb) => vb);
};
var abc = function(pa, pb, pc, join2) {
  return (data, i) => mapOuter(pa(data, i), (ma) => mapOuter(pb(data, ma.position), (mb) => mapInner(pc(data, mb.position), (vc, j) => join2(ma.value, mb.value, vc, data, i, j))));
};
var middle = function(pa, pb, pc) {
  return abc(pa, pb, pc, (ra, rb) => rb);
};
var all = function(...ps) {
  return (data, i) => {
    const result = [];
    let position = i;
    for (const p3 of ps) {
      const r13 = p3(data, position);
      if (r13.matched) {
        result.push(r13.value);
        position = r13.position;
      } else {
        return { matched: false };
      }
    }
    return {
      matched: true,
      position,
      value: result
    };
  };
};
var flatten = function(...ps) {
  return flatten1(all(...ps));
};
var flatten1 = function(p3) {
  return map5(p3, (vs) => vs.flatMap((v3) => v3));
};
var chainReduce = function(acc, f) {
  return (data, i) => {
    let loop = true;
    let acc1 = acc;
    let pos = i;
    do {
      const r2 = f(acc1, data, pos)(data, pos);
      if (r2.matched) {
        acc1 = r2.value;
        pos = r2.position;
      } else {
        loop = false;
      }
    } while (loop);
    return {
      matched: true,
      position: pos,
      value: acc1
    };
  };
};
var reduceLeft = function(acc, p3, reducer) {
  return chainReduce(acc, (acc2) => map5(p3, (v3, data, i, j) => reducer(acc2, v3, data, i, j)));
};
var leftAssoc2 = function(pLeft, pOper, pRight) {
  return chain(pLeft, (v03) => reduceLeft(v03, ab(pOper, pRight, (f, y3) => [f, y3]), (acc, [f, y3]) => f(acc, y3)));
};
var chain = function(p3, f) {
  return (data, i) => mapOuter(p3(data, i), (m1) => f(m1.value, data, i, m1.position)(data, m1.position));
};

// ../sisventa/node_modules/parseley/lib/parseley.mjs
var sumSpec = function([a03, a1, a22], [b03, b1, b22]) {
  return [a03 + b03, a1 + b1, a22 + b22];
};
var sumAllSpec = function(ss) {
  return ss.reduce(sumSpec, [0, 0, 0]);
};
var unescape = function(escapedString) {
  const lexerResult = lexEscapedString(escapedString);
  const result = escapedString_({ tokens: lexerResult.tokens, options: undefined }, 0);
  return result.value;
};
var literal25 = function(name) {
  return token((t4) => t4.name === name ? true : undefined);
};
var optionallySpaced = function(parser) {
  return middle(optionalWhitespace_, parser, optionalWhitespace_);
};
var parse_ = function(parser, str) {
  if (!(typeof str === "string" || str instanceof String)) {
    throw new Error("Expected a selector string. Actual input is not a string!");
  }
  const lexerResult = lexSelector(str);
  if (!lexerResult.complete) {
    throw new Error(`The input "${str}" was only partially tokenized, stopped at offset ${lexerResult.offset}!\n` + prettyPrintPosition(str, lexerResult.offset));
  }
  const result = optionallySpaced(parser)({ tokens: lexerResult.tokens, options: undefined }, 0);
  if (!result.matched) {
    throw new Error(`No match for "${str}" input!`);
  }
  if (result.position < lexerResult.tokens.length) {
    const token2 = lexerResult.tokens[result.position];
    throw new Error(`The input "${str}" was only partially parsed, stopped at offset ${token2.offset}!\n` + prettyPrintPosition(str, token2.offset, token2.len));
  }
  return result.value;
};
var prettyPrintPosition = function(str, offset, len = 1) {
  return `${str.replace(/(\t)|(\r)|(\n)/g, (m, t4, r2) => t4 ? "\u2409" : r2 ? "\u240D" : "\u240A")}\n${"".padEnd(offset)}${"^".repeat(len)}`;
};
var parse1 = function(str) {
  return parse_(complexSelector_, str);
};
var serialize = function(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "universal":
      return _serNs(selector.namespace) + "*";
    case "tag":
      return _serNs(selector.namespace) + _serIdent(selector.name);
    case "class":
      return "." + _serIdent(selector.name);
    case "id":
      return "#" + _serIdent(selector.name);
    case "attrPresence":
      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}]`;
    case "attrValue":
      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}${selector.matcher}"${_serStr(selector.value)}"${selector.modifier ? selector.modifier : ""}]`;
    case "combinator":
      return serialize(selector.left) + selector.combinator;
    case "compound":
      return selector.list.reduce((acc, node3) => {
        if (node3.type === "combinator") {
          return serialize(node3) + acc;
        } else {
          return acc + serialize(node3);
        }
      }, "");
    case "list":
      return selector.list.map(serialize).join(",");
  }
};
var _serNs = function(ns) {
  return ns || ns === "" ? _serIdent(ns) + "|" : "";
};
var _codePoint = function(char) {
  return `\\${char.codePointAt(0).toString(16)} `;
};
var _serIdent = function(str) {
  return str.replace(/(^[0-9])|(^-[0-9])|(^-$)|([-0-9a-zA-Z_]|[^\x00-\x7F])|(\x00)|([\x01-\x1f]|\x7f)|([\s\S])/g, (m, d1, d22, hy, safe, nl, ctrl, other) => d1 ? _codePoint(d1) : d22 ? "-" + _codePoint(d22.slice(1)) : hy ? "\\-" : safe ? safe : nl ? "\uFFFD" : ctrl ? _codePoint(ctrl) : "\\" + other);
};
var _serStr = function(str) {
  return str.replace(/(")|(\\)|(\x00)|([\x01-\x1f]|\x7f)/g, (m, dq, bs, nl, ctrl) => dq ? '\\"' : bs ? "\\\\" : nl ? "\uFFFD" : _codePoint(ctrl));
};
var normalize = function(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "compound": {
      selector.list.forEach(normalize);
      selector.list.sort((a3, b3) => _compareArrays(_getSelectorPriority(a3), _getSelectorPriority(b3)));
      break;
    }
    case "combinator": {
      normalize(selector.left);
      break;
    }
    case "list": {
      selector.list.forEach(normalize);
      selector.list.sort((a3, b3) => serialize(a3) < serialize(b3) ? -1 : 1);
      break;
    }
  }
  return selector;
};
var _getSelectorPriority = function(selector) {
  switch (selector.type) {
    case "universal":
      return [1];
    case "tag":
      return [1];
    case "id":
      return [2];
    case "class":
      return [3, selector.name];
    case "attrPresence":
      return [4, serialize(selector)];
    case "attrValue":
      return [5, serialize(selector)];
    case "combinator":
      return [15, serialize(selector)];
  }
};
var compareSpecificity = function(a3, b3) {
  return _compareArrays(a3, b3);
};
var _compareArrays = function(a3, b3) {
  if (!Array.isArray(a3) || !Array.isArray(b3)) {
    throw new Error("Arguments must be arrays.");
  }
  const shorter = a3.length < b3.length ? a3.length : b3.length;
  for (let i = 0;i < shorter; i++) {
    if (a3[i] === b3[i]) {
      continue;
    }
    return a3[i] < b3[i] ? -1 : 1;
  }
  return a3.length - b3.length;
};
var ws = `(?:[ \\t\\r\\n\\f]*)`;
var nl = `(?:\\n|\\r\\n|\\r|\\f)`;
var nonascii = `[^\\x00-\\x7F]`;
var unicode = `(?:\\\\[0-9a-f]{1,6}(?:\\r\\n|[ \\n\\r\\t\\f])?)`;
var escape = `(?:\\\\[^\\n\\r\\f0-9a-f])`;
var nmstart = `(?:[_a-z]|${nonascii}|${unicode}|${escape})`;
var nmchar = `(?:[_a-z0-9-]|${nonascii}|${unicode}|${escape})`;
var name = `(?:${nmchar}+)`;
var ident = `(?:[-]?${nmstart}${nmchar}*)`;
var string1 = `'([^\\n\\r\\f\\\\']|\\\\${nl}|${nonascii}|${unicode}|${escape})*'`;
var string22 = `"([^\\n\\r\\f\\\\"]|\\\\${nl}|${nonascii}|${unicode}|${escape})*"`;
var lexSelector = o3([
  { name: "ws", regex: new RegExp(ws) },
  { name: "hash", regex: new RegExp(`#${name}`, "i") },
  { name: "ident", regex: new RegExp(ident, "i") },
  { name: "str1", regex: new RegExp(string1, "i") },
  { name: "str2", regex: new RegExp(string22, "i") },
  { name: "*" },
  { name: "." },
  { name: "," },
  { name: "[" },
  { name: "]" },
  { name: "=" },
  { name: ">" },
  { name: "|" },
  { name: "+" },
  { name: "~" },
  { name: "^" },
  { name: "$" }
]);
var lexEscapedString = o3([
  { name: "unicode", regex: new RegExp(unicode, "i") },
  { name: "escape", regex: new RegExp(escape, "i") },
  { name: "any", regex: new RegExp("[\\s\\S]", "i") }
]);
var unicodeEscapedSequence_ = token((t4) => t4.name === "unicode" ? String.fromCodePoint(parseInt(t4.text.slice(1), 16)) : undefined);
var escapedSequence_ = token((t4) => t4.name === "escape" ? t4.text.slice(1) : undefined);
var anyChar_ = token((t4) => t4.name === "any" ? t4.text : undefined);
var escapedString_ = map5(many(choice(unicodeEscapedSequence_, escapedSequence_, anyChar_)), (cs) => cs.join(""));
var whitespace_ = token((t4) => t4.name === "ws" ? null : undefined);
var optionalWhitespace_ = option(whitespace_, null);
var identifier_ = token((t4) => t4.name === "ident" ? unescape(t4.text) : undefined);
var hashId_ = token((t4) => t4.name === "hash" ? unescape(t4.text.slice(1)) : undefined);
var string_ = token((t4) => t4.name.startsWith("str") ? unescape(t4.text.slice(1, -1)) : undefined);
var namespace_ = left(option(identifier_, ""), literal25("|"));
var qualifiedName_ = otherwise(ab(namespace_, identifier_, (ns, name2) => ({ name: name2, namespace: ns })), map5(identifier_, (name2) => ({ name: name2, namespace: null })));
var uniSelector_ = otherwise(ab(namespace_, literal25("*"), (ns) => ({ type: "universal", namespace: ns, specificity: [0, 0, 0] })), map5(literal25("*"), () => ({ type: "universal", namespace: null, specificity: [0, 0, 0] })));
var tagSelector_ = map5(qualifiedName_, ({ name: name2, namespace }) => ({
  type: "tag",
  name: name2,
  namespace,
  specificity: [0, 0, 1]
}));
var classSelector_ = ab(literal25("."), identifier_, (fullstop, name2) => ({
  type: "class",
  name: name2,
  specificity: [0, 1, 0]
}));
var idSelector_ = map5(hashId_, (name2) => ({
  type: "id",
  name: name2,
  specificity: [1, 0, 0]
}));
var attrModifier_ = token((t4) => {
  if (t4.name === "ident") {
    if (t4.text === "i" || t4.text === "I") {
      return "i";
    }
    if (t4.text === "s" || t4.text === "S") {
      return "s";
    }
  }
  return;
});
var attrValue_ = otherwise(ab(string_, option(right(optionalWhitespace_, attrModifier_), null), (v3, mod) => ({ value: v3, modifier: mod })), ab(identifier_, option(right(whitespace_, attrModifier_), null), (v3, mod) => ({ value: v3, modifier: mod })));
var attrMatcher_ = choice(map5(literal25("="), () => "="), ab(literal25("~"), literal25("="), () => "~="), ab(literal25("|"), literal25("="), () => "|="), ab(literal25("^"), literal25("="), () => "^="), ab(literal25("$"), literal25("="), () => "$="), ab(literal25("*"), literal25("="), () => "*="));
var attrPresenceSelector_ = abc(literal25("["), optionallySpaced(qualifiedName_), literal25("]"), (lbr, { name: name2, namespace }) => ({
  type: "attrPresence",
  name: name2,
  namespace,
  specificity: [0, 1, 0]
}));
var attrValueSelector_ = middle(literal25("["), abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name: name2, namespace }, matcher, { value: value27, modifier }) => ({
  type: "attrValue",
  name: name2,
  namespace,
  matcher,
  value: value27,
  modifier,
  specificity: [0, 1, 0]
})), literal25("]"));
var attrSelector_ = otherwise(attrPresenceSelector_, attrValueSelector_);
var typeSelector_ = otherwise(uniSelector_, tagSelector_);
var subclassSelector_ = choice(idSelector_, classSelector_, attrSelector_);
var compoundSelector_ = map5(otherwise(flatten(typeSelector_, many(subclassSelector_)), many1(subclassSelector_)), (ss) => {
  return {
    type: "compound",
    list: ss,
    specificity: sumAllSpec(ss.map((s5) => s5.specificity))
  };
});
var combinator_ = choice(map5(literal25(">"), () => ">"), map5(literal25("+"), () => "+"), map5(literal25("~"), () => "~"), ab(literal25("|"), literal25("|"), () => "||"));
var combinatorSeparator_ = otherwise(optionallySpaced(combinator_), map5(whitespace_, () => " "));
var complexSelector_ = leftAssoc2(compoundSelector_, map5(combinatorSeparator_, (c4) => (left2, right2) => ({
  type: "compound",
  list: [...right2.list, { type: "combinator", combinator: c4, left: left2, specificity: left2.specificity }],
  specificity: sumSpec(left2.specificity, right2.specificity)
})), compoundSelector_);
var listSelector_ = leftAssoc2(map5(complexSelector_, (s5) => ({ type: "list", list: [s5] })), map5(optionallySpaced(literal25(",")), () => (acc, next) => ({ type: "list", list: [...acc.list, next] })), complexSelector_);

// ../sisventa/node_modules/selderee/lib/selderee.mjs
var toAstTerminalPairs = function(array7) {
  const len = array7.length;
  const results = new Array(len);
  for (let i = 0;i < len; i++) {
    const [selectorString, val] = array7[i];
    const ast = preprocess(parse1(selectorString));
    results[i] = {
      ast,
      terminal: {
        type: "terminal",
        valueContainer: { index: i, value: val, specificity: ast.specificity }
      }
    };
  }
  return results;
};
var preprocess = function(ast) {
  reduceSelectorVariants(ast);
  normalize(ast);
  return ast;
};
var reduceSelectorVariants = function(ast) {
  const newList = [];
  ast.list.forEach((sel) => {
    switch (sel.type) {
      case "class":
        newList.push({
          matcher: "~=",
          modifier: null,
          name: "class",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "id":
        newList.push({
          matcher: "=",
          modifier: null,
          name: "id",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "combinator":
        reduceSelectorVariants(sel.left);
        newList.push(sel);
        break;
      case "universal":
        break;
      default:
        newList.push(sel);
        break;
    }
  });
  ast.list = newList;
};
var weave = function(items) {
  const branches = [];
  while (items.length) {
    const topKind = findTopKey(items, (sel) => true, getSelectorKind);
    const { matches, nonmatches, empty: empty2 } = breakByKind(items, topKind);
    items = nonmatches;
    if (matches.length) {
      branches.push(branchOfKind(topKind, matches));
    }
    if (empty2.length) {
      branches.push(...terminate(empty2));
    }
  }
  return branches;
};
var terminate = function(items) {
  const results = [];
  for (const item of items) {
    const terminal = item.terminal;
    if (terminal.type === "terminal") {
      results.push(terminal);
    } else {
      const { matches, rest: rest5 } = partition(terminal.cont, (node3) => node3.type === "terminal");
      matches.forEach((node3) => results.push(node3));
      if (rest5.length) {
        terminal.cont = rest5;
        results.push(terminal);
      }
    }
  }
  return results;
};
var breakByKind = function(items, selectedKind) {
  const matches = [];
  const nonmatches = [];
  const empty2 = [];
  for (const item of items) {
    const simpsels = item.ast.list;
    if (simpsels.length) {
      const isMatch = simpsels.some((node3) => getSelectorKind(node3) === selectedKind);
      (isMatch ? matches : nonmatches).push(item);
    } else {
      empty2.push(item);
    }
  }
  return { matches, nonmatches, empty: empty2 };
};
var getSelectorKind = function(sel) {
  switch (sel.type) {
    case "attrPresence":
      return `attrPresence ${sel.name}`;
    case "attrValue":
      return `attrValue ${sel.name}`;
    case "combinator":
      return `combinator ${sel.combinator}`;
    default:
      return sel.type;
  }
};
var branchOfKind = function(kind, items) {
  if (kind === "tag") {
    return tagNameBranch(items);
  }
  if (kind.startsWith("attrValue ")) {
    return attrValueBranch(kind.substring(10), items);
  }
  if (kind.startsWith("attrPresence ")) {
    return attrPresenceBranch(kind.substring(13), items);
  }
  if (kind === "combinator >") {
    return combinatorBranch(">", items);
  }
  if (kind === "combinator +") {
    return combinatorBranch("+", items);
  }
  throw new Error(`Unsupported selector kind: ${kind}`);
};
var tagNameBranch = function(items) {
  const groups = spliceAndGroup(items, (x) => x.type === "tag", (x) => x.name);
  const variants = Object.entries(groups).map(([name2, group]) => ({
    type: "variant",
    value: name2,
    cont: weave(group.items)
  }));
  return {
    type: "tagName",
    variants
  };
};
var attrPresenceBranch = function(name2, items) {
  for (const item of items) {
    spliceSimpleSelector(item, (x) => x.type === "attrPresence" && x.name === name2);
  }
  return {
    type: "attrPresence",
    name: name2,
    cont: weave(items)
  };
};
var attrValueBranch = function(name2, items) {
  const groups = spliceAndGroup(items, (x) => x.type === "attrValue" && x.name === name2, (x) => `${x.matcher} ${x.modifier || ""} ${x.value}`);
  const matchers = [];
  for (const group of Object.values(groups)) {
    const sel = group.oneSimpleSelector;
    const predicate = getAttrPredicate(sel);
    const continuation = weave(group.items);
    matchers.push({
      type: "matcher",
      matcher: sel.matcher,
      modifier: sel.modifier,
      value: sel.value,
      predicate,
      cont: continuation
    });
  }
  return {
    type: "attrValue",
    name: name2,
    matchers
  };
};
var getAttrPredicate = function(sel) {
  if (sel.modifier === "i") {
    const expected = sel.value.toLowerCase();
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual.toLowerCase();
      case "~=":
        return (actual) => actual.toLowerCase().split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.toLowerCase().startsWith(expected);
      case "$=":
        return (actual) => actual.toLowerCase().endsWith(expected);
      case "*=":
        return (actual) => actual.toLowerCase().includes(expected);
      case "|=":
        return (actual) => {
          const lower = actual.toLowerCase();
          return expected === lower || lower.startsWith(expected) && lower[expected.length] === "-";
        };
    }
  } else {
    const expected = sel.value;
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual;
      case "~=":
        return (actual) => actual.split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.startsWith(expected);
      case "$=":
        return (actual) => actual.endsWith(expected);
      case "*=":
        return (actual) => actual.includes(expected);
      case "|=":
        return (actual) => expected === actual || actual.startsWith(expected) && actual[expected.length] === "-";
    }
  }
};
var combinatorBranch = function(combinator, items) {
  const groups = spliceAndGroup(items, (x) => x.type === "combinator" && x.combinator === combinator, (x) => serialize(x.left));
  const leftItems = [];
  for (const group of Object.values(groups)) {
    const rightCont = weave(group.items);
    const leftAst = group.oneSimpleSelector.left;
    leftItems.push({
      ast: leftAst,
      terminal: { type: "popElement", cont: rightCont }
    });
  }
  return {
    type: "pushElement",
    combinator,
    cont: weave(leftItems)
  };
};
var spliceAndGroup = function(items, predicate, keyCallback) {
  const groups = {};
  while (items.length) {
    const bestKey = findTopKey(items, predicate, keyCallback);
    const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;
    const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);
    const { matches, rest: rest5 } = partition1(items, hasBestKeyPredicate);
    let oneSimpleSelector = null;
    for (const item of matches) {
      const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);
      if (!oneSimpleSelector) {
        oneSimpleSelector = splicedNode;
      }
    }
    if (oneSimpleSelector == null) {
      throw new Error("No simple selector is found.");
    }
    groups[bestKey] = { oneSimpleSelector, items: matches };
    items = rest5;
  }
  return groups;
};
var spliceSimpleSelector = function(item, predicate) {
  const simpsels = item.ast.list;
  const matches = new Array(simpsels.length);
  let firstIndex = -1;
  for (let i = simpsels.length;i-- > 0; ) {
    if (predicate(simpsels[i])) {
      matches[i] = true;
      firstIndex = i;
    }
  }
  if (firstIndex == -1) {
    throw new Error(`Couldn't find the required simple selector.`);
  }
  const result = simpsels[firstIndex];
  item.ast.list = simpsels.filter((sel, i) => !matches[i]);
  return result;
};
var findTopKey = function(items, predicate, keyCallback) {
  const candidates = {};
  for (const item of items) {
    const candidates1 = {};
    for (const node3 of item.ast.list.filter(predicate)) {
      candidates1[keyCallback(node3)] = true;
    }
    for (const key of Object.keys(candidates1)) {
      if (candidates[key]) {
        candidates[key]++;
      } else {
        candidates[key] = 1;
      }
    }
  }
  let topKind = "";
  let topCounter = 0;
  for (const entry of Object.entries(candidates)) {
    if (entry[1] > topCounter) {
      topKind = entry[0];
      topCounter = entry[1];
    }
  }
  return topKind;
};
var partition = function(src, predicate) {
  const matches = [];
  const rest5 = [];
  for (const x of src) {
    if (predicate(x)) {
      matches.push(x);
    } else {
      rest5.push(x);
    }
  }
  return { matches, rest: rest5 };
};
var partition1 = function(src, predicate) {
  const matches = [];
  const rest5 = [];
  for (const x of src) {
    if (predicate(x)) {
      matches.push(x);
    } else {
      rest5.push(x);
    }
  }
  return { matches, rest: rest5 };
};
var comparatorPreferFirst = function(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index < acc.index;
};
var comparatorPreferLast = function(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index > acc.index;
};
class DecisionTree {
  constructor(input) {
    this.branches = weave(toAstTerminalPairs(input));
  }
  build(builder) {
    return builder(this.branches);
  }
}

class Picker {
  constructor(f) {
    this.f = f;
  }
  pickAll(el) {
    return this.f(el);
  }
  pick1(el, preferFirst = false) {
    const results = this.f(el);
    const len = results.length;
    if (len === 0) {
      return null;
    }
    if (len === 1) {
      return results[0].value;
    }
    const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;
    let result = results[0];
    for (let i = 1;i < len; i++) {
      const next = results[i];
      if (comparator(result, next)) {
        result = next;
      }
    }
    return result.value;
  }
}

// ../sisventa/node_modules/@selderee/plugin-htmlparser2/lib/hp2-builder.mjs
var hp2Builder = function(nodes) {
  return new Picker(handleArray(nodes));
};
var handleArray = function(nodes) {
  const matchers = nodes.map(handleNode);
  return (el, ...tail) => matchers.flatMap((m) => m(el, ...tail));
};
var handleNode = function(node3) {
  switch (node3.type) {
    case "terminal": {
      const result = [node3.valueContainer];
      return (el, ...tail) => result;
    }
    case "tagName":
      return handleTagName(node3);
    case "attrValue":
      return handleAttrValueName(node3);
    case "attrPresence":
      return handleAttrPresenceName(node3);
    case "pushElement":
      return handlePushElementNode(node3);
    case "popElement":
      return handlePopElementNode(node3);
  }
};
var handleTagName = function(node3) {
  const variants = {};
  for (const variant of node3.variants) {
    variants[variant.value] = handleArray(variant.cont);
  }
  return (el, ...tail) => {
    const continuation = variants[el.name];
    return continuation ? continuation(el, ...tail) : [];
  };
};
var handleAttrPresenceName = function(node3) {
  const attrName = node3.name;
  const continuation = handleArray(node3.cont);
  return (el, ...tail) => Object.prototype.hasOwnProperty.call(el.attribs, attrName) ? continuation(el, ...tail) : [];
};
var handleAttrValueName = function(node3) {
  const callbacks = [];
  for (const matcher of node3.matchers) {
    const predicate = matcher.predicate;
    const continuation = handleArray(matcher.cont);
    callbacks.push((attr, el, ...tail) => predicate(attr) ? continuation(el, ...tail) : []);
  }
  const attrName = node3.name;
  return (el, ...tail) => {
    const attr = el.attribs[attrName];
    return attr || attr === "" ? callbacks.flatMap((cb) => cb(attr, el, ...tail)) : [];
  };
};
var handlePushElementNode = function(node3) {
  const continuation = handleArray(node3.cont);
  const leftElementGetter = node3.combinator === "+" ? getPrecedingElement : getParentElement;
  return (el, ...tail) => {
    const next = leftElementGetter(el);
    if (next === null) {
      return [];
    }
    return continuation(next, el, ...tail);
  };
};
var handlePopElementNode = function(node3) {
  const continuation = handleArray(node3.cont);
  return (el, next, ...tail) => continuation(next, ...tail);
};
var getPrecedingElement = (el) => {
  const prev = el.prev;
  if (prev === null) {
    return null;
  }
  return isTag2(prev) ? prev : getPrecedingElement(prev);
};
var getParentElement = (el) => {
  const parent = el.parent;
  return parent && isTag2(parent) ? parent : null;
};

// ../sisventa/node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array('\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\uD835\uDD04rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\uD835\uDD38plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\uD835\uDC9Cign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\uD835\uDD05pf;\uC000\uD835\uDD39eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\uD835\uDC9Ep\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\uD835\uDD07\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\uD835\uDD3B\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\uD835\uDC9Frok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\uD835\uDD08rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\uD835\uDD3Csilon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\uD835\uDD09lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\uD835\uDD3DAll;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\uD835\uDD0A;\u62D9pf;\uC000\uD835\uDD3Eeater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\uD835\uDCA2;\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\uD835\uDD40a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\uD835\uDD0Dpf;\uC000\uD835\uDD41\u01E3\u07C7\0\u07CCr;\uC000\uD835\uDCA5rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\uD835\uDD0Epf;\uC000\uD835\uDD42cr;\uC000\uD835\uDCA6\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\uD835\uDD0F\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\uD835\uDD43er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\uD835\uDD10nusPlus;\u6213pf;\uC000\uD835\uDD44c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\uD835\uDD11\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\uD835\uDCA9ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\uD835\uDD12rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\uD835\uDD46enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\uD835\uDCAAash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\uD835\uDD13i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\uD835\uDCAB;\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\uD835\uDD14pf;\u611Acr;\uC000\uD835\uDCAC\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\uD835\uDD16ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\uD835\uDD4A\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\uD835\uDCAEar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\uD835\uDD17\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\uD835\uDD4BipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\uD835\uDCAFrok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\uD835\uDD18rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\uD835\uDD4C\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\uD835\uDCB0ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\uD835\uDD19pf;\uC000\uD835\uDD4Dcr;\uC000\uD835\uDCB1dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\uD835\uDD1Apf;\uC000\uD835\uDD4Ecr;\uC000\uD835\uDCB2\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\uD835\uDD1B;\u439Epf;\uC000\uD835\uDD4Fcr;\uC000\uD835\uDCB3\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\uD835\uDD1Cpf;\uC000\uD835\uDD50cr;\uC000\uD835\uDCB4ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\uD835\uDCB5\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\uD835\uDD1Erave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\uD835\uDD52\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\uD835\uDCB6;\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\uD835\uDD1Fg\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\uD835\uDD53\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\uD835\uDCB7mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\uD835\uDD20\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\uD835\uDD54o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\uD835\uDCB8\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\uD835\uDD21ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\uD835\uDD55\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\uD835\uDCB9;\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\uD835\uDD22\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\uD835\uDD56\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\uD835\uDD23lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\uD835\uDD57\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\uD835\uDCBB\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\uD835\uDD24\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\uD835\uDD58\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\uD835\uDD25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\uD835\uDD59bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\uD835\uDCBDas\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\uD835\uDD26rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\uD835\uDD5Aa;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\uD835\uDCBEn\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\uD835\uDD27ath;\u4237pf;\uC000\uD835\uDD5B\u01E3\u23EC\0\u23F1r;\uC000\uD835\uDCBFrcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\uD835\uDD28reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\uD835\uDD5Ccr;\uC000\uD835\uDCC0\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\uD835\uDD29\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\uD835\uDD5Dus;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\uD835\uDCC1m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\uD835\uDD2Ao;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\uD835\uDD5E\u0100ct\u28F8\u28FDr;\uC000\uD835\uDCC2pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\uD835\uDD2B\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\uD835\uDD5F\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\uD835\uDCC3ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\uD835\uDD2C\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\uD835\uDD60\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\uD835\uDD2D\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\uD835\uDD61nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\uD835\uDCC5;\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\uD835\uDD2Epf;\uC000\uD835\uDD62rime;\u6057cr;\uC000\uD835\uDCC6\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\uD835\uDD2F\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\uD835\uDD63us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\uD835\uDCC7\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\uD835\uDD30\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\uD835\uDD64a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\uD835\uDCC8tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\uD835\uDD31\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\uD835\uDD65rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\uD835\uDCC9;\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\uD835\uDD32rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\uD835\uDD66\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\uD835\uDCCA\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\uD835\uDD33tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\uD835\uDD67ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\uD835\uDCCB\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\uD835\uDD34pf;\uC000\uD835\uDD68\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\uD835\uDCCC\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\uD835\uDD35\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\uD835\uDD69im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\uD835\uDCCD\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\uD835\uDD36cy;\u4457pf;\uC000\uD835\uDD6Acr;\uC000\uD835\uDCCE\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\uD835\uDD37cy;\u4436grarr;\u61DDpf;\uC000\uD835\uDD6Bcr;\uC000\uD835\uDCCF\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c4) => c4.charCodeAt(0)));

// ../sisventa/node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array("\u0200aglq\t\x15\x18\x1B\u026D\x0F\0\0\x12p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c4) => c4.charCodeAt(0)));

// ../sisventa/node_modules/entities/lib/esm/decode_codepoint.js
function replaceCodePoint(codePoint) {
  var _a;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a = decodeMap.get(codePoint)) !== null && _a !== undefined ? _a : codePoint;
}
var _a;
var decodeMap = new Map([
  [0, 65533],
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== undefined ? _a : function(codePoint) {
  let output = "";
  if (codePoint > 65535) {
    codePoint -= 65536;
    output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
    codePoint = 56320 | codePoint & 1023;
  }
  output += String.fromCharCode(codePoint);
  return output;
};

// ../sisventa/node_modules/entities/lib/esm/decode.js
var isNumber = function(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
};
var isHexadecimalCharacter = function(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
};
var isAsciiAlphaNumeric = function(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
};
var isEntityInAttributeInvalidEnd = function(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
};
var getDecoder = function(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(str, offset + 1);
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
};
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value27 = char - jumpOffset;
    return value27 < 0 || value27 >= branchCount ? -1 : decodeTree[nodeIdx + value27] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));

class EntityDecoder {
  constructor(decodeTree, emitCodePoint, errors7) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors7;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === undefined || _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (;offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === undefined || _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === undefined || _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);

// ../sisventa/node_modules/htmlparser2/lib/esm/Tokenizer.js
var isWhitespace = function(c4) {
  return c4 === CharCodes2.Space || c4 === CharCodes2.NewLine || c4 === CharCodes2.Tab || c4 === CharCodes2.FormFeed || c4 === CharCodes2.CarriageReturn;
};
var isEndOfTagSection = function(c4) {
  return c4 === CharCodes2.Slash || c4 === CharCodes2.Gt || isWhitespace(c4);
};
var isNumber2 = function(c4) {
  return c4 >= CharCodes2.Zero && c4 <= CharCodes2.Nine;
};
var isASCIIAlpha = function(c4) {
  return c4 >= CharCodes2.LowerA && c4 <= CharCodes2.LowerZ || c4 >= CharCodes2.UpperA && c4 <= CharCodes2.UpperZ;
};
var isHexDigit = function(c4) {
  return c4 >= CharCodes2.UpperA && c4 <= CharCodes2.UpperF || c4 >= CharCodes2.LowerA && c4 <= CharCodes2.LowerF;
};
var CharCodes2;
(function(CharCodes3) {
  CharCodes3[CharCodes3["Tab"] = 9] = "Tab";
  CharCodes3[CharCodes3["NewLine"] = 10] = "NewLine";
  CharCodes3[CharCodes3["FormFeed"] = 12] = "FormFeed";
  CharCodes3[CharCodes3["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes3[CharCodes3["Space"] = 32] = "Space";
  CharCodes3[CharCodes3["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes3[CharCodes3["Number"] = 35] = "Number";
  CharCodes3[CharCodes3["Amp"] = 38] = "Amp";
  CharCodes3[CharCodes3["SingleQuote"] = 39] = "SingleQuote";
  CharCodes3[CharCodes3["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes3[CharCodes3["Dash"] = 45] = "Dash";
  CharCodes3[CharCodes3["Slash"] = 47] = "Slash";
  CharCodes3[CharCodes3["Zero"] = 48] = "Zero";
  CharCodes3[CharCodes3["Nine"] = 57] = "Nine";
  CharCodes3[CharCodes3["Semi"] = 59] = "Semi";
  CharCodes3[CharCodes3["Lt"] = 60] = "Lt";
  CharCodes3[CharCodes3["Eq"] = 61] = "Eq";
  CharCodes3[CharCodes3["Gt"] = 62] = "Gt";
  CharCodes3[CharCodes3["Questionmark"] = 63] = "Questionmark";
  CharCodes3[CharCodes3["UpperA"] = 65] = "UpperA";
  CharCodes3[CharCodes3["LowerA"] = 97] = "LowerA";
  CharCodes3[CharCodes3["UpperF"] = 70] = "UpperF";
  CharCodes3[CharCodes3["LowerF"] = 102] = "LowerF";
  CharCodes3[CharCodes3["UpperZ"] = 90] = "UpperZ";
  CharCodes3[CharCodes3["LowerZ"] = 122] = "LowerZ";
  CharCodes3[CharCodes3["LowerX"] = 120] = "LowerX";
  CharCodes3[CharCodes3["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes2 || (CharCodes2 = {}));
var State;
(function(State2) {
  State2[State2["Text"] = 1] = "Text";
  State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
  State2[State2["InTagName"] = 3] = "InTagName";
  State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
  State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State2[State2["InAttributeName"] = 9] = "InAttributeName";
  State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
  State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State2[State2["InDeclaration"] = 16] = "InDeclaration";
  State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State2[State2["BeforeComment"] = 18] = "BeforeComment";
  State2[State2["CDATASequence"] = 19] = "CDATASequence";
  State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
  State2[State2["InCommentLike"] = 21] = "InCommentLike";
  State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
  State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
  State2[State2["BeforeEntity"] = 25] = "BeforeEntity";
  State2[State2["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
  State2[State2["InNamedEntity"] = 27] = "InNamedEntity";
  State2[State2["InNumericEntity"] = 28] = "InNumericEntity";
  State2[State2["InHexEntity"] = 29] = "InHexEntity";
})(State || (State = {}));
var QuoteType;
(function(QuoteType2) {
  QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
  QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
  QuoteType2[QuoteType2["Single"] = 2] = "Single";
  QuoteType2[QuoteType2["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
var Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
};

class Tokenizer {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = undefined;
    this.sequenceIndex = 0;
    this.trieIndex = 0;
    this.trieCurrent = 0;
    this.entityResult = 0;
    this.entityExcess = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityTrie = xmlMode ? decode_data_xml_default : decode_data_html_default;
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = undefined;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  getIndex() {
    return this.index;
  }
  getSectionStart() {
    return this.sectionStart;
  }
  stateText(c4) {
    if (c4 === CharCodes2.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes2.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c4 === CharCodes2.Amp) {
      this.state = State.BeforeEntity;
    }
  }
  stateSpecialStartSequence(c4) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? isEndOfTagSection(c4) : (c4 | 32) === this.currentSequence[this.sequenceIndex];
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c4);
  }
  stateInSpecialTag(c4) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c4 === CharCodes2.Gt || isWhitespace(c4)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c4);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c4 | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c4 === CharCodes2.Amp) {
          this.state = State.BeforeEntity;
        }
      } else if (this.fastForwardTo(CharCodes2.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c4 === CharCodes2.Lt);
    }
  }
  stateCDATASequence(c4) {
    if (c4 === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c4);
    }
  }
  fastForwardTo(c4) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c4) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  stateInCommentLike(c4) {
    if (c4 === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c4 !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  isTagStartChar(c4) {
    return this.xmlMode ? !isEndOfTagSection(c4) : isASCIIAlpha(c4);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c4) {
    if (c4 === CharCodes2.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c4 === CharCodes2.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c4)) {
      const lower = c4 | 32;
      this.sectionStart = this.index;
      if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
        this.startSpecial(Sequences.TitleEnd, 3);
      } else {
        this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
      }
    } else if (c4 === CharCodes2.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c4);
    }
  }
  stateInTagName(c4) {
    if (isEndOfTagSection(c4)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c4);
    }
  }
  stateBeforeClosingTagName(c4) {
    if (isWhitespace(c4)) {
    } else if (c4 === CharCodes2.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c4) ? State.InClosingTagName : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c4) {
    if (c4 === CharCodes2.Gt || isWhitespace(c4)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c4);
    }
  }
  stateAfterClosingTagName(c4) {
    if (c4 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c4) {
    if (c4 === CharCodes2.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.baseState = this.state;
      this.sectionStart = this.index + 1;
    } else if (c4 === CharCodes2.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace(c4)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c4) {
    if (c4 === CharCodes2.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace(c4)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c4);
    }
  }
  stateInAttributeName(c4) {
    if (c4 === CharCodes2.Eq || isEndOfTagSection(c4)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c4);
    }
  }
  stateAfterAttributeName(c4) {
    if (c4 === CharCodes2.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c4 === CharCodes2.Slash || c4 === CharCodes2.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c4);
    } else if (!isWhitespace(c4)) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c4) {
    if (c4 === CharCodes2.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c4 === CharCodes2.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c4)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c4);
    }
  }
  handleInAttributeValue(c4, quote) {
    if (c4 === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes2.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c4 === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateInAttributeValueDoubleQuotes(c4) {
    this.handleInAttributeValue(c4, CharCodes2.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c4) {
    this.handleInAttributeValue(c4, CharCodes2.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c4) {
    if (isWhitespace(c4) || c4 === CharCodes2.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c4);
    } else if (this.decodeEntities && c4 === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateBeforeDeclaration(c4) {
    if (c4 === CharCodes2.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c4 === CharCodes2.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c4) {
    if (c4 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c4) {
    if (c4 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c4) {
    if (c4 === CharCodes2.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c4) {
    if (c4 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c4) {
    const lower = c4 | 32;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c4);
    }
  }
  stateBeforeEntity(c4) {
    this.entityExcess = 1;
    this.entityResult = 0;
    if (c4 === CharCodes2.Number) {
      this.state = State.BeforeNumericEntity;
    } else if (c4 === CharCodes2.Amp) {
    } else {
      this.trieIndex = 0;
      this.trieCurrent = this.entityTrie[0];
      this.state = State.InNamedEntity;
      this.stateInNamedEntity(c4);
    }
  }
  stateInNamedEntity(c4) {
    this.entityExcess += 1;
    this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c4);
    if (this.trieIndex < 0) {
      this.emitNamedEntity();
      this.index--;
      return;
    }
    this.trieCurrent = this.entityTrie[this.trieIndex];
    const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
    if (masked) {
      const valueLength = (masked >> 14) - 1;
      if (!this.allowLegacyEntity() && c4 !== CharCodes2.Semi) {
        this.trieIndex += valueLength;
      } else {
        const entityStart = this.index - this.entityExcess + 1;
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.entityResult = this.trieIndex;
        this.trieIndex += valueLength;
        this.entityExcess = 0;
        this.sectionStart = this.index + 1;
        if (valueLength === 0) {
          this.emitNamedEntity();
        }
      }
    }
  }
  emitNamedEntity() {
    this.state = this.baseState;
    if (this.entityResult === 0) {
      return;
    }
    const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;
    switch (valueLength) {
      case 1: {
        this.emitCodePoint(this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH);
        break;
      }
      case 2: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        break;
      }
      case 3: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
      }
    }
  }
  stateBeforeNumericEntity(c4) {
    if ((c4 | 32) === CharCodes2.LowerX) {
      this.entityExcess++;
      this.state = State.InHexEntity;
    } else {
      this.state = State.InNumericEntity;
      this.stateInNumericEntity(c4);
    }
  }
  emitNumericEntity(strict5) {
    const entityStart = this.index - this.entityExcess - 1;
    const numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
    if (numberStart !== this.index) {
      if (entityStart > this.sectionStart) {
        this.emitPartial(this.sectionStart, entityStart);
      }
      this.sectionStart = this.index + Number(strict5);
      this.emitCodePoint(replaceCodePoint(this.entityResult));
    }
    this.state = this.baseState;
  }
  stateInNumericEntity(c4) {
    if (c4 === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c4)) {
      this.entityResult = this.entityResult * 10 + (c4 - CharCodes2.Zero);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  stateInHexEntity(c4) {
    if (c4 === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c4)) {
      this.entityResult = this.entityResult * 16 + (c4 - CharCodes2.Zero);
      this.entityExcess++;
    } else if (isHexDigit(c4)) {
      this.entityResult = this.entityResult * 16 + ((c4 | 32) - CharCodes2.LowerA + 10);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  allowLegacyEntity() {
    return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
  }
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  parse() {
    while (this.shouldContinue()) {
      const c4 = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text: {
          this.stateText(c4);
          break;
        }
        case State.SpecialStartSequence: {
          this.stateSpecialStartSequence(c4);
          break;
        }
        case State.InSpecialTag: {
          this.stateInSpecialTag(c4);
          break;
        }
        case State.CDATASequence: {
          this.stateCDATASequence(c4);
          break;
        }
        case State.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c4);
          break;
        }
        case State.InAttributeName: {
          this.stateInAttributeName(c4);
          break;
        }
        case State.InCommentLike: {
          this.stateInCommentLike(c4);
          break;
        }
        case State.InSpecialComment: {
          this.stateInSpecialComment(c4);
          break;
        }
        case State.BeforeAttributeName: {
          this.stateBeforeAttributeName(c4);
          break;
        }
        case State.InTagName: {
          this.stateInTagName(c4);
          break;
        }
        case State.InClosingTagName: {
          this.stateInClosingTagName(c4);
          break;
        }
        case State.BeforeTagName: {
          this.stateBeforeTagName(c4);
          break;
        }
        case State.AfterAttributeName: {
          this.stateAfterAttributeName(c4);
          break;
        }
        case State.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c4);
          break;
        }
        case State.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c4);
          break;
        }
        case State.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c4);
          break;
        }
        case State.AfterClosingTagName: {
          this.stateAfterClosingTagName(c4);
          break;
        }
        case State.BeforeSpecialS: {
          this.stateBeforeSpecialS(c4);
          break;
        }
        case State.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c4);
          break;
        }
        case State.InSelfClosingTag: {
          this.stateInSelfClosingTag(c4);
          break;
        }
        case State.InDeclaration: {
          this.stateInDeclaration(c4);
          break;
        }
        case State.BeforeDeclaration: {
          this.stateBeforeDeclaration(c4);
          break;
        }
        case State.BeforeComment: {
          this.stateBeforeComment(c4);
          break;
        }
        case State.InProcessingInstruction: {
          this.stateInProcessingInstruction(c4);
          break;
        }
        case State.InNamedEntity: {
          this.stateInNamedEntity(c4);
          break;
        }
        case State.BeforeEntity: {
          this.stateBeforeEntity(c4);
          break;
        }
        case State.InHexEntity: {
          this.stateInHexEntity(c4);
          break;
        }
        case State.InNumericEntity: {
          this.stateInNumericEntity(c4);
          break;
        }
        default: {
          this.stateBeforeNumericEntity(c4);
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InNamedEntity) {
      this.emitNamedEntity();
    }
    if (this.sectionStart < this.index) {
      this.handleTrailingData();
    }
    this.cbs.onend();
  }
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
    } else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitPartial(start, endIndex) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribdata(start, endIndex);
    } else {
      this.cbs.ontext(start, endIndex);
    }
  }
  emitCodePoint(cp) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribentity(cp);
    } else {
      this.cbs.ontextentity(cp);
    }
  }
}

// ../sisventa/node_modules/htmlparser2/lib/esm/Parser.js
var formTags = new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag = new Set(["p"]);
var tableSectionTags = new Set(["thead", "tbody"]);
var ddtTags = new Set(["dd", "dt"]);
var rtpTags = new Set(["rt", "rp"]);
var openImpliesClose = new Map([
  ["tr", new Set(["tr", "th", "td"])],
  ["th", new Set(["th"])],
  ["td", new Set(["thead", "th", "td"])],
  ["body", new Set(["head", "link", "script"])],
  ["li", new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", new Set(["option"])],
  ["optgroup", new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
var voidElements = new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements = new Set(["math", "svg"]);
var htmlIntegrationElements = new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd = /\s|\//;

class Parser {
  constructor(cbs, options = {}) {
    var _a2, _b, _c, _d, _e;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== undefined ? cbs : {};
    this.lowerCaseTagNames = (_a2 = options.lowerCaseTags) !== null && _a2 !== undefined ? _a2 : !options.xmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== undefined ? _b : !options.xmlMode;
    this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== undefined ? _c : Tokenizer)(this.options, this);
    (_e = (_d = this.cbs).onparserinit) === null || _e === undefined || _e.call(_d, this);
  }
  ontext(start, endIndex) {
    var _a2, _b;
    const data = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === undefined || _b.call(_a2, data);
    this.startIndex = endIndex;
  }
  ontextentity(cp) {
    var _a2, _b;
    const index = this.tokenizer.getSectionStart();
    this.endIndex = index - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === undefined || _b.call(_a2, fromCodePoint(cp));
    this.startIndex = index;
  }
  isVoidElement(name2) {
    return !this.options.xmlMode && voidElements.has(name2);
  }
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    this.emitOpenTag(name2);
  }
  emitOpenTag(name2) {
    var _a2, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name2;
    const impliesClose = !this.options.xmlMode && openImpliesClose.get(name2);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
        const element = this.stack.pop();
        (_b = (_a2 = this.cbs).onclosetag) === null || _b === undefined || _b.call(_a2, element, true);
      }
    }
    if (!this.isVoidElement(name2)) {
      this.stack.push(name2);
      if (foreignContextElements.has(name2)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements.has(name2)) {
        this.foreignContext.push(false);
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === undefined || _d.call(_c, name2);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a2, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a2 = this.cbs).onopentag) === null || _b === undefined || _b.call(_a2, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  onclosetag(start, endIndex) {
    var _a2, _b, _c, _d, _e, _f;
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    if (foreignContextElements.has(name2) || htmlIntegrationElements.has(name2)) {
      this.foreignContext.pop();
    }
    if (!this.isVoidElement(name2)) {
      const pos = this.stack.lastIndexOf(name2);
      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          let count = this.stack.length - pos;
          while (count--) {
            this.cbs.onclosetag(this.stack.pop(), count !== 0);
          }
        } else
          this.stack.length = pos;
      } else if (!this.options.xmlMode && name2 === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (!this.options.xmlMode && name2 === "br") {
      (_b = (_a2 = this.cbs).onopentagname) === null || _b === undefined || _b.call(_a2, "br");
      (_d = (_c = this.cbs).onopentag) === null || _d === undefined || _d.call(_c, "br", {}, true);
      (_f = (_e = this.cbs).onclosetag) === null || _f === undefined || _f.call(_e, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a2, _b;
    const name2 = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[this.stack.length - 1] === name2) {
      (_b = (_a2 = this.cbs).onclosetag) === null || _b === undefined || _b.call(_a2, name2, !isOpenImplied);
      this.stack.pop();
    }
  }
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name2 = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name2.toLowerCase() : name2;
  }
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  onattribend(quote, endIndex) {
    var _a2, _b;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).onattribute) === null || _b === undefined || _b.call(_a2, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? undefined : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value27) {
    const index = value27.search(reNameEnd);
    let name2 = index < 0 ? value27 : value27.substr(0, index);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    return name2;
  }
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value27 = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value27);
      this.cbs.onprocessinginstruction(`!${name2}`, `!${value27}`);
    }
    this.startIndex = endIndex + 1;
  }
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value27 = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value27);
      this.cbs.onprocessinginstruction(`?${name2}`, `?${value27}`);
    }
    this.startIndex = endIndex + 1;
  }
  oncomment(start, endIndex, offset) {
    var _a2, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).oncomment) === null || _b === undefined || _b.call(_a2, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === undefined || _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  oncdata(start, endIndex, offset) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value27 = this.getSlice(start, endIndex - offset);
    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b = (_a2 = this.cbs).oncdatastart) === null || _b === undefined || _b.call(_a2);
      (_d = (_c = this.cbs).ontext) === null || _d === undefined || _d.call(_c, value27);
      (_f = (_e = this.cbs).oncdataend) === null || _f === undefined || _f.call(_e);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === undefined || _h.call(_g, `[CDATA[${value27}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === undefined || _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  onend() {
    var _a2, _b;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index = this.stack.length;index > 0; this.cbs.onclosetag(this.stack[--index], true))
        ;
    }
    (_b = (_a2 = this.cbs).onend) === null || _b === undefined || _b.call(_a2);
  }
  reset() {
    var _a2, _b, _c, _d;
    (_b = (_a2 = this.cbs).onreset) === null || _b === undefined || _b.call(_a2);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === undefined || _d.call(_c, this);
    this.buffers.length = 0;
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  parseComplete(data) {
    this.reset();
    this.end(data);
  }
  getSlice(start, end) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
    while (end - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice += this.buffers[0].slice(0, end - this.bufferOffset);
    }
    return slice;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  write(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === undefined || _b.call(_a2, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  end(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === undefined || _b.call(_a2, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  pause() {
    this.tokenizer.pause();
  }
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  parseChunk(chunk) {
    this.write(chunk);
  }
  done(chunk) {
    this.end(chunk);
  }
}

// ../sisventa/node_modules/htmlparser2/lib/esm/index.js
function parseDocument(data, options) {
  const handler = new DomHandler(undefined, options);
  new Parser(handler, options).end(data);
  return handler.root;
}
// ../sisventa/node_modules/entities/lib/esm/escape.js
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer.exec(str)) !== null) {
    const i = match.index;
    const char = str.charCodeAt(i);
    const next = xmlCodeMap.get(char);
    if (next !== undefined) {
      ret += str.substring(lastIdx, i) + next;
      lastIdx = i + 1;
    } else {
      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
var getEscaper = function(regex, map6) {
  return function escape(data) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data)) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      result += map6.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  };
};
var xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (c4, index) => (c4.charCodeAt(index) & 64512) === 55296 ? (c4.charCodeAt(index) - 55296) * 1024 + c4.charCodeAt(index + 1) - 56320 + 65536 : c4.charCodeAt(index);
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));
// ../sisventa/node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// ../sisventa/node_modules/dom-serializer/lib/esm/foreignNames.js
var elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val) => [val.toLowerCase(), val]));
var attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val) => [val.toLowerCase(), val]));

// ../sisventa/node_modules/dom-serializer/lib/esm/index.js
var replaceQuotes = function(value27) {
  return value27.replace(/"/g, "&quot;");
};
var formatAttributes = function(attributes, opts) {
  var _a2;
  if (!attributes)
    return;
  const encode3 = ((_a2 = opts.encodeEntities) !== null && _a2 !== undefined ? _a2 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes).map((key) => {
    var _a3, _b;
    const value27 = (_a3 = attributes[key]) !== null && _a3 !== undefined ? _a3 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b = attributeNames.get(key)) !== null && _b !== undefined ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value27 === "") {
      return key;
    }
    return `${key}="${encode3(value27)}"`;
  }).join(" ");
};
function render(node3, options = {}) {
  const nodes = "length" in node3 ? node3 : [node3];
  let output = "";
  for (let i = 0;i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }
  return output;
}
var renderNode = function(node3, options) {
  switch (node3.type) {
    case Root:
      return render(node3.children, options);
    case Doctype:
    case Directive:
      return renderDirective(node3);
    case Comment:
      return renderComment(node3);
    case CDATA:
      return renderCdata(node3);
    case Script:
    case Style:
    case Tag:
      return renderTag(node3, options);
    case Text:
      return renderText(node3, options);
  }
};
var renderTag = function(elem, opts) {
  var _a2;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a2 = elementNames.get(elem.name)) !== null && _a2 !== undefined ? _a2 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
};
var renderDirective = function(elem) {
  return `<${elem.data}>`;
};
var renderText = function(elem, opts) {
  var _a2;
  let data = elem.data || "";
  if (((_a2 = opts.encodeEntities) !== null && _a2 !== undefined ? _a2 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data) : escapeText(data);
  }
  return data;
};
var renderCdata = function(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
};
var renderComment = function(elem) {
  return `<!--${elem.data}-->`;
};
var unencodedElements = new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
var singleTag = new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignModeIntegrationPoints = new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements = new Set(["svg", "math"]);
// ../sisventa/node_modules/html-to-text/lib/html-to-text.mjs
var import_deepmerge = __toESM(require_cjs(), 1);
var limitedDepthRecursive = function(n4, f, g = () => {
  return;
}) {
  if (n4 === undefined) {
    const f13 = function(...args) {
      return f(f13, ...args);
    };
    return f13;
  }
  if (n4 >= 0) {
    return function(...args) {
      return f(limitedDepthRecursive(n4 - 1, f, g), ...args);
    };
  }
  return g;
};
var trimCharacter = function(str, char) {
  let start = 0;
  let end = str.length;
  while (start < end && str[start] === char) {
    ++start;
  }
  while (end > start && str[end - 1] === char) {
    --end;
  }
  return start > 0 || end < str.length ? str.substring(start, end) : str;
};
var trimCharacterEnd = function(str, char) {
  let end = str.length;
  while (end > 0 && str[end - 1] === char) {
    --end;
  }
  return end < str.length ? str.substring(0, end) : str;
};
var unicodeEscape = function(str) {
  return str.replace(/[\s\S]/g, (c4) => "\\u" + c4.charCodeAt().toString(16).padStart(4, "0"));
};
var mergeDuplicatesPreferLast = function(items, getKey) {
  const map6 = new Map;
  for (let i = items.length;i-- > 0; ) {
    const item = items[i];
    const key = getKey(item);
    map6.set(key, map6.has(key) ? import_deepmerge.default(item, map6.get(key), { arrayMerge: overwriteMerge$1 }) : item);
  }
  return [...map6.values()].reverse();
};
var get = function(obj, path) {
  for (const key of path) {
    if (!obj) {
      return;
    }
    obj = obj[key];
  }
  return obj;
};
var numberToLetterSequence = function(num, baseChar = "a", base = 26) {
  const digits = [];
  do {
    num -= 1;
    digits.push(num % base);
    num = num / base >> 0;
  } while (num > 0);
  const baseCode = baseChar.charCodeAt(0);
  return digits.reverse().map((n4) => String.fromCharCode(baseCode + n4)).join("");
};
var numberToRoman = function(num) {
  return [...num + ""].map((n4) => +n4).reverse().map((v3, i) => v3 % 5 < 4 ? (v3 < 5 ? "" : V[i]) + I[i].repeat(v3 % 5) : I[i] + (v3 < 5 ? V[i] : I[i + 1])).reverse().join("");
};
var charactersToCodes = function(str) {
  return [...str].map((c4) => "\\u" + c4.charCodeAt(0).toString(16).padStart(4, "0")).join("");
};
var getText = function(stackItem) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can be requested for text contents.");
  }
  return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();
};
var addText = function(stackItem, text, leadingLineBreaks, trailingLineBreaks) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can contain text.");
  }
  const parentText = getText(stackItem);
  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);
  stackItem.inlineTextBuilder.clear();
  if (parentText) {
    stackItem.rawText = parentText + "\n".repeat(lineBreaks) + text;
  } else {
    stackItem.rawText = text;
    stackItem.leadingLineBreaks = lineBreaks;
  }
  stackItem.stashedLineBreaks = trailingLineBreaks;
};
var applyTransformer = function(str, transformer) {
  return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;
};
var compile$1 = function(options = {}) {
  const selectorsWithoutFormat = options.selectors.filter((s5) => !s5.format);
  if (selectorsWithoutFormat.length) {
    throw new Error("Following selectors have no specified format: " + selectorsWithoutFormat.map((s5) => `\`${s5.selector}\``).join(", "));
  }
  const picker = new DecisionTree(options.selectors.map((s5) => [s5.selector, s5])).build(hp2Builder);
  if (typeof options.encodeCharacters !== "function") {
    options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);
  }
  const baseSelectorsPicker = new DecisionTree(options.baseElements.selectors.map((s5, i) => [s5, i + 1])).build(hp2Builder);
  function findBaseElements(dom) {
    return findBases(dom, options, baseSelectorsPicker);
  }
  const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk, function(dom, builder) {
    builder.addInline(options.limits.ellipsis || "");
  });
  return function(html, metadata = undefined) {
    return process2(html, metadata, options, picker, findBaseElements, limitedWalk);
  };
};
var process2 = function(html, metadata, options, picker, findBaseElements, walk) {
  const maxInputLength = options.limits.maxInputLength;
  if (maxInputLength && html && html.length > maxInputLength) {
    console.warn(`Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`);
    html = html.substring(0, maxInputLength);
  }
  const document2 = parseDocument(html, { decodeEntities: options.decodeEntities });
  const bases = findBaseElements(document2.children);
  const builder = new BlockTextBuilder(options, picker, metadata);
  walk(bases, builder);
  return builder.toString();
};
var findBases = function(dom, options, baseSelectorsPicker) {
  const results = [];
  function recursiveWalk(walk, dom2) {
    dom2 = dom2.slice(0, options.limits.maxChildNodes);
    for (const elem of dom2) {
      if (elem.type !== "tag") {
        continue;
      }
      const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);
      if (pickedSelectorIndex > 0) {
        results.push({ selectorIndex: pickedSelectorIndex, element: elem });
      } else if (elem.children) {
        walk(elem.children);
      }
      if (results.length >= options.limits.maxBaseElements) {
        return;
      }
    }
  }
  const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk);
  limitedWalk(dom);
  if (options.baseElements.orderBy !== "occurrence") {
    results.sort((a3, b3) => a3.selectorIndex - b3.selectorIndex);
  }
  return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map((x) => x.element);
};
var recursiveWalk = function(walk, dom, builder) {
  if (!dom) {
    return;
  }
  const options = builder.options;
  const tooManyChildNodes = dom.length > options.limits.maxChildNodes;
  if (tooManyChildNodes) {
    dom = dom.slice(0, options.limits.maxChildNodes);
    dom.push({
      data: options.limits.ellipsis,
      type: "text"
    });
  }
  for (const elem of dom) {
    switch (elem.type) {
      case "text": {
        builder.addInline(elem.data);
        break;
      }
      case "tag": {
        const tagDefinition = builder.picker.pick1(elem);
        const format = options.formatters[tagDefinition.format];
        format(elem, walk, builder, tagDefinition.options || {});
        break;
      }
    }
  }
  return;
};
var makeReplacerFromDict = function(dict) {
  if (!dict || Object.keys(dict).length === 0) {
    return;
  }
  const entries = Object.entries(dict).filter(([, v3]) => v3 !== false);
  const regex = new RegExp(entries.map(([c4]) => `(${unicodeEscape([...c4][0])})`).join("|"), "g");
  const values = entries.map(([, v3]) => v3);
  const replacer = (m, ...cgs) => values[cgs.findIndex((cg) => cg)];
  return (str) => str.replace(regex, replacer);
};
var formatSkip = function(elem, walk, builder, formatOptions) {
};
var formatInlineString = function(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.string || "");
};
var formatBlockString = function(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addLiteral(formatOptions.string || "");
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
};
var formatInline = function(elem, walk, builder, formatOptions) {
  walk(elem.children, builder);
};
var formatBlock$1 = function(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
};
var renderOpenTag = function(elem) {
  const attrs = elem.attribs && elem.attribs.length ? " " + Object.entries(elem.attribs).map(([k3, v3]) => v3 === "" ? k3 : `${k3}=${v3.replace(/"/g, "&quot;")}`).join(" ") : "";
  return `<${elem.name}${attrs}>`;
};
var renderCloseTag = function(elem) {
  return `</${elem.name}>`;
};
var formatInlineTag = function(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
};
var formatBlockTag = function(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
};
var formatInlineHtml = function(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(render(elem, { decodeEntities: builder.options.decodeEntities }));
  builder.stopNoWrap();
};
var formatBlockHtml = function(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(render(elem, { decodeEntities: builder.options.decodeEntities }));
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
};
var formatInlineSurround = function(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.prefix || "");
  walk(elem.children, builder);
  builder.addLiteral(formatOptions.suffix || "");
};
var getRow = function(matrix, j) {
  if (!matrix[j]) {
    matrix[j] = [];
  }
  return matrix[j];
};
var findFirstVacantIndex = function(row, x = 0) {
  while (row[x]) {
    x++;
  }
  return x;
};
var transposeInPlace = function(matrix, maxSize) {
  for (let i = 0;i < maxSize; i++) {
    const rowI = getRow(matrix, i);
    for (let j = 0;j < i; j++) {
      const rowJ = getRow(matrix, j);
      if (rowI[j] || rowJ[i]) {
        const temp = rowI[j];
        rowI[j] = rowJ[i];
        rowJ[i] = temp;
      }
    }
  }
};
var putCellIntoLayout = function(cell, layout, baseRow, baseCol) {
  for (let r2 = 0;r2 < cell.rowspan; r2++) {
    const layoutRow = getRow(layout, baseRow + r2);
    for (let c4 = 0;c4 < cell.colspan; c4++) {
      layoutRow[baseCol + c4] = cell;
    }
  }
};
var getOrInitOffset = function(offsets, index) {
  if (offsets[index] === undefined) {
    offsets[index] = index === 0 ? 0 : 1 + getOrInitOffset(offsets, index - 1);
  }
  return offsets[index];
};
var updateOffset = function(offsets, base, span, value27) {
  offsets[base + span] = Math.max(getOrInitOffset(offsets, base + span), getOrInitOffset(offsets, base) + value27);
};
var tableToString = function(tableRows, rowSpacing, colSpacing) {
  const layout = [];
  let colNumber = 0;
  const rowNumber = tableRows.length;
  const rowOffsets = [0];
  for (let j = 0;j < rowNumber; j++) {
    const layoutRow = getRow(layout, j);
    const cells = tableRows[j];
    let x = 0;
    for (let i = 0;i < cells.length; i++) {
      const cell = cells[i];
      x = findFirstVacantIndex(layoutRow, x);
      putCellIntoLayout(cell, layout, j, x);
      x += cell.colspan;
      cell.lines = cell.text.split("\n");
      const cellHeight = cell.lines.length;
      updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);
    }
    colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;
  }
  transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);
  const outputLines = [];
  const colOffsets = [0];
  for (let x = 0;x < colNumber; x++) {
    let y3 = 0;
    let cell;
    const rowsInThisColumn = Math.min(rowNumber, layout[x].length);
    while (y3 < rowsInThisColumn) {
      cell = layout[x][y3];
      if (cell) {
        if (!cell.rendered) {
          let cellWidth = 0;
          for (let j = 0;j < cell.lines.length; j++) {
            const line = cell.lines[j];
            const lineOffset = rowOffsets[y3] + j;
            outputLines[lineOffset] = (outputLines[lineOffset] || "").padEnd(colOffsets[x]) + line;
            cellWidth = line.length > cellWidth ? line.length : cellWidth;
          }
          updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);
          cell.rendered = true;
        }
        y3 += cell.rowspan;
      } else {
        const lineOffset = rowOffsets[y3];
        outputLines[lineOffset] = outputLines[lineOffset] || "";
        y3++;
      }
    }
  }
  return outputLines.join("\n");
};
var formatLineBreak = function(elem, walk, builder, formatOptions) {
  builder.addLineBreak();
};
var formatWbr = function(elem, walk, builder, formatOptions) {
  builder.addWordBreakOpportunity();
};
var formatHorizontalLine = function(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addInline("-".repeat(formatOptions.length || builder.options.wordwrap || 40));
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
};
var formatParagraph = function(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
};
var formatPre = function(elem, walk, builder, formatOptions) {
  builder.openBlock({
    isPre: true,
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2
  });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
};
var formatHeading = function(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  if (formatOptions.uppercase !== false) {
    builder.pushWordTransform((str) => str.toUpperCase());
    walk(elem.children, builder);
    builder.popWordTransform();
  } else {
    walk(elem.children, builder);
  }
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
};
var formatBlockquote = function(elem, walk, builder, formatOptions) {
  builder.openBlock({
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,
    reservedLineLength: 2
  });
  walk(elem.children, builder);
  builder.closeBlock({
    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,
    blockTransform: (str) => (formatOptions.trimEmptyLines !== false ? trimCharacter(str, "\n") : str).split("\n").map((line) => "> " + line).join("\n")
  });
};
var withBrackets = function(str, brackets) {
  if (!brackets) {
    return str;
  }
  const lbr = typeof brackets[0] === "string" ? brackets[0] : "[";
  const rbr = typeof brackets[1] === "string" ? brackets[1] : "]";
  return lbr + str + rbr;
};
var pathRewrite = function(path, rewriter, baseUrl, metadata, elem) {
  const modifiedPath = typeof rewriter === "function" ? rewriter(path, metadata, elem) : path;
  return modifiedPath[0] === "/" && baseUrl ? trimCharacterEnd(baseUrl, "/") + modifiedPath : modifiedPath;
};
var formatImage = function(elem, walk, builder, formatOptions) {
  const attribs = elem.attribs || {};
  const alt = attribs.alt ? attribs.alt : "";
  const src = !attribs.src ? "" : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
  const text = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + " " + withBrackets(src, formatOptions.linkBrackets);
  builder.addInline(text, { noWordTransform: true });
};
var formatAnchor = function(elem, walk, builder, formatOptions) {
  function getHref() {
    if (formatOptions.ignoreHref) {
      return "";
    }
    if (!elem.attribs || !elem.attribs.href) {
      return "";
    }
    let href2 = elem.attribs.href.replace(/^mailto:/, "");
    if (formatOptions.noAnchorUrl && href2[0] === "#") {
      return "";
    }
    href2 = pathRewrite(href2, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
    return href2;
  }
  const href = getHref();
  if (!href) {
    walk(elem.children, builder);
  } else {
    let text = "";
    builder.pushWordTransform((str) => {
      if (str) {
        text += str;
      }
      return str;
    });
    walk(elem.children, builder);
    builder.popWordTransform();
    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;
    if (!hideSameLink) {
      builder.addInline(!text ? href : " " + withBrackets(href, formatOptions.linkBrackets), { noWordTransform: true });
    }
  }
};
var formatList = function(elem, walk, builder, formatOptions, nextPrefixCallback) {
  const isNestedList = get(elem, ["parent", "name"]) === "li";
  let maxPrefixLength = 0;
  const listItems = (elem.children || []).filter((child) => child.type !== "text" || !/^\s*$/.test(child.data)).map(function(child) {
    if (child.name !== "li") {
      return { node: child, prefix: "" };
    }
    const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();
    if (prefix.length > maxPrefixLength) {
      maxPrefixLength = prefix.length;
    }
    return { node: child, prefix };
  });
  if (!listItems.length) {
    return;
  }
  builder.openList({
    interRowLineBreaks: 1,
    leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2,
    maxPrefixLength,
    prefixAlign: "left"
  });
  for (const { node: node3, prefix } of listItems) {
    builder.openListItem({ prefix });
    walk([node3], builder);
    builder.closeListItem();
  }
  builder.closeList({ trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2 });
};
var formatUnorderedList = function(elem, walk, builder, formatOptions) {
  const prefix = formatOptions.itemPrefix || " * ";
  return formatList(elem, walk, builder, formatOptions, () => prefix);
};
var formatOrderedList = function(elem, walk, builder, formatOptions) {
  let nextIndex = Number(elem.attribs.start || "1");
  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);
  const nextPrefixCallback = () => " " + indexFunction(nextIndex++) + ". ";
  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);
};
var getOrderedListIndexFunction = function(olType = "1") {
  switch (olType) {
    case "a":
      return (i) => numberToLetterSequence(i, "a");
    case "A":
      return (i) => numberToLetterSequence(i, "A");
    case "i":
      return (i) => numberToRoman(i).toLowerCase();
    case "I":
      return (i) => numberToRoman(i);
    case "1":
    default:
      return (i) => i.toString();
  }
};
var splitClassesAndIds = function(selectors) {
  const classes = [];
  const ids = [];
  for (const selector of selectors) {
    if (selector.startsWith(".")) {
      classes.push(selector.substring(1));
    } else if (selector.startsWith("#")) {
      ids.push(selector.substring(1));
    }
  }
  return { classes, ids };
};
var isDataTable = function(attr, tables) {
  if (tables === true) {
    return true;
  }
  if (!attr) {
    return false;
  }
  const { classes, ids } = splitClassesAndIds(tables);
  const attrClasses = (attr["class"] || "").split(" ");
  const attrIds = (attr["id"] || "").split(" ");
  return attrClasses.some((x) => classes.includes(x)) || attrIds.some((x) => ids.includes(x));
};
var formatTable = function(elem, walk, builder, formatOptions) {
  return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);
};
var formatBlock = function(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });
};
var formatDataTable = function(elem, walk, builder, formatOptions) {
  builder.openTable();
  elem.children.forEach(walkTable);
  builder.closeTable({
    tableToString: (rows) => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),
    leadingLineBreaks: formatOptions.leadingLineBreaks,
    trailingLineBreaks: formatOptions.trailingLineBreaks
  });
  function formatCell(cellNode) {
    const colspan = +get(cellNode, ["attribs", "colspan"]) || 1;
    const rowspan = +get(cellNode, ["attribs", "rowspan"]) || 1;
    builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });
    walk(cellNode.children, builder);
    builder.closeTableCell({ colspan, rowspan });
  }
  function walkTable(elem2) {
    if (elem2.type !== "tag") {
      return;
    }
    const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? (cellNode) => {
      builder.pushWordTransform((str) => str.toUpperCase());
      formatCell(cellNode);
      builder.popWordTransform();
    } : formatCell;
    switch (elem2.name) {
      case "thead":
      case "tbody":
      case "tfoot":
      case "center":
        elem2.children.forEach(walkTable);
        return;
      case "tr": {
        builder.openTableRow();
        for (const childOfTr of elem2.children) {
          if (childOfTr.type !== "tag") {
            continue;
          }
          switch (childOfTr.name) {
            case "th": {
              formatHeaderCell(childOfTr);
              break;
            }
            case "td": {
              formatCell(childOfTr);
              break;
            }
          }
        }
        builder.closeTableRow();
        break;
      }
    }
  }
};
var compile = function(options = {}) {
  options = import_deepmerge.default(DEFAULT_OPTIONS, options, {
    arrayMerge: overwriteMerge,
    customMerge: (key) => key === "selectors" ? selectorsMerge : undefined
  });
  options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);
  options.selectors = mergeDuplicatesPreferLast(options.selectors, (s5) => s5.selector);
  handleDeprecatedOptions(options);
  return compile$1(options);
};
var convert5 = function(html, options = {}, metadata = undefined) {
  return compile(options)(html, metadata);
};
var handleDeprecatedOptions = function(options) {
  if (options.tags) {
    const tagDefinitions = Object.entries(options.tags).map(([selector, definition]) => ({ ...definition, selector: selector || "*" }));
    options.selectors.push(...tagDefinitions);
    options.selectors = mergeDuplicatesPreferLast(options.selectors, (s5) => s5.selector);
  }
  function set3(obj, path, value27) {
    const valueKey = path.pop();
    for (const key of path) {
      let nested = obj[key];
      if (!nested) {
        nested = {};
        obj[key] = nested;
      }
      obj = nested;
    }
    obj[valueKey] = value27;
  }
  if (options["baseElement"]) {
    const baseElement = options["baseElement"];
    set3(options, ["baseElements", "selectors"], Array.isArray(baseElement) ? baseElement : [baseElement]);
  }
  if (options["returnDomByDefault"] !== undefined) {
    set3(options, ["baseElements", "returnDomByDefault"], options["returnDomByDefault"]);
  }
  for (const definition of options.selectors) {
    if (definition.format === "anchor" && get(definition, ["options", "noLinkBrackets"])) {
      set3(definition, ["options", "linkBrackets"], false);
    }
  }
};
var overwriteMerge$1 = (acc, src, options) => [...src];
var I = ["I", "X", "C", "M"];
var V = ["V", "L", "D"];

class InlineTextBuilder {
  constructor(options, maxLineLength = undefined) {
    this.lines = [];
    this.nextLineWords = [];
    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;
    this.nextLineAvailableChars = this.maxLineLength;
    this.wrapCharacters = get(options, ["longWordSplit", "wrapCharacters"]) || [];
    this.forceWrapOnLimit = get(options, ["longWordSplit", "forceWrapOnLimit"]) || false;
    this.stashedSpace = false;
    this.wordBreakOpportunity = false;
  }
  pushWord(word, noWrap = false) {
    if (this.nextLineAvailableChars <= 0 && !noWrap) {
      this.startNewLine();
    }
    const isLineStart = this.nextLineWords.length === 0;
    const cost = word.length + (isLineStart ? 0 : 1);
    if (cost <= this.nextLineAvailableChars || noWrap) {
      this.nextLineWords.push(word);
      this.nextLineAvailableChars -= cost;
    } else {
      const [first, ...rest5] = this.splitLongWord(word);
      if (!isLineStart) {
        this.startNewLine();
      }
      this.nextLineWords.push(first);
      this.nextLineAvailableChars -= first.length;
      for (const part of rest5) {
        this.startNewLine();
        this.nextLineWords.push(part);
        this.nextLineAvailableChars -= part.length;
      }
    }
  }
  popWord() {
    const lastWord = this.nextLineWords.pop();
    if (lastWord !== undefined) {
      const isLineStart = this.nextLineWords.length === 0;
      const cost = lastWord.length + (isLineStart ? 0 : 1);
      this.nextLineAvailableChars += cost;
    }
    return lastWord;
  }
  concatWord(word, noWrap = false) {
    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {
      this.pushWord(word, noWrap);
      this.wordBreakOpportunity = false;
    } else {
      const lastWord = this.popWord();
      this.pushWord(lastWord ? lastWord.concat(word) : word, noWrap);
    }
  }
  startNewLine(n4 = 1) {
    this.lines.push(this.nextLineWords);
    if (n4 > 1) {
      this.lines.push(...Array.from({ length: n4 - 1 }, () => []));
    }
    this.nextLineWords = [];
    this.nextLineAvailableChars = this.maxLineLength;
  }
  isEmpty() {
    return this.lines.length === 0 && this.nextLineWords.length === 0;
  }
  clear() {
    this.lines.length = 0;
    this.nextLineWords.length = 0;
    this.nextLineAvailableChars = this.maxLineLength;
  }
  toString() {
    return [...this.lines, this.nextLineWords].map((words) => words.join(" ")).join("\n");
  }
  splitLongWord(word) {
    const parts = [];
    let idx = 0;
    while (word.length > this.maxLineLength) {
      const firstLine = word.substring(0, this.maxLineLength);
      const remainingChars = word.substring(this.maxLineLength);
      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);
      if (splitIndex > -1) {
        word = firstLine.substring(splitIndex + 1) + remainingChars;
        parts.push(firstLine.substring(0, splitIndex + 1));
      } else {
        idx++;
        if (idx < this.wrapCharacters.length) {
          word = firstLine + remainingChars;
        } else {
          if (this.forceWrapOnLimit) {
            parts.push(firstLine);
            word = remainingChars;
            if (word.length > this.maxLineLength) {
              continue;
            }
          } else {
            word = firstLine + remainingChars;
          }
          break;
        }
      }
    }
    parts.push(word);
    return parts;
  }
}

class StackItem {
  constructor(next = null) {
    this.next = next;
  }
  getRoot() {
    return this.next ? this.next : this;
  }
}

class BlockStackItem extends StackItem {
  constructor(options, next = null, leadingLineBreaks = 1, maxLineLength = undefined) {
    super(next);
    this.leadingLineBreaks = leadingLineBreaks;
    this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);
    this.rawText = "";
    this.stashedLineBreaks = 0;
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class ListStackItem extends BlockStackItem {
  constructor(options, next = null, {
    interRowLineBreaks = 1,
    leadingLineBreaks = 2,
    maxLineLength = undefined,
    maxPrefixLength = 0,
    prefixAlign = "left"
  } = {}) {
    super(options, next, leadingLineBreaks, maxLineLength);
    this.maxPrefixLength = maxPrefixLength;
    this.prefixAlign = prefixAlign;
    this.interRowLineBreaks = interRowLineBreaks;
  }
}

class ListItemStackItem extends BlockStackItem {
  constructor(options, next = null, {
    leadingLineBreaks = 1,
    maxLineLength = undefined,
    prefix = ""
  } = {}) {
    super(options, next, leadingLineBreaks, maxLineLength);
    this.prefix = prefix;
  }
}

class TableStackItem extends StackItem {
  constructor(next = null) {
    super(next);
    this.rows = [];
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class TableRowStackItem extends StackItem {
  constructor(next = null) {
    super(next);
    this.cells = [];
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class TableCellStackItem extends StackItem {
  constructor(options, next = null, maxColumnWidth = undefined) {
    super(next);
    this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);
    this.rawText = "";
    this.stashedLineBreaks = 0;
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class TransformerStackItem extends StackItem {
  constructor(next = null, transform9) {
    super(next);
    this.transform = transform9;
  }
}

class WhitespaceProcessor {
  constructor(options) {
    this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\n/g, "") : options.whitespaceCharacters;
    const whitespaceCodes = charactersToCodes(this.whitespaceChars);
    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);
    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]\$`);
    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*\$`);
    this.newlineOrNonWhitespaceRe = new RegExp(`(\\n|[^\\n${whitespaceCodes}])`, "g");
    this.newlineOrNonNewlineStringRe = new RegExp(`(\\n|[^\\n]+)`, "g");
    if (options.preserveNewlines) {
      const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, "gm");
      this.shrinkWrapAdd = function(text, inlineTextBuilder, transform9 = (str) => str, noWrap = false) {
        if (!text) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordOrNewlineRe.exec(text);
        if (m) {
          anyMatch = true;
          if (m[0] === "\n") {
            inlineTextBuilder.startNewLine();
          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
            inlineTextBuilder.pushWord(transform9(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform9(m[0]), noWrap);
          }
          while ((m = wordOrNewlineRe.exec(text)) !== null) {
            if (m[0] === "\n") {
              inlineTextBuilder.startNewLine();
            } else {
              inlineTextBuilder.pushWord(transform9(m[0]), noWrap);
            }
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);
      };
    } else {
      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, "g");
      this.shrinkWrapAdd = function(text, inlineTextBuilder, transform9 = (str) => str, noWrap = false) {
        if (!text) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordRe.exec(text);
        if (m) {
          anyMatch = true;
          if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
            inlineTextBuilder.pushWord(transform9(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform9(m[0]), noWrap);
          }
          while ((m = wordRe.exec(text)) !== null) {
            inlineTextBuilder.pushWord(transform9(m[0]), noWrap);
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);
      };
    }
  }
  addLiteral(text, inlineTextBuilder, noWrap = true) {
    if (!text) {
      return;
    }
    const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
    let anyMatch = false;
    let m = this.newlineOrNonNewlineStringRe.exec(text);
    if (m) {
      anyMatch = true;
      if (m[0] === "\n") {
        inlineTextBuilder.startNewLine();
      } else if (previouslyStashedSpace) {
        inlineTextBuilder.pushWord(m[0], noWrap);
      } else {
        inlineTextBuilder.concatWord(m[0], noWrap);
      }
      while ((m = this.newlineOrNonNewlineStringRe.exec(text)) !== null) {
        if (m[0] === "\n") {
          inlineTextBuilder.startNewLine();
        } else {
          inlineTextBuilder.pushWord(m[0], noWrap);
        }
      }
    }
    inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch;
  }
  testLeadingWhitespace(text) {
    return this.leadingWhitespaceRe.test(text);
  }
  testTrailingWhitespace(text) {
    return this.trailingWhitespaceRe.test(text);
  }
  testContainsWords(text) {
    return !this.allWhitespaceOrEmptyRe.test(text);
  }
  countNewlinesNoWords(text) {
    this.newlineOrNonWhitespaceRe.lastIndex = 0;
    let counter = 0;
    let match;
    while ((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null) {
      if (match[0] === "\n") {
        counter++;
      } else {
        return 0;
      }
    }
    return counter;
  }
}

class BlockTextBuilder {
  constructor(options, picker, metadata = undefined) {
    this.options = options;
    this.picker = picker;
    this.metadata = metadata;
    this.whitespaceProcessor = new WhitespaceProcessor(options);
    this._stackItem = new BlockStackItem(options);
    this._wordTransformer = undefined;
  }
  pushWordTransform(wordTransform) {
    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);
  }
  popWordTransform() {
    if (!this._wordTransformer) {
      return;
    }
    const transform9 = this._wordTransformer.transform;
    this._wordTransformer = this._wordTransformer.next;
    return transform9;
  }
  startNoWrap() {
    this._stackItem.isNoWrap = true;
  }
  stopNoWrap() {
    this._stackItem.isNoWrap = false;
  }
  _getCombinedWordTransformer() {
    const wt = this._wordTransformer ? (str) => applyTransformer(str, this._wordTransformer) : undefined;
    const ce = this.options.encodeCharacters;
    return wt ? ce ? (str) => ce(wt(str)) : wt : ce;
  }
  _popStackItem() {
    const item = this._stackItem;
    this._stackItem = item.next;
    return item;
  }
  addLineBreak() {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += "\n";
    } else {
      this._stackItem.inlineTextBuilder.startNewLine();
    }
  }
  addWordBreakOpportunity() {
    if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem) {
      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;
    }
  }
  addInline(str, { noWordTransform = false } = {}) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (str.length === 0 || this._stackItem.stashedLineBreaks && !this.whitespaceProcessor.testContainsWords(str)) {
      return;
    }
    if (this.options.preserveNewlines) {
      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);
      if (newlinesNumber > 0) {
        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);
        return;
      }
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, noWordTransform ? undefined : this._getCombinedWordTransformer(), this._stackItem.isNoWrap);
    this._stackItem.stashedLineBreaks = 0;
  }
  addLiteral(str) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (str.length === 0) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.addLiteral(str, this._stackItem.inlineTextBuilder, this._stackItem.isNoWrap);
    this._stackItem.stashedLineBreaks = 0;
  }
  openBlock({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {
    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);
    this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);
    if (isPre) {
      this._stackItem.isPre = true;
    }
  }
  closeBlock({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {
    const block = this._popStackItem();
    const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);
    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));
  }
  openList({ maxPrefixLength = 0, prefixAlign = "left", interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {
    this._stackItem = new ListStackItem(this.options, this._stackItem, {
      interRowLineBreaks,
      leadingLineBreaks,
      maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,
      maxPrefixLength,
      prefixAlign
    });
  }
  openListItem({ prefix = "" } = {}) {
    if (!(this._stackItem instanceof ListStackItem)) {
      throw new Error("Can\'t add a list item to something that is not a list! Check the formatter.");
    }
    const list = this._stackItem;
    const prefixLength = Math.max(prefix.length, list.maxPrefixLength);
    const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);
    this._stackItem = new ListItemStackItem(this.options, list, {
      prefix,
      maxLineLength,
      leadingLineBreaks: list.interRowLineBreaks
    });
  }
  closeListItem() {
    const listItem = this._popStackItem();
    const list = listItem.next;
    const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);
    const spacing = "\n" + " ".repeat(prefixLength);
    const prefix = list.prefixAlign === "right" ? listItem.prefix.padStart(prefixLength) : listItem.prefix.padEnd(prefixLength);
    const text = prefix + getText(listItem).replace(/\n/g, spacing);
    addText(list, text, listItem.leadingLineBreaks, Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks));
  }
  closeList({ trailingLineBreaks = 2 } = {}) {
    const list = this._popStackItem();
    const text = getText(list);
    if (text) {
      addText(this._stackItem, text, list.leadingLineBreaks, trailingLineBreaks);
    }
  }
  openTable() {
    this._stackItem = new TableStackItem(this._stackItem);
  }
  openTableRow() {
    if (!(this._stackItem instanceof TableStackItem)) {
      throw new Error("Can\'t add a table row to something that is not a table! Check the formatter.");
    }
    this._stackItem = new TableRowStackItem(this._stackItem);
  }
  openTableCell({ maxColumnWidth = undefined } = {}) {
    if (!(this._stackItem instanceof TableRowStackItem)) {
      throw new Error("Can\'t add a table cell to something that is not a table row! Check the formatter.");
    }
    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);
  }
  closeTableCell({ colspan = 1, rowspan = 1 } = {}) {
    const cell = this._popStackItem();
    const text = trimCharacter(getText(cell), "\n");
    cell.next.cells.push({ colspan, rowspan, text });
  }
  closeTableRow() {
    const row = this._popStackItem();
    row.next.rows.push(row.cells);
  }
  closeTable({ tableToString: tableToString2, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {
    const table = this._popStackItem();
    const output = tableToString2(table.rows);
    if (output) {
      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);
    }
  }
  toString() {
    return getText(this._stackItem.getRoot());
  }
}
var genericFormatters = Object.freeze({
  __proto__: null,
  block: formatBlock$1,
  blockHtml: formatBlockHtml,
  blockString: formatBlockString,
  blockTag: formatBlockTag,
  inline: formatInline,
  inlineHtml: formatInlineHtml,
  inlineString: formatInlineString,
  inlineSurround: formatInlineSurround,
  inlineTag: formatInlineTag,
  skip: formatSkip
});
var textFormatters = Object.freeze({
  __proto__: null,
  anchor: formatAnchor,
  blockquote: formatBlockquote,
  dataTable: formatDataTable,
  heading: formatHeading,
  horizontalLine: formatHorizontalLine,
  image: formatImage,
  lineBreak: formatLineBreak,
  orderedList: formatOrderedList,
  paragraph: formatParagraph,
  pre: formatPre,
  table: formatTable,
  unorderedList: formatUnorderedList,
  wbr: formatWbr
});
var DEFAULT_OPTIONS = {
  baseElements: {
    selectors: ["body"],
    orderBy: "selectors",
    returnDomByDefault: true
  },
  decodeEntities: true,
  encodeCharacters: {},
  formatters: {},
  limits: {
    ellipsis: "...",
    maxBaseElements: undefined,
    maxChildNodes: undefined,
    maxDepth: undefined,
    maxInputLength: 1 << 24
  },
  longWordSplit: {
    forceWrapOnLimit: false,
    wrapCharacters: []
  },
  preserveNewlines: false,
  selectors: [
    { selector: "*", format: "inline" },
    {
      selector: "a",
      format: "anchor",
      options: {
        baseUrl: null,
        hideLinkHrefIfSameAsText: false,
        ignoreHref: false,
        linkBrackets: ["[", "]"],
        noAnchorUrl: true
      }
    },
    { selector: "article", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "aside", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "blockquote",
      format: "blockquote",
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }
    },
    { selector: "br", format: "lineBreak" },
    { selector: "div", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "footer", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "form", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "h1", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h2", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h3", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h4", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h5", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h6", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "header", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "hr",
      format: "horizontalLine",
      options: { leadingLineBreaks: 2, length: undefined, trailingLineBreaks: 2 }
    },
    {
      selector: "img",
      format: "image",
      options: { baseUrl: null, linkBrackets: ["[", "]"] }
    },
    { selector: "main", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "nav", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "ol",
      format: "orderedList",
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: "p", format: "paragraph", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: "pre", format: "pre", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: "section", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "table",
      format: "table",
      options: {
        colSpacing: 3,
        leadingLineBreaks: 2,
        maxColumnWidth: 60,
        rowSpacing: 0,
        trailingLineBreaks: 2,
        uppercaseHeaderCells: true
      }
    },
    {
      selector: "ul",
      format: "unorderedList",
      options: { itemPrefix: " * ", leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: "wbr", format: "wbr" }
  ],
  tables: [],
  whitespaceCharacters: ` 	\r
\u200B`,
  wordwrap: 80
};
var concatMerge = (acc, src, options) => [...acc, ...src];
var overwriteMerge = (acc, src, options) => [...src];
var selectorsMerge = (acc, src, options) => acc.some((s5) => typeof s5 === "object") ? concatMerge(acc, src) : overwriteMerge(acc, src);

// ../sisventa/node_modules/@react-email/render/dist/index.mjs
var import_js_beautify = __toESM(require_js(), 1);
var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name2, symbol7) => {
  if (symbol7 = Symbol[name2])
    return symbol7;
  throw Error("Symbol." + name2 + " is not defined");
};
var __defNormalProp = (obj, key, value27) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value: value27 }) : obj[key] = value27;
var __spreadValues = (a3, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp2.call(b3, prop))
      __defNormalProp(a3, prop, b3[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b3)) {
      if (__propIsEnum.call(b3, prop))
        __defNormalProp(a3, prop, b3[prop]);
    }
  return a3;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value27) => {
      try {
        step(generator.next(value27));
      } catch (e4) {
        reject(e4);
      }
    };
    var rejected = (value27) => {
      try {
        step(generator.throw(value27));
      } catch (e4) {
        reject(e4);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value27) => yes({ value: value27, done }), no)))), method("next"), method("return"), it);
var defaults = {
  unformatted: ["code", "pre", "em", "strong", "span"],
  indent_inner_html: true,
  indent_char: " ",
  indent_size: 2,
  sep: "\n"
};
var pretty = (str, options = {}) => {
  return import_js_beautify.default.html(str, __spreadValues(__spreadValues({}, defaults), options));
};
var plainTextSelectors = [
  { selector: "img", format: "skip" },
  { selector: "#__react-email-preview", format: "skip" },
  {
    selector: "a",
    options: { linkBrackets: false }
  }
];
var decoder = new TextDecoder("utf-8");
var readStream = (readableStream) => __async(undefined, null, function* () {
  let result = "";
  if ("allReady" in readableStream) {
    const reader = readableStream.getReader();
    while (true) {
      const { value: value27, done } = yield reader.read();
      if (done) {
        break;
      }
      result += decoder.decode(value27);
    }
  } else {
    try {
      for (var iter = __forAwait(readableStream), more, temp, error41;more = !(temp = yield iter.next()).done; more = false) {
        const chunk = temp.value;
        result += decoder.decode(Buffer.from(chunk));
      }
    } catch (temp2) {
      error41 = [temp2];
    } finally {
      try {
        more && (temp = iter.return) && (yield temp.call(iter));
      } finally {
        if (error41)
          throw error41[0];
      }
    }
  }
  return result;
});
var renderAsync = (component, options) => __async(undefined, null, function* () {
  var _a2;
  const reactDOMServer = (yield Promise.resolve().then(() => (init_server_node(), exports_server_node))).default;
  const renderToStream = (_a2 = reactDOMServer.renderToReadableStream) != null ? _a2 : reactDOMServer.renderToStaticNodeStream;
  const doctype = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
  const htmlOrReadableStream = yield renderToStream(component);
  const html = typeof htmlOrReadableStream === "string" ? htmlOrReadableStream : yield readStream(htmlOrReadableStream);
  if (options == null ? undefined : options.plainText) {
    return convert5(html, __spreadValues({
      selectors: plainTextSelectors
    }, options.htmlToTextOptions));
  }
  const document2 = `${doctype}${html}`;
  if (options == null ? undefined : options.pretty) {
    return pretty(document2);
  }
  return document2;
});

// ../sisventa/node_modules/resend/dist/index.mjs
var __defProp3 = Object.defineProperty;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value27) => (key in obj) ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value: value27 }) : obj[key] = value27;
var __spreadValues2 = (a3, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp3.call(b3, prop))
      __defNormalProp2(a3, prop, b3[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b3)) {
      if (__propIsEnum2.call(b3, prop))
        __defNormalProp2(a3, prop, b3[prop]);
    }
  return a3;
};
var __async2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value27) => {
      try {
        step(generator.next(value27));
      } catch (e4) {
        reject(e4);
      }
    };
    var rejected = (value27) => {
      try {
        step(generator.throw(value27));
      } catch (e4) {
        reject(e4);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var version = "3.1.0";
var ApiKeys = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(_03) {
    return __async2(this, arguments, function* (payload, options = {}) {
      const data = yield this.resend.post("/api-keys", payload, options);
      return data;
    });
  }
  list() {
    return __async2(this, null, function* () {
      const data = yield this.resend.get("/api-keys");
      return data;
    });
  }
  remove(id) {
    return __async2(this, null, function* () {
      const data = yield this.resend.delete(`/api-keys/${id}`);
      return data;
    });
  }
};
var Audiences = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(_03) {
    return __async2(this, arguments, function* (payload, options = {}) {
      const data = yield this.resend.post("/audiences", payload, options);
      return data;
    });
  }
  list() {
    return __async2(this, null, function* () {
      const data = yield this.resend.get("/audiences");
      return data;
    });
  }
  get(id) {
    return __async2(this, null, function* () {
      const data = yield this.resend.get(`/audiences/${id}`);
      return data;
    });
  }
  remove(id) {
    return __async2(this, null, function* () {
      const data = yield this.resend.delete(`/audiences/${id}`);
      return data;
    });
  }
};
var Batch = class {
  constructor(resend) {
    this.resend = resend;
  }
  send(_03) {
    return __async2(this, arguments, function* (payload, options = {}) {
      return this.create(payload, options);
    });
  }
  create(_03) {
    return __async2(this, arguments, function* (payload, options = {}) {
      for (const email of payload) {
        if (email.react) {
          email.html = yield renderAsync(email.react);
          delete email.react;
        }
      }
      const data = yield this.resend.post("/emails/batch", payload, options);
      return data;
    });
  }
};
var Contacts = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(_03) {
    return __async2(this, arguments, function* (payload, options = {}) {
      const data = yield this.resend.post(`/audiences/${payload.audienceId}/contacts`, {
        unsubscribed: payload.unsubscribed,
        email: payload.email,
        first_name: payload.firstName,
        last_name: payload.lastName
      }, options);
      return data;
    });
  }
  list(options) {
    return __async2(this, null, function* () {
      const data = yield this.resend.get(`/audiences/${options.audienceId}/contacts`);
      return data;
    });
  }
  get(options) {
    return __async2(this, null, function* () {
      const data = yield this.resend.get(`/audiences/${options.audienceId}/contacts/${options.id}`);
      return data;
    });
  }
  update(payload) {
    return __async2(this, null, function* () {
      const data = yield this.resend.patch(`/audiences/${payload.audienceId}/contacts/${payload.id}`, {
        unsubscribed: payload.unsubscribed,
        first_name: payload.fistName,
        last_name: payload.lastName
      });
      return data;
    });
  }
  remove(payload) {
    return __async2(this, null, function* () {
      const data = yield this.resend.delete(`/audiences/${payload.audienceId}/contacts/${(payload == null ? undefined : payload.email) ? payload == null ? undefined : payload.email : payload == null ? undefined : payload.id}`);
      return data;
    });
  }
};
var Domains = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(_03) {
    return __async2(this, arguments, function* (payload, options = {}) {
      const data = yield this.resend.post("/domains", payload, options);
      return data;
    });
  }
  list() {
    return __async2(this, null, function* () {
      const data = yield this.resend.get("/domains");
      return data;
    });
  }
  get(id) {
    return __async2(this, null, function* () {
      const data = yield this.resend.get(`/domains/${id}`);
      return data;
    });
  }
  remove(id) {
    return __async2(this, null, function* () {
      const data = yield this.resend.delete(`/domains/${id}`);
      return data;
    });
  }
  verify(id) {
    return __async2(this, null, function* () {
      const data = yield this.resend.post(`/domains/${id}/verify`);
      return data;
    });
  }
};
var Emails = class {
  constructor(resend) {
    this.resend = resend;
  }
  send(_03) {
    return __async2(this, arguments, function* (payload, options = {}) {
      return this.create(payload, options);
    });
  }
  create(_03) {
    return __async2(this, arguments, function* (payload, options = {}) {
      if (payload.react) {
        payload.html = yield renderAsync(payload.react);
        delete payload.react;
      }
      const data = yield this.resend.post("/emails", payload, options);
      return data;
    });
  }
  get(id) {
    return __async2(this, null, function* () {
      const data = yield this.resend.get(`/emails/${id}`);
      return data;
    });
  }
};
var isResendErrorResponse = (response) => {
  if (typeof response !== "object" || response === null) {
    return false;
  }
  const error41 = response;
  if (typeof error41 !== "object" || error41 === null) {
    return false;
  }
  const { message, name: name2 } = error41;
  return typeof message === "string" && typeof name2 === "string";
};
var defaultBaseUrl = "https://api.resend.com";
var defaultUserAgent = `resend-node:${version}`;
var baseUrl = typeof process !== "undefined" && process.env ? process.env.RESEND_BASE_URL || defaultBaseUrl : defaultBaseUrl;
var userAgent = typeof process !== "undefined" && process.env ? process.env.RESEND_USER_AGENT || defaultUserAgent : defaultUserAgent;
var Resend = class {
  constructor(key) {
    this.key = key;
    this.apiKeys = new ApiKeys(this);
    this.audiences = new Audiences(this);
    this.batch = new Batch(this);
    this.contacts = new Contacts(this);
    this.domains = new Domains(this);
    this.emails = new Emails(this);
    if (!key) {
      if (typeof process !== "undefined" && process.env) {
        this.key = process.env.RESEND_API_KEY;
      }
      if (!this.key) {
        throw new Error('Missing API key. Pass it to the constructor `new Resend("re_123")`');
      }
    }
    this.headers = new Headers({
      Authorization: `Bearer ${this.key}`,
      "User-Agent": userAgent,
      "Content-Type": "application/json"
    });
  }
  fetchRequest(_03) {
    return __async2(this, arguments, function* (path, options = {}) {
      const response = yield fetch(`${baseUrl}${path}`, options);
      if (!response.ok) {
        const error41 = yield response.json();
        if (isResendErrorResponse(error41)) {
          return { data: null, error: error41 };
        }
        return { data: null, error: error41 };
      }
      const data = yield response.json();
      return { data, error: null };
    });
  }
  post(_03, _13) {
    return __async2(this, arguments, function* (path, entity, options = {}) {
      const requestOptions = __spreadValues2({
        method: "POST",
        headers: this.headers,
        body: JSON.stringify(entity)
      }, options);
      return this.fetchRequest(path, requestOptions);
    });
  }
  get(_03) {
    return __async2(this, arguments, function* (path, options = {}) {
      const requestOptions = __spreadValues2({
        method: "GET",
        headers: this.headers
      }, options);
      return this.fetchRequest(path, requestOptions);
    });
  }
  put(_03, _13) {
    return __async2(this, arguments, function* (path, entity, options = {}) {
      const requestOptions = __spreadValues2({
        method: "PUT",
        headers: this.headers,
        body: JSON.stringify(entity)
      }, options);
      return this.fetchRequest(path, requestOptions);
    });
  }
  patch(_03, _13) {
    return __async2(this, arguments, function* (path, entity, options = {}) {
      const requestOptions = __spreadValues2({
        method: "PATCH",
        headers: this.headers,
        body: JSON.stringify(entity)
      }, options);
      return this.fetchRequest(path, requestOptions);
    });
  }
  delete(path, query) {
    return __async2(this, null, function* () {
      const requestOptions = {
        method: "DELETE",
        headers: this.headers,
        body: JSON.stringify(query)
      };
      return this.fetchRequest(path, requestOptions);
    });
  }
};

// ../sisventa/src/controllers/loginController.ts
var Login = async (input) => {
  const {
    db,
    body,
    headers,
    cookie: { _secure }
  } = input;
  const tokenRecord = await db.token.findFirst({
    where: { token: _secure.value ?? "" }
  });
  if (tokenRecord) {
    return {
      status: false,
      msj: "Ya esta logeado"
    };
  }
  const user = await db.user.findUnique({
    where: {
      email: body.email
    },
    select: {
      id: true,
      name: true,
      email: true,
      role: true,
      password: true
    }
  });
  if (!user || !await comparePasswd(body.password, user.password))
    return {
      status: "error",
      msj: "Credenciales incorrectas"
    };
  delete user.password;
  const token3 = makeToken({ id: user.id, role: user.role }, "2d");
  const tokenSaved = await db.token.create({
    data: {
      userId: user.id,
      token: token3
    }
  });
  if (!tokenSaved)
    return "error";
  _secure.value = token3;
  _secure.httpOnly = true;
  _secure.domain = headers.host.split(":")[0];
  _secure.path = "/";
  return {
    status: true,
    token: token3
  };
};
var Logout = async ({ db, headers, cookie: { _secure } }) => {
  await db.token.deleteMany({
    where: {
      token: {
        contains: _secure.value
      }
    }
  });
  _secure.remove();
  _secure.domain = headers.host.split(":")[0];
  _secure.path = "/";
  _secure.httpOnly = true;
  return {
    status: "true",
    msj: "Session cerrada"
  };
};
var requestPasswd = async ({ body, db, headers }) => {
  const user = await db.user.findFirst({
    where: {
      email: body.email
    }
  });
  if (!user) {
    return {
      status: false,
      msj: "Este email no existe"
    };
  }
  const tok = makeToken({ id: user.id, role: "nothing" }, "10m");
  const url = headers.host + "/sisventa/auth/verify?auth=" + tok;
  const resend = new Resend("re_gJ9U29Ve_K3dA7LXQGLQgytPZhfcgc61X");
  const { data, error: error41 } = await resend.emails.send({
    from: "Triceratox <auth@triceratox.lat>",
    to: user.email,
    subject: "Reestablece tu contrase\xF1a",
    html: `<a href="${url}">${url}</a>`
  });
  if (error41) {
    return {
      status: false,
      msj: "Ha currido un error"
    };
  }
  return {
    status: true,
    msj: "Email fue enviado a tu correo"
  };
};
var verify = async ({ query, body, db }) => {
  const user = await verifyToken(query.auth, null, false);
  if (!user) {
    return {
      status: "false",
      code: 404
    };
  }
  if (body.confirm !== body.passwd) {
    return {
      status: false,
      msj: "Las contrase\xF1as no coinciden"
    };
  }
  const updated = await db.user.update({
    where: {
      id: user.id
    },
    data: {
      password: await makePasswd(body.passwd)
    }
  });
  return {
    status: true,
    msj: "Contrase\xF1a actualizada correctamente"
  };
};

// ../sisventa/src/middlewares/validation.ts
var Validation = async (app, schema) => {
  const method = app.request.method;
  const id = app.params?.id ? app.params.id : method === "PUT" ? app.store.user.id : undefined;
  try {
    await schema[0](id).validate(app.body, { abortEarly: false });
  } catch (err) {
    var val = {};
    err.inner.map((x) => {
      val[x.path] = x.message;
    });
    return {
      status: false,
      errors: val
    };
  }
};
var validation_default = Validation;

// ../sisventa/node_modules/yup/index.esm.js
var import_property_expr = __toESM(require_property_expr(), 1);
var import_tiny_case = __toESM(require_tiny_case(), 1);
var import_toposort = __toESM(require_toposort(), 1);
var printNumber = function(val) {
  if (val != +val)
    return "NaN";
  const isNegativeZero = val === 0 && 1 / val < 0;
  return isNegativeZero ? "-0" : "" + val;
};
var printSimpleValue = function(val, quoteStrings = false) {
  if (val == null || val === true || val === false)
    return "" + val;
  const typeOf = typeof val;
  if (typeOf === "number")
    return printNumber(val);
  if (typeOf === "string")
    return quoteStrings ? `"${val}"` : val;
  if (typeOf === "function")
    return "[Function " + (val.name || "anonymous") + "]";
  if (typeOf === "symbol")
    return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
  const tag = toString2.call(val).slice(8, -1);
  if (tag === "Date")
    return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
  if (tag === "Error" || val instanceof Error)
    return "[" + errorToString.call(val) + "]";
  if (tag === "RegExp")
    return regExpToString.call(val);
  return null;
};
var printValue = function(value27, quoteStrings) {
  let result = printSimpleValue(value27, quoteStrings);
  if (result !== null)
    return result;
  return JSON.stringify(value27, function(key, value28) {
    let result2 = printSimpleValue(this[key], quoteStrings);
    if (result2 !== null)
      return result2;
    return value28;
  }, 2);
};
var toArray = function(value27) {
  return value27 == null ? [] : [].concat(value27);
};
var createValidation = function(config2) {
  function validate({
    value: value27,
    path = "",
    options,
    originalValue,
    schema
  }, panic, next) {
    const {
      name: name2,
      test,
      params,
      message,
      skipAbsent
    } = config2;
    let {
      parent,
      context,
      abortEarly = schema.spec.abortEarly,
      disableStackTrace = schema.spec.disableStackTrace
    } = options;
    function resolve(item) {
      return Reference.isRef(item) ? item.getValue(value27, parent, context) : item;
    }
    function createError(overrides = {}) {
      var _overrides$disableSta;
      const nextParams = Object.assign({
        value: value27,
        originalValue,
        label: schema.spec.label,
        path: overrides.path || path,
        spec: schema.spec
      }, params, overrides.params);
      for (const key of Object.keys(nextParams))
        nextParams[key] = resolve(nextParams[key]);
      const error41 = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value27, nextParams.path, overrides.type || name2, (_overrides$disableSta = overrides.disableStackTrace) != null ? _overrides$disableSta : disableStackTrace);
      error41.params = nextParams;
      return error41;
    }
    const invalid = abortEarly ? panic : next;
    let ctx = {
      path,
      parent,
      type: name2,
      from: options.from,
      createError,
      resolve,
      options,
      originalValue,
      schema
    };
    const handleResult = (validOrError) => {
      if (ValidationError.isError(validOrError))
        invalid(validOrError);
      else if (!validOrError)
        invalid(createError());
      else
        next(null);
    };
    const handleError = (err) => {
      if (ValidationError.isError(err))
        invalid(err);
      else
        panic(err);
    };
    const shouldSkip = skipAbsent && isAbsent(value27);
    if (shouldSkip) {
      return handleResult(true);
    }
    let result;
    try {
      var _result;
      result = test.call(ctx, value27, ctx);
      if (typeof ((_result = result) == null ? undefined : _result.then) === "function") {
        if (options.sync) {
          throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. ` + `This test will finish after the validate call has returned`);
        }
        return Promise.resolve(result).then(handleResult, handleError);
      }
    } catch (err) {
      handleError(err);
      return;
    }
    handleResult(result);
  }
  validate.OPTIONS = config2;
  return validate;
};
var getIn = function(schema, path, value27, context = value27) {
  let parent, lastPart, lastPartDebug;
  if (!path)
    return {
      parent,
      parentPath: path,
      schema
    };
  import_property_expr.forEach(path, (_part, isBracket, isArray) => {
    let part = isBracket ? _part.slice(1, _part.length - 1) : _part;
    schema = schema.resolve({
      context,
      parent,
      value: value27
    });
    let isTuple = schema.type === "tuple";
    let idx = isArray ? parseInt(part, 10) : 0;
    if (schema.innerType || isTuple) {
      if (isTuple && !isArray)
        throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${lastPartDebug}" must contain an index to the tuple element, e.g. "${lastPartDebug}[0]"`);
      if (value27 && idx >= value27.length) {
        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. ` + `because there is no value at that index. `);
      }
      parent = value27;
      value27 = value27 && value27[idx];
      schema = isTuple ? schema.spec.types[idx] : schema.innerType;
    }
    if (!isArray) {
      if (!schema.fields || !schema.fields[part])
        throw new Error(`The schema does not contain the path: ${path}. ` + `(failed at: ${lastPartDebug} which is a type: "${schema.type}")`);
      parent = value27;
      value27 = value27 && value27[part];
      schema = schema.fields[part];
    }
    lastPart = part;
    lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
  });
  return {
    schema,
    parent,
    parentPath: lastPart
  };
};
var clone21 = function(src, seen = new Map) {
  if (isSchema(src) || !src || typeof src !== "object")
    return src;
  if (seen.has(src))
    return seen.get(src);
  let copy;
  if (src instanceof Date) {
    copy = new Date(src.getTime());
    seen.set(src, copy);
  } else if (src instanceof RegExp) {
    copy = new RegExp(src);
    seen.set(src, copy);
  } else if (Array.isArray(src)) {
    copy = new Array(src.length);
    seen.set(src, copy);
    for (let i = 0;i < src.length; i++)
      copy[i] = clone21(src[i], seen);
  } else if (src instanceof Map) {
    copy = new Map;
    seen.set(src, copy);
    for (const [k3, v3] of src.entries())
      copy.set(k3, clone21(v3, seen));
  } else if (src instanceof Set) {
    copy = new Set;
    seen.set(src, copy);
    for (const v3 of src)
      copy.add(clone21(v3, seen));
  } else if (src instanceof Object) {
    copy = {};
    seen.set(src, copy);
    for (const [k3, v3] of Object.entries(src))
      copy[k3] = clone21(v3, seen);
  } else {
    throw Error(`Unable to clone ${src}`);
  }
  return copy;
};
var create$8 = function(spec) {
  return new MixedSchema(spec);
};
var create$7 = function() {
  return new BooleanSchema;
};
var create$6 = function() {
  return new StringSchema;
};
var create$5 = function() {
  return new NumberSchema;
};
var toNumber = function(str, defaultValue = 0) {
  return Number(str) || defaultValue;
};
var parseIsoDate = function(date7) {
  const regexResult = isoReg.exec(date7);
  if (!regexResult)
    return Date.parse ? Date.parse(date7) : Number.NaN;
  const struct = {
    year: toNumber(regexResult[1]),
    month: toNumber(regexResult[2], 1) - 1,
    day: toNumber(regexResult[3], 1),
    hour: toNumber(regexResult[4]),
    minute: toNumber(regexResult[5]),
    second: toNumber(regexResult[6]),
    millisecond: regexResult[7] ? toNumber(regexResult[7].substring(0, 3)) : 0,
    z: regexResult[8] || undefined,
    plusMinus: regexResult[9] || undefined,
    hourOffset: toNumber(regexResult[10]),
    minuteOffset: toNumber(regexResult[11])
  };
  if (struct.z === undefined && struct.plusMinus === undefined) {
    return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();
  }
  let totalMinutesOffset = 0;
  if (struct.z !== "Z" && struct.plusMinus !== undefined) {
    totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;
    if (struct.plusMinus === "+")
      totalMinutesOffset = 0 - totalMinutesOffset;
  }
  return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);
};
var create$4 = function() {
  return new DateSchema;
};
var sortFields = function(fields, excludedEdges = []) {
  let edges = [];
  let nodes = new Set;
  let excludes = new Set(excludedEdges.map(([a3, b3]) => `${a3}-${b3}`));
  function addNode(depPath, key) {
    let node3 = import_property_expr.split(depPath)[0];
    nodes.add(node3);
    if (!excludes.has(`${key}-${node3}`))
      edges.push([key, node3]);
  }
  for (const key of Object.keys(fields)) {
    let value27 = fields[key];
    nodes.add(key);
    if (Reference.isRef(value27) && value27.isSibling)
      addNode(value27.path, key);
    else if (isSchema(value27) && "deps" in value27)
      value27.deps.forEach((path) => addNode(path, key));
  }
  return import_toposort.default.array(Array.from(nodes), edges).reverse();
};
var findIndex = function(arr, err) {
  let idx = Infinity;
  arr.some((key, ii) => {
    var _err$path;
    if ((_err$path = err.path) != null && _err$path.includes(key)) {
      idx = ii;
      return true;
    }
  });
  return idx;
};
var sortByKeyOrder = function(keys) {
  return (a3, b3) => {
    return findIndex(keys, a3) - findIndex(keys, b3);
  };
};
var deepPartial = function(schema) {
  if ("fields" in schema) {
    const partial7 = {};
    for (const [key, fieldSchema] of Object.entries(schema.fields)) {
      partial7[key] = deepPartial(fieldSchema);
    }
    return schema.setFields(partial7);
  }
  if (schema.type === "array") {
    const nextArray = schema.optional();
    if (nextArray.innerType)
      nextArray.innerType = deepPartial(nextArray.innerType);
    return nextArray;
  }
  if (schema.type === "tuple") {
    return schema.optional().clone({
      types: schema.spec.types.map(deepPartial)
    });
  }
  if ("optional" in schema) {
    return schema.optional();
  }
  return schema;
};
var unknown11 = function(ctx, value27) {
  let known = Object.keys(ctx.fields);
  return Object.keys(value27).filter((key) => known.indexOf(key) === -1);
};
var create$3 = function(spec) {
  return new ObjectSchema(spec);
};
var create$2 = function(type145) {
  return new ArraySchema(type145);
};
var create$1 = function(schemas) {
  return new TupleSchema(schemas);
};
var toString2 = Object.prototype.toString;
var errorToString = Error.prototype.toString;
var regExpToString = RegExp.prototype.toString;
var symbolToString = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
var _Symbol$toStringTag;
var strReg = /\$\{\s*(\w+)\s*\}/g;
_Symbol$toStringTag = Symbol.toStringTag;

class ValidationError extends Error {
  static formatError(message, params) {
    const path = params.label || params.path || "this";
    if (path !== params.path)
      params = Object.assign({}, params, {
        path
      });
    if (typeof message === "string")
      return message.replace(strReg, (_, key) => printValue(params[key]));
    if (typeof message === "function")
      return message(params);
    return message;
  }
  static isError(err) {
    return err && err.name === "ValidationError";
  }
  constructor(errorOrErrors, value27, field, type145, disableStack) {
    super();
    this.value = undefined;
    this.path = undefined;
    this.type = undefined;
    this.errors = undefined;
    this.params = undefined;
    this.inner = undefined;
    this[_Symbol$toStringTag] = "Error";
    this.name = "ValidationError";
    this.value = value27;
    this.path = field;
    this.type = type145;
    this.errors = [];
    this.inner = [];
    toArray(errorOrErrors).forEach((err) => {
      if (ValidationError.isError(err)) {
        this.errors.push(...err.errors);
        const innerErrors = err.inner.length ? err.inner : [err];
        this.inner.push(...innerErrors);
      } else {
        this.errors.push(err);
      }
    });
    this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
    if (!disableStack && Error.captureStackTrace)
      Error.captureStackTrace(this, ValidationError);
  }
}
var mixed = {
  default: "${path} is invalid",
  required: "${path} is a required field",
  defined: "${path} must be defined",
  notNull: "${path} cannot be null",
  oneOf: "${path} must be one of the following values: ${values}",
  notOneOf: "${path} must not be one of the following values: ${values}",
  notType: ({
    path,
    type: type145,
    value: value27,
    originalValue
  }) => {
    const castMsg = originalValue != null && originalValue !== value27 ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".";
    return type145 !== "mixed" ? `${path} must be a \`${type145}\` type, ` + `but the final value was: \`${printValue(value27, true)}\`` + castMsg : `${path} must match the configured type. ` + `The validated value was: \`${printValue(value27, true)}\`` + castMsg;
  }
};
var string11 = {
  length: "${path} must be exactly ${length} characters",
  min: "${path} must be at least ${min} characters",
  max: "${path} must be at most ${max} characters",
  matches: '${path} must match the following: "${regex}"',
  email: "${path} must be a valid email",
  url: "${path} must be a valid URL",
  uuid: "${path} must be a valid UUID",
  trim: "${path} must be a trimmed string",
  lowercase: "${path} must be a lowercase string",
  uppercase: "${path} must be a upper case string"
};
var number11 = {
  min: "${path} must be greater than or equal to ${min}",
  max: "${path} must be less than or equal to ${max}",
  lessThan: "${path} must be less than ${less}",
  moreThan: "${path} must be greater than ${more}",
  positive: "${path} must be a positive number",
  negative: "${path} must be a negative number",
  integer: "${path} must be an integer"
};
var date7 = {
  min: "${path} field must be later than ${min}",
  max: "${path} field must be at earlier than ${max}"
};
var boolean7 = {
  isValue: "${path} field must be ${value}"
};
var object23 = {
  noUnknown: "${path} field has unspecified keys: ${unknown}"
};
var array7 = {
  min: "${path} field must have at least ${min} items",
  max: "${path} field must have less than or equal to ${max} items",
  length: "${path} must have ${length} items"
};
var tuple13 = {
  notType: (params) => {
    const {
      path,
      value: value27,
      spec
    } = params;
    const typeLen = spec.types.length;
    if (Array.isArray(value27)) {
      if (value27.length < typeLen)
        return `${path} tuple value has too few items, expected a length of ${typeLen} but got ${value27.length} for value: \`${printValue(value27, true)}\``;
      if (value27.length > typeLen)
        return `${path} tuple value has too many items, expected a length of ${typeLen} but got ${value27.length} for value: \`${printValue(value27, true)}\``;
    }
    return ValidationError.formatError(mixed.notType, params);
  }
};
var locale = Object.assign(Object.create(null), {
  mixed,
  string: string11,
  number: number11,
  date: date7,
  object: object23,
  array: array7,
  boolean: boolean7,
  tuple: tuple13
});
var isSchema = (obj) => obj && obj.__isYupSchema__;

class Condition {
  static fromOptions(refs, config2) {
    if (!config2.then && !config2.otherwise)
      throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
    let {
      is,
      then,
      otherwise: otherwise2
    } = config2;
    let check19 = typeof is === "function" ? is : (...values) => values.every((value27) => value27 === is);
    return new Condition(refs, (values, schema) => {
      var _branch;
      let branch = check19(...values) ? then : otherwise2;
      return (_branch = branch == null ? undefined : branch(schema)) != null ? _branch : schema;
    });
  }
  constructor(refs, builder) {
    this.fn = undefined;
    this.refs = refs;
    this.refs = refs;
    this.fn = builder;
  }
  resolve(base, options) {
    let values = this.refs.map((ref5) => ref5.getValue(options == null ? undefined : options.value, options == null ? undefined : options.parent, options == null ? undefined : options.context));
    let schema = this.fn(values, base, options);
    if (schema === undefined || schema === base) {
      return base;
    }
    if (!isSchema(schema))
      throw new TypeError("conditions must return a schema object");
    return schema.resolve(options);
  }
}
var prefixes = {
  context: "$",
  value: "."
};

class Reference {
  constructor(key, options = {}) {
    this.key = undefined;
    this.isContext = undefined;
    this.isValue = undefined;
    this.isSibling = undefined;
    this.path = undefined;
    this.getter = undefined;
    this.map = undefined;
    if (typeof key !== "string")
      throw new TypeError("ref must be a string, got: " + key);
    this.key = key.trim();
    if (key === "")
      throw new TypeError("ref must be a non-empty string");
    this.isContext = this.key[0] === prefixes.context;
    this.isValue = this.key[0] === prefixes.value;
    this.isSibling = !this.isContext && !this.isValue;
    let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
    this.path = this.key.slice(prefix.length);
    this.getter = this.path && import_property_expr.getter(this.path, true);
    this.map = options.map;
  }
  getValue(value27, parent, context) {
    let result = this.isContext ? context : this.isValue ? value27 : parent;
    if (this.getter)
      result = this.getter(result || {});
    if (this.map)
      result = this.map(result);
    return result;
  }
  cast(value27, options) {
    return this.getValue(value27, options == null ? undefined : options.parent, options == null ? undefined : options.context);
  }
  resolve() {
    return this;
  }
  describe() {
    return {
      type: "ref",
      key: this.key
    };
  }
  toString() {
    return `Ref(${this.key})`;
  }
  static isRef(value27) {
    return value27 && value27.__isYupRef;
  }
}
Reference.prototype.__isYupRef = true;
var isAbsent = (value27) => value27 == null;

class ReferenceSet extends Set {
  describe() {
    const description = [];
    for (const item of this.values()) {
      description.push(Reference.isRef(item) ? item.describe() : item);
    }
    return description;
  }
  resolveAll(resolve) {
    let result = [];
    for (const item of this.values()) {
      result.push(resolve(item));
    }
    return result;
  }
  clone() {
    return new ReferenceSet(this.values());
  }
  merge(newItems, removeItems) {
    const next = this.clone();
    newItems.forEach((value27) => next.add(value27));
    removeItems.forEach((value27) => next.delete(value27));
    return next;
  }
}

class Schema {
  constructor(options) {
    this.type = undefined;
    this.deps = [];
    this.tests = undefined;
    this.transforms = undefined;
    this.conditions = [];
    this._mutate = undefined;
    this.internalTests = {};
    this._whitelist = new ReferenceSet;
    this._blacklist = new ReferenceSet;
    this.exclusiveTests = Object.create(null);
    this._typeCheck = undefined;
    this.spec = undefined;
    this.tests = [];
    this.transforms = [];
    this.withMutation(() => {
      this.typeError(mixed.notType);
    });
    this.type = options.type;
    this._typeCheck = options.check;
    this.spec = Object.assign({
      strip: false,
      strict: false,
      abortEarly: true,
      recursive: true,
      disableStackTrace: false,
      nullable: false,
      optional: true,
      coerce: true
    }, options == null ? undefined : options.spec);
    this.withMutation((s5) => {
      s5.nonNullable();
    });
  }
  get _type() {
    return this.type;
  }
  clone(spec) {
    if (this._mutate) {
      if (spec)
        Object.assign(this.spec, spec);
      return this;
    }
    const next = Object.create(Object.getPrototypeOf(this));
    next.type = this.type;
    next._typeCheck = this._typeCheck;
    next._whitelist = this._whitelist.clone();
    next._blacklist = this._blacklist.clone();
    next.internalTests = Object.assign({}, this.internalTests);
    next.exclusiveTests = Object.assign({}, this.exclusiveTests);
    next.deps = [...this.deps];
    next.conditions = [...this.conditions];
    next.tests = [...this.tests];
    next.transforms = [...this.transforms];
    next.spec = clone21(Object.assign({}, this.spec, spec));
    return next;
  }
  label(label) {
    let next = this.clone();
    next.spec.label = label;
    return next;
  }
  meta(...args) {
    if (args.length === 0)
      return this.spec.meta;
    let next = this.clone();
    next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
    return next;
  }
  withMutation(fn) {
    let before = this._mutate;
    this._mutate = true;
    let result = fn(this);
    this._mutate = before;
    return result;
  }
  concat(schema) {
    if (!schema || schema === this)
      return this;
    if (schema.type !== this.type && this.type !== "mixed")
      throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
    let base = this;
    let combined = schema.clone();
    const mergedSpec = Object.assign({}, base.spec, combined.spec);
    combined.spec = mergedSpec;
    combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);
    combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
    combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);
    combined.tests = base.tests;
    combined.exclusiveTests = base.exclusiveTests;
    combined.withMutation((next) => {
      schema.tests.forEach((fn) => {
        next.test(fn.OPTIONS);
      });
    });
    combined.transforms = [...base.transforms, ...combined.transforms];
    return combined;
  }
  isType(v3) {
    if (v3 == null) {
      if (this.spec.nullable && v3 === null)
        return true;
      if (this.spec.optional && v3 === undefined)
        return true;
      return false;
    }
    return this._typeCheck(v3);
  }
  resolve(options) {
    let schema = this;
    if (schema.conditions.length) {
      let conditions = schema.conditions;
      schema = schema.clone();
      schema.conditions = [];
      schema = conditions.reduce((prevSchema, condition) => condition.resolve(prevSchema, options), schema);
      schema = schema.resolve(options);
    }
    return schema;
  }
  resolveOptions(options) {
    var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;
    return Object.assign({}, options, {
      from: options.from || [],
      strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,
      abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,
      recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive,
      disableStackTrace: (_options$disableStack = options.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace
    });
  }
  cast(value27, options = {}) {
    let resolvedSchema = this.resolve(Object.assign({
      value: value27
    }, options));
    let allowOptionality = options.assert === "ignore-optionality";
    let result = resolvedSchema._cast(value27, options);
    if (options.assert !== false && !resolvedSchema.isType(result)) {
      if (allowOptionality && isAbsent(result)) {
        return result;
      }
      let formattedValue = printValue(value27);
      let formattedResult = printValue(result);
      throw new TypeError(`The value of ${options.path || "field"} could not be cast to a value ` + `that satisfies the schema type: "${resolvedSchema.type}". \n\n` + `attempted value: ${formattedValue} \n` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
    }
    return result;
  }
  _cast(rawValue, options) {
    let value27 = rawValue === undefined ? rawValue : this.transforms.reduce((prevValue, fn) => fn.call(this, prevValue, rawValue, this), rawValue);
    if (value27 === undefined) {
      value27 = this.getDefault(options);
    }
    return value27;
  }
  _validate(_value, options = {}, panic, next) {
    let {
      path,
      originalValue = _value,
      strict: strict5 = this.spec.strict
    } = options;
    let value27 = _value;
    if (!strict5) {
      value27 = this._cast(value27, Object.assign({
        assert: false
      }, options));
    }
    let initialTests = [];
    for (let test of Object.values(this.internalTests)) {
      if (test)
        initialTests.push(test);
    }
    this.runTests({
      path,
      value: value27,
      originalValue,
      options,
      tests: initialTests
    }, panic, (initialErrors) => {
      if (initialErrors.length) {
        return next(initialErrors, value27);
      }
      this.runTests({
        path,
        value: value27,
        originalValue,
        options,
        tests: this.tests
      }, panic, next);
    });
  }
  runTests(runOptions, panic, next) {
    let fired = false;
    let {
      tests,
      value: value27,
      originalValue,
      path,
      options
    } = runOptions;
    let panicOnce = (arg) => {
      if (fired)
        return;
      fired = true;
      panic(arg, value27);
    };
    let nextOnce = (arg) => {
      if (fired)
        return;
      fired = true;
      next(arg, value27);
    };
    let count = tests.length;
    let nestedErrors = [];
    if (!count)
      return nextOnce([]);
    let args = {
      value: value27,
      originalValue,
      path,
      options,
      schema: this
    };
    for (let i = 0;i < tests.length; i++) {
      const test = tests[i];
      test(args, panicOnce, function finishTestRun(err) {
        if (err) {
          Array.isArray(err) ? nestedErrors.push(...err) : nestedErrors.push(err);
        }
        if (--count <= 0) {
          nextOnce(nestedErrors);
        }
      });
    }
  }
  asNestedTest({
    key,
    index,
    parent,
    parentPath,
    originalParent,
    options
  }) {
    const k3 = key != null ? key : index;
    if (k3 == null) {
      throw TypeError("Must include `key` or `index` for nested validations");
    }
    const isIndex = typeof k3 === "number";
    let value27 = parent[k3];
    const testOptions = Object.assign({}, options, {
      strict: true,
      parent,
      value: value27,
      originalValue: originalParent[k3],
      key: undefined,
      [isIndex ? "index" : "key"]: k3,
      path: isIndex || k3.includes(".") ? `${parentPath || ""}[${value27 ? k3 : `"${k3}"`}]` : (parentPath ? `${parentPath}.` : "") + key
    });
    return (_, panic, next) => this.resolve(testOptions)._validate(value27, testOptions, panic, next);
  }
  validate(value27, options) {
    var _options$disableStack2;
    let schema = this.resolve(Object.assign({}, options, {
      value: value27
    }));
    let disableStackTrace = (_options$disableStack2 = options == null ? undefined : options.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;
    return new Promise((resolve, reject) => schema._validate(value27, options, (error41, parsed) => {
      if (ValidationError.isError(error41))
        error41.value = parsed;
      reject(error41);
    }, (errors7, validated) => {
      if (errors7.length)
        reject(new ValidationError(errors7, validated, undefined, undefined, disableStackTrace));
      else
        resolve(validated);
    }));
  }
  validateSync(value27, options) {
    var _options$disableStack3;
    let schema = this.resolve(Object.assign({}, options, {
      value: value27
    }));
    let result;
    let disableStackTrace = (_options$disableStack3 = options == null ? undefined : options.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;
    schema._validate(value27, Object.assign({}, options, {
      sync: true
    }), (error41, parsed) => {
      if (ValidationError.isError(error41))
        error41.value = parsed;
      throw error41;
    }, (errors7, validated) => {
      if (errors7.length)
        throw new ValidationError(errors7, value27, undefined, undefined, disableStackTrace);
      result = validated;
    });
    return result;
  }
  isValid(value27, options) {
    return this.validate(value27, options).then(() => true, (err) => {
      if (ValidationError.isError(err))
        return false;
      throw err;
    });
  }
  isValidSync(value27, options) {
    try {
      this.validateSync(value27, options);
      return true;
    } catch (err) {
      if (ValidationError.isError(err))
        return false;
      throw err;
    }
  }
  _getDefault(options) {
    let defaultValue = this.spec.default;
    if (defaultValue == null) {
      return defaultValue;
    }
    return typeof defaultValue === "function" ? defaultValue.call(this, options) : clone21(defaultValue);
  }
  getDefault(options) {
    let schema = this.resolve(options || {});
    return schema._getDefault(options);
  }
  default(def) {
    if (arguments.length === 0) {
      return this._getDefault();
    }
    let next = this.clone({
      default: def
    });
    return next;
  }
  strict(isStrict = true) {
    return this.clone({
      strict: isStrict
    });
  }
  nullability(nullable, message) {
    const next = this.clone({
      nullable
    });
    next.internalTests.nullable = createValidation({
      message,
      name: "nullable",
      test(value27) {
        return value27 === null ? this.schema.spec.nullable : true;
      }
    });
    return next;
  }
  optionality(optional17, message) {
    const next = this.clone({
      optional: optional17
    });
    next.internalTests.optionality = createValidation({
      message,
      name: "optionality",
      test(value27) {
        return value27 === undefined ? this.schema.spec.optional : true;
      }
    });
    return next;
  }
  optional() {
    return this.optionality(true);
  }
  defined(message = mixed.defined) {
    return this.optionality(false, message);
  }
  nullable() {
    return this.nullability(true);
  }
  nonNullable(message = mixed.notNull) {
    return this.nullability(false, message);
  }
  required(message = mixed.required) {
    return this.clone().withMutation((next) => next.nonNullable(message).defined(message));
  }
  notRequired() {
    return this.clone().withMutation((next) => next.nullable().optional());
  }
  transform(fn) {
    let next = this.clone();
    next.transforms.push(fn);
    return next;
  }
  test(...args) {
    let opts;
    if (args.length === 1) {
      if (typeof args[0] === "function") {
        opts = {
          test: args[0]
        };
      } else {
        opts = args[0];
      }
    } else if (args.length === 2) {
      opts = {
        name: args[0],
        test: args[1]
      };
    } else {
      opts = {
        name: args[0],
        message: args[1],
        test: args[2]
      };
    }
    if (opts.message === undefined)
      opts.message = mixed.default;
    if (typeof opts.test !== "function")
      throw new TypeError("`test` is a required parameters");
    let next = this.clone();
    let validate = createValidation(opts);
    let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
    if (opts.exclusive) {
      if (!opts.name)
        throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
    }
    if (opts.name)
      next.exclusiveTests[opts.name] = !!opts.exclusive;
    next.tests = next.tests.filter((fn) => {
      if (fn.OPTIONS.name === opts.name) {
        if (isExclusive)
          return false;
        if (fn.OPTIONS.test === validate.OPTIONS.test)
          return false;
      }
      return true;
    });
    next.tests.push(validate);
    return next;
  }
  when(keys, options) {
    if (!Array.isArray(keys) && typeof keys !== "string") {
      options = keys;
      keys = ".";
    }
    let next = this.clone();
    let deps = toArray(keys).map((key) => new Reference(key));
    deps.forEach((dep) => {
      if (dep.isSibling)
        next.deps.push(dep.key);
    });
    next.conditions.push(typeof options === "function" ? new Condition(deps, options) : Condition.fromOptions(deps, options));
    return next;
  }
  typeError(message) {
    let next = this.clone();
    next.internalTests.typeError = createValidation({
      message,
      name: "typeError",
      skipAbsent: true,
      test(value27) {
        if (!this.schema._typeCheck(value27))
          return this.createError({
            params: {
              type: this.schema.type
            }
          });
        return true;
      }
    });
    return next;
  }
  oneOf(enums, message = mixed.oneOf) {
    let next = this.clone();
    enums.forEach((val) => {
      next._whitelist.add(val);
      next._blacklist.delete(val);
    });
    next.internalTests.whiteList = createValidation({
      message,
      name: "oneOf",
      skipAbsent: true,
      test(value27) {
        let valids = this.schema._whitelist;
        let resolved = valids.resolveAll(this.resolve);
        return resolved.includes(value27) ? true : this.createError({
          params: {
            values: Array.from(valids).join(", "),
            resolved
          }
        });
      }
    });
    return next;
  }
  notOneOf(enums, message = mixed.notOneOf) {
    let next = this.clone();
    enums.forEach((val) => {
      next._blacklist.add(val);
      next._whitelist.delete(val);
    });
    next.internalTests.blacklist = createValidation({
      message,
      name: "notOneOf",
      test(value27) {
        let invalids = this.schema._blacklist;
        let resolved = invalids.resolveAll(this.resolve);
        if (resolved.includes(value27))
          return this.createError({
            params: {
              values: Array.from(invalids).join(", "),
              resolved
            }
          });
        return true;
      }
    });
    return next;
  }
  strip(strip = true) {
    let next = this.clone();
    next.spec.strip = strip;
    return next;
  }
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const {
      label,
      meta,
      optional: optional17,
      nullable
    } = next.spec;
    const description = {
      meta,
      label,
      optional: optional17,
      nullable,
      default: next.getDefault(options),
      type: next.type,
      oneOf: next._whitelist.describe(),
      notOneOf: next._blacklist.describe(),
      tests: next.tests.map((fn) => ({
        name: fn.OPTIONS.name,
        params: fn.OPTIONS.params
      })).filter((n4, idx, list) => list.findIndex((c4) => c4.name === n4.name) === idx)
    };
    return description;
  }
}
Schema.prototype.__isYupSchema__ = true;
for (const method of ["validate", "validateSync"])
  Schema.prototype[`${method}At`] = function(path, value27, options = {}) {
    const {
      parent,
      parentPath,
      schema
    } = getIn(this, path, value27, options.context);
    return schema[method](parent && parent[parentPath], Object.assign({}, options, {
      parent,
      path
    }));
  };
for (const alias of ["equals", "is"])
  Schema.prototype[alias] = Schema.prototype.oneOf;
for (const alias of ["not", "nope"])
  Schema.prototype[alias] = Schema.prototype.notOneOf;
var returnsTrue = () => true;

class MixedSchema extends Schema {
  constructor(spec) {
    super(typeof spec === "function" ? {
      type: "mixed",
      check: spec
    } : Object.assign({
      type: "mixed",
      check: returnsTrue
    }, spec));
  }
}
create$8.prototype = MixedSchema.prototype;

class BooleanSchema extends Schema {
  constructor() {
    super({
      type: "boolean",
      check(v3) {
        if (v3 instanceof Boolean)
          v3 = v3.valueOf();
        return typeof v3 === "boolean";
      }
    });
    this.withMutation(() => {
      this.transform((value27, _raw, ctx) => {
        if (ctx.spec.coerce && !ctx.isType(value27)) {
          if (/^(true|1)$/i.test(String(value27)))
            return true;
          if (/^(false|0)$/i.test(String(value27)))
            return false;
        }
        return value27;
      });
    });
  }
  isTrue(message = boolean7.isValue) {
    return this.test({
      message,
      name: "is-value",
      exclusive: true,
      params: {
        value: "true"
      },
      test(value27) {
        return isAbsent(value27) || value27 === true;
      }
    });
  }
  isFalse(message = boolean7.isValue) {
    return this.test({
      message,
      name: "is-value",
      exclusive: true,
      params: {
        value: "false"
      },
      test(value27) {
        return isAbsent(value27) || value27 === false;
      }
    });
  }
  default(def) {
    return super.default(def);
  }
  defined(msg) {
    return super.defined(msg);
  }
  optional() {
    return super.optional();
  }
  required(msg) {
    return super.required(msg);
  }
  notRequired() {
    return super.notRequired();
  }
  nullable() {
    return super.nullable();
  }
  nonNullable(msg) {
    return super.nonNullable(msg);
  }
  strip(v3) {
    return super.strip(v3);
  }
}
create$7.prototype = BooleanSchema.prototype;
var rEmail = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rUrl = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
var rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
var isTrimmed = (value27) => isAbsent(value27) || value27 === value27.trim();
var objStringTag = {}.toString();

class StringSchema extends Schema {
  constructor() {
    super({
      type: "string",
      check(value27) {
        if (value27 instanceof String)
          value27 = value27.valueOf();
        return typeof value27 === "string";
      }
    });
    this.withMutation(() => {
      this.transform((value27, _raw, ctx) => {
        if (!ctx.spec.coerce || ctx.isType(value27))
          return value27;
        if (Array.isArray(value27))
          return value27;
        const strValue = value27 != null && value27.toString ? value27.toString() : value27;
        if (strValue === objStringTag)
          return value27;
        return strValue;
      });
    });
  }
  required(message) {
    return super.required(message).withMutation((schema) => schema.test({
      message: message || mixed.required,
      name: "required",
      skipAbsent: true,
      test: (value27) => !!value27.length
    }));
  }
  notRequired() {
    return super.notRequired().withMutation((schema) => {
      schema.tests = schema.tests.filter((t4) => t4.OPTIONS.name !== "required");
      return schema;
    });
  }
  length(length, message = string11.length) {
    return this.test({
      message,
      name: "length",
      exclusive: true,
      params: {
        length
      },
      skipAbsent: true,
      test(value27) {
        return value27.length === this.resolve(length);
      }
    });
  }
  min(min, message = string11.min) {
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      test(value27) {
        return value27.length >= this.resolve(min);
      }
    });
  }
  max(max, message = string11.max) {
    return this.test({
      name: "max",
      exclusive: true,
      message,
      params: {
        max
      },
      skipAbsent: true,
      test(value27) {
        return value27.length <= this.resolve(max);
      }
    });
  }
  matches(regex, options) {
    let excludeEmptyString = false;
    let message;
    let name2;
    if (options) {
      if (typeof options === "object") {
        ({
          excludeEmptyString = false,
          message,
          name: name2
        } = options);
      } else {
        message = options;
      }
    }
    return this.test({
      name: name2 || "matches",
      message: message || string11.matches,
      params: {
        regex
      },
      skipAbsent: true,
      test: (value27) => value27 === "" && excludeEmptyString || value27.search(regex) !== -1
    });
  }
  email(message = string11.email) {
    return this.matches(rEmail, {
      name: "email",
      message,
      excludeEmptyString: true
    });
  }
  url(message = string11.url) {
    return this.matches(rUrl, {
      name: "url",
      message,
      excludeEmptyString: true
    });
  }
  uuid(message = string11.uuid) {
    return this.matches(rUUID, {
      name: "uuid",
      message,
      excludeEmptyString: false
    });
  }
  ensure() {
    return this.default("").transform((val) => val === null ? "" : val);
  }
  trim(message = string11.trim) {
    return this.transform((val) => val != null ? val.trim() : val).test({
      message,
      name: "trim",
      test: isTrimmed
    });
  }
  lowercase(message = string11.lowercase) {
    return this.transform((value27) => !isAbsent(value27) ? value27.toLowerCase() : value27).test({
      message,
      name: "string_case",
      exclusive: true,
      skipAbsent: true,
      test: (value27) => isAbsent(value27) || value27 === value27.toLowerCase()
    });
  }
  uppercase(message = string11.uppercase) {
    return this.transform((value27) => !isAbsent(value27) ? value27.toUpperCase() : value27).test({
      message,
      name: "string_case",
      exclusive: true,
      skipAbsent: true,
      test: (value27) => isAbsent(value27) || value27 === value27.toUpperCase()
    });
  }
}
create$6.prototype = StringSchema.prototype;
var isNaN$1 = (value27) => value27 != +value27;

class NumberSchema extends Schema {
  constructor() {
    super({
      type: "number",
      check(value27) {
        if (value27 instanceof Number)
          value27 = value27.valueOf();
        return typeof value27 === "number" && !isNaN$1(value27);
      }
    });
    this.withMutation(() => {
      this.transform((value27, _raw, ctx) => {
        if (!ctx.spec.coerce)
          return value27;
        let parsed = value27;
        if (typeof parsed === "string") {
          parsed = parsed.replace(/\s/g, "");
          if (parsed === "")
            return NaN;
          parsed = +parsed;
        }
        if (ctx.isType(parsed) || parsed === null)
          return parsed;
        return parseFloat(parsed);
      });
    });
  }
  min(min, message = number11.min) {
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      test(value27) {
        return value27 >= this.resolve(min);
      }
    });
  }
  max(max, message = number11.max) {
    return this.test({
      message,
      name: "max",
      exclusive: true,
      params: {
        max
      },
      skipAbsent: true,
      test(value27) {
        return value27 <= this.resolve(max);
      }
    });
  }
  lessThan(less, message = number11.lessThan) {
    return this.test({
      message,
      name: "max",
      exclusive: true,
      params: {
        less
      },
      skipAbsent: true,
      test(value27) {
        return value27 < this.resolve(less);
      }
    });
  }
  moreThan(more, message = number11.moreThan) {
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        more
      },
      skipAbsent: true,
      test(value27) {
        return value27 > this.resolve(more);
      }
    });
  }
  positive(msg = number11.positive) {
    return this.moreThan(0, msg);
  }
  negative(msg = number11.negative) {
    return this.lessThan(0, msg);
  }
  integer(message = number11.integer) {
    return this.test({
      name: "integer",
      message,
      skipAbsent: true,
      test: (val) => Number.isInteger(val)
    });
  }
  truncate() {
    return this.transform((value27) => !isAbsent(value27) ? value27 | 0 : value27);
  }
  round(method) {
    var _method;
    let avail = ["ceil", "floor", "round", "trunc"];
    method = ((_method = method) == null ? undefined : _method.toLowerCase()) || "round";
    if (method === "trunc")
      return this.truncate();
    if (avail.indexOf(method.toLowerCase()) === -1)
      throw new TypeError("Only valid options for round() are: " + avail.join(", "));
    return this.transform((value27) => !isAbsent(value27) ? Math[method](value27) : value27);
  }
}
create$5.prototype = NumberSchema.prototype;
var isoReg = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
var invalidDate = new Date("");
var isDate = (obj) => Object.prototype.toString.call(obj) === "[object Date]";

class DateSchema extends Schema {
  constructor() {
    super({
      type: "date",
      check(v3) {
        return isDate(v3) && !isNaN(v3.getTime());
      }
    });
    this.withMutation(() => {
      this.transform((value27, _raw, ctx) => {
        if (!ctx.spec.coerce || ctx.isType(value27) || value27 === null)
          return value27;
        value27 = parseIsoDate(value27);
        return !isNaN(value27) ? new Date(value27) : DateSchema.INVALID_DATE;
      });
    });
  }
  prepareParam(ref5, name2) {
    let param;
    if (!Reference.isRef(ref5)) {
      let cast5 = this.cast(ref5);
      if (!this._typeCheck(cast5))
        throw new TypeError(`\`${name2}\` must be a Date or a value that can be \`cast()\` to a Date`);
      param = cast5;
    } else {
      param = ref5;
    }
    return param;
  }
  min(min, message = date7.min) {
    let limit = this.prepareParam(min, "min");
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      test(value27) {
        return value27 >= this.resolve(limit);
      }
    });
  }
  max(max, message = date7.max) {
    let limit = this.prepareParam(max, "max");
    return this.test({
      message,
      name: "max",
      exclusive: true,
      params: {
        max
      },
      skipAbsent: true,
      test(value27) {
        return value27 <= this.resolve(limit);
      }
    });
  }
}
DateSchema.INVALID_DATE = invalidDate;
create$4.prototype = DateSchema.prototype;
create$4.INVALID_DATE = invalidDate;
var parseJson = (value27, _, ctx) => {
  if (typeof value27 !== "string") {
    return value27;
  }
  let parsed = value27;
  try {
    parsed = JSON.parse(value27);
  } catch (err) {
  }
  return ctx.isType(parsed) ? parsed : value27;
};
var deepHas = (obj, p3) => {
  const path = [...import_property_expr.normalizePath(p3)];
  if (path.length === 1)
    return path[0] in obj;
  let last = path.pop();
  let parent = import_property_expr.getter(import_property_expr.join(path), true)(obj);
  return !!(parent && (last in parent));
};
var isObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
var defaultSort = sortByKeyOrder([]);

class ObjectSchema extends Schema {
  constructor(spec) {
    super({
      type: "object",
      check(value27) {
        return isObject(value27) || typeof value27 === "function";
      }
    });
    this.fields = Object.create(null);
    this._sortErrors = defaultSort;
    this._nodes = [];
    this._excludedEdges = [];
    this.withMutation(() => {
      if (spec) {
        this.shape(spec);
      }
    });
  }
  _cast(_value, options = {}) {
    var _options$stripUnknown;
    let value27 = super._cast(_value, options);
    if (value27 === undefined)
      return this.getDefault(options);
    if (!this._typeCheck(value27))
      return value27;
    let fields = this.fields;
    let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
    let props = [].concat(this._nodes, Object.keys(value27).filter((v3) => !this._nodes.includes(v3)));
    let intermediateValue = {};
    let innerOptions = Object.assign({}, options, {
      parent: intermediateValue,
      __validating: options.__validating || false
    });
    let isChanged = false;
    for (const prop of props) {
      let field = fields[prop];
      let exists = prop in value27;
      if (field) {
        let fieldValue;
        let inputValue = value27[prop];
        innerOptions.path = (options.path ? `${options.path}.` : "") + prop;
        field = field.resolve({
          value: inputValue,
          context: options.context,
          parent: intermediateValue
        });
        let fieldSpec = field instanceof Schema ? field.spec : undefined;
        let strict5 = fieldSpec == null ? undefined : fieldSpec.strict;
        if (fieldSpec != null && fieldSpec.strip) {
          isChanged = isChanged || prop in value27;
          continue;
        }
        fieldValue = !options.__validating || !strict5 ? field.cast(value27[prop], innerOptions) : value27[prop];
        if (fieldValue !== undefined) {
          intermediateValue[prop] = fieldValue;
        }
      } else if (exists && !strip) {
        intermediateValue[prop] = value27[prop];
      }
      if (exists !== prop in intermediateValue || intermediateValue[prop] !== value27[prop]) {
        isChanged = true;
      }
    }
    return isChanged ? intermediateValue : value27;
  }
  _validate(_value, options = {}, panic, next) {
    let {
      from = [],
      originalValue = _value,
      recursive: recursive5 = this.spec.recursive
    } = options;
    options.from = [{
      schema: this,
      value: originalValue
    }, ...from];
    options.__validating = true;
    options.originalValue = originalValue;
    super._validate(_value, options, panic, (objectErrors, value27) => {
      if (!recursive5 || !isObject(value27)) {
        next(objectErrors, value27);
        return;
      }
      originalValue = originalValue || value27;
      let tests = [];
      for (let key of this._nodes) {
        let field = this.fields[key];
        if (!field || Reference.isRef(field)) {
          continue;
        }
        tests.push(field.asNestedTest({
          options,
          key,
          parent: value27,
          parentPath: options.path,
          originalParent: originalValue
        }));
      }
      this.runTests({
        tests,
        value: value27,
        originalValue,
        options
      }, panic, (fieldErrors) => {
        next(fieldErrors.sort(this._sortErrors).concat(objectErrors), value27);
      });
    });
  }
  clone(spec) {
    const next = super.clone(spec);
    next.fields = Object.assign({}, this.fields);
    next._nodes = this._nodes;
    next._excludedEdges = this._excludedEdges;
    next._sortErrors = this._sortErrors;
    return next;
  }
  concat(schema) {
    let next = super.concat(schema);
    let nextFields = next.fields;
    for (let [field, schemaOrRef] of Object.entries(this.fields)) {
      const target = nextFields[field];
      nextFields[field] = target === undefined ? schemaOrRef : target;
    }
    return next.withMutation((s5) => s5.setFields(nextFields, [...this._excludedEdges, ...schema._excludedEdges]));
  }
  _getDefault(options) {
    if ("default" in this.spec) {
      return super._getDefault(options);
    }
    if (!this._nodes.length) {
      return;
    }
    let dft = {};
    this._nodes.forEach((key) => {
      var _innerOptions;
      const field = this.fields[key];
      let innerOptions = options;
      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[key]
        });
      }
      dft[key] = field && "getDefault" in field ? field.getDefault(innerOptions) : undefined;
    });
    return dft;
  }
  setFields(shape, excludedEdges) {
    let next = this.clone();
    next.fields = shape;
    next._nodes = sortFields(shape, excludedEdges);
    next._sortErrors = sortByKeyOrder(Object.keys(shape));
    if (excludedEdges)
      next._excludedEdges = excludedEdges;
    return next;
  }
  shape(additions, excludes = []) {
    return this.clone().withMutation((next) => {
      let edges = next._excludedEdges;
      if (excludes.length) {
        if (!Array.isArray(excludes[0]))
          excludes = [excludes];
        edges = [...next._excludedEdges, ...excludes];
      }
      return next.setFields(Object.assign(next.fields, additions), edges);
    });
  }
  partial() {
    const partial7 = {};
    for (const [key, schema] of Object.entries(this.fields)) {
      partial7[key] = "optional" in schema && schema.optional instanceof Function ? schema.optional() : schema;
    }
    return this.setFields(partial7);
  }
  deepPartial() {
    const next = deepPartial(this);
    return next;
  }
  pick(keys) {
    const picked = {};
    for (const key of keys) {
      if (this.fields[key])
        picked[key] = this.fields[key];
    }
    return this.setFields(picked, this._excludedEdges.filter(([a3, b3]) => keys.includes(a3) && keys.includes(b3)));
  }
  omit(keys) {
    const remaining = [];
    for (const key of Object.keys(this.fields)) {
      if (keys.includes(key))
        continue;
      remaining.push(key);
    }
    return this.pick(remaining);
  }
  from(from, to, alias) {
    let fromGetter = import_property_expr.getter(from, true);
    return this.transform((obj) => {
      if (!obj)
        return obj;
      let newObj = obj;
      if (deepHas(obj, from)) {
        newObj = Object.assign({}, obj);
        if (!alias)
          delete newObj[from];
        newObj[to] = fromGetter(obj);
      }
      return newObj;
    });
  }
  json() {
    return this.transform(parseJson);
  }
  noUnknown(noAllow = true, message = object23.noUnknown) {
    if (typeof noAllow !== "boolean") {
      message = noAllow;
      noAllow = true;
    }
    let next = this.test({
      name: "noUnknown",
      exclusive: true,
      message,
      test(value27) {
        if (value27 == null)
          return true;
        const unknownKeys = unknown11(this.schema, value27);
        return !noAllow || unknownKeys.length === 0 || this.createError({
          params: {
            unknown: unknownKeys.join(", ")
          }
        });
      }
    });
    next.spec.noUnknown = noAllow;
    return next;
  }
  unknown(allow = true, message = object23.noUnknown) {
    return this.noUnknown(!allow, message);
  }
  transformKeys(fn) {
    return this.transform((obj) => {
      if (!obj)
        return obj;
      const result = {};
      for (const key of Object.keys(obj))
        result[fn(key)] = obj[key];
      return result;
    });
  }
  camelCase() {
    return this.transformKeys(import_tiny_case.camelCase);
  }
  snakeCase() {
    return this.transformKeys(import_tiny_case.snakeCase);
  }
  constantCase() {
    return this.transformKeys((key) => import_tiny_case.snakeCase(key).toUpperCase());
  }
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const base = super.describe(options);
    base.fields = {};
    for (const [key, value27] of Object.entries(next.fields)) {
      var _innerOptions2;
      let innerOptions = options;
      if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[key]
        });
      }
      base.fields[key] = value27.describe(innerOptions);
    }
    return base;
  }
}
create$3.prototype = ObjectSchema.prototype;

class ArraySchema extends Schema {
  constructor(type145) {
    super({
      type: "array",
      spec: {
        types: type145
      },
      check(v3) {
        return Array.isArray(v3);
      }
    });
    this.innerType = undefined;
    this.innerType = type145;
  }
  _cast(_value, _opts) {
    const value27 = super._cast(_value, _opts);
    if (!this._typeCheck(value27) || !this.innerType) {
      return value27;
    }
    let isChanged = false;
    const castArray = value27.map((v3, idx) => {
      const castElement = this.innerType.cast(v3, Object.assign({}, _opts, {
        path: `${_opts.path || ""}[${idx}]`
      }));
      if (castElement !== v3) {
        isChanged = true;
      }
      return castElement;
    });
    return isChanged ? castArray : value27;
  }
  _validate(_value, options = {}, panic, next) {
    var _options$recursive;
    let innerType = this.innerType;
    let recursive5 = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
    options.originalValue != null && options.originalValue;
    super._validate(_value, options, panic, (arrayErrors, value27) => {
      var _options$originalValu2;
      if (!recursive5 || !innerType || !this._typeCheck(value27)) {
        next(arrayErrors, value27);
        return;
      }
      let tests = new Array(value27.length);
      for (let index = 0;index < value27.length; index++) {
        var _options$originalValu;
        tests[index] = innerType.asNestedTest({
          options,
          index,
          parent: value27,
          parentPath: options.path,
          originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
        });
      }
      this.runTests({
        value: value27,
        tests,
        originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
        options
      }, panic, (innerTypeErrors) => next(innerTypeErrors.concat(arrayErrors), value27));
    });
  }
  clone(spec) {
    const next = super.clone(spec);
    next.innerType = this.innerType;
    return next;
  }
  json() {
    return this.transform(parseJson);
  }
  concat(schema) {
    let next = super.concat(schema);
    next.innerType = this.innerType;
    if (schema.innerType)
      next.innerType = next.innerType ? next.innerType.concat(schema.innerType) : schema.innerType;
    return next;
  }
  of(schema) {
    let next = this.clone();
    if (!isSchema(schema))
      throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema));
    next.innerType = schema;
    next.spec = Object.assign({}, next.spec, {
      types: schema
    });
    return next;
  }
  length(length, message = array7.length) {
    return this.test({
      message,
      name: "length",
      exclusive: true,
      params: {
        length
      },
      skipAbsent: true,
      test(value27) {
        return value27.length === this.resolve(length);
      }
    });
  }
  min(min, message) {
    message = message || array7.min;
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      test(value27) {
        return value27.length >= this.resolve(min);
      }
    });
  }
  max(max, message) {
    message = message || array7.max;
    return this.test({
      message,
      name: "max",
      exclusive: true,
      params: {
        max
      },
      skipAbsent: true,
      test(value27) {
        return value27.length <= this.resolve(max);
      }
    });
  }
  ensure() {
    return this.default(() => []).transform((val, original) => {
      if (this._typeCheck(val))
        return val;
      return original == null ? [] : [].concat(original);
    });
  }
  compact(rejector) {
    let reject = !rejector ? (v3) => !!v3 : (v3, i, a3) => !rejector(v3, i, a3);
    return this.transform((values) => values != null ? values.filter(reject) : values);
  }
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const base = super.describe(options);
    if (next.innerType) {
      var _innerOptions;
      let innerOptions = options;
      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[0]
        });
      }
      base.innerType = next.innerType.describe(innerOptions);
    }
    return base;
  }
}
create$2.prototype = ArraySchema.prototype;

class TupleSchema extends Schema {
  constructor(schemas) {
    super({
      type: "tuple",
      spec: {
        types: schemas
      },
      check(v3) {
        const types = this.spec.types;
        return Array.isArray(v3) && v3.length === types.length;
      }
    });
    this.withMutation(() => {
      this.typeError(tuple13.notType);
    });
  }
  _cast(inputValue, options) {
    const {
      types
    } = this.spec;
    const value27 = super._cast(inputValue, options);
    if (!this._typeCheck(value27)) {
      return value27;
    }
    let isChanged = false;
    const castArray = types.map((type145, idx) => {
      const castElement = type145.cast(value27[idx], Object.assign({}, options, {
        path: `${options.path || ""}[${idx}]`
      }));
      if (castElement !== value27[idx])
        isChanged = true;
      return castElement;
    });
    return isChanged ? castArray : value27;
  }
  _validate(_value, options = {}, panic, next) {
    let itemTypes = this.spec.types;
    super._validate(_value, options, panic, (tupleErrors, value27) => {
      var _options$originalValu2;
      if (!this._typeCheck(value27)) {
        next(tupleErrors, value27);
        return;
      }
      let tests = [];
      for (let [index, itemSchema] of itemTypes.entries()) {
        var _options$originalValu;
        tests[index] = itemSchema.asNestedTest({
          options,
          index,
          parent: value27,
          parentPath: options.path,
          originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
        });
      }
      this.runTests({
        value: value27,
        tests,
        originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
        options
      }, panic, (innerTypeErrors) => next(innerTypeErrors.concat(tupleErrors), value27));
    });
  }
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const base = super.describe(options);
    base.innerType = next.spec.types.map((schema, index) => {
      var _innerOptions;
      let innerOptions = options;
      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[index]
        });
      }
      return schema.describe(innerOptions);
    });
    return base;
  }
}
create$1.prototype = TupleSchema.prototype;

// ../sisventa/src/validations/authSchema.ts
var LoginSchema = () => create$3({
  email: create$6().email("Correo inv\xE1lido"),
  password: create$6().min(4, "Debe ser mayor a 4 caracteres")
});

// ../sisventa/src/middlewares/auth.ts
var Auth = async (input) => {
  const { headers, store, db, cookie } = input;
  const t4 = await verifyToken(cookie._secure.value, db, true);
  if (!t4) {
    return {
      status: false,
      msj: "No autorizado"
    };
  }
  if (t4.id) {
    store.user = { id: t4.id, role: t4.role };
  }
};
var auth_default = Auth;

// ../sisventa/src/helpers/parseMiddle.ts
var parse7 = (input) => {
  const method = input[0];
  const params = input;
  params.splice(0, 1);
  return {
    beforeHandle: (d3) => method(d3, params)
  };
};
var parseMiddle_default = parse7;

// ../sisventa/src/routes/authR.ts
var route = new n2({ prefix: "/auth" }).post("/login", Login, parseMiddle_default([validation_default, LoginSchema])).post("/reset", requestPasswd).post("/verify", verify).get("/logout", Logout, parseMiddle_default([auth_default]));
var authR_default = route;

// ../sisventa/src/helpers/Files.ts
import fs from "fs";

class archivos {
  #path;
  constructor(path) {
    if (!fs.existsSync(path)) {
      fs.mkdirSync(path, { recursive: true });
    }
    this.#path = path;
  }
  get(name2) {
    fs.statSync(this.#path + name2);
    let file = Bun.file(this.#path + name2);
    const nam = file.name?.split("/") ?? [];
    return {
      size: file.size,
      type: file.type,
      names: nam[nam?.length - 1],
      file
    };
  }
  save(path, file) {
    Bun.write(this.#path + path, file);
  }
  move(filePath, newLocation) {
    fs.renameSync(filePath, newLocation);
  }
  copy(filePath, newLocation) {
    const content = fs.readFileSync(filePath);
    fs.writeFileSync(newLocation, content);
  }
  remove(file) {
    fs.unlinkSync(this.#path + file);
  }
}
var Files_default = archivos;

// ../sisventa/src/controllers/userController.ts
var all2 = async ({ db, query: { page, pageSize, search }, store }) => {
  let where = {
    NOT: {
      id: {
        equals: store.user.id
      }
    },
    OR: undefined
  };
  if (search) {
    where.OR = [
      {
        name: {
          contains: search
        }
      },
      {
        email: {
          contains: search
        }
      }
    ];
  }
  const users = await db.user.findMany({
    skip: (parseInt(page) - 1) * parseInt(pageSize),
    take: parseInt(pageSize),
    where,
    select: {
      id: true,
      name: true,
      email: true,
      role: true,
      picture: true
    }
  });
  const count = parseInt(await db.user.count({ where }));
  return {
    status: true,
    all: {
      data: users,
      count,
      pages: Math.ceil(count / parseInt(pageSize)),
      page: parseInt(page),
      pageSize: parseInt(pageSize)
    }
  };
};
var createUser = async ({ db, body }) => {
  const ext = body.imgFile.name.split(".")[1];
  const nameFile = `${body.email}.${ext}`;
  const user = await db.user.create({
    data: {
      name: body.name,
      email: body.email,
      password: await makePasswd(body.password),
      role: body.role,
      picture: nameFile
    }
  });
  const file = new Files_default("sisventa/uploads/img/profile/");
  file.save(nameFile, body.imgFile);
  return {
    status: true,
    msj: "Usuario creado correctamente",
    user
  };
};
var updateUser = async ({ db, body, params, store }) => {
  const id = params?.id ? params.id : store.user.id;
  try {
    const updateUser2 = await db.user.update({
      where: {
        id
      },
      data: {
        name: body.name,
        email: body.email,
        password: await makePasswd(body.password),
        role: body.role
      }
    });
    return {
      status: true,
      msj: "Usuario actualizado correctamente",
      user: updateUser2
    };
  } catch (error41) {
    if (error41.code === "P2025")
      return {
        status: false,
        msj: "Usuario no encontrado"
      };
  }
};
var getProfile = async ({ db, store, params }) => {
  const id = params !== undefined ? params.id : store.user.id;
  const user = await db.user.findUnique({
    where: {
      id
    }
  });
  if (!user) {
    return {
      status: false,
      msj: "Usuario no encontrado"
    };
  }
  delete user.password;
  return {
    status: true,
    find: user
  };
};
var deleteUser = async ({ db, store, params }) => {
  const id = params.id;
  if (id === store.user.id)
    return {
      status: false,
      msj: "No puedes eliminar tu cuenta"
    };
  try {
    const delUser = await db.user.delete({
      where: {
        id
      }
    });
    if (delUser)
      return {
        status: true,
        msj: "Usuario eliminado correctamente"
      };
  } catch (error41) {
    if (error41.code === "P2025")
      return {
        status: false,
        msj: "Usuario no encontrado"
      };
  }
};
var updatePasswd = async ({ db, store, body, set: set3 }) => {
  const { old, confirm, passwd: passwd3 } = body;
  let err = { error: [] };
  const user = await db.user.findUnique({ where: { id: store.user.id } });
  if (await comparePasswd(old, user.password)) {
    err.error.push({
      input: "old",
      msj: "Contrase\xF1a incorrecta"
    });
  }
  if (passwd3 !== confirm) {
    err.error.push({
      input: "confirm",
      msj: "Las contrase\xF1as no coinciden"
    });
  }
  if (err.error.length !== 0) {
    return err;
  }
  const up = await db.user.update({
    where: {
      id: user.id
    },
    data: {
      password: await makePasswd(passwd3)
    }
  });
  if (up) {
    return {
      status: true,
      msj: "Contrase\xF1a actualizada correctamente"
    };
  } else {
    set3.status = 500;
  }
};
var picture = ({ params: { name: name2 }, set: set3 }) => {
  const file = new Files_default("sisventa/uploads/img/profile/");
  set3.headers["Content-Type"] = "image/png";
  return file.get(name2).file;
};

// ../sisventa/src/config/database.ts
var client = __toESM(require_client(), 1);
var prisma = new client.PrismaClient({
  log: ["error", "info", "warn"]
});
prisma.$connect().then(() => console.log("Conectado a la base de datos"));
var database_default = new n2().decorate("db", prisma);

// ../sisventa/src/validations/userSchema.ts
async function repeat(email, id) {
  const users = await prisma.user.findFirst({
    where: {
      email,
      NOT: {
        id: {
          equals: id
        }
      }
    }
  });
  return !users;
}
var CreateSchema = (id) => create$3().shape({
  name: create$6().max(50).required("Campo requerido"),
  email: create$6().email("Correo inv\xE1lido").required("Campo requerido").test("is-repeat", "Este correo ya existe", (d3) => repeat(d3, id)),
  password: create$6().min(4).required("Campo requerido"),
  role: create$6().required("Campo requerido").oneOf(["admin", "vendedor", "bodega"], "Rol inv\xE1lido"),
  imgFile: create$8().test("false", "Tipo de imagen invalido ", (value27) => {
    return ["image/png", "image/jpeg", "image/jpg", "image/webp", ""].includes(value27.type);
  }).test("false", "Imagen supera los 10MB", (value27) => {
    return value27.size <= 10485760;
  })
});
var UpdatePassSchema = create$3({
  old: create$6(),
  confirm: create$6().min(4),
  passwd: create$6().min(4)
});

// ../sisventa/src/middlewares/role.ts
var Role = ({ store: { user } }, role) => {
  if (!role.find((x) => x === user.role) && user.role !== "admin") {
    return {
      status: false,
      msj: "No tiene permisos para este recurso"
    };
  }
};
var role_default = Role;

// ../sisventa/src/routes/userR.ts
var UserR = new n2({ prefix: "/users" }).guard({
  beforeHandle: auth_default
}, (app) => app.get("/picture/:name", picture).get("/all", all2, parseMiddle_default([role_default])).group("/profile", (app2) => app2.get("", getProfile).get("/:id", getProfile, parseMiddle_default([role_default]))).group("", parseMiddle_default([validation_default, CreateSchema]), (app2) => app2.post("", createUser, parseMiddle_default([role_default])).put("", updateUser, parseMiddle_default([role_default, "user"])).put("/:id", updateUser, parseMiddle_default([role_default]))).post("/upload", ({ body }) => {
  console.log(body);
}).post("/update_passwd", updatePasswd, parseMiddle_default([validation_default, UpdatePassSchema])).delete("/:id", deleteUser, parseMiddle_default([role_default]))).post("", createUser);
var userR_default = UserR;

// ../sisventa/src/controllers/clienteController.ts
var all3 = async ({
  db,
  query: { page, pageSize, search }
}) => {
  let where = {};
  if (search) {
    where = {
      OR: [
        {
          nombre: {
            contains: search
          }
        },
        {
          apellido: {
            contains: search
          }
        }
      ]
    };
  }
  const clientes = await db.cliente.findMany({
    skip: (parseInt(page) - 1) * parseInt(pageSize),
    take: parseInt(pageSize),
    where
  });
  const count = parseInt(await db.cliente.count({ where }));
  return {
    status: true,
    all: {
      data: clientes,
      count,
      pages: Math.ceil(count / parseInt(pageSize)),
      page: parseInt(page),
      pageSize: parseInt(pageSize)
    }
  };
};
var find = async ({ params, db }) => {
  const cliente = await db.cliente.findUnique({ where: { id: params.id } });
  if (!cliente)
    return {
      status: false,
      msj: "Usuario no encontrado"
    };
  return {
    status: true,
    find: cliente
  };
};
var save = async ({ db, body }) => {
  const cliente = await db.cliente.create({
    data: {
      nombre: body.nombre,
      apellido: body.apellido,
      celular: body.celular,
      correo: body.correo,
      direccion: body.direccion
    }
  });
  if (!cliente)
    return {
      status: false,
      msj: "Ha ocurrido un error"
    };
  return {
    status: true,
    msj: "Cliente creado exitosamente",
    cliente
  };
};
var update = async ({ db, body, params }) => {
  try {
    const cliente = await db.cliente.update({
      where: {
        id: params.id
      },
      data: {
        nombre: body.nombre,
        apellido: body.apellido,
        celular: body.celular,
        correo: body.correo,
        direccion: body.direccion
      }
    });
    return {
      status: true,
      msj: "Cliente actualizado correctamente"
    };
  } catch (error41) {
    if (error41.code === "P2025")
      return {
        status: false,
        msj: "Cliente no encontrado"
      };
  }
};
var remove = async ({ db, params }) => {
  try {
    await db.cliente.delete({ where: { id: params.id } });
    return {
      status: true,
      msj: "Cliente eliminado correctamente"
    };
  } catch (error41) {
    if (error41.code === "P2025")
      return {
        status: false,
        msj: "Cliente no encontrado"
      };
  }
};

// ../sisventa/src/validations/clienteSchema.ts
async function repeat2(nombre, id) {
  const clientes = await prisma.cliente.findFirst({
    where: {
      nombre,
      NOT: {
        id: {
          equals: id
        }
      }
    }
  });
  return !clientes;
}
var ClienteSchema = (id) => create$3({
  nombre: create$6().max(10, "Debe ser menor a 10 caracteres").trim().required("Campo requerido").test("is-repeat", "Este nombre ya existe", (d3) => repeat2(d3, id)),
  apellido: create$6().max(15).trim(),
  celular: create$6().trim().max(15).matches(/^$|^[0-9]+$/, "Debe ser numerico"),
  correo: create$6().email("Correo invalido").trim(),
  direccion: create$6().max(50).trim()
});

// ../sisventa/src/routes/clienteR.ts
var ClienteR = new n2({ prefix: "/clientes" }).guard({
  beforeHandle: auth_default
}, (app) => app.get("/all", all3).get("/:id", find).group("", parseMiddle_default([validation_default, ClienteSchema]), (app2) => app2.post("/", save).put("/:id", update)).delete("/:id", remove));
var clienteR_default = ClienteR;

// ../sisventa/src/index.ts
var app = new n2({ prefix: "/sisventa" }).use(database_default).use(authR_default).use(userR_default).use(clienteR_default).get("/", () => {
  return "hello";
}).onError(({ error: error41, set: set3 }) => {
  if (error41.name == "ENOENT") {
    set3.status = 200;
    return {
      status: false,
      msj: "Archivo no encontrado"
    };
  }
});
var src_default = app;

// node_modules/@elysiajs/cors/dist/index.js
var cors = (config2 = {
  origin: true,
  methods: true,
  allowedHeaders: "*",
  exposedHeaders: "*",
  credentials: true,
  maxAge: 5,
  preflight: true
}) => {
  const { origin = true, methods = true, allowedHeaders = "*", exposedHeaders = "*", credentials = true, maxAge = 5, preflight = true } = config2;
  const app2 = new n({
    name: "@elysiajs/cors",
    seed: config2
  });
  const origins = typeof origin === "boolean" ? undefined : Array.isArray(origin) ? origin : [origin];
  const processOrigin = (origin2, request, from) => {
    switch (typeof origin2) {
      case "string":
        const protocolStart = from.indexOf("://");
        if (protocolStart !== -1)
          from = from.slice(protocolStart + 3);
        const trailingSlash = from.indexOf("/", 0);
        if (trailingSlash !== -1)
          from = from.slice(trailingSlash);
        return origin2 === from;
      case "function":
        return origin2(request);
      case "object":
        return origin2.test(from);
    }
  };
  const handleOrigin = (set3, request) => {
    if (origin === true) {
      set3.headers["Vary"] = "*";
      set3.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") || "*";
      return;
    }
    if (!origins?.length)
      return;
    const headers = [];
    if (origins.length) {
      const from = request.headers.get("Origin") ?? "";
      for (let i = 0;i < origins.length; i++) {
        const value27 = processOrigin(origins[i], request, from);
        if (value27 === true) {
          set3.headers["Vary"] = origin ? "Origin" : "*";
          set3.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") || "*";
          return;
        }
        if (value27)
          headers.push(value27);
      }
    }
    set3.headers["Vary"] = "Origin";
    set3.headers["Access-Control-Allow-Origin"] = headers.join(", ");
  };
  const handleMethod = (set3, method) => {
    if (methods === true)
      return set3.headers["Access-Control-Allow-Methods"] = method ?? "*";
    if (methods === false || !methods?.length)
      return;
    if (methods === "*")
      return set3.headers["Access-Control-Allow-Methods"] = "*";
    if (!Array.isArray(methods))
      return set3.headers["Access-Control-Allow-Methods"] = methods;
    set3.headers["Access-Control-Allow-Methods"] = methods.join(", ");
  };
  if (preflight)
    app2.options("/", ({ set: set3, request }) => {
      handleOrigin(set3, request);
      handleMethod(set3, request.method);
      if (exposedHeaders.length)
        set3.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
      if (maxAge)
        set3.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response("", {
        status: 204
      });
    }).options("/*", ({ set: set3, request }) => {
      handleOrigin(set3, request);
      handleMethod(set3, request.method);
      if (exposedHeaders.length)
        set3.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
      if (maxAge)
        set3.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response("", {
        status: 204
      });
    });
  const defaultHeaders = {
    "Access-Control-Allow-Headers": typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", "),
    "Access-Control-Exposed-Headers": typeof exposedHeaders === "string" ? exposedHeaders : exposedHeaders.join(", ")
  };
  if (credentials === true)
    defaultHeaders["Access-Control-Allow-Credentials"] = "true";
  return app2.headers(defaultHeaders).onRequest(({ set: set3, request }) => {
    handleOrigin(set3, request);
    handleMethod(set3, request.method);
  });
};

// index.ts
var app2 = new n().use(cors({
  methods: ["GET", "DELETE", "PUT", "POST"]
})).use(src_default).listen(8080);
console.log(`\uD83D\uDC80 server is running at ${app2.server?.hostname}: ${app2.server?.port} \uD83D\uDCE1`);
